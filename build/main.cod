; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29334.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG81926 DB	'unknown code', 00H
$SG81740 DB	00H
	ORG $+2
$SG81936 DB	'outofmem', 00H
	ORG $+3
$SG82160 DB	'#?RGBE', 00H
	ORG $+1
$SG82168 DB	'-Y ', 00H
$SG81990 DB	'not GIF', 00H
$SG82027 DB	'#?RADIANCE', 0aH, 00H
$SG82171 DB	'+X ', 00H
$SG82029 DB	'#?RGBE', 0aH, 00H
$SG82159 DB	'#?RADIANCE', 00H
	ORG $+1
$SG82228 DB	'-Y ', 00H
$SG82161 DB	'not HDR', 00H
$SG82164 DB	'FORMAT=32-bit_rle_rgbe', 00H
	ORG $+1
$SG82166 DB	'unsupported format', 00H
	ORG $+1
$SG82230 DB	'+X ', 00H
$SG82169 DB	'unsupported data layout', 00H
$SG82172 DB	'unsupported data layout', 00H
$SG82174 DB	'too large', 00H
	ORG $+2
$SG82445 DB	'rb', 00H
	ORG $+1
$SG82176 DB	'too large', 00H
	ORG $+2
$SG82462 DB	'rb', 00H
	ORG $+1
$SG82180 DB	'too large', 00H
	ORG $+2
$SG82511 DB	'r', 00H
	ORG $+2
$SG82182 DB	'outofmem', 00H
	ORG $+3
$SG82514 DB	0aH, 00H
	ORG $+2
$SG82189 DB	'invalid decoded scanline length', 00H
$SG82192 DB	'outofmem', 00H
	ORG $+3
$SG83069 DB	'usemtl', 00H
	ORG $+1
$SG83140 DB	0aH, 00H
	ORG $+2
$SG82197 DB	'corrupt', 00H
$SG82200 DB	'corrupt', 00H
$SG82225 DB	'FORMAT=32-bit_rle_rgbe', 00H
	ORG $+1
$SG82294 DB	'S', 080H, 0f6H, '4', 00H
	ORG $+3
$SG82337 DB	'too large', 00H
	ORG $+2
$SG83072 DB	'mtllib', 00H
	ORG $+1
$SG83150 DB	0aH, 00H
	ORG $+2
$SG82339 DB	'too large', 00H
	ORG $+2
$SG83119 DB	'newmtl', 00H
	ORG $+1
$SG83176 DB	0aH, 00H
	ORG $+2
$SG82342 DB	'too large', 00H
	ORG $+2
$SG83188 DB	0aH, 00H
	ORG $+2
$SG82344 DB	'outofmem', 00H
	ORG $+3
$SG83159 DB	'illum', 00H
	ORG $+2
$SG83284 DB	'r', 00H
	ORG $+2
$SG82346 DB	'bad PNM', 00H
$SG82382 DB	'integer parse overflow', 00H
	ORG $+1
$SG82403 DB	'invalid width', 00H
	ORG $+2
$SG82405 DB	'invalid width', 00H
	ORG $+2
$SG82408 DB	'max value > 65535', 00H
	ORG $+2
$SG83300 DB	0aH, 00H
	ORG $+2
$SG82430 DB	'unknown image type', 00H
	ORG $+1
$SG83324 DB	0aH, 00H
	ORG $+2
$SG82447 DB	'can''t fopen', 00H
$SG84561 DB	'far', 00H
$SG82464 DB	'can''t fopen', 00H
$SG84597 DB	'X', 00H
	ORG $+2
$SG82513 DB	'Could not open shader source file.', 00H
	ORG $+1
$SG84599 DB	'Y', 00H
	ORG $+2
$SG83062 DB	'Unsupported Obj Command.', 00H
	ORG $+3
$SG84565 DB	'model', 00H
	ORG $+2
$SG84601 DB	'Z', 00H
	ORG $+2
$SG83063 DB	'Assertion failed at line %d: %s', 0aH, 00H
	ORG $+3
$SG84566 DB	'model', 00H
	ORG $+2
$SG84823 DB	'1.90.4', 00H
	ORG $+1
$SG84840 DB	'tex', 00H
$SG83139 DB	'Unsupported Mtl Command.', 00H
	ORG $+3
$SG84846 DB	'Monkey', 00H
	ORG $+1
$SG84848 DB	'Cow', 00H
$SG83149 DB	'Unsupported Mtl Command.', 00H
	ORG $+3
$SG83163 DB	'map_', 00H
	ORG $+3
$SG84847 DB	'Dragon', 00H
	ORG $+1
$SG84856 DB	'C1', 00H
	ORG $+1
$SG83175 DB	'Unsupported Mtl Command.', 00H
	ORG $+3
$SG83182 DB	'Bump', 00H
	ORG $+3
$SG84851 DB	'Phong', 00H
	ORG $+2
$SG84857 DB	'G1', 00H
	ORG $+1
$SG83187 DB	'Unsupported Mtl Command.', 00H
	ORG $+3
$SG83191 DB	'bump', 00H
	ORG $+3
$SG83194 DB	'disp', 00H
	ORG $+3
$SG84862 DB	'Scene', 00H
	ORG $+2
$SG84867 DB	'FOV', 00H
$SG83209 DB	'..\data\models\', 00H
$SG83211 DB	'Shader file path is too long.', 00H
	ORG $+2
$SG83212 DB	'Assertion failed at line %d: %s', 0aH, 00H
	ORG $+3
$SG84873 DB	'Shader', 00H
	ORG $+1
$SG84888 DB	'Pos', 00H
$SG83280 DB	'..\data\shaders\', 00H
	ORG $+3
$SG84883 DB	'Model', 00H
	ORG $+2
$SG84885 DB	'Models', 00H
	ORG $+1
$SG84889 DB	'Rot', 00H
$SG83282 DB	'Shader file path is too long.', 00H
	ORG $+2
$SG83283 DB	'Assertion failed at line %d: %s', 0aH, 00H
	ORG $+3
$SG84890 DB	'Scale', 00H
	ORG $+2
$SG84894 DB	'Curves', 00H
	ORG $+1
$SG84896 DB	'dt', 00H
	ORG $+1
$SG83286 DB	'Could not open shader source file.', 00H
	ORG $+1
$SG84913 DB	0aH, 00H
	ORG $+2
$SG83287 DB	'Assertion failed at line %d: %s', 0aH, 00H
	ORG $+3
$SG84891 DB	'Color', 00H
	ORG $+2
$SG84902 DB	'Pos %d', 00H
	ORG $+1
$SG76758 DB	'rb', 00H
	ORG $+1
$SG83299 DB	'ERROR::SHADER::COMPILATION: %s', 00H
	ORG $+1
$SG83323 DB	'ERROR::SHADER::LINKING_FAILED: %s', 00H
	ORG $+2
$SG76795 DB	'rb', 00H
	ORG $+1
$SG83468 DB	'Unsupported Texture format.', 00H
$SG76896 DB	'rb', 00H
	ORG $+1
$SG83469 DB	'Assertion failed at line %d: %s', 0aH, 00H
	ORG $+3
$SG84897 DB	'Debug', 00H
	ORG $+2
$SG76917 DB	'rb', 00H
	ORG $+1
$SG84118 DB	'Failed to make framebuffer.', 00H
$SG77099 DB	'0', 00H, 00H, 00H
$SG84119 DB	'Assertion failed at line %d: %s', 0aH, 00H
	ORG $+3
$SG77191 DB	'0', 00H, 00H, 00H
$SG84442 DB	'mat.ambient', 00H
	ORG $+4
$SG84443 DB	'mat.diffuse', 00H
	ORG $+4
$SG84444 DB	'mat.specular', 00H
	ORG $+3
$SG84445 DB	'mat.shininess', 00H
	ORG $+2
$SG84446 DB	'mat.diffuse_tex', 00H
$SG84447 DB	'mat.specular_tex', 00H
	ORG $+7
$SG84459 DB	'point_light_count', 00H
	ORG $+6
$SG84460 DB	'point_lights[%u].pos', 00H
	ORG $+3
$SG84461 DB	'point_lights[%u].constant', 00H
	ORG $+6
$SG84462 DB	'point_lights[%u].linear', 00H
$SG84463 DB	'point_lights[%u].quadratic', 00H
	ORG $+1
$SG84556 DB	'proj', 00H
	ORG $+3
$SG84557 DB	'view', 00H
	ORG $+3
$SG84558 DB	'proj', 00H
	ORG $+3
$SG84559 DB	'view', 00H
	ORG $+3
$SG84560 DB	'near', 00H
	ORG $+3
$SG84596 DB	'%.3f', 00H
	ORG $+3
$SG84598 DB	'%.3f', 00H
	ORG $+3
$SG84600 DB	'%.3f', 00H
	ORG $+7
$SG76618 DB	'unknown image type', 00H
	ORG $+5
$SG84821 DB	'Model Transforms', 00H
	ORG $+7
$SG84824 DB	'#version 330', 00H
	ORG $+3
$SG84825 DB	'framebuffer_frag.glsl', 00H
	ORG $+2
$SG84826 DB	'framebuffer_vert.glsl', 00H
	ORG $+2
$SG84827 DB	'frag.glsl', 00H
	ORG $+6
$SG84828 DB	'vert.glsl', 00H
	ORG $+6
$SG76636 DB	'outofmem', 00H
	ORG $+7
$SG84829 DB	'flat_frag.glsl', 00H
	ORG $+1
$SG84830 DB	'flat_geo.glsl', 00H
	ORG $+2
$SG84831 DB	'flat_vert.glsl', 00H
	ORG $+1
$SG84832 DB	'gouraud_frag.glsl', 00H
	ORG $+6
$SG84833 DB	'gouraud_vert.glsl', 00H
	ORG $+6
$SG84834 DB	'phong_frag.glsl', 00H
$SG84835 DB	'phong_vert.glsl', 00H
$SG84836 DB	'depth_frag.glsl', 00H
$SG84837 DB	'depth_vert.glsl', 00H
$SG84838 DB	'linear_depth_frag.glsl', 00H
	ORG $+1
$SG84839 DB	'linear_depth_vert.glsl', 00H
	ORG $+1
$SG84841 DB	'backpack\backpack.obj', 00H
	ORG $+2
$SG84842 DB	'smooth_monkey\monkey.obj', 00H
	ORG $+7
$SG84843 DB	'dragon\dragon.obj', 00H
	ORG $+6
$SG84844 DB	'cow\cow.obj', 00H
	ORG $+4
$SG84845 DB	'Backpack', 00H
	ORG $+7
$SG76655 DB	'outofmem', 00H
	ORG $+3
$SG84849 DB	'None', 00H
	ORG $+7
$SG84850 DB	'Gouraud', 00H
$SG84852 DB	'Flat', 00H
	ORG $+3
$SG84853 DB	'Z Buffer', 00H
	ORG $+7
$SG84854 DB	'Z'' Buffer', 00H
	ORG $+2
$SG84855 DB	'None', 00H
	ORG $+7
$SG84858 DB	'De Castelgau', 00H
	ORG $+3
$SG84859 DB	'Matrix Form', 00H
	ORG $+4
$SG84860 DB	'InvisibleWindow', 00H
$SG84861 DB	'InvisibleWindowSockSpace', 00H
	ORG $+7
$SG84863 DB	'Properties', 00H
	ORG $+5
$SG84865 DB	'Perspective', 00H
$SG84866 DB	'%.3f', 00H
	ORG $+3
$SG84868 DB	'%.3f', 00H
	ORG $+7
$SG84869 DB	'Near Plane', 00H
	ORG $+1
$SG84870 DB	'%.3f', 00H
	ORG $+7
$SG84871 DB	'Far Plane', 00H
	ORG $+6
$SG84875 DB	'Add Light', 00H
	ORG $+6
$SG84877 DB	'Light Pos %u', 00H
	ORG $+3
$SG84879 DB	'Shaders', 00H
$SG84892 DB	'Use Textures', 00H
	ORG $+3
$SG84895 DB	'%.3f', 00H
	ORG $+3
$SG84898 DB	'%.3f', 00H
	ORG $+3
$SG84899 DB	'Debug t', 00H
$SG76707 DB	'W', 00H, ':', 00H, '\', 00H, 'O', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, 'G', 00H, 'L', 00H, '_', 00H, 'V', 00H, 'i', 00H, 'e'
	DB	00H, 'w', 00H, 'e', 00H, 'r', 00H, '\', 00H, 'l', 00H, 'i', 00H
	DB	'b', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 'i'
	DB	00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'h', 00H
	DB	00H, 00H
	ORG $+6
$SG84912 DB	'FPS: %f', 00H
$SG76708 DB	'r', 00H, 'i', 00H, '.', 00H, 'b', 00H, 'i', 00H, 't', 00H
	DB	's', 00H, '_', 00H, 'p', 00H, 'e', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'h', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'e', 00H, 'l', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '8', 00H, ' ', 00H, '|'
	DB	00H, '|', 00H, ' ', 00H, 'r', 00H, 'i', 00H, '.', 00H, 'b', 00H
	DB	'i', 00H, 't', 00H, 's', 00H, '_', 00H, 'p', 00H, 'e', 00H, 'r'
	DB	00H, '_', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'n', 00H, 'n', 00H
	DB	'e', 00H, 'l', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '1'
	DB	00H, '6', 00H, 00H, 00H
	ORG $+4
$SG84908 DB	'Add Point', 00H
	ORG $+6
$SG76727 DB	'W', 00H, ':', 00H, '\', 00H, 'O', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, 'G', 00H, 'L', 00H, '_', 00H, 'V', 00H, 'i', 00H, 'e'
	DB	00H, 'w', 00H, 'e', 00H, 'r', 00H, '\', 00H, 'l', 00H, 'i', 00H
	DB	'b', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 'i'
	DB	00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'h', 00H
	DB	00H, 00H
	ORG $+6
$SG76760 DB	'can''t fopen', 00H
$SG79005 DB	'bad H', 00H
	ORG $+6
$SG76728 DB	'r', 00H, 'i', 00H, '.', 00H, 'b', 00H, 'i', 00H, 't', 00H
	DB	's', 00H, '_', 00H, 'p', 00H, 'e', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'h', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'e', 00H, 'l', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '8', 00H, ' ', 00H, '|'
	DB	00H, '|', 00H, ' ', 00H, 'r', 00H, 'i', 00H, '.', 00H, 'b', 00H
	DB	'i', 00H, 't', 00H, 's', 00H, '_', 00H, 'p', 00H, 'e', 00H, 'r'
	DB	00H, '_', 00H, 'c', 00H, 'h', 00H, 'a', 00H, 'n', 00H, 'n', 00H
	DB	'e', 00H, 'l', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '1'
	DB	00H, '6', 00H, 00H, 00H
	ORG $+4
$SG76797 DB	'can''t fopen', 00H
	ORG $+4
$SG76865 DB	'unknown image type', 00H
	ORG $+5
$SG76898 DB	'can''t fopen', 00H
$SG79008 DB	'bad V', 00H
	ORG $+6
$SG77081 DB	'W', 00H, ':', 00H, '\', 00H, 'O', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, 'G', 00H, 'L', 00H, '_', 00H, 'V', 00H, 'i', 00H, 'e'
	DB	00H, 'w', 00H, 'e', 00H, 'r', 00H, '\', 00H, 'l', 00H, 'i', 00H
	DB	'b', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 'i'
	DB	00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'h', 00H
	DB	00H, 00H
	ORG $+6
$SG77082 DB	'r', 00H, 'e', 00H, 'q', 00H, '_', 00H, 'c', 00H, 'o', 00H
	DB	'm', 00H, 'p', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '1'
	DB	00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'r', 00H, 'e', 00H
	DB	'q', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, ' '
	DB	00H, '<', 00H, '=', 00H, ' ', 00H, '4', 00H, 00H, 00H
	ORG $+2
$SG77084 DB	'outofmem', 00H
	ORG $+7
$SG77100 DB	'unsupported', 00H
$SG79010 DB	'bad TQ', 00H
	ORG $+5
$SG77098 DB	'W', 00H, ':', 00H, '\', 00H, 'O', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, 'G', 00H, 'L', 00H, '_', 00H, 'V', 00H, 'i', 00H, 'e'
	DB	00H, 'w', 00H, 'e', 00H, 'r', 00H, '\', 00H, 'l', 00H, 'i', 00H
	DB	'b', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 'i'
	DB	00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'h', 00H
	DB	00H, 00H
	ORG $+6
$SG77174 DB	'r', 00H, 'e', 00H, 'q', 00H, '_', 00H, 'c', 00H, 'o', 00H
	DB	'm', 00H, 'p', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H, '1'
	DB	00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'r', 00H, 'e', 00H
	DB	'q', 00H, '_', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, ' '
	DB	00H, '<', 00H, '=', 00H, ' ', 00H, '4', 00H, 00H, 00H
	ORG $+2
$SG77420 DB	'bad code lengths', 00H
	ORG $+7
$SG77173 DB	'W', 00H, ':', 00H, '\', 00H, 'O', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, 'G', 00H, 'L', 00H, '_', 00H, 'V', 00H, 'i', 00H, 'e'
	DB	00H, 'w', 00H, 'e', 00H, 'r', 00H, '\', 00H, 'l', 00H, 'i', 00H
	DB	'b', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 'i'
	DB	00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'h', 00H
	DB	00H, 00H
	ORG $+6
$SG77176 DB	'outofmem', 00H
	ORG $+7
$SG77192 DB	'unsupported', 00H
$SG79017 DB	'bad H', 00H
	ORG $+6
$SG77190 DB	'W', 00H, ':', 00H, '\', 00H, 'O', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, 'G', 00H, 'L', 00H, '_', 00H, 'V', 00H, 'i', 00H, 'e'
	DB	00H, 'w', 00H, 'e', 00H, 'r', 00H, '\', 00H, 'l', 00H, 'i', 00H
	DB	'b', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 'i'
	DB	00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'h', 00H
	DB	00H, 00H
	ORG $+6
$SG77240 DB	'outofmem', 00H
	ORG $+7
$SG77272 DB	'outofmem', 00H
	ORG $+7
$SG77417 DB	'bad size list', 00H
	ORG $+2
$SG77529 DB	'bad huffman code', 00H
	ORG $+7
?stbi__bmask@@3QBIB DD 00H				; stbi__bmask
	DD	01H
	DD	03H
	DD	07H
	DD	0fH
	DD	01fH
	DD	03fH
	DD	07fH
	DD	0ffH
	DD	01ffH
	DD	03ffH
	DD	07ffH
	DD	0fffH
	DD	01fffH
	DD	03fffH
	DD	07fffH
	DD	0ffffH
$SG79019 DB	'bad V', 00H
	ORG $+6
$SG77477 DB	'W', 00H, ':', 00H, '\', 00H, 'O', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, 'G', 00H, 'L', 00H, '_', 00H, 'V', 00H, 'i', 00H, 'e'
	DB	00H, 'w', 00H, 'e', 00H, 'r', 00H, '\', 00H, 'l', 00H, 'i', 00H
	DB	'b', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 'i'
	DB	00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'h', 00H
	DB	00H, 00H
	ORG $+6
$SG77533 DB	'can''t merge dc and ac', 00H
	ORG $+2
$SG77478 DB	'(', 00H, '(', 00H, '(', 00H, 'j', 00H, '-', 00H, '>', 00H
	DB	'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, '_', 00H, 'b', 00H, 'u'
	DB	00H, 'f', 00H, 'f', 00H, 'e', 00H, 'r', 00H, ')', 00H, ' ', 00H
	DB	'>', 00H, '>', 00H, ' ', 00H, '(', 00H, '3', 00H, '2', 00H, ' '
	DB	00H, '-', 00H, ' ', 00H, 'h', 00H, '-', 00H, '>', 00H, 's', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, '[', 00H, 'c', 00H, ']', 00H, ')'
	DB	00H, ')', 00H, ' ', 00H, '&', 00H, ' ', 00H, 's', 00H, 't', 00H
	DB	'b', 00H, 'i', 00H, '_', 00H, '_', 00H, 'b', 00H, 'm', 00H, 'a'
	DB	00H, 's', 00H, 'k', 00H, '[', 00H, 'h', 00H, '-', 00H, '>', 00H
	DB	's', 00H, 'i', 00H, 'z', 00H, 'e', 00H, '[', 00H, 'c', 00H, ']'
	DB	00H, ']', 00H, ')', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H
	DB	'h', 00H, '-', 00H, '>', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e'
	DB	00H, '[', 00H, 'c', 00H, ']', 00H, 00H, 00H
$SG79035 DB	'no SOI', 00H
	ORG $+5
?stbi__jbias@@3QBHB DD 00H				; stbi__jbias
	DD	0ffffffffH
	DD	0fffffffdH
	DD	0fffffff9H
	DD	0fffffff1H
	DD	0ffffffe1H
	DD	0ffffffc1H
	DD	0ffffff81H
	DD	0ffffff01H
	DD	0fffffe01H
	DD	0fffffc01H
	DD	0fffff801H
	DD	0fffff001H
	DD	0ffffe001H
	DD	0ffffc001H
	DD	0ffff8001H
?stbi__jpeg_dezigzag@@3QBEB DB 00H			; stbi__jpeg_dezigzag
	DB	01H
	DB	08H
	DB	010H
	DB	09H
	DB	02H
	DB	03H
	DB	0aH
	DB	011H
	DB	018H
	DB	020H
	DB	019H
	DB	012H
	DB	0bH
	DB	04H
	DB	05H
	DB	0cH
	DB	013H
	DB	01aH
	DB	021H
	DB	028H
	DB	030H
	DB	029H
	DB	022H
	DB	01bH
	DB	014H
	DB	0dH
	DB	06H
	DB	07H
	DB	0eH
	DB	015H
	DB	01cH
	DB	023H
	DB	02aH
	DB	031H
	DB	038H
	DB	039H
	DB	032H
	DB	02bH
	DB	024H
	DB	01dH
	DB	016H
	DB	0fH
	DB	017H
	DB	01eH
	DB	025H
	DB	02cH
	DB	033H
	DB	03aH
	DB	03bH
	DB	034H
	DB	02dH
	DB	026H
	DB	01fH
	DB	027H
	DB	02eH
	DB	035H
	DB	03cH
	DB	03dH
	DB	036H
	DB	02fH
	DB	037H
	DB	03eH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	DB	03fH
	ORG $+1
$SG77531 DB	'bad delta', 00H
	ORG $+6
$SG77538 DB	'bad huffman code', 00H
	ORG $+7
$SG77540 DB	'bad huffman code', 00H
	ORG $+7
$SG77556 DB	'can''t merge dc and ac', 00H
	ORG $+2
$SG77562 DB	'can''t merge dc and ac', 00H
	ORG $+2
$SG77564 DB	'bad delta', 00H
	ORG $+6
$SG77566 DB	'can''t merge dc and ac', 00H
	ORG $+2
$SG77603 DB	'can''t merge dc and ac', 00H
	ORG $+2
$SG77611 DB	'bad huffman code', 00H
	ORG $+7
$SG77613 DB	'bad huffman code', 00H
	ORG $+7
$SG77626 DB	'bad huffman code', 00H
	ORG $+7
$SG77633 DB	'bad huffman code', 00H
	ORG $+7
$SG78867 DB	'expected marker', 00H
$SG78870 DB	'bad DRI len', 00H
	ORG $+4
$SG78873 DB	'bad DQT type', 00H
	ORG $+3
$SG78875 DB	'bad DQT table', 00H
	ORG $+2
$SG78879 DB	'bad DHT header', 00H
	ORG $+1
$SG78881 DB	'bad DHT header', 00H
	ORG $+1
$SG78893 DB	'bad COM len', 00H
	ORG $+4
$SG78894 DB	'bad APP len', 00H
	ORG $+4
$SG78902 DB	'unknown marker', 00H
	ORG $+1
$SG78921 DB	'bad SOS component count', 00H
$SG78923 DB	'bad SOS len', 00H
	ORG $+4
$SG78927 DB	'bad DC huff', 00H
	ORG $+4
$SG78929 DB	'bad AC huff', 00H
	ORG $+4
$SG78934 DB	'bad SOS', 00H
$SG78936 DB	'bad SOS', 00H
$SG78939 DB	'bad SOS', 00H
$SG78987 DB	'bad SOF len', 00H
	ORG $+4
$SG78989 DB	'only 8-bit', 00H
	ORG $+5
$SG78991 DB	'no header height', 00H
	ORG $+7
$SG78993 DB	'0 width', 00H
$SG78995 DB	'too large', 00H
	ORG $+6
$SG78997 DB	'too large', 00H
	ORG $+6
$SG78999 DB	'bad component count', 00H
	ORG $+4
$SG79001 DB	'bad SOF len', 00H
	ORG $+4
$SG79013 DB	'too large', 00H
	ORG $+6
$SG79021 DB	'outofmem', 00H
	ORG $+7
$SG79024 DB	'outofmem', 00H
	ORG $+3
$SG79039 DB	'no SOF', 00H
	ORG $+5
$SG79072 DB	'bad DNL len', 00H
	ORG $+4
$SG79074 DB	'bad DNL height', 00H
	ORG $+1
$SG79579 DB	'bad req_comp', 00H
	ORG $+3
$SG79585 DB	'outofmem', 00H
	ORG $+7
$SG79595 DB	'outofmem', 00H
	ORG $+7
$SG79638 DB	'outofmem', 00H
	ORG $+7
$SG79648 DB	'outofmem', 00H
	ORG $+7
$SG79671 DB	'outofmem', 00H
	ORG $+7
$SG79699 DB	'W', 00H, ':', 00H, '\', 00H, 'O', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, 'G', 00H, 'L', 00H, '_', 00H, 'V', 00H, 'i', 00H, 'e'
	DB	00H, 'w', 00H, 'e', 00H, 'r', 00H, '\', 00H, 'l', 00H, 'i', 00H
	DB	'b', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 'i'
	DB	00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'h', 00H
	DB	00H, 00H
	ORG $+6
$SG79700 DB	'b', 00H, 'i', 00H, 't', 00H, 's', 00H, ' ', 00H, '<', 00H
	DB	'=', 00H, ' ', 00H, '1', 00H, '6', 00H, 00H, 00H
	ORG $+2
$SG79735 DB	'bad sizes', 00H
	ORG $+6
$SG79738 DB	'bad codelengths', 00H
$SG79827 DB	'output buffer limit', 00H
	ORG $+4
$SG79829 DB	'outofmem', 00H
	ORG $+7
$SG79831 DB	'outofmem', 00H
	ORG $+7
$SG79833 DB	'outofmem', 00H
	ORG $+7
$SG79861 DB	'bad huffman code', 00H
	ORG $+7
?stbi__zlength_base@@3QBHB DD 03H			; stbi__zlength_base
	DD	04H
	DD	05H
	DD	06H
	DD	07H
	DD	08H
	DD	09H
	DD	0aH
	DD	0bH
	DD	0dH
	DD	0fH
	DD	011H
	DD	013H
	DD	017H
	DD	01bH
	DD	01fH
	DD	023H
	DD	02bH
	DD	033H
	DD	03bH
	DD	043H
	DD	053H
	DD	063H
	DD	073H
	DD	083H
	DD	0a3H
	DD	0c3H
	DD	0e3H
	DD	0102H
	DD	00H
	DD	00H
	ORG $+4
?stbi__zlength_extra@@3QBHB DD 00H			; stbi__zlength_extra
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	05H
	DD	05H
	DD	00H
	DD	00H
	DD	00H
	ORG $+4
?stbi__zdist_base@@3QBHB DD 01H				; stbi__zdist_base
	DD	02H
	DD	03H
	DD	04H
	DD	05H
	DD	07H
	DD	09H
	DD	0dH
	DD	011H
	DD	019H
	DD	021H
	DD	031H
	DD	041H
	DD	061H
	DD	081H
	DD	0c1H
	DD	0101H
	DD	0181H
	DD	0201H
	DD	0301H
	DD	0401H
	DD	0601H
	DD	0801H
	DD	0c01H
	DD	01001H
	DD	01801H
	DD	02001H
	DD	03001H
	DD	04001H
	DD	06001H
	DD	00H
	DD	00H
?stbi__zdist_extra@@3QBHB DD 00H			; stbi__zdist_extra
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	06H
	DD	06H
	DD	07H
	DD	07H
	DD	08H
	DD	08H
	DD	09H
	DD	09H
	DD	0aH
	DD	0aH
	DD	0bH
	DD	0bH
	DD	0cH
	DD	0cH
	DD	0dH
	DD	0dH
	ORG $+8
$SG79866 DB	'unexpected end', 00H
	ORG $+1
$SG79868 DB	'bad huffman code', 00H
	ORG $+7
$SG79872 DB	'bad huffman code', 00H
	ORG $+7
$SG79875 DB	'bad dist', 00H
	ORG $+7
$SG79909 DB	'bad codelengths', 00H
$SG79915 DB	'bad codelengths', 00H
$SG79920 DB	'bad codelengths', 00H
$SG79922 DB	'bad codelengths', 00H
$SG79924 DB	'bad codelengths', 00H
$SG79941 DB	'zlib corrupt', 00H
	ORG $+3
$SG79943 DB	'zlib corrupt', 00H
	ORG $+3
$SG79945 DB	'read past buffer', 00H
	ORG $+7
$SG79955 DB	'bad zlib header', 00H
$SG79957 DB	'bad zlib header', 00H
$SG79959 DB	'no preset dict', 00H
	ORG $+1
$SG79961 DB	'bad compression', 00H
$SG80153 DB	'i', 00H, 'm', 00H, 'g', 00H, '_', 00H, 'n', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, '3', 00H, 00H, 00H
	ORG $+2
?stbi__zdefault_length@@3QBEB DB 08H			; stbi__zdefault_length
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
?stbi__zdefault_distance@@3QBEB DB 05H			; stbi__zdefault_distance
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
$SG80098 DB	'bad png sig', 00H
	ORG $+4
?stbi__depth_scale_table@@3QBEB DB 00H			; stbi__depth_scale_table
	DB	0ffH
	DB	055H
	DB	00H
	DB	011H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	ORG $+7
$SG80152 DB	'W', 00H, ':', 00H, '\', 00H, 'O', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, 'G', 00H, 'L', 00H, '_', 00H, 'V', 00H, 'i', 00H, 'e'
	DB	00H, 'w', 00H, 'e', 00H, 'r', 00H, '\', 00H, 'l', 00H, 'i', 00H
	DB	'b', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 'i'
	DB	00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'h', 00H
	DB	00H, 00H
	ORG $+6
$SG80261 DB	'not enough pixels', 00H
	ORG $+6
$SG80252 DB	'W', 00H, ':', 00H, '\', 00H, 'O', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, 'G', 00H, 'L', 00H, '_', 00H, 'V', 00H, 'i', 00H, 'e'
	DB	00H, 'w', 00H, 'e', 00H, 'r', 00H, '\', 00H, 'l', 00H, 'i', 00H
	DB	'b', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 'i'
	DB	00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'h', 00H
	DB	00H, 00H
	ORG $+6
$SG80266 DB	'invalid filter', 00H
	ORG $+1
$SG80283 DB	'd', 00H, 'e', 00H, 'p', 00H, 't', 00H, 'h', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, '1', 00H, 00H, 00H
	ORG $+2
$SG80253 DB	'o', 00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, 's', 00H, '-', 00H, '>', 00H, 'i'
	DB	00H, 'm', 00H, 'g', 00H, '_', 00H, 'n', 00H, ' ', 00H, '|', 00H
	DB	'|', 00H, ' ', 00H, 'o', 00H, 'u', 00H, 't', 00H, '_', 00H, 'n'
	DB	00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 's', 00H, '-', 00H
	DB	'>', 00H, 'i', 00H, 'm', 00H, 'g', 00H, '_', 00H, 'n', 00H, '+'
	DB	00H, '1', 00H, 00H, 00H
	ORG $+6
$SG80255 DB	'outofmem', 00H
	ORG $+7
$SG80257 DB	'too large', 00H
	ORG $+6
$SG80259 DB	'too large', 00H
	ORG $+6
$SG80263 DB	'outofmem', 00H
	ORG $+7
$SG80294 DB	'i', 00H, 'm', 00H, 'g', 00H, '_', 00H, 'n', 00H, '+', 00H
	DB	'1', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'o', 00H, 'u'
	DB	00H, 't', 00H, '_', 00H, 'n', 00H, 00H, 00H
	ORG $+6
$SG80282 DB	'W', 00H, ':', 00H, '\', 00H, 'O', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, 'G', 00H, 'L', 00H, '_', 00H, 'V', 00H, 'i', 00H, 'e'
	DB	00H, 'w', 00H, 'e', 00H, 'r', 00H, '\', 00H, 'l', 00H, 'i', 00H
	DB	'b', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 'i'
	DB	00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'h', 00H
	DB	00H, 00H
	ORG $+6
$SG80298 DB	'i', 00H, 'm', 00H, 'g', 00H, '_', 00H, 'n', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, '3', 00H, 00H, 00H
	ORG $+2
$SG80293 DB	'W', 00H, ':', 00H, '\', 00H, 'O', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, 'G', 00H, 'L', 00H, '_', 00H, 'V', 00H, 'i', 00H, 'e'
	DB	00H, 'w', 00H, 'e', 00H, 'r', 00H, '\', 00H, 'l', 00H, 'i', 00H
	DB	'b', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 'i'
	DB	00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'h', 00H
	DB	00H, 00H
	ORG $+6
$SG80357 DB	'o', 00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, '2', 00H, ' ', 00H, '|', 00H, '|'
	DB	00H, ' ', 00H, 'o', 00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '4', 00H, 00H, 00H
	ORG $+6
$SG80297 DB	'W', 00H, ':', 00H, '\', 00H, 'O', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, 'G', 00H, 'L', 00H, '_', 00H, 'V', 00H, 'i', 00H, 'e'
	DB	00H, 'w', 00H, 'e', 00H, 'r', 00H, '\', 00H, 'l', 00H, 'i', 00H
	DB	'b', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 'i'
	DB	00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'h', 00H
	DB	00H, 00H
	ORG $+6
$SG80336 DB	'outofmem', 00H
	ORG $+7
$SG80380 DB	'o', 00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H, ' ', 00H
	DB	'=', 00H, '=', 00H, ' ', 00H, '2', 00H, ' ', 00H, '|', 00H, '|'
	DB	00H, ' ', 00H, 'o', 00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '4', 00H, 00H, 00H
	ORG $+6
$SG80356 DB	'W', 00H, ':', 00H, '\', 00H, 'O', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, 'G', 00H, 'L', 00H, '_', 00H, 'V', 00H, 'i', 00H, 'e'
	DB	00H, 'w', 00H, 'e', 00H, 'r', 00H, '\', 00H, 'l', 00H, 'i', 00H
	DB	'b', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 'i'
	DB	00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'h', 00H
	DB	00H, 00H
	ORG $+6
$SG80453 DB	's', 00H, '-', 00H, '>', 00H, 'i', 00H, 'm', 00H, 'g', 00H
	DB	'_', 00H, 'o', 00H, 'u', 00H, 't', 00H, '_', 00H, 'n', 00H, ' '
	DB	00H, '=', 00H, '=', 00H, ' ', 00H, '4', 00H, 00H, 00H
	ORG $+4
$SG80379 DB	'W', 00H, ':', 00H, '\', 00H, 'O', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, 'G', 00H, 'L', 00H, '_', 00H, 'V', 00H, 'i', 00H, 'e'
	DB	00H, 'w', 00H, 'e', 00H, 'r', 00H, '\', 00H, 'l', 00H, 'i', 00H
	DB	'b', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 'i'
	DB	00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'h', 00H
	DB	00H, 00H
	ORG $+6
$SG80406 DB	'outofmem', 00H
	ORG $+7
$SG80551 DB	'multiple IHDR', 00H
	ORG $+2
$SG80559 DB	'1/2/4/8/16-bit only', 00H
	ORG $+4
$SG80452 DB	'W', 00H, ':', 00H, '\', 00H, 'O', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, 'G', 00H, 'L', 00H, '_', 00H, 'V', 00H, 'i', 00H, 'e'
	DB	00H, 'w', 00H, 'e', 00H, 'r', 00H, '\', 00H, 'l', 00H, 'i', 00H
	DB	'b', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 'i'
	DB	00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'h', 00H
	DB	00H, 00H
	ORG $+6
$SG80553 DB	'bad IHDR len', 00H
	ORG $+3
$SG80555 DB	'too large', 00H
	ORG $+6
$SG80557 DB	'too large', 00H
	ORG $+6
$SG80561 DB	'bad ctype', 00H
	ORG $+6
$SG80563 DB	'bad ctype', 00H
	ORG $+6
$SG80567 DB	'bad ctype', 00H
	ORG $+6
$SG80569 DB	'bad comp method', 00H
$SG80571 DB	'bad filter method', 00H
	ORG $+6
$SG80573 DB	'bad interlace method', 00H
	ORG $+3
$SG80576 DB	'0-pixel image', 00H
	ORG $+2
$SG80580 DB	'too large', 00H
	ORG $+6
$SG80582 DB	'too large', 00H
	ORG $+6
$SG80585 DB	'first not IHDR', 00H
	ORG $+1
$SG80587 DB	'invalid PLTE', 00H
	ORG $+3
$SG80589 DB	'invalid PLTE', 00H
	ORG $+3
$SG80592 DB	'first not IHDR', 00H
	ORG $+1
$SG80594 DB	'tRNS after IDAT', 00H
$SG80599 DB	'tRNS before PLTE', 00H
	ORG $+7
$SG80601 DB	'bad tRNS len', 00H
	ORG $+3
$SG80603 DB	'tRNS with alpha', 00H
$SG80605 DB	'bad tRNS len', 00H
	ORG $+3
$SG80611 DB	'first not IHDR', 00H
	ORG $+1
$SG80613 DB	'no PLTE', 00H
$SG80617 DB	'IDAT size limit', 00H
$SG80622 DB	'outofmem', 00H
	ORG $+7
$SG80624 DB	'outofdata', 00H
	ORG $+6
$SG80627 DB	'first not IHDR', 00H
	ORG $+1
$SG80630 DB	'no IDAT', 00H
$SG80650 DB	'first not IHDR', 00H
	ORG $+1
$SG80669 DB	'bad req_comp', 00H
	ORG $+3
$SG80675 DB	'bad bits_per_channel', 00H
	ORG $+3
$SG80759 DB	'v', 00H, ' ', 00H, '<', 00H, ' ', 00H, '2', 00H, '5', 00H
	DB	'6', 00H, 00H, 00H
$SG80826 DB	'not BMP', 00H
$SG80758 DB	'W', 00H, ':', 00H, '\', 00H, 'O', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, 'G', 00H, 'L', 00H, '_', 00H, 'V', 00H, 'i', 00H, 'e'
	DB	00H, 'w', 00H, 'e', 00H, 'r', 00H, '\', 00H, 'l', 00H, 'i', 00H
	DB	'b', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 'i'
	DB	00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'h', 00H
	DB	00H, 00H
	ORG $+6
$SG80761 DB	'b', 00H, 'i', 00H, 't', 00H, 's', 00H, ' ', 00H, '>', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' '
	DB	00H, 'b', 00H, 'i', 00H, 't', 00H, 's', 00H, ' ', 00H, '<', 00H
	DB	'=', 00H, ' ', 00H, '8', 00H, 00H, 00H
	ORG $+2
$SG80828 DB	'bad BMP', 00H
$SG80760 DB	'W', 00H, ':', 00H, '\', 00H, 'O', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, 'G', 00H, 'L', 00H, '_', 00H, 'V', 00H, 'i', 00H, 'e'
	DB	00H, 'w', 00H, 'e', 00H, 'r', 00H, '\', 00H, 'l', 00H, 'i', 00H
	DB	'b', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 'i'
	DB	00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'h', 00H
	DB	00H, 00H
	ORG $+6
$SG80830 DB	'unknown BMP', 00H
	ORG $+4
$SG80834 DB	'bad BMP', 00H
$SG80838 DB	'BMP RLE', 00H
$SG80840 DB	'BMP JPEG/PNG', 00H
	ORG $+3
$SG80842 DB	'bad BMP', 00H
$SG80854 DB	'bad BMP', 00H
$SG80855 DB	'bad BMP', 00H
$SG80857 DB	'bad BMP', 00H
$SG80985 DB	'too large', 00H
	ORG $+6
$SG80987 DB	'too large', 00H
	ORG $+6
$SG80995 DB	'bad header', 00H
	ORG $+5
$SG80999 DB	'bad offset', 00H
	ORG $+5
$SG81005 DB	'too large', 00H
	ORG $+6
$SG81007 DB	'outofmem', 00H
	ORG $+7
$SG81012 DB	'invalid', 00H
$SG81020 DB	'bad bpp', 00H
$SG81041 DB	'bad masks', 00H
	ORG $+6
$SG81044 DB	'bad masks', 00H
	ORG $+6
$SG81231 DB	'too large', 00H
	ORG $+6
$SG81233 DB	'too large', 00H
	ORG $+6
$SG81238 DB	'bad format', 00H
	ORG $+5
$SG81241 DB	'too large', 00H
	ORG $+6
$SG81243 DB	'outofmem', 00H
	ORG $+7
$SG81248 DB	'bad palette', 00H
	ORG $+4
$SG81250 DB	'outofmem', 00H
	ORG $+7
$SG81254 DB	't', 00H, 'g', 00H, 'a', 00H, '_', 00H, 'c', 00H, 'o', 00H
	DB	'm', 00H, 'p', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'S'
	DB	00H, 'T', 00H, 'B', 00H, 'I', 00H, '_', 00H, 'r', 00H, 'g', 00H
	DB	'b', 00H, 00H, 00H
	ORG $+6
$SG81256 DB	'bad palette', 00H
$SG81466 DB	'S', 080H, 0f6H, '4', 00H
	ORG $+7
$SG81253 DB	'W', 00H, ':', 00H, '\', 00H, 'O', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, 'G', 00H, 'L', 00H, '_', 00H, 'V', 00H, 'i', 00H, 'e'
	DB	00H, 'w', 00H, 'e', 00H, 'r', 00H, '\', 00H, 'l', 00H, 'i', 00H
	DB	'b', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 'i'
	DB	00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'h', 00H
	DB	00H, 00H
	ORG $+6
$SG81402 DB	'not PSD', 00H
$SG81268 DB	'W', 00H, ':', 00H, '\', 00H, 'O', 00H, 'p', 00H, 'e', 00H
	DB	'n', 00H, 'G', 00H, 'L', 00H, '_', 00H, 'V', 00H, 'i', 00H, 'e'
	DB	00H, 'w', 00H, 'e', 00H, 'r', 00H, '\', 00H, 'l', 00H, 'i', 00H
	DB	'b', 00H, '\', 00H, 's', 00H, 't', 00H, 'b', 00H, '_', 00H, 'i'
	DB	00H, 'm', 00H, 'a', 00H, 'g', 00H, 'e', 00H, '.', 00H, 'h', 00H
	DB	00H, 00H
	ORG $+6
$SG81269 DB	't', 00H, 'g', 00H, 'a', 00H, '_', 00H, 'c', 00H, 'o', 00H
	DB	'm', 00H, 'p', 00H, ' ', 00H, '=', 00H, '=', 00H, ' ', 00H, 'S'
	DB	00H, 'T', 00H, 'B', 00H, 'I', 00H, '_', 00H, 'r', 00H, 'g', 00H
	DB	'b', 00H, 00H, 00H
	ORG $+6
$SG81404 DB	'wrong version', 00H
	ORG $+2
$SG81407 DB	'wrong channel count', 00H
	ORG $+4
$SG81409 DB	'too large', 00H
	ORG $+6
$SG81411 DB	'too large', 00H
	ORG $+6
$SG81413 DB	'unsupported bit depth', 00H
	ORG $+2
$SG81415 DB	'wrong color format', 00H
	ORG $+5
$SG81417 DB	'bad compression', 00H
$SG81419 DB	'too large', 00H
	ORG $+6
$SG81423 DB	'outofmem', 00H
	ORG $+7
$SG81429 DB	'corrupt', 00H
$SG81468 DB	'PICT', 00H
	ORG $+3
$SG81498 DB	'bad file', 00H
	ORG $+7
$SG81580 DB	'bad format', 00H
	ORG $+5
$SG81582 DB	'bad file', 00H
	ORG $+7
$SG81584 DB	'bad format', 00H
	ORG $+5
$SG81586 DB	'bad format', 00H
	ORG $+5
$SG81591 DB	'bad file', 00H
	ORG $+7
$SG81596 DB	'bad file', 00H
	ORG $+7
$SG81602 DB	'bad file', 00H
	ORG $+7
$SG81605 DB	'bad file', 00H
	ORG $+7
$SG81637 DB	'too large', 00H
	ORG $+6
$SG81639 DB	'too large', 00H
	ORG $+6
$SG81641 DB	'bad file', 00H
	ORG $+7
$SG81643 DB	'too large', 00H
	ORG $+6
$SG81645 DB	'outofmem', 00H
	ORG $+7
$SG81735 DB	'not GIF', 00H
$SG81737 DB	'not GIF', 00H
$SG81739 DB	'not GIF', 00H
$SG81742 DB	'too large', 00H
	ORG $+6
$SG81744 DB	'too large', 00H
	ORG $+6
$SG81758 DB	'outofmem', 00H
	ORG $+7
$SG81825 DB	'no clear code', 00H
	ORG $+2
$SG81829 DB	'too many codes', 00H
	ORG $+1
$SG81831 DB	'illegal code in raster', 00H
	ORG $+1
$SG81833 DB	'illegal code in raster', 00H
	ORG $+1
$SG81890 DB	'too large', 00H
	ORG $+6
$SG81893 DB	'outofmem', 00H
	ORG $+7
$SG81904 DB	'bad Image Descriptor', 00H
	ORG $+3
$SG81912 DB	'missing color table', 00H
CONST	ENDS
PUBLIC	?strrchr@@YAPEADQEADH@Z				; strrchr
PUBLIC	??0ImVec2@@QEAA@MM@Z				; ImVec2::ImVec2
PUBLIC	??0ImVec4@@QEAA@MMMM@Z				; ImVec4::ImVec4
PUBLIC	??0?$ImVector@G@@QEAA@AEBU0@@Z			; ImVector<unsigned short>::ImVector<unsigned short>
PUBLIC	??4?$ImVector@G@@QEAAAEAU0@AEBU0@@Z		; ImVector<unsigned short>::operator=
PUBLIC	??1?$ImVector@G@@QEAA@XZ			; ImVector<unsigned short>::~ImVector<unsigned short>
PUBLIC	?clear@?$ImVector@G@@QEAAXXZ			; ImVector<unsigned short>::clear
PUBLIC	?_grow_capacity@?$ImVector@G@@QEBAHH@Z		; ImVector<unsigned short>::_grow_capacity
PUBLIC	?resize@?$ImVector@G@@QEAAXH@Z			; ImVector<unsigned short>::resize
PUBLIC	?reserve@?$ImVector@G@@QEAAXH@Z			; ImVector<unsigned short>::reserve
PUBLIC	??1ImGuiIO@@QEAA@XZ				; ImGuiIO::~ImGuiIO
PUBLIC	??0ImGuiIO@@QEAA@AEBU0@@Z			; ImGuiIO::ImGuiIO
PUBLIC	ldexpf
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	fprintf
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	?cos@@YAMM@Z					; cos
PUBLIC	?ldexp@@YAMMH@Z					; ldexp
PUBLIC	?pow@@YAMMM@Z					; pow
PUBLIC	?sin@@YAMM@Z					; sin
PUBLIC	stbi_load_from_memory
PUBLIC	stbi_load_from_callbacks
PUBLIC	stbi_load
PUBLIC	stbi_load_from_file
PUBLIC	stbi_load_gif_from_memory
PUBLIC	stbi_load_16_from_memory
PUBLIC	stbi_load_16_from_callbacks
PUBLIC	stbi_load_16
PUBLIC	stbi_load_from_file_16
PUBLIC	stbi_loadf_from_memory
PUBLIC	stbi_loadf_from_callbacks
PUBLIC	stbi_loadf
PUBLIC	stbi_loadf_from_file
PUBLIC	stbi_hdr_to_ldr_gamma
PUBLIC	stbi_hdr_to_ldr_scale
PUBLIC	stbi_ldr_to_hdr_gamma
PUBLIC	stbi_ldr_to_hdr_scale
PUBLIC	stbi_is_hdr_from_callbacks
PUBLIC	stbi_is_hdr_from_memory
PUBLIC	stbi_is_hdr
PUBLIC	stbi_is_hdr_from_file
PUBLIC	stbi_failure_reason
PUBLIC	stbi_image_free
PUBLIC	stbi_info_from_memory
PUBLIC	stbi_info_from_callbacks
PUBLIC	stbi_is_16_bit_from_memory
PUBLIC	stbi_is_16_bit_from_callbacks
PUBLIC	stbi_info
PUBLIC	stbi_info_from_file
PUBLIC	stbi_is_16_bit
PUBLIC	stbi_is_16_bit_from_file
PUBLIC	stbi_set_unpremultiply_on_load
PUBLIC	stbi_convert_iphone_png_to_rgb
PUBLIC	stbi_set_flip_vertically_on_load
PUBLIC	stbi_set_unpremultiply_on_load_thread
PUBLIC	stbi_convert_iphone_png_to_rgb_thread
PUBLIC	stbi_set_flip_vertically_on_load_thread
PUBLIC	stbi_zlib_decode_malloc_guesssize
PUBLIC	stbi_zlib_decode_malloc_guesssize_headerflag
PUBLIC	stbi_zlib_decode_malloc
PUBLIC	stbi_zlib_decode_buffer
PUBLIC	stbi_zlib_decode_noheader_malloc
PUBLIC	stbi_zlib_decode_noheader_buffer
PUBLIC	?init_framebuffer@@YAXPEAUgl_renderer@@PEBD1@Z	; init_framebuffer
PUBLIC	?framebuffer_size_callback@@YAXPEAUGLFWwindow@@HH@Z ; framebuffer_size_callback
PUBLIC	?process_input@@YAXPEAUGLFWwindow@@PEAUgl_renderer@@I@Z ; process_input
PUBLIC	main
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	__real@00000000
PUBLIC	__real@3a83126f
PUBLIC	__real@3c23d70a
PUBLIC	__real@3c8efa35
PUBLIC	__real@3d03126f
PUBLIC	__real@3d4ccccd
PUBLIC	__real@3db851ec
PUBLIC	__real@3dcccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f800000
PUBLIC	__real@3faaaaab
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3fe8a3d70a3d70a4
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@40200000
PUBLIC	__real@40400000
PUBLIC	__real@40800000
PUBLIC	__real@40a00000
PUBLIC	__real@40e00000
PUBLIC	__real@41200000
PUBLIC	__real@42340000
PUBLIC	__real@42480000
PUBLIC	__real@42b40000
PUBLIC	__real@42c80000
PUBLIC	__real@437f0000
PUBLIC	__real@43fa0000
PUBLIC	__real@477fff00
PUBLIC	__real@bf800000
PUBLIC	__real@c2b40000
PUBLIC	__xmm@00000200000002000000020000000200
PUBLIC	__xmm@00080008000800080008000800080008
PUBLIC	__xmm@00ff00ff00ff00ff00ff00ff00ff00ff
PUBLIC	__xmm@01010000010100000101000001010000
PUBLIC	__xmm@08a914e808a914e808a914e808a914e8
PUBLIC	__xmm@11c8e09e11c8e09e11c8e09e11c8e09e
PUBLIC	__xmm@11c8f9c311c8f9c311c8f9c311c8f9c3
PUBLIC	__xmm@12d0046b12d0046b12d0046b12d0046b
PUBLIC	__xmm@166f166f166f166f166f166f166f166f
PUBLIC	__xmm@1c5a1c5a1c5a1c5a1c5a1c5a1c5a1c5a
PUBLIC	__xmm@80000000800000008000000080000000
PUBLIC	__xmm@80808080808080808080808080808080
PUBLIC	__xmm@e09ee565e09ee565e09ee565e09ee565
PUBLIC	__xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0
PUBLIC	__xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9
PUBLIC	__xmm@f493f493f493f493f493f493f493f493
PUBLIC	__xmm@f9c31a9df9c31a9df9c31a9df9c31a9d
PUBLIC	__xmm@fa7efa7efa7efa7efa7efa7efa7efa7e
EXTRN	__imp_glBindTexture:PROC
EXTRN	__imp_glClear:PROC
EXTRN	__imp_glClearColor:PROC
EXTRN	__imp_glDrawElements:PROC
EXTRN	__imp_glEnable:PROC
EXTRN	__imp_glGenTextures:PROC
EXTRN	__imp_glLineWidth:PROC
EXTRN	__imp_glTexImage2D:PROC
EXTRN	__imp_glTexParameteri:PROC
EXTRN	__imp_glViewport:PROC
EXTRN	__imp_glewInit:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	strrchr:PROC
EXTRN	strcat:PROC
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	strncmp:PROC
EXTRN	_wassert:PROC
EXTRN	?CreateContext@ImGui@@YAPEAUImGuiContext@@PEAUImFontAtlas@@@Z:PROC ; ImGui::CreateContext
EXTRN	?GetIO@ImGui@@YAAEAUImGuiIO@@XZ:PROC		; ImGui::GetIO
EXTRN	?GetStyle@ImGui@@YAAEAUImGuiStyle@@XZ:PROC	; ImGui::GetStyle
EXTRN	?NewFrame@ImGui@@YAXXZ:PROC			; ImGui::NewFrame
EXTRN	?Render@ImGui@@YAXXZ:PROC			; ImGui::Render
EXTRN	?GetDrawData@ImGui@@YAPEAUImDrawData@@XZ:PROC	; ImGui::GetDrawData
EXTRN	?StyleColorsDark@ImGui@@YAXPEAUImGuiStyle@@@Z:PROC ; ImGui::StyleColorsDark
EXTRN	?Begin@ImGui@@YA_NPEBDPEA_NH@Z:PROC		; ImGui::Begin
EXTRN	?End@ImGui@@YAXXZ:PROC				; ImGui::End
EXTRN	?SetNextWindowPos@ImGui@@YAXAEBUImVec2@@H0@Z:PROC ; ImGui::SetNextWindowPos
EXTRN	?SetNextWindowSize@ImGui@@YAXAEBUImVec2@@H@Z:PROC ; ImGui::SetNextWindowSize
EXTRN	?SetNextWindowViewport@ImGui@@YAXI@Z:PROC	; ImGui::SetNextWindowViewport
EXTRN	?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ:PROC ; ImGui::GetContentRegionAvail
EXTRN	?PushStyleVar@ImGui@@YAXHM@Z:PROC		; ImGui::PushStyleVar
EXTRN	?PushStyleVar@ImGui@@YAXHAEBUImVec2@@@Z:PROC	; ImGui::PushStyleVar
EXTRN	?PopStyleVar@ImGui@@YAXH@Z:PROC			; ImGui::PopStyleVar
EXTRN	?PushItemWidth@ImGui@@YAXM@Z:PROC		; ImGui::PushItemWidth
EXTRN	?PopItemWidth@ImGui@@YAXXZ:PROC			; ImGui::PopItemWidth
EXTRN	?SameLine@ImGui@@YAXMM@Z:PROC			; ImGui::SameLine
EXTRN	?Spacing@ImGui@@YAXXZ:PROC			; ImGui::Spacing
EXTRN	?PushID@ImGui@@YAXPEBD@Z:PROC			; ImGui::PushID
EXTRN	?PopID@ImGui@@YAXXZ:PROC			; ImGui::PopID
EXTRN	?GetID@ImGui@@YAIPEBD@Z:PROC			; ImGui::GetID
EXTRN	?Text@ImGui@@YAXPEBDZZ:PROC			; ImGui::Text
EXTRN	?Button@ImGui@@YA_NPEBDAEBUImVec2@@@Z:PROC	; ImGui::Button
EXTRN	?Checkbox@ImGui@@YA_NPEBDPEA_N@Z:PROC		; ImGui::Checkbox
EXTRN	?RadioButton@ImGui@@YA_NPEBD_N@Z:PROC		; ImGui::RadioButton
EXTRN	?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z:PROC ; ImGui::Image
EXTRN	?BeginCombo@ImGui@@YA_NPEBD0H@Z:PROC		; ImGui::BeginCombo
EXTRN	?EndCombo@ImGui@@YAXXZ:PROC			; ImGui::EndCombo
EXTRN	?DragFloat@ImGui@@YA_NPEBDPEAMMMM0H@Z:PROC	; ImGui::DragFloat
EXTRN	?SliderFloat@ImGui@@YA_NPEBDPEAMMM0H@Z:PROC	; ImGui::SliderFloat
EXTRN	?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z:PROC	; ImGui::ColorPicker4
EXTRN	?CollapsingHeader@ImGui@@YA_NPEBDH@Z:PROC	; ImGui::CollapsingHeader
EXTRN	?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z:PROC ; ImGui::Selectable
EXTRN	?DockSpace@ImGui@@YAIIAEBUImVec2@@HPEBUImGuiWindowClass@@@Z:PROC ; ImGui::DockSpace
EXTRN	?SetItemDefaultFocus@ImGui@@YAXXZ:PROC		; ImGui::SetItemDefaultFocus
EXTRN	?GetMainViewport@ImGui@@YAPEAUImGuiViewport@@XZ:PROC ; ImGui::GetMainViewport
EXTRN	?DebugCheckVersionAndDataLayout@ImGui@@YA_NPEBD_K11111@Z:PROC ; ImGui::DebugCheckVersionAndDataLayout
EXTRN	?MemAlloc@ImGui@@YAPEAX_K@Z:PROC		; ImGui::MemAlloc
EXTRN	?MemFree@ImGui@@YAXPEAX@Z:PROC			; ImGui::MemFree
EXTRN	?UpdatePlatformWindows@ImGui@@YAXXZ:PROC	; ImGui::UpdatePlatformWindows
EXTRN	?RenderPlatformWindowsDefault@ImGui@@YAXPEAX0@Z:PROC ; ImGui::RenderPlatformWindowsDefault
EXTRN	?ImGui_ImplOpenGL3_Init@@YA_NPEBD@Z:PROC	; ImGui_ImplOpenGL3_Init
EXTRN	?ImGui_ImplOpenGL3_NewFrame@@YAXXZ:PROC		; ImGui_ImplOpenGL3_NewFrame
EXTRN	?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z:PROC ; ImGui_ImplOpenGL3_RenderDrawData
EXTRN	?ImGui_ImplGlfw_InitForOpenGL@@YA_NPEAUGLFWwindow@@_N@Z:PROC ; ImGui_ImplGlfw_InitForOpenGL
EXTRN	?ImGui_ImplGlfw_NewFrame@@YAXXZ:PROC		; ImGui_ImplGlfw_NewFrame
EXTRN	glfwInit:PROC
EXTRN	glfwTerminate:PROC
EXTRN	glfwWindowHint:PROC
EXTRN	glfwCreateWindow:PROC
EXTRN	glfwWindowShouldClose:PROC
EXTRN	glfwSetWindowShouldClose:PROC
EXTRN	glfwGetFramebufferSize:PROC
EXTRN	glfwSetFramebufferSizeCallback:PROC
EXTRN	glfwPollEvents:PROC
EXTRN	glfwGetKey:PROC
EXTRN	glfwGetTime:PROC
EXTRN	glfwMakeContextCurrent:PROC
EXTRN	glfwGetCurrentContext:PROC
EXTRN	glfwSwapBuffers:PROC
EXTRN	calloc:PROC
EXTRN	free:PROC
EXTRN	malloc:PROC
EXTRN	realloc:PROC
EXTRN	abs:PROC
EXTRN	ldexp:PROC
EXTRN	ceilf:PROC
EXTRN	cosf:PROC
EXTRN	powf:PROC
EXTRN	sinf:PROC
EXTRN	tanf:PROC
EXTRN	__acrt_iob_func:PROC
EXTRN	fopen_s:PROC
EXTRN	fclose:PROC
EXTRN	feof:PROC
EXTRN	ferror:PROC
EXTRN	fgetc:PROC
EXTRN	fopen:PROC
EXTRN	fread:PROC
EXTRN	fseek:PROC
EXTRN	ftell:PROC
EXTRN	ungetc:PROC
EXTRN	__stdio_common_vfprintf:PROC
EXTRN	__stdio_common_vsprintf:PROC
EXTRN	exit:PROC
EXTRN	_lrotl:PROC
EXTRN	strtod:PROC
EXTRN	strtol:PROC
EXTRN	__CxxFrameHandler4:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__GSHandlerCheck_EH4:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp___glewActiveTexture:QWORD
EXTRN	__imp___glewBindBuffer:QWORD
EXTRN	__imp___glewBufferData:QWORD
EXTRN	__imp___glewGenBuffers:QWORD
EXTRN	__imp___glewAttachShader:QWORD
EXTRN	__imp___glewCompileShader:QWORD
EXTRN	__imp___glewCreateProgram:QWORD
EXTRN	__imp___glewCreateShader:QWORD
EXTRN	__imp___glewEnableVertexAttribArray:QWORD
EXTRN	__imp___glewGetProgramInfoLog:QWORD
EXTRN	__imp___glewGetProgramiv:QWORD
EXTRN	__imp___glewGetShaderInfoLog:QWORD
EXTRN	__imp___glewGetShaderiv:QWORD
EXTRN	__imp___glewGetUniformLocation:QWORD
EXTRN	__imp___glewLinkProgram:QWORD
EXTRN	__imp___glewShaderSource:QWORD
EXTRN	__imp___glewUniform1f:QWORD
EXTRN	__imp___glewUniform1i:QWORD
EXTRN	__imp___glewUniform3f:QWORD
EXTRN	__imp___glewUniformMatrix4fv:QWORD
EXTRN	__imp___glewUseProgram:QWORD
EXTRN	__imp___glewVertexAttribPointer:QWORD
EXTRN	__imp___glewBindFramebuffer:QWORD
EXTRN	__imp___glewBindRenderbuffer:QWORD
EXTRN	__imp___glewCheckFramebufferStatus:QWORD
EXTRN	__imp___glewFramebufferRenderbuffer:QWORD
EXTRN	__imp___glewFramebufferTexture2D:QWORD
EXTRN	__imp___glewGenFramebuffers:QWORD
EXTRN	__imp___glewGenRenderbuffers:QWORD
EXTRN	__imp___glewGenerateMipmap:QWORD
EXTRN	__imp___glewRenderbufferStorage:QWORD
EXTRN	__imp___glewBindVertexArray:QWORD
EXTRN	__imp___glewGenVertexArrays:QWORD
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
EXTRN	_tls_index:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_TLS	SEGMENT
?stbi__g_failure_reason@@3PEBDEB DQ 01H DUP (?)		; stbi__g_failure_reason
_TLS	ENDS
_BSS	SEGMENT
?stbi__vertically_flip_on_load_global@@3HA DD 01H DUP (?) ; stbi__vertically_flip_on_load_global
_BSS	ENDS
_TLS	SEGMENT
?stbi__vertically_flip_on_load_local@@3HA DD 01H DUP (?) ; stbi__vertically_flip_on_load_local
?stbi__vertically_flip_on_load_set@@3HA DD 01H DUP (?)	; stbi__vertically_flip_on_load_set
_TLS	ENDS
_BSS	SEGMENT
?stbi__unpremultiply_on_load_global@@3HA DD 01H DUP (?)	; stbi__unpremultiply_on_load_global
?stbi__de_iphone_flag_global@@3HA DD 01H DUP (?)	; stbi__de_iphone_flag_global
_BSS	ENDS
_TLS	SEGMENT
?stbi__unpremultiply_on_load_local@@3HA DD 01H DUP (?)	; stbi__unpremultiply_on_load_local
?stbi__unpremultiply_on_load_set@@3HA DD 01H DUP (?)	; stbi__unpremultiply_on_load_set
?stbi__de_iphone_flag_local@@3HA DD 01H DUP (?)		; stbi__de_iphone_flag_local
?stbi__de_iphone_flag_set@@3HA DD 01H DUP (?)		; stbi__de_iphone_flag_set
_TLS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?strrchr@@YAPEADQEADH@Z DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$?strrchr@@YAPEADQEADH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$ImVector@G@@QEAA@AEBU0@@Z DD imagerel $LN3
	DD	imagerel $LN3+75
	DD	imagerel $unwind$??0?$ImVector@G@@QEAA@AEBU0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$ImVector@G@@QEAAAEAU0@AEBU0@@Z DD imagerel $LN4
	DD	imagerel $LN4+100
	DD	imagerel $unwind$??4?$ImVector@G@@QEAAAEAU0@AEBU0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$ImVector@G@@QEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+41
	DD	imagerel $unwind$??1?$ImVector@G@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$ImVector@G@@QEAAXXZ DD imagerel $LN4
	DD	imagerel $LN4+76
	DD	imagerel $unwind$?clear@?$ImVector@G@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_grow_capacity@?$ImVector@G@@QEBAHH@Z DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$?_grow_capacity@?$ImVector@G@@QEBAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$ImVector@G@@QEAAXH@Z DD imagerel $LN4
	DD	imagerel $LN4+69
	DD	imagerel $unwind$?resize@?$ImVector@G@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$ImVector@G@@QEAAXH@Z DD imagerel $LN5
	DD	imagerel $LN5+140
	DD	imagerel $unwind$?reserve@?$ImVector@G@@QEAAXH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ImGuiIO@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$??1ImGuiIO@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ImGuiIO@@QEAA@AEBU0@@Z DD imagerel $LN4
	DD	imagerel $LN4+2341
	DD	imagerel $unwind$??0ImGuiIO@@QEAA@AEBU0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ldexpf DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$ldexpf
pdata	ENDS
pdata	SEGMENT
$pdata$HMM_ToRad DD imagerel HMM_ToRad
	DD	imagerel HMM_ToRad+39
	DD	imagerel $unwind$HMM_ToRad
$pdata$HMM_SinF DD imagerel HMM_SinF
	DD	imagerel HMM_SinF+26
	DD	imagerel $unwind$HMM_SinF
$pdata$HMM_CosF DD imagerel HMM_CosF
	DD	imagerel HMM_CosF+26
	DD	imagerel $unwind$HMM_CosF
$pdata$HMM_TanF DD imagerel HMM_TanF
	DD	imagerel HMM_TanF+26
	DD	imagerel $unwind$HMM_TanF
$pdata$HMM_SqrtF DD imagerel HMM_SqrtF
	DD	imagerel HMM_SqrtF+97
	DD	imagerel $unwind$HMM_SqrtF
$pdata$HMM_InvSqrtF DD imagerel HMM_InvSqrtF
	DD	imagerel HMM_InvSqrtF+53
	DD	imagerel $unwind$HMM_InvSqrtF
$pdata$HMM_V2 DD imagerel HMM_V2
	DD	imagerel HMM_V2+76
	DD	imagerel $unwind$HMM_V2
$pdata$HMM_V3 DD imagerel HMM_V3
	DD	imagerel HMM_V3+123
	DD	imagerel $unwind$HMM_V3
$pdata$HMM_V4V DD imagerel HMM_V4V
	DD	imagerel HMM_V4V+132
	DD	imagerel $unwind$HMM_V4V
$pdata$HMM_AddV3 DD imagerel HMM_AddV3
	DD	imagerel HMM_AddV3+155
	DD	imagerel $unwind$HMM_AddV3
$pdata$HMM_SubV3 DD imagerel HMM_SubV3
	DD	imagerel HMM_SubV3+155
	DD	imagerel $unwind$HMM_SubV3
$pdata$HMM_MulV3F DD imagerel HMM_MulV3F
	DD	imagerel HMM_MulV3F+145
	DD	imagerel $unwind$HMM_MulV3F
$pdata$HMM_DivV3F DD imagerel HMM_DivV3F
	DD	imagerel HMM_DivV3F+145
	DD	imagerel $unwind$HMM_DivV3F
$pdata$HMM_Cross DD imagerel HMM_Cross
	DD	imagerel HMM_Cross+225
	DD	imagerel $unwind$HMM_Cross
$pdata$HMM_NormV3 DD imagerel HMM_NormV3
	DD	imagerel HMM_NormV3+213
	DD	imagerel $unwind$HMM_NormV3
$pdata$HMM_LinearCombineV4M4 DD imagerel HMM_LinearCombineV4M4
	DD	imagerel HMM_LinearCombineV4M4+450
	DD	imagerel $unwind$HMM_LinearCombineV4M4
$pdata$HMM_M4D DD imagerel HMM_M4D
	DD	imagerel HMM_M4D+233
	DD	imagerel $unwind$HMM_M4D
$pdata$HMM_MulM4 DD imagerel HMM_MulM4
	DD	imagerel HMM_MulM4+600
	DD	imagerel $unwind$HMM_MulM4
$pdata$HMM_MulM4V4 DD imagerel HMM_MulM4V4
	DD	imagerel HMM_MulM4V4+168
	DD	imagerel $unwind$HMM_MulM4V4
$pdata$HMM_Perspective_RH_NO DD imagerel HMM_Perspective_RH_NO
	DD	imagerel HMM_Perspective_RH_NO+427
	DD	imagerel $unwind$HMM_Perspective_RH_NO
$pdata$HMM_Translate DD imagerel HMM_Translate
	DD	imagerel HMM_Translate+281
	DD	imagerel $unwind$HMM_Translate
$pdata$HMM_Rotate_RH DD imagerel HMM_Rotate_RH
	DD	imagerel HMM_Rotate_RH+1031
	DD	imagerel $unwind$HMM_Rotate_RH
$pdata$HMM_Scale DD imagerel HMM_Scale
	DD	imagerel HMM_Scale+281
	DD	imagerel $unwind$HMM_Scale
$pdata$_HMM_LookAt DD imagerel _HMM_LookAt
	DD	imagerel _HMM_LookAt+952
	DD	imagerel $unwind$_HMM_LookAt
$pdata$HMM_LookAt_RH DD imagerel HMM_LookAt_RH
	DD	imagerel HMM_LookAt_RH+805
	DD	imagerel $unwind$HMM_LookAt_RH
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+67
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fprintf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$fprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+117
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?cos@@YAMM@Z DD imagerel $LN3
	DD	imagerel $LN3+26
	DD	imagerel $unwind$?cos@@YAMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ldexp@@YAMMH@Z DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$?ldexp@@YAMMH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pow@@YAMMM@Z DD imagerel $LN3
	DD	imagerel $LN3+38
	DD	imagerel $unwind$?pow@@YAMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?sin@@YAMM@Z DD imagerel $LN3
	DD	imagerel $LN3+26
	DD	imagerel $unwind$?sin@@YAMM@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?_stack_resize@@YAHPEAPEAXII@Z DD imagerel ?_stack_resize@@YAHPEAPEAXII@Z
	DD	imagerel ?_stack_resize@@YAHPEAPEAXII@Z+322
	DD	imagerel $unwind$?_stack_resize@@YAHPEAPEAXII@Z
$pdata$?_stack_fit@@YAPEAXPEAPEAXII@Z DD imagerel ?_stack_fit@@YAPEAXPEAPEAXII@Z
	DD	imagerel ?_stack_fit@@YAPEAXPEAPEAXII@Z+215
	DD	imagerel $unwind$?_stack_fit@@YAPEAXPEAPEAXII@Z
$pdata$?_stack_push@@YAPEAXPEAPEAXII@Z DD imagerel ?_stack_push@@YAPEAXPEAPEAXII@Z
	DD	imagerel ?_stack_push@@YAPEAXPEAPEAXII@Z+157
	DD	imagerel $unwind$?_stack_push@@YAPEAXPEAPEAXII@Z
$pdata$stbi_load_from_memory DD imagerel $LN3
	DD	imagerel $LN3+139
	DD	imagerel $unwind$stbi_load_from_memory
$pdata$stbi_load_from_callbacks DD imagerel $LN3
	DD	imagerel $LN3+140
	DD	imagerel $unwind$stbi_load_from_callbacks
$pdata$stbi_load DD imagerel $LN6
	DD	imagerel $LN6+156
	DD	imagerel $unwind$stbi_load
$pdata$stbi_load_from_file DD imagerel $LN4
	DD	imagerel $LN4+195
	DD	imagerel $unwind$stbi_load_from_file
$pdata$stbi_load_gif_from_memory DD imagerel $LN6
	DD	imagerel $LN6+315
	DD	imagerel $unwind$stbi_load_gif_from_memory
$pdata$stbi_load_16_from_memory DD imagerel $LN3
	DD	imagerel $LN3+139
	DD	imagerel $unwind$stbi_load_16_from_memory
$pdata$stbi_load_16_from_callbacks DD imagerel $LN3
	DD	imagerel $LN3+140
	DD	imagerel $unwind$stbi_load_16_from_callbacks
$pdata$stbi_load_16 DD imagerel $LN6
	DD	imagerel $LN6+156
	DD	imagerel $unwind$stbi_load_16
$pdata$stbi_load_from_file_16 DD imagerel $LN4
	DD	imagerel $LN4+195
	DD	imagerel $unwind$stbi_load_from_file_16
$pdata$stbi_loadf_from_memory DD imagerel $LN3
	DD	imagerel $LN3+139
	DD	imagerel $unwind$stbi_loadf_from_memory
$pdata$stbi_loadf_from_callbacks DD imagerel $LN3
	DD	imagerel $LN3+140
	DD	imagerel $unwind$stbi_loadf_from_callbacks
$pdata$stbi_loadf DD imagerel $LN6
	DD	imagerel $LN6+156
	DD	imagerel $unwind$stbi_loadf
$pdata$stbi_loadf_from_file DD imagerel $LN3
	DD	imagerel $LN3+132
	DD	imagerel $unwind$stbi_loadf_from_file
$pdata$stbi_is_hdr_from_callbacks DD imagerel $LN3
	DD	imagerel $LN3+95
	DD	imagerel $unwind$stbi_is_hdr_from_callbacks
$pdata$stbi_is_hdr_from_memory DD imagerel $LN3
	DD	imagerel $LN3+94
	DD	imagerel $unwind$stbi_is_hdr_from_memory
$pdata$stbi_is_hdr DD imagerel $LN4
	DD	imagerel $LN4+80
	DD	imagerel $unwind$stbi_is_hdr
$pdata$stbi_is_hdr_from_file DD imagerel $LN3
	DD	imagerel $LN3+127
	DD	imagerel $unwind$stbi_is_hdr_from_file
$pdata$stbi_image_free DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$stbi_image_free
$pdata$stbi_info_from_memory DD imagerel $LN3
	DD	imagerel $LN3+128
	DD	imagerel $unwind$stbi_info_from_memory
$pdata$stbi_info_from_callbacks DD imagerel $LN3
	DD	imagerel $LN3+129
	DD	imagerel $unwind$stbi_info_from_callbacks
$pdata$stbi_is_16_bit_from_memory DD imagerel $LN3
	DD	imagerel $LN3+94
	DD	imagerel $unwind$stbi_is_16_bit_from_memory
$pdata$stbi_is_16_bit_from_callbacks DD imagerel $LN3
	DD	imagerel $LN3+95
	DD	imagerel $unwind$stbi_is_16_bit_from_callbacks
$pdata$stbi_info DD imagerel $LN4
	DD	imagerel $LN4+116
	DD	imagerel $unwind$stbi_info
$pdata$stbi_info_from_file DD imagerel $LN3
	DD	imagerel $LN3+166
	DD	imagerel $unwind$stbi_info_from_file
$pdata$stbi_is_16_bit DD imagerel $LN4
	DD	imagerel $LN4+86
	DD	imagerel $unwind$stbi_is_16_bit
$pdata$stbi_is_16_bit_from_file DD imagerel $LN3
	DD	imagerel $LN3+127
	DD	imagerel $unwind$stbi_is_16_bit_from_file
$pdata$stbi_zlib_decode_malloc_guesssize DD imagerel $LN7
	DD	imagerel $LN7+249
	DD	imagerel $unwind$stbi_zlib_decode_malloc_guesssize
$pdata$stbi_zlib_decode_malloc_guesssize_headerflag DD imagerel $LN7
	DD	imagerel $LN7+252
	DD	imagerel $unwind$stbi_zlib_decode_malloc_guesssize_headerflag
$pdata$stbi_zlib_decode_malloc DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$stbi_zlib_decode_malloc
$pdata$stbi_zlib_decode_buffer DD imagerel $LN5
	DD	imagerel $LN5+180
	DD	imagerel $unwind$stbi_zlib_decode_buffer
$pdata$stbi_zlib_decode_noheader_malloc DD imagerel $LN7
	DD	imagerel $LN7+236
	DD	imagerel $unwind$stbi_zlib_decode_noheader_malloc
$pdata$stbi_zlib_decode_noheader_buffer DD imagerel $LN5
	DD	imagerel $LN5+180
	DD	imagerel $unwind$stbi_zlib_decode_noheader_buffer
$pdata$?stbi__cpuid3@@YAHXZ DD imagerel ?stbi__cpuid3@@YAHXZ
	DD	imagerel ?stbi__cpuid3@@YAHXZ+80
	DD	imagerel $unwind$?stbi__cpuid3@@YAHXZ
$pdata$?stbi__sse2_available@@YAHXZ DD imagerel ?stbi__sse2_available@@YAHXZ
	DD	imagerel ?stbi__sse2_available@@YAHXZ+54
	DD	imagerel $unwind$?stbi__sse2_available@@YAHXZ
$pdata$?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z DD imagerel ?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z
	DD	imagerel ?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z+231
	DD	imagerel $unwind$?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z
$pdata$?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z DD imagerel ?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z
	DD	imagerel ?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z+147
	DD	imagerel $unwind$?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z
$pdata$?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z DD imagerel ?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z
	DD	imagerel ?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z+184
	DD	imagerel $unwind$?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z
$pdata$?stbi__stdio_read@@YAHPEAXPEADH@Z DD imagerel ?stbi__stdio_read@@YAHPEAXPEADH@Z
	DD	imagerel ?stbi__stdio_read@@YAHPEAXPEADH@Z+52
	DD	imagerel $unwind$?stbi__stdio_read@@YAHPEAXPEADH@Z
$pdata$?stbi__stdio_skip@@YAXPEAXH@Z DD imagerel ?stbi__stdio_skip@@YAXPEAXH@Z
	DD	imagerel ?stbi__stdio_skip@@YAXPEAXH@Z+73
	DD	imagerel $unwind$?stbi__stdio_skip@@YAXPEAXH@Z
$pdata$?stbi__stdio_eof@@YAHPEAX@Z DD imagerel ?stbi__stdio_eof@@YAHPEAX@Z
	DD	imagerel ?stbi__stdio_eof@@YAHPEAX@Z+64
	DD	imagerel $unwind$?stbi__stdio_eof@@YAHPEAX@Z
$pdata$?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z DD imagerel ?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z
	DD	imagerel ?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z+41
	DD	imagerel $unwind$?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z
$pdata$?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z+135
	DD	imagerel $unwind$?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__jpeg_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__jpeg_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__jpeg_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+190
	DD	imagerel $unwind$?stbi__jpeg_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
$pdata$?stbi__jpeg_info@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__jpeg_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__jpeg_info@@YAHPEAUstbi__context@@PEAH11@Z+140
	DD	imagerel $unwind$?stbi__jpeg_info@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__png_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__png_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__png_test@@YAHPEAUstbi__context@@@Z+42
	DD	imagerel $unwind$?stbi__png_test@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__png_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__png_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__png_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+94
	DD	imagerel $unwind$?stbi__png_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
$pdata$?stbi__png_info@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__png_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__png_info@@YAHPEAUstbi__context@@PEAH11@Z+64
	DD	imagerel $unwind$?stbi__png_info@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__png_is16@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__png_is16@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__png_is16@@YAHPEAUstbi__context@@@Z+76
	DD	imagerel $unwind$?stbi__png_is16@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__bmp_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__bmp_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__bmp_test@@YAHPEAUstbi__context@@@Z+42
	DD	imagerel $unwind$?stbi__bmp_test@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+4719
	DD	imagerel $unwind$?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
$pdata$?stbi__bmp_info@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__bmp_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__bmp_info@@YAHPEAUstbi__context@@PEAH11@Z+249
	DD	imagerel $unwind$?stbi__bmp_info@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__tga_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__tga_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__tga_test@@YAHPEAUstbi__context@@@Z+402
	DD	imagerel $unwind$?stbi__tga_test@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__tga_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__tga_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__tga_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+2679
	DD	imagerel $unwind$?stbi__tga_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
$pdata$?stbi__tga_info@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__tga_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__tga_info@@YAHPEAUstbi__context@@PEAH11@Z+612
	DD	imagerel $unwind$?stbi__tga_info@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__psd_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__psd_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__psd_test@@YAHPEAUstbi__context@@@Z+71
	DD	imagerel $unwind$?stbi__psd_test@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z DD imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
	DD	imagerel ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+2963
	DD	imagerel $unwind$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
$pdata$?stbi__psd_info@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__psd_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__psd_info@@YAHPEAUstbi__context@@PEAH11@Z+327
	DD	imagerel $unwind$?stbi__psd_info@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__psd_is16@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__psd_is16@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__psd_is16@@YAHPEAUstbi__context@@@Z+194
	DD	imagerel $unwind$?stbi__psd_is16@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__hdr_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__hdr_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__hdr_test@@YAHPEAUstbi__context@@@Z+87
	DD	imagerel $unwind$?stbi__hdr_test@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+2341
	DD	imagerel $unwind$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
$pdata$?stbi__hdr_info@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__hdr_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__hdr_info@@YAHPEAUstbi__context@@PEAH11@Z+539
	DD	imagerel $unwind$?stbi__hdr_info@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__pic_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__pic_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__pic_test@@YAHPEAUstbi__context@@@Z+42
	DD	imagerel $unwind$?stbi__pic_test@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+656
	DD	imagerel $unwind$?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
$pdata$?stbi__pic_info@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__pic_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__pic_info@@YAHPEAUstbi__context@@PEAH11@Z+642
	DD	imagerel $unwind$?stbi__pic_info@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__gif_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__gif_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__gif_test@@YAHPEAUstbi__context@@@Z+42
	DD	imagerel $unwind$?stbi__gif_test@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__gif_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__gif_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__gif_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+316
	DD	imagerel $unwind$?stbi__gif_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
$pdata$?stbi__load_gif_main@@YAPEAXPEAUstbi__context@@PEAPEAHPEAH222H@Z DD imagerel ?stbi__load_gif_main@@YAPEAXPEAUstbi__context@@PEAPEAHPEAH222H@Z
	DD	imagerel ?stbi__load_gif_main@@YAPEAXPEAUstbi__context@@PEAPEAHPEAH222H@Z+1005
	DD	imagerel $unwind$?stbi__load_gif_main@@YAPEAXPEAUstbi__context@@PEAPEAHPEAH222H@Z
$pdata$?stbi__gif_info@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__gif_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__gif_info@@YAHPEAUstbi__context@@PEAH11@Z+54
	DD	imagerel $unwind$?stbi__gif_info@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__pnm_test@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__pnm_test@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__pnm_test@@YAHPEAUstbi__context@@@Z+91
	DD	imagerel $unwind$?stbi__pnm_test@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__pnm_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__pnm_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__pnm_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z+793
	DD	imagerel $unwind$?stbi__pnm_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z
$pdata$?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z+430
	DD	imagerel $unwind$?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__pnm_is16@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__pnm_is16@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__pnm_is16@@YAHPEAUstbi__context@@@Z+46
	DD	imagerel $unwind$?stbi__pnm_is16@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__malloc@@YAPEAX_K@Z DD imagerel ?stbi__malloc@@YAPEAX_K@Z
	DD	imagerel ?stbi__malloc@@YAPEAX_K@Z+24
	DD	imagerel $unwind$?stbi__malloc@@YAPEAX_K@Z
$pdata$?stbi__addsizes_valid@@YAHHH@Z DD imagerel ?stbi__addsizes_valid@@YAHHH@Z
	DD	imagerel ?stbi__addsizes_valid@@YAHHH@Z+62
	DD	imagerel $unwind$?stbi__addsizes_valid@@YAHHH@Z
$pdata$?stbi__mul2sizes_valid@@YAHHH@Z DD imagerel ?stbi__mul2sizes_valid@@YAHHH@Z
	DD	imagerel ?stbi__mul2sizes_valid@@YAHHH@Z+84
	DD	imagerel $unwind$?stbi__mul2sizes_valid@@YAHHH@Z
$pdata$?stbi__mad2sizes_valid@@YAHHHH@Z DD imagerel ?stbi__mad2sizes_valid@@YAHHHH@Z
	DD	imagerel ?stbi__mad2sizes_valid@@YAHHHH@Z+85
	DD	imagerel $unwind$?stbi__mad2sizes_valid@@YAHHHH@Z
$pdata$?stbi__mad3sizes_valid@@YAHHHHH@Z DD imagerel ?stbi__mad3sizes_valid@@YAHHHHH@Z
	DD	imagerel ?stbi__mad3sizes_valid@@YAHHHHH@Z+119
	DD	imagerel $unwind$?stbi__mad3sizes_valid@@YAHHHHH@Z
$pdata$?stbi__mad4sizes_valid@@YAHHHHHH@Z DD imagerel ?stbi__mad4sizes_valid@@YAHHHHHH@Z
	DD	imagerel ?stbi__mad4sizes_valid@@YAHHHHHH@Z+153
	DD	imagerel $unwind$?stbi__mad4sizes_valid@@YAHHHHHH@Z
$pdata$?stbi__malloc_mad2@@YAPEAXHHH@Z DD imagerel ?stbi__malloc_mad2@@YAPEAXHHH@Z
	DD	imagerel ?stbi__malloc_mad2@@YAPEAXHHH@Z+71
	DD	imagerel $unwind$?stbi__malloc_mad2@@YAPEAXHHH@Z
$pdata$?stbi__malloc_mad3@@YAPEAXHHHH@Z DD imagerel ?stbi__malloc_mad3@@YAPEAXHHHH@Z
	DD	imagerel ?stbi__malloc_mad3@@YAPEAXHHHH@Z+86
	DD	imagerel $unwind$?stbi__malloc_mad3@@YAPEAXHHHH@Z
$pdata$?stbi__malloc_mad4@@YAPEAXHHHHH@Z DD imagerel ?stbi__malloc_mad4@@YAPEAXHHHHH@Z
	DD	imagerel ?stbi__malloc_mad4@@YAPEAXHHHHH@Z+99
	DD	imagerel $unwind$?stbi__malloc_mad4@@YAPEAXHHHHH@Z
$pdata$?stbi__addints_valid@@YAHHH@Z DD imagerel ?stbi__addints_valid@@YAHHH@Z
	DD	imagerel ?stbi__addints_valid@@YAHHH@Z+171
	DD	imagerel $unwind$?stbi__addints_valid@@YAHHH@Z
$pdata$?stbi__mul2shorts_valid@@YAHHH@Z DD imagerel ?stbi__mul2shorts_valid@@YAHHH@Z
	DD	imagerel ?stbi__mul2shorts_valid@@YAHHH@Z+223
	DD	imagerel $unwind$?stbi__mul2shorts_valid@@YAHHH@Z
$pdata$?stbi__ldr_to_hdr@@YAPEAMPEAEHHH@Z DD imagerel ?stbi__ldr_to_hdr@@YAPEAMPEAEHHH@Z
	DD	imagerel ?stbi__ldr_to_hdr@@YAPEAMPEAEHHH@Z+450
	DD	imagerel $unwind$?stbi__ldr_to_hdr@@YAPEAMPEAEHHH@Z
$pdata$?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z DD imagerel ?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z
	DD	imagerel ?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z+541
	DD	imagerel $unwind$?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z
$pdata$?stbi__load_main@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z DD imagerel ?stbi__load_main@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
	DD	imagerel ?stbi__load_main@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z+819
	DD	imagerel $unwind$?stbi__load_main@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z
$pdata$?stbi__convert_16_to_8@@YAPEAEPEAGHHH@Z DD imagerel ?stbi__convert_16_to_8@@YAPEAEPEAGHHH@Z
	DD	imagerel ?stbi__convert_16_to_8@@YAPEAEPEAGHHH@Z+195
	DD	imagerel $unwind$?stbi__convert_16_to_8@@YAPEAEPEAGHHH@Z
$pdata$?stbi__convert_8_to_16@@YAPEAGPEAEHHH@Z DD imagerel ?stbi__convert_8_to_16@@YAPEAGPEAEHHH@Z
	DD	imagerel ?stbi__convert_8_to_16@@YAPEAGPEAEHHH@Z+210
	DD	imagerel $unwind$?stbi__convert_8_to_16@@YAPEAGPEAEHHH@Z
$pdata$?stbi__vertical_flip@@YAXPEAXHHH@Z DD imagerel ?stbi__vertical_flip@@YAXPEAXHHH@Z
	DD	imagerel ?stbi__vertical_flip@@YAXPEAXHHH@Z+410
	DD	imagerel $unwind$?stbi__vertical_flip@@YAXPEAXHHH@Z
$pdata$?stbi__vertical_flip_slices@@YAXPEAXHHHH@Z DD imagerel ?stbi__vertical_flip_slices@@YAXPEAXHHHH@Z
	DD	imagerel ?stbi__vertical_flip_slices@@YAXPEAXHHHH@Z+133
	DD	imagerel $unwind$?stbi__vertical_flip_slices@@YAXPEAXHHHH@Z
$pdata$?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z DD imagerel ?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z
	DD	imagerel ?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z+453
	DD	imagerel $unwind$?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z
$pdata$?stbi__load_and_postprocess_16bit@@YAPEAGPEAUstbi__context@@PEAH11H@Z DD imagerel ?stbi__load_and_postprocess_16bit@@YAPEAGPEAUstbi__context@@PEAH11H@Z
	DD	imagerel ?stbi__load_and_postprocess_16bit@@YAPEAGPEAUstbi__context@@PEAH11H@Z+459
	DD	imagerel $unwind$?stbi__load_and_postprocess_16bit@@YAPEAGPEAUstbi__context@@PEAH11H@Z
$pdata$?stbi__float_postprocess@@YAXPEAMPEAH11H@Z DD imagerel ?stbi__float_postprocess@@YAXPEAMPEAH11H@Z
	DD	imagerel ?stbi__float_postprocess@@YAXPEAMPEAH11H@Z+194
	DD	imagerel $unwind$?stbi__float_postprocess@@YAXPEAMPEAH11H@Z
$pdata$?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z DD imagerel ?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z
	DD	imagerel ?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z+57
	DD	imagerel $unwind$?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z
$pdata$?stbi__loadf_main@@YAPEAMPEAUstbi__context@@PEAH11H@Z DD imagerel ?stbi__loadf_main@@YAPEAMPEAUstbi__context@@PEAH11H@Z
	DD	imagerel ?stbi__loadf_main@@YAPEAMPEAUstbi__context@@PEAH11H@Z+354
	DD	imagerel $unwind$?stbi__loadf_main@@YAPEAMPEAUstbi__context@@PEAH11H@Z
$pdata$?stbi__get8@@YAEPEAUstbi__context@@@Z DD imagerel ?stbi__get8@@YAEPEAUstbi__context@@@Z
	DD	imagerel ?stbi__get8@@YAEPEAUstbi__context@@@Z+169
	DD	imagerel $unwind$?stbi__get8@@YAEPEAUstbi__context@@@Z
$pdata$?stbi__at_eof@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__at_eof@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__at_eof@@YAHPEAUstbi__context@@@Z+117
	DD	imagerel $unwind$?stbi__at_eof@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__skip@@YAXPEAUstbi__context@@H@Z DD imagerel ?stbi__skip@@YAXPEAUstbi__context@@H@Z
	DD	imagerel ?stbi__skip@@YAXPEAUstbi__context@@H@Z+205
	DD	imagerel $unwind$?stbi__skip@@YAXPEAUstbi__context@@H@Z
$pdata$?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z DD imagerel ?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z
	DD	imagerel ?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z+345
	DD	imagerel $unwind$?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z
$pdata$?stbi__get16be@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__get16be@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__get16be@@YAHPEAUstbi__context@@@Z+63
	DD	imagerel $unwind$?stbi__get16be@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__get32be@@YAIPEAUstbi__context@@@Z DD imagerel ?stbi__get32be@@YAIPEAUstbi__context@@@Z
	DD	imagerel ?stbi__get32be@@YAIPEAUstbi__context@@@Z+57
	DD	imagerel $unwind$?stbi__get32be@@YAIPEAUstbi__context@@@Z
$pdata$?stbi__get16le@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__get16le@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__get16le@@YAHPEAUstbi__context@@@Z+55
	DD	imagerel $unwind$?stbi__get16le@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__get32le@@YAIPEAUstbi__context@@@Z DD imagerel ?stbi__get32le@@YAIPEAUstbi__context@@@Z
	DD	imagerel ?stbi__get32le@@YAIPEAUstbi__context@@@Z+57
	DD	imagerel $unwind$?stbi__get32le@@YAIPEAUstbi__context@@@Z
$pdata$?stbi__convert_format@@YAPEAEPEAEHHII@Z DD imagerel ?stbi__convert_format@@YAPEAEPEAEHHII@Z
	DD	imagerel ?stbi__convert_format@@YAPEAEPEAEHHII@Z+2660
	DD	imagerel $unwind$?stbi__convert_format@@YAPEAEPEAEHHII@Z
$pdata$?stbi__convert_format16@@YAPEAGPEAGHHII@Z DD imagerel ?stbi__convert_format16@@YAPEAGPEAGHHII@Z
	DD	imagerel ?stbi__convert_format16@@YAPEAGPEAGHHII@Z+2712
	DD	imagerel $unwind$?stbi__convert_format16@@YAPEAGPEAGHHII@Z
$pdata$?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z DD imagerel ?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z
	DD	imagerel ?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z+675
	DD	imagerel $unwind$?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z
$pdata$?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z DD imagerel ?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z
	DD	imagerel ?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z+367
	DD	imagerel $unwind$?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z
$pdata$?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z DD imagerel ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z+264
	DD	imagerel $unwind$?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z
$pdata$?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z DD imagerel ?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z
	DD	imagerel ?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z+688
	DD	imagerel $unwind$?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z
$pdata$?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z DD imagerel ?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z
	DD	imagerel ?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z+233
	DD	imagerel $unwind$?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z
$pdata$?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z DD imagerel ?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z
	DD	imagerel ?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z+185
	DD	imagerel $unwind$?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z
$pdata$?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z DD imagerel ?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z+128
	DD	imagerel $unwind$?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z
$pdata$?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z DD imagerel ?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z
	DD	imagerel ?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z+881
	DD	imagerel $unwind$?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z
$pdata$?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z DD imagerel ?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z
	DD	imagerel ?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z+517
	DD	imagerel $unwind$?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z
$pdata$?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z DD imagerel ?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z
	DD	imagerel ?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z+1655
	DD	imagerel $unwind$?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z
$pdata$?stbi__idct_block@@YAXPEAEHQEAF@Z DD imagerel ?stbi__idct_block@@YAXPEAEHQEAF@Z
	DD	imagerel ?stbi__idct_block@@YAXPEAEHQEAF@Z+2715
	DD	imagerel $unwind$?stbi__idct_block@@YAXPEAEHQEAF@Z
$pdata$?stbi__idct_simd@@YAXPEAEHQEAF@Z DD imagerel ?stbi__idct_simd@@YAXPEAEHQEAF@Z
	DD	imagerel ?stbi__idct_simd@@YAXPEAEHQEAF@Z+11018
	DD	imagerel $unwind$?stbi__idct_simd@@YAXPEAEHQEAF@Z
$pdata$?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z DD imagerel ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z+137
	DD	imagerel $unwind$?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z
$pdata$?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z DD imagerel ?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z+237
	DD	imagerel $unwind$?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z
$pdata$?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z DD imagerel ?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z+3156
	DD	imagerel $unwind$?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z
$pdata$?stbi__jpeg_dequantize@@YAXPEAFPEAG@Z DD imagerel ?stbi__jpeg_dequantize@@YAXPEAFPEAG@Z
	DD	imagerel ?stbi__jpeg_dequantize@@YAXPEAFPEAG@Z+86
	DD	imagerel $unwind$?stbi__jpeg_dequantize@@YAXPEAFPEAG@Z
$pdata$?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z DD imagerel ?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z+457
	DD	imagerel $unwind$?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z
$pdata$?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z DD imagerel ?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z
	DD	imagerel ?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z+1743
	DD	imagerel $unwind$?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z
$pdata$?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z DD imagerel ?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z+812
	DD	imagerel $unwind$?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z
$pdata$?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z DD imagerel ?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z
	DD	imagerel ?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z+352
	DD	imagerel $unwind$?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z
$pdata$?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z DD imagerel ?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z
	DD	imagerel ?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z+2318
	DD	imagerel $unwind$?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z
$pdata$?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z DD imagerel ?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z
	DD	imagerel ?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z+345
	DD	imagerel $unwind$?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z
$pdata$?stbi__skip_jpeg_junk_at_end@@YAEPEAUstbi__jpeg@@@Z DD imagerel ?stbi__skip_jpeg_junk_at_end@@YAEPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__skip_jpeg_junk_at_end@@YAEPEAUstbi__jpeg@@@Z+132
	DD	imagerel $unwind$?stbi__skip_jpeg_junk_at_end@@YAEPEAUstbi__jpeg@@@Z
$pdata$?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z DD imagerel ?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z+510
	DD	imagerel $unwind$?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z
$pdata$?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z DD imagerel ?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z
	DD	imagerel ?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z+110
	DD	imagerel $unwind$?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z
$pdata$?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z DD imagerel ?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z
	DD	imagerel ?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z+474
	DD	imagerel $unwind$?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z
$pdata$?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z DD imagerel ?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z
	DD	imagerel ?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z+383
	DD	imagerel $unwind$?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z
$pdata$?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z DD imagerel ?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z
	DD	imagerel ?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z+1637
	DD	imagerel $unwind$?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z
$pdata$?stbi__resample_row_generic@@YAPEAEPEAE00HH@Z DD imagerel ?stbi__resample_row_generic@@YAPEAEPEAE00HH@Z
	DD	imagerel ?stbi__resample_row_generic@@YAPEAEPEAE00HH@Z+131
	DD	imagerel $unwind$?stbi__resample_row_generic@@YAPEAEPEAE00HH@Z
$pdata$?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z DD imagerel ?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z
	DD	imagerel ?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z+451
	DD	imagerel $unwind$?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z
$pdata$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z DD imagerel ?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z
	DD	imagerel ?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z+1986
	DD	imagerel $unwind$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z
$pdata$?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z DD imagerel ?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z+137
	DD	imagerel $unwind$?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z
$pdata$?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z DD imagerel ?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z
	DD	imagerel ?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z+38
	DD	imagerel $unwind$?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z
$pdata$?stbi__blinn_8x8@@YAEEE@Z DD imagerel ?stbi__blinn_8x8@@YAEEE@Z
	DD	imagerel ?stbi__blinn_8x8@@YAEEE@Z+54
	DD	imagerel $unwind$?stbi__blinn_8x8@@YAEEE@Z
$pdata$?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z DD imagerel ?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z
	DD	imagerel ?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z+4514
	DD	imagerel $unwind$?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z
$pdata$?stbi__jpeg_info_raw@@YAHPEAUstbi__jpeg@@PEAH11@Z DD imagerel ?stbi__jpeg_info_raw@@YAHPEAUstbi__jpeg@@PEAH11@Z
	DD	imagerel ?stbi__jpeg_info_raw@@YAHPEAUstbi__jpeg@@PEAH11@Z+172
	DD	imagerel $unwind$?stbi__jpeg_info_raw@@YAHPEAUstbi__jpeg@@PEAH11@Z
$pdata$?stbi__bit_reverse@@YAHHH@Z DD imagerel ?stbi__bit_reverse@@YAHHH@Z
	DD	imagerel ?stbi__bit_reverse@@YAHHH@Z+71
	DD	imagerel $unwind$?stbi__bit_reverse@@YAHHH@Z
$pdata$?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z DD imagerel ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z
	DD	imagerel ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z+896
	DD	imagerel $unwind$?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z
$pdata$?stbi__zeof@@YAHPEAUstbi__zbuf@@@Z DD imagerel ?stbi__zeof@@YAHPEAUstbi__zbuf@@@Z
	DD	imagerel ?stbi__zeof@@YAHPEAUstbi__zbuf@@@Z+52
	DD	imagerel $unwind$?stbi__zeof@@YAHPEAUstbi__zbuf@@@Z
$pdata$?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z DD imagerel ?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z
	DD	imagerel ?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z+77
	DD	imagerel $unwind$?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z
$pdata$?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z DD imagerel ?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z
	DD	imagerel ?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z+142
	DD	imagerel $unwind$?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z
$pdata$?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z DD imagerel ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z
	DD	imagerel ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z+143
	DD	imagerel $unwind$?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z
$pdata$?stbi__zhuffman_decode_slowpath@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z DD imagerel ?stbi__zhuffman_decode_slowpath@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z
	DD	imagerel ?stbi__zhuffman_decode_slowpath@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z+290
	DD	imagerel $unwind$?stbi__zhuffman_decode_slowpath@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z
$pdata$?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z DD imagerel ?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z
	DD	imagerel ?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z+239
	DD	imagerel $unwind$?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z
$pdata$?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z DD imagerel ?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z
	DD	imagerel ?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z+324
	DD	imagerel $unwind$?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z
$pdata$?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z DD imagerel ?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z
	DD	imagerel ?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z+780
	DD	imagerel $unwind$?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z
$pdata$?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z DD imagerel ?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z
	DD	imagerel ?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z+787
	DD	imagerel $unwind$?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z
$pdata$?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z DD imagerel ?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z
	DD	imagerel ?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z+498
	DD	imagerel $unwind$?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z
$pdata$?stbi__parse_zlib_header@@YAHPEAUstbi__zbuf@@@Z DD imagerel ?stbi__parse_zlib_header@@YAHPEAUstbi__zbuf@@@Z
	DD	imagerel ?stbi__parse_zlib_header@@YAHPEAUstbi__zbuf@@@Z+178
	DD	imagerel $unwind$?stbi__parse_zlib_header@@YAHPEAUstbi__zbuf@@@Z
$pdata$?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z DD imagerel ?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z
	DD	imagerel ?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z+308
	DD	imagerel $unwind$?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z
$pdata$?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z DD imagerel ?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z
	DD	imagerel ?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z+108
	DD	imagerel $unwind$?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z
$pdata$?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z DD imagerel ?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z
	DD	imagerel ?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z+47
	DD	imagerel $unwind$?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z
$pdata$?stbi__check_png_header@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__check_png_header@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__check_png_header@@YAHPEAUstbi__context@@@Z+95
	DD	imagerel $unwind$?stbi__check_png_header@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__paeth@@YAHHHH@Z DD imagerel ?stbi__paeth@@YAHHHH@Z
	DD	imagerel ?stbi__paeth@@YAHHHH@Z+190
	DD	imagerel $unwind$?stbi__paeth@@YAHHHH@Z
$pdata$?stbi__create_png_alpha_expand8@@YAXPEAE0IH@Z DD imagerel ?stbi__create_png_alpha_expand8@@YAXPEAE0IH@Z
	DD	imagerel ?stbi__create_png_alpha_expand8@@YAXPEAE0IH@Z+335
	DD	imagerel $unwind$?stbi__create_png_alpha_expand8@@YAXPEAE0IH@Z
$pdata$?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z DD imagerel ?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z
	DD	imagerel ?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z+3192
	DD	imagerel $unwind$?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z
$pdata$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z DD imagerel ?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z
	DD	imagerel ?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z+1284
	DD	imagerel $unwind$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z
$pdata$?stbi__compute_transparency@@YAHPEAUstbi__png@@QEAEH@Z DD imagerel ?stbi__compute_transparency@@YAHPEAUstbi__png@@QEAEH@Z
	DD	imagerel ?stbi__compute_transparency@@YAHPEAUstbi__png@@QEAEH@Z+450
	DD	imagerel $unwind$?stbi__compute_transparency@@YAHPEAUstbi__png@@QEAEH@Z
$pdata$?stbi__compute_transparency16@@YAHPEAUstbi__png@@QEAGH@Z DD imagerel ?stbi__compute_transparency16@@YAHPEAUstbi__png@@QEAGH@Z
	DD	imagerel ?stbi__compute_transparency16@@YAHPEAUstbi__png@@QEAGH@Z+453
	DD	imagerel $unwind$?stbi__compute_transparency16@@YAHPEAUstbi__png@@QEAGH@Z
$pdata$?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z DD imagerel ?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z
	DD	imagerel ?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z+562
	DD	imagerel $unwind$?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z
$pdata$?stbi__de_iphone@@YAXPEAUstbi__png@@@Z DD imagerel ?stbi__de_iphone@@YAXPEAUstbi__png@@@Z
	DD	imagerel ?stbi__de_iphone@@YAXPEAUstbi__png@@@Z+800
	DD	imagerel $unwind$?stbi__de_iphone@@YAXPEAUstbi__png@@@Z
$pdata$?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z DD imagerel ?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z
	DD	imagerel ?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z+3480
	DD	imagerel $unwind$?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z
$pdata$?stbi__do_png@@YAPEAXPEAUstbi__png@@PEAH11HPEAUstbi__result_info@@@Z DD imagerel ?stbi__do_png@@YAPEAXPEAUstbi__png@@PEAH11HPEAUstbi__result_info@@@Z
	DD	imagerel ?stbi__do_png@@YAPEAXPEAUstbi__png@@PEAH11HPEAUstbi__result_info@@@Z+578
	DD	imagerel $unwind$?stbi__do_png@@YAPEAXPEAUstbi__png@@PEAH11HPEAUstbi__result_info@@@Z
$pdata$?stbi__png_info_raw@@YAHPEAUstbi__png@@PEAH11@Z DD imagerel ?stbi__png_info_raw@@YAHPEAUstbi__png@@PEAH11@Z
	DD	imagerel ?stbi__png_info_raw@@YAHPEAUstbi__png@@PEAH11@Z+150
	DD	imagerel $unwind$?stbi__png_info_raw@@YAHPEAUstbi__png@@PEAH11@Z
$pdata$?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z+180
	DD	imagerel $unwind$?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__high_bit@@YAHI@Z DD imagerel ?stbi__high_bit@@YAHI@Z
	DD	imagerel ?stbi__high_bit@@YAHI@Z+169
	DD	imagerel $unwind$?stbi__high_bit@@YAHI@Z
$pdata$?stbi__shiftsigned@@YAHIHH@Z DD imagerel ?stbi__shiftsigned@@YAHIHH@Z
	DD	imagerel ?stbi__shiftsigned@@YAHIHH@Z+206
	DD	imagerel $unwind$?stbi__shiftsigned@@YAHIHH@Z
$pdata$?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z DD imagerel ?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z
	DD	imagerel ?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z+1359
	DD	imagerel $unwind$?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z
$pdata$?stbi__tga_get_comp@@YAHHHPEAH@Z DD imagerel ?stbi__tga_get_comp@@YAHHHPEAH@Z
	DD	imagerel ?stbi__tga_get_comp@@YAHHHPEAH@Z+144
	DD	imagerel $unwind$?stbi__tga_get_comp@@YAHHHPEAH@Z
$pdata$?stbi__tga_read_rgb16@@YAXPEAUstbi__context@@PEAE@Z DD imagerel ?stbi__tga_read_rgb16@@YAXPEAUstbi__context@@PEAE@Z
	DD	imagerel ?stbi__tga_read_rgb16@@YAXPEAUstbi__context@@PEAE@Z+197
	DD	imagerel $unwind$?stbi__tga_read_rgb16@@YAXPEAUstbi__context@@PEAE@Z
$pdata$?stbi__psd_decode_rle@@YAHPEAUstbi__context@@PEAEH@Z DD imagerel ?stbi__psd_decode_rle@@YAHPEAUstbi__context@@PEAEH@Z
	DD	imagerel ?stbi__psd_decode_rle@@YAHPEAUstbi__context@@PEAEH@Z+318
	DD	imagerel $unwind$?stbi__psd_decode_rle@@YAHPEAUstbi__context@@PEAEH@Z
$pdata$?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z DD imagerel ?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z
	DD	imagerel ?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z+88
	DD	imagerel $unwind$?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z
$pdata$?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z+108
	DD	imagerel $unwind$?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z DD imagerel ?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z
	DD	imagerel ?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z+169
	DD	imagerel $unwind$?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z
$pdata$?stbi__copyval@@YAXHPEAEPEBE@Z DD imagerel ?stbi__copyval@@YAXHPEAEPEBE@Z
	DD	imagerel ?stbi__copyval@@YAXHPEAEPEBE@Z+108
	DD	imagerel $unwind$?stbi__copyval@@YAXHPEAEPEBE@Z
$pdata$?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z DD imagerel ?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z
	DD	imagerel ?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z+1593
	DD	imagerel $unwind$?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z
$pdata$?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z+152
	DD	imagerel $unwind$?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z
$pdata$?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z DD imagerel ?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z
	DD	imagerel ?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z+235
	DD	imagerel $unwind$?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z
$pdata$?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z DD imagerel ?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z
	DD	imagerel ?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z+524
	DD	imagerel $unwind$?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z
$pdata$?stbi__gif_info_raw@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__gif_info_raw@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__gif_info_raw@@YAHPEAUstbi__context@@PEAH11@Z+180
	DD	imagerel $unwind$?stbi__gif_info_raw@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z DD imagerel ?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z
	DD	imagerel ?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z+662
	DD	imagerel $unwind$?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z
$pdata$?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z DD imagerel ?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z
	DD	imagerel ?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z+1097
	DD	imagerel $unwind$?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z
$pdata$?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHHPEAE@Z DD imagerel ?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHHPEAE@Z
	DD	imagerel ?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHHPEAE@Z+2536
	DD	imagerel $unwind$?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHHPEAE@Z
$pdata$?stbi__load_gif_main_outofmem@@YAPEAXPEAUstbi__gif@@PEAEPEAPEAH@Z DD imagerel ?stbi__load_gif_main_outofmem@@YAPEAXPEAUstbi__gif@@PEAEPEAPEAH@Z
	DD	imagerel ?stbi__load_gif_main_outofmem@@YAPEAXPEAUstbi__gif@@PEAEPEAPEAH@Z+155
	DD	imagerel $unwind$?stbi__load_gif_main_outofmem@@YAPEAXPEAUstbi__gif@@PEAEPEAPEAH@Z
$pdata$?stbi__hdr_test_core@@YAHPEAUstbi__context@@PEBD@Z DD imagerel ?stbi__hdr_test_core@@YAHPEAUstbi__context@@PEBD@Z
	DD	imagerel ?stbi__hdr_test_core@@YAHPEAUstbi__context@@PEBD@Z+109
	DD	imagerel $unwind$?stbi__hdr_test_core@@YAHPEAUstbi__context@@PEBD@Z
$pdata$?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z DD imagerel ?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z
	DD	imagerel ?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z+179
	DD	imagerel $unwind$?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z
$pdata$?stbi__hdr_convert@@YAXPEAMPEAEH@Z DD imagerel ?stbi__hdr_convert@@YAXPEAMPEAEH@Z
	DD	imagerel ?stbi__hdr_convert@@YAXPEAMPEAEH@Z+604
	DD	imagerel $unwind$?stbi__hdr_convert@@YAXPEAMPEAEH@Z
$pdata$?stbi__pnm_isspace@@YAHD@Z DD imagerel ?stbi__pnm_isspace@@YAHD@Z
	DD	imagerel ?stbi__pnm_isspace@@YAHD@Z+92
	DD	imagerel $unwind$?stbi__pnm_isspace@@YAHD@Z
$pdata$?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z DD imagerel ?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z
	DD	imagerel ?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z+162
	DD	imagerel $unwind$?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z
$pdata$?stbi__pnm_isdigit@@YAHD@Z DD imagerel ?stbi__pnm_isdigit@@YAHD@Z
	DD	imagerel ?stbi__pnm_isdigit@@YAHD@Z+52
	DD	imagerel $unwind$?stbi__pnm_isdigit@@YAHD@Z
$pdata$?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z DD imagerel ?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z
	DD	imagerel ?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z+149
	DD	imagerel $unwind$?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z
$pdata$?stbi__info_main@@YAHPEAUstbi__context@@PEAH11@Z DD imagerel ?stbi__info_main@@YAHPEAUstbi__context@@PEAH11@Z
	DD	imagerel ?stbi__info_main@@YAHPEAUstbi__context@@PEAH11@Z+380
	DD	imagerel $unwind$?stbi__info_main@@YAHPEAUstbi__context@@PEAH11@Z
$pdata$?stbi__is_16_main@@YAHPEAUstbi__context@@@Z DD imagerel ?stbi__is_16_main@@YAHPEAUstbi__context@@@Z
	DD	imagerel ?stbi__is_16_main@@YAHPEAUstbi__context@@@Z+79
	DD	imagerel $unwind$?stbi__is_16_main@@YAHPEAUstbi__context@@@Z
$pdata$?read_file@@YAXPEADPEAPEAEPEA_K@Z DD imagerel ?read_file@@YAXPEADPEAPEAEPEA_K@Z
	DD	imagerel ?read_file@@YAXPEADPEAPEAEPEA_K@Z+286
	DD	imagerel $unwind$?read_file@@YAXPEADPEAPEAEPEA_K@Z
$pdata$?parse_int@@YAHPEAPEAE@Z DD imagerel ?parse_int@@YAHPEAPEAE@Z
	DD	imagerel ?parse_int@@YAHPEAPEAE@Z+64
	DD	imagerel $unwind$?parse_int@@YAHPEAPEAE@Z
$pdata$?parse_double@@YANPEAPEAE@Z DD imagerel ?parse_double@@YANPEAPEAE@Z
	DD	imagerel ?parse_double@@YANPEAPEAE@Z+67
	DD	imagerel $unwind$?parse_double@@YANPEAPEAE@Z
$pdata$?parse_v2@@YAXPEAMPEAPEAE@Z DD imagerel ?parse_v2@@YAXPEAMPEAPEAE@Z
	DD	imagerel ?parse_v2@@YAXPEAMPEAPEAE@Z+85
	DD	imagerel $unwind$?parse_v2@@YAXPEAMPEAPEAE@Z
$pdata$?parse_v3@@YAXPEAMPEAPEAE@Z DD imagerel ?parse_v3@@YAXPEAMPEAPEAE@Z
	DD	imagerel ?parse_v3@@YAXPEAMPEAPEAE@Z+118
	DD	imagerel $unwind$?parse_v3@@YAXPEAMPEAPEAE@Z
$pdata$?parse_indices@@YA?ATvert_idx_t@@PEAPEAE@Z DD imagerel ?parse_indices@@YA?ATvert_idx_t@@PEAPEAE@Z
	DD	imagerel ?parse_indices@@YA?ATvert_idx_t@@PEAPEAE@Z+291
	DD	imagerel $unwind$?parse_indices@@YA?ATvert_idx_t@@PEAPEAE@Z
$pdata$?parse_name@@YAIPEAPEAEPEAPEAD@Z DD imagerel ?parse_name@@YAIPEAPEAEPEAPEAD@Z
	DD	imagerel ?parse_name@@YAIPEAPEAEPEAPEAD@Z+200
	DD	imagerel $unwind$?parse_name@@YAIPEAPEAEPEAPEAD@Z
$pdata$?parse_obj@@YAXPEAUobj_info_t@@PEAEPEAPEAD@Z DD imagerel ?parse_obj@@YAXPEAUobj_info_t@@PEAEPEAPEAD@Z
	DD	imagerel ?parse_obj@@YAXPEAUobj_info_t@@PEAEPEAPEAD@Z+1614
	DD	imagerel $unwind$?parse_obj@@YAXPEAUobj_info_t@@PEAEPEAPEAD@Z
$pdata$?init_obj_material@@YAXPEAUobj_mat_t@@@Z DD imagerel ?init_obj_material@@YAXPEAUobj_mat_t@@@Z
	DD	imagerel ?init_obj_material@@YAXPEAUobj_mat_t@@@Z+86
	DD	imagerel $unwind$?init_obj_material@@YAXPEAUobj_mat_t@@@Z
$pdata$?parse_mtl@@YAXPEAUobj_info_t@@PEAE@Z DD imagerel ?parse_mtl@@YAXPEAUobj_info_t@@PEAE@Z
	DD	imagerel ?parse_mtl@@YAXPEAUobj_info_t@@PEAE@Z+2343
	DD	imagerel $unwind$?parse_mtl@@YAXPEAUobj_info_t@@PEAE@Z
$pdata$?load_obj@@YA?AUobj_info_t@@PEAD@Z DD imagerel ?load_obj@@YA?AUobj_info_t@@PEAD@Z
	DD	imagerel ?load_obj@@YA?AUobj_info_t@@PEAD@Z+555
	DD	imagerel $unwind$?load_obj@@YA?AUobj_info_t@@PEAD@Z
$pdata$?free_obj@@YAXPEAUobj_info_t@@@Z DD imagerel ?free_obj@@YAXPEAUobj_info_t@@@Z
	DD	imagerel ?free_obj@@YAXPEAUobj_info_t@@@Z+642
	DD	imagerel $unwind$?free_obj@@YAXPEAUobj_info_t@@@Z
$pdata$?load_shader_source@@YAPEADPEBD@Z DD imagerel ?load_shader_source@@YAPEADPEBD@Z
	DD	imagerel ?load_shader_source@@YAPEADPEBD@Z+433
	DD	imagerel $unwind$?load_shader_source@@YAPEADPEBD@Z
$pdata$?compile_shader@@YAIPEADI@Z DD imagerel ?compile_shader@@YAIPEADI@Z
	DD	imagerel ?compile_shader@@YAIPEADI@Z+245
	DD	imagerel $unwind$?compile_shader@@YAIPEADI@Z
$pdata$?compile_shader_from_file@@YAIPEBDI@Z DD imagerel ?compile_shader_from_file@@YAIPEBDI@Z
	DD	imagerel ?compile_shader_from_file@@YAIPEBDI@Z+65
	DD	imagerel $unwind$?compile_shader_from_file@@YAIPEBDI@Z
$pdata$?create_program@@YAIPEAII@Z DD imagerel ?create_program@@YAIPEAII@Z
	DD	imagerel ?create_program@@YAIPEAII@Z+272
	DD	imagerel $unwind$?create_program@@YAIPEAII@Z
$pdata$?add_shader@@YAIPEAUgl_renderer@@IZZ DD imagerel ?add_shader@@YAIPEAUgl_renderer@@IZZ
	DD	imagerel ?add_shader@@YAIPEAUgl_renderer@@IZZ+389
	DD	imagerel $unwind$?add_shader@@YAIPEAUgl_renderer@@IZZ
$pdata$?set_uniform_int@@YAXIPEBDH@Z DD imagerel ?set_uniform_int@@YAXIPEBDH@Z
	DD	imagerel ?set_uniform_int@@YAXIPEBDH@Z+71
	DD	imagerel $unwind$?set_uniform_int@@YAXIPEBDH@Z
$pdata$?set_uniform_float@@YAXIPEBDM@Z DD imagerel ?set_uniform_float@@YAXIPEBDM@Z
	DD	imagerel ?set_uniform_float@@YAXIPEBDM@Z+74
	DD	imagerel $unwind$?set_uniform_float@@YAXIPEBDM@Z
$pdata$?set_uniform_vec3@@YAXIPEBDTHMM_Vec3@@@Z DD imagerel ?set_uniform_vec3@@YAXIPEBDTHMM_Vec3@@@Z
	DD	imagerel ?set_uniform_vec3@@YAXIPEBDTHMM_Vec3@@@Z+96
	DD	imagerel $unwind$?set_uniform_vec3@@YAXIPEBDTHMM_Vec3@@@Z
$pdata$?set_uniform_mat4@@YAXIPEBDTHMM_Mat4@@@Z DD imagerel ?set_uniform_mat4@@YAXIPEBDTHMM_Mat4@@@Z
	DD	imagerel ?set_uniform_mat4@@YAXIPEBDTHMM_Mat4@@@Z+83
	DD	imagerel $unwind$?set_uniform_mat4@@YAXIPEBDTHMM_Mat4@@@Z
$pdata$?create_texture_from_bitmap@@YAIPEAUasset_manager_t@@PEAEHHH@Z DD imagerel ?create_texture_from_bitmap@@YAIPEAUasset_manager_t@@PEAEHHH@Z
	DD	imagerel ?create_texture_from_bitmap@@YAIPEAUasset_manager_t@@PEAEHHH@Z+831
	DD	imagerel $unwind$?create_texture_from_bitmap@@YAIPEAUasset_manager_t@@PEAEHHH@Z
$pdata$?init_asset_manager@@YAXPEAUasset_manager_t@@@Z DD imagerel ?init_asset_manager@@YAXPEAUasset_manager_t@@@Z
	DD	imagerel ?init_asset_manager@@YAXPEAUasset_manager_t@@@Z+319
	DD	imagerel $unwind$?init_asset_manager@@YAXPEAUasset_manager_t@@@Z
$pdata$?hash_vert_idx@@YA_KPEAH@Z DD imagerel ?hash_vert_idx@@YA_KPEAH@Z
	DD	imagerel ?hash_vert_idx@@YA_KPEAH@Z+142
	DD	imagerel $unwind$?hash_vert_idx@@YA_KPEAH@Z
$pdata$?kh_init_vertex_map_t@@YAPEAUkh_vertex_map_t_s@@XZ DD imagerel ?kh_init_vertex_map_t@@YAPEAUkh_vertex_map_t_s@@XZ
	DD	imagerel ?kh_init_vertex_map_t@@YAPEAUkh_vertex_map_t_s@@XZ+24
	DD	imagerel $unwind$?kh_init_vertex_map_t@@YAPEAUkh_vertex_map_t_s@@XZ
$pdata$?kh_destroy_vertex_map_t@@YAXPEAUkh_vertex_map_t_s@@@Z DD imagerel ?kh_destroy_vertex_map_t@@YAXPEAUkh_vertex_map_t_s@@@Z
	DD	imagerel ?kh_destroy_vertex_map_t@@YAXPEAUkh_vertex_map_t_s@@@Z+74
	DD	imagerel $unwind$?kh_destroy_vertex_map_t@@YAXPEAUkh_vertex_map_t_s@@@Z
$pdata$?kh_get_vertex_map_t@@YAIPEBUkh_vertex_map_t_s@@Tvert_idx_t@@@Z DD imagerel ?kh_get_vertex_map_t@@YAIPEBUkh_vertex_map_t_s@@Tvert_idx_t@@@Z
	DD	imagerel ?kh_get_vertex_map_t@@YAIPEBUkh_vertex_map_t_s@@Tvert_idx_t@@@Z+431
	DD	imagerel $unwind$?kh_get_vertex_map_t@@YAIPEBUkh_vertex_map_t_s@@Tvert_idx_t@@@Z
$pdata$?kh_resize_vertex_map_t@@YAHPEAUkh_vertex_map_t_s@@I@Z DD imagerel ?kh_resize_vertex_map_t@@YAHPEAUkh_vertex_map_t_s@@I@Z
	DD	imagerel ?kh_resize_vertex_map_t@@YAHPEAUkh_vertex_map_t_s@@I@Z+1764
	DD	imagerel $unwind$?kh_resize_vertex_map_t@@YAHPEAUkh_vertex_map_t_s@@I@Z
$pdata$?kh_put_vertex_map_t@@YAIPEAUkh_vertex_map_t_s@@Tvert_idx_t@@PEAH@Z DD imagerel ?kh_put_vertex_map_t@@YAIPEAUkh_vertex_map_t_s@@Tvert_idx_t@@PEAH@Z
	DD	imagerel ?kh_put_vertex_map_t@@YAIPEAUkh_vertex_map_t_s@@Tvert_idx_t@@PEAH@Z+1310
	DD	imagerel $unwind$?kh_put_vertex_map_t@@YAIPEAUkh_vertex_map_t_s@@Tvert_idx_t@@PEAH@Z
$pdata$?kh_del_vertex_map_t@@YAXPEAUkh_vertex_map_t_s@@I@Z DD imagerel ?kh_del_vertex_map_t@@YAXPEAUkh_vertex_map_t_s@@I@Z
	DD	imagerel ?kh_del_vertex_map_t@@YAXPEAUkh_vertex_map_t_s@@I@Z+182
	DD	imagerel $unwind$?kh_del_vertex_map_t@@YAXPEAUkh_vertex_map_t_s@@I@Z
$pdata$?create_model@@YAXPEAUmesh_t@@PEAUobj_info_t@@IUcolor_t@@@Z DD imagerel ?create_model@@YAXPEAUmesh_t@@PEAUobj_info_t@@IUcolor_t@@@Z
	DD	imagerel ?create_model@@YAXPEAUmesh_t@@PEAUobj_info_t@@IUcolor_t@@@Z+1957
	DD	imagerel $unwind$?create_model@@YAXPEAUmesh_t@@PEAUobj_info_t@@IUcolor_t@@@Z
$pdata$?create_texture@@YAIPEAUasset_manager_t@@PEAD@Z DD imagerel ?create_texture@@YAIPEAUasset_manager_t@@PEAD@Z
	DD	imagerel ?create_texture@@YAIPEAUasset_manager_t@@PEAD@Z+108
	DD	imagerel $unwind$?create_texture@@YAIPEAUasset_manager_t@@PEAD@Z
$pdata$?create_materials@@YAXPEAUasset_manager_t@@PEAUmaterial_t@@PEAUobj_info_t@@@Z DD imagerel ?create_materials@@YAXPEAUasset_manager_t@@PEAUmaterial_t@@PEAUobj_info_t@@@Z
	DD	imagerel ?create_materials@@YAXPEAUasset_manager_t@@PEAUmaterial_t@@PEAUobj_info_t@@@Z+652
	DD	imagerel $unwind$?create_materials@@YAXPEAUasset_manager_t@@PEAUmaterial_t@@PEAUobj_info_t@@@Z
$pdata$?add_model@@YAXPEAUasset_manager_t@@PEADPEAUmodel_info_t@@Ucolor_t@@@Z DD imagerel ?add_model@@YAXPEAUasset_manager_t@@PEADPEAUmodel_info_t@@Ucolor_t@@@Z
	DD	imagerel ?add_model@@YAXPEAUasset_manager_t@@PEADPEAUmodel_info_t@@Ucolor_t@@@Z+597
	DD	imagerel $unwind$?add_model@@YAXPEAUasset_manager_t@@PEADPEAUmodel_info_t@@Ucolor_t@@@Z
$pdata$?init_gl_renderer@@YAXPEAUgl_renderer@@PEAUcamera_t@@@Z DD imagerel ?init_gl_renderer@@YAXPEAUgl_renderer@@PEAUcamera_t@@@Z
	DD	imagerel ?init_gl_renderer@@YAXPEAUgl_renderer@@PEAUcamera_t@@@Z+236
	DD	imagerel $unwind$?init_gl_renderer@@YAXPEAUgl_renderer@@PEAUcamera_t@@@Z
$pdata$?update_camera@@YAXPEAUcamera_t@@@Z DD imagerel ?update_camera@@YAXPEAUcamera_t@@@Z
	DD	imagerel ?update_camera@@YAXPEAUcamera_t@@@Z+870
	DD	imagerel $unwind$?update_camera@@YAXPEAUcamera_t@@@Z
$pdata$?init_camera@@YAXPEAUcamera_t@@THMM_Vec3@@MMMMMM@Z DD imagerel ?init_camera@@YAXPEAUcamera_t@@THMM_Vec3@@MMMMMM@Z
	DD	imagerel ?init_camera@@YAXPEAUcamera_t@@THMM_Vec3@@MMMMMM@Z+369
	DD	imagerel $unwind$?init_camera@@YAXPEAUcamera_t@@THMM_Vec3@@MMMMMM@Z
$pdata$?init_light@@YAXPEAUlight_t@@THMM_Vec3@@MMM@Z DD imagerel ?init_light@@YAXPEAUlight_t@@THMM_Vec3@@MMM@Z
	DD	imagerel ?init_light@@YAXPEAUlight_t@@THMM_Vec3@@MMM@Z+92
	DD	imagerel $unwind$?init_light@@YAXPEAUlight_t@@THMM_Vec3@@MMM@Z
$pdata$?add_light@@YAXPEAUgl_renderer@@THMM_Vec3@@MMM@Z DD imagerel ?add_light@@YAXPEAUgl_renderer@@THMM_Vec3@@MMM@Z
	DD	imagerel ?add_light@@YAXPEAUgl_renderer@@THMM_Vec3@@MMM@Z+159
	DD	imagerel $unwind$?add_light@@YAXPEAUgl_renderer@@THMM_Vec3@@MMM@Z
$pdata$?init_framebuffer@@YAXPEAUgl_renderer@@PEBD1@Z DD imagerel $LN7
	DD	imagerel $LN7+1193
	DD	imagerel $unwind$?init_framebuffer@@YAXPEAUgl_renderer@@PEBD1@Z
$pdata$?update_transform@@YAXPEAUgl_renderer@@PEATHMM_Mat4@@THMM_Vec3@@22@Z DD imagerel ?update_transform@@YAXPEAUgl_renderer@@PEATHMM_Mat4@@THMM_Vec3@@22@Z
	DD	imagerel ?update_transform@@YAXPEAUgl_renderer@@PEATHMM_Mat4@@THMM_Vec3@@22@Z+1377
	DD	imagerel $unwind$?update_transform@@YAXPEAUgl_renderer@@PEATHMM_Mat4@@THMM_Vec3@@22@Z
$pdata$?add_entity@@YAIPEAUgl_renderer@@PEAUmodel_info_t@@THMM_Vec3@@22@Z DD imagerel ?add_entity@@YAIPEAUgl_renderer@@PEAUmodel_info_t@@THMM_Vec3@@22@Z
	DD	imagerel ?add_entity@@YAIPEAUgl_renderer@@PEAUmodel_info_t@@THMM_Vec3@@22@Z+425
	DD	imagerel $unwind$?add_entity@@YAIPEAUgl_renderer@@PEAUmodel_info_t@@THMM_Vec3@@22@Z
$pdata$?push_mesh@@YAXPEAUgl_renderer@@PEAUasset_manager_t@@PEAUmodel_info_t@@Ucolor_t@@@Z DD imagerel ?push_mesh@@YAXPEAUgl_renderer@@PEAUasset_manager_t@@PEAUmodel_info_t@@Ucolor_t@@@Z
	DD	imagerel ?push_mesh@@YAXPEAUgl_renderer@@PEAUasset_manager_t@@PEAUmodel_info_t@@Ucolor_t@@@Z+721
	DD	imagerel $unwind$?push_mesh@@YAXPEAUgl_renderer@@PEAUasset_manager_t@@PEAUmodel_info_t@@Ucolor_t@@@Z
$pdata$?adjust_bezier_c1@@YAXPEATHMM_Vec3@@I@Z DD imagerel ?adjust_bezier_c1@@YAXPEATHMM_Vec3@@I@Z
	DD	imagerel ?adjust_bezier_c1@@YAXPEATHMM_Vec3@@I@Z+690
	DD	imagerel $unwind$?adjust_bezier_c1@@YAXPEATHMM_Vec3@@I@Z
$pdata$?adjust_bezier_g1@@YAXPEATHMM_Vec3@@I@Z DD imagerel ?adjust_bezier_g1@@YAXPEATHMM_Vec3@@I@Z
	DD	imagerel ?adjust_bezier_g1@@YAXPEATHMM_Vec3@@I@Z+1091
	DD	imagerel $unwind$?adjust_bezier_g1@@YAXPEATHMM_Vec3@@I@Z
$pdata$?render_mesh@@YAXPEAUgl_renderer@@Umodel_info_t@@@Z DD imagerel ?render_mesh@@YAXPEAUgl_renderer@@Umodel_info_t@@@Z
	DD	imagerel ?render_mesh@@YAXPEAUgl_renderer@@Umodel_info_t@@@Z+250
	DD	imagerel $unwind$?render_mesh@@YAXPEAUgl_renderer@@Umodel_info_t@@@Z
$pdata$?bind_material@@YAXPEAUasset_manager_t@@PEAUmaterial_t@@II@Z DD imagerel ?bind_material@@YAXPEAUasset_manager_t@@PEAUmaterial_t@@II@Z
	DD	imagerel ?bind_material@@YAXPEAUasset_manager_t@@PEAUmaterial_t@@II@Z+489
	DD	imagerel $unwind$?bind_material@@YAXPEAUasset_manager_t@@PEAUmaterial_t@@II@Z
$pdata$?bind_lights@@YAXPEAUlight_t@@II@Z DD imagerel ?bind_lights@@YAXPEAUlight_t@@II@Z
	DD	imagerel ?bind_lights@@YAXPEAUlight_t@@II@Z+386
	DD	imagerel $unwind$?bind_lights@@YAXPEAUlight_t@@II@Z
$pdata$?render@@YAXPEAUgl_renderer@@PEAUasset_manager_t@@I@Z DD imagerel ?render@@YAXPEAUgl_renderer@@PEAUasset_manager_t@@I@Z
	DD	imagerel ?render@@YAXPEAUgl_renderer@@PEAUasset_manager_t@@I@Z+3360
	DD	imagerel $unwind$?render@@YAXPEAUgl_renderer@@PEAUasset_manager_t@@I@Z
$pdata$?framebuffer_size_callback@@YAXPEAUGLFWwindow@@HH@Z DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$?framebuffer_size_callback@@YAXPEAUGLFWwindow@@HH@Z
$pdata$?draw_vec3_widget@@YAXPEBDPEATHMM_Vec3@@@Z DD imagerel ?draw_vec3_widget@@YAXPEBDPEATHMM_Vec3@@@Z
	DD	imagerel ?draw_vec3_widget@@YAXPEBDPEATHMM_Vec3@@@Z+375
	DD	imagerel $unwind$?draw_vec3_widget@@YAXPEBDPEATHMM_Vec3@@@Z
$pdata$?process_input@@YAXPEAUGLFWwindow@@PEAUgl_renderer@@I@Z DD imagerel $LN26
	DD	imagerel $LN26+1019
	DD	imagerel $unwind$?process_input@@YAXPEAUGLFWwindow@@PEAUgl_renderer@@I@Z
$pdata$main DD	imagerel $LN85
	DD	imagerel $LN85+7138
	DD	imagerel $unwind$main
pdata	ENDS
pdata	SEGMENT
$pdata$main$dtor$0 DD imagerel main$dtor$0
	DD	imagerel main$dtor$0+27
	DD	imagerel $unwind$main$dtor$0
pdata	ENDS
;	COMDAT __xmm@fa7efa7efa7efa7efa7efa7efa7efa7e
CONST	SEGMENT
__xmm@fa7efa7efa7efa7efa7efa7efa7efa7e DB '~', 0faH, '~', 0faH, '~', 0faH
	DB	'~', 0faH, '~', 0faH, '~', 0faH, '~', 0faH, '~', 0faH
CONST	ENDS
;	COMDAT __xmm@f9c31a9df9c31a9df9c31a9df9c31a9d
CONST	SEGMENT
__xmm@f9c31a9df9c31a9df9c31a9df9c31a9d DB 09dH, 01aH, 0c3H, 0f9H, 09dH, 01aH
	DB	0c3H, 0f9H, 09dH, 01aH, 0c3H, 0f9H, 09dH, 01aH, 0c3H, 0f9H
CONST	ENDS
;	COMDAT __xmm@f493f493f493f493f493f493f493f493
CONST	SEGMENT
__xmm@f493f493f493f493f493f493f493f493 DB 093H, 0f4H, 093H, 0f4H, 093H, 0f4H
	DB	093H, 0f4H, 093H, 0f4H, 093H, 0f4H, 093H, 0f4H, 093H, 0f4H
CONST	ENDS
;	COMDAT __xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9
CONST	SEGMENT
__xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9 DB 0a9H, 08H, 01aH, 0ebH, 0a9H, 08H
	DB	01aH, 0ebH, 0a9H, 08H, 01aH, 0ebH, 0a9H, 08H, 01aH, 0ebH
CONST	ENDS
;	COMDAT __xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0
CONST	SEGMENT
__xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0 DB 0d0H, 012H, 0cfH, 0e9H, 0d0H, 012H
	DB	0cfH, 0e9H, 0d0H, 012H, 0cfH, 0e9H, 0d0H, 012H, 0cfH, 0e9H
CONST	ENDS
;	COMDAT __xmm@e09ee565e09ee565e09ee565e09ee565
CONST	SEGMENT
__xmm@e09ee565e09ee565e09ee565e09ee565 DB 'e', 0e5H, 09eH, 0e0H, 'e', 0e5H
	DB	09eH, 0e0H, 'e', 0e5H, 09eH, 0e0H, 'e', 0e5H, 09eH, 0e0H
CONST	ENDS
;	COMDAT __xmm@80808080808080808080808080808080
CONST	SEGMENT
__xmm@80808080808080808080808080808080 DB 080H, 080H, 080H, 080H, 080H, 080H
	DB	080H, 080H, 080H, 080H, 080H, 080H, 080H, 080H, 080H, 080H
CONST	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@1c5a1c5a1c5a1c5a1c5a1c5a1c5a1c5a
CONST	SEGMENT
__xmm@1c5a1c5a1c5a1c5a1c5a1c5a1c5a1c5a DB 'Z', 01cH, 'Z', 01cH, 'Z', 01cH
	DB	'Z', 01cH, 'Z', 01cH, 'Z', 01cH, 'Z', 01cH, 'Z', 01cH
CONST	ENDS
;	COMDAT __xmm@166f166f166f166f166f166f166f166f
CONST	SEGMENT
__xmm@166f166f166f166f166f166f166f166f DB 'o', 016H, 'o', 016H, 'o', 016H
	DB	'o', 016H, 'o', 016H, 'o', 016H, 'o', 016H, 'o', 016H
CONST	ENDS
;	COMDAT __xmm@12d0046b12d0046b12d0046b12d0046b
CONST	SEGMENT
__xmm@12d0046b12d0046b12d0046b12d0046b DB 'k', 04H, 0d0H, 012H, 'k', 04H, 0d0H
	DB	012H, 'k', 04H, 0d0H, 012H, 'k', 04H, 0d0H, 012H
CONST	ENDS
;	COMDAT __xmm@11c8f9c311c8f9c311c8f9c311c8f9c3
CONST	SEGMENT
__xmm@11c8f9c311c8f9c311c8f9c311c8f9c3 DB 0c3H, 0f9H, 0c8H, 011H, 0c3H, 0f9H
	DB	0c8H, 011H, 0c3H, 0f9H, 0c8H, 011H, 0c3H, 0f9H, 0c8H, 011H
CONST	ENDS
;	COMDAT __xmm@11c8e09e11c8e09e11c8e09e11c8e09e
CONST	SEGMENT
__xmm@11c8e09e11c8e09e11c8e09e11c8e09e DB 09eH, 0e0H, 0c8H, 011H, 09eH, 0e0H
	DB	0c8H, 011H, 09eH, 0e0H, 0c8H, 011H, 09eH, 0e0H, 0c8H, 011H
CONST	ENDS
;	COMDAT __xmm@08a914e808a914e808a914e808a914e8
CONST	SEGMENT
__xmm@08a914e808a914e808a914e808a914e8 DB 0e8H, 014H, 0a9H, 08H, 0e8H, 014H
	DB	0a9H, 08H, 0e8H, 014H, 0a9H, 08H, 0e8H, 014H, 0a9H, 08H
CONST	ENDS
;	COMDAT __xmm@01010000010100000101000001010000
CONST	SEGMENT
__xmm@01010000010100000101000001010000 DB 00H, 00H, 01H, 01H, 00H, 00H, 01H
	DB	01H, 00H, 00H, 01H, 01H, 00H, 00H, 01H, 01H
CONST	ENDS
;	COMDAT __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
CONST	SEGMENT
__xmm@00ff00ff00ff00ff00ff00ff00ff00ff DB 0ffH, 00H, 0ffH, 00H, 0ffH, 00H
	DB	0ffH, 00H, 0ffH, 00H, 0ffH, 00H, 0ffH, 00H, 0ffH, 00H
CONST	ENDS
;	COMDAT __xmm@00080008000800080008000800080008
CONST	SEGMENT
__xmm@00080008000800080008000800080008 DB 08H, 00H, 08H, 00H, 08H, 00H, 08H
	DB	00H, 08H, 00H, 08H, 00H, 08H, 00H, 08H, 00H
CONST	ENDS
;	COMDAT __xmm@00000200000002000000020000000200
CONST	SEGMENT
__xmm@00000200000002000000020000000200 DB 00H, 02H, 00H, 00H, 00H, 02H, 00H
	DB	00H, 00H, 02H, 00H, 00H, 00H, 02H, 00H, 00H
CONST	ENDS
;	COMDAT __real@c2b40000
CONST	SEGMENT
__real@c2b40000 DD 0c2b40000r			; -90
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@477fff00
CONST	SEGMENT
__real@477fff00 DD 0477fff00r			; 65535
CONST	ENDS
;	COMDAT __real@43fa0000
CONST	SEGMENT
__real@43fa0000 DD 043fa0000r			; 500
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42b40000
CONST	SEGMENT
__real@42b40000 DD 042b40000r			; 90
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@42340000
CONST	SEGMENT
__real@42340000 DD 042340000r			; 45
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40e00000
CONST	SEGMENT
__real@40e00000 DD 040e00000r			; 7
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@40200000
CONST	SEGMENT
__real@40200000 DD 040200000r			; 2.5
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe8a3d70a3d70a4
CONST	SEGMENT
__real@3fe8a3d70a3d70a4 DQ 03fe8a3d70a3d70a4r	; 0.77
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3faaaaab
CONST	SEGMENT
__real@3faaaaab DD 03faaaaabr			; 1.33333
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3db851ec
CONST	SEGMENT
__real@3db851ec DD 03db851ecr			; 0.09
CONST	ENDS
;	COMDAT __real@3d4ccccd
CONST	SEGMENT
__real@3d4ccccd DD 03d4ccccdr			; 0.05
CONST	ENDS
;	COMDAT __real@3d03126f
CONST	SEGMENT
__real@3d03126f DD 03d03126fr			; 0.032
CONST	ENDS
;	COMDAT __real@3c8efa35
CONST	SEGMENT
__real@3c8efa35 DD 03c8efa35r			; 0.0174533
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@3a83126f
CONST	SEGMENT
__real@3a83126f DD 03a83126fr			; 0.001
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ?shift_table@?1??stbi__shiftsigned@@YAHIHH@Z@4PAIA
_DATA	SEGMENT
?shift_table@?1??stbi__shiftsigned@@YAHIHH@Z@4PAIA DD 00H ; `stbi__shiftsigned'::`2'::shift_table
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	02H
	DD	04H
	DD	06H
	DD	00H
_DATA	ENDS
;	COMDAT ?mul_table@?1??stbi__shiftsigned@@YAHIHH@Z@4PAIA
_DATA	SEGMENT
?mul_table@?1??stbi__shiftsigned@@YAHIHH@Z@4PAIA DD 00H	; `stbi__shiftsigned'::`2'::mul_table
	DD	0ffH
	DD	055H
	DD	049H
	DD	011H
	DD	021H
	DD	041H
	DD	081H
	DD	01H
_DATA	ENDS
;	COMDAT ?invalid_chunk@?JM@??stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z@4PADA
_DATA	SEGMENT
?invalid_chunk@?JM@??stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z@4PADA DB 'X'
	DB	'XXX PNG chunk not known', 00H		; `stbi__parse_png_file'::`156'::invalid_chunk
_DATA	ENDS
;	COMDAT ?png_sig@?1??stbi__check_png_header@@YAHPEAUstbi__context@@@Z@4QBEB
CONST	SEGMENT
?png_sig@?1??stbi__check_png_header@@YAHPEAUstbi__context@@@Z@4QBEB DB 089H ; `stbi__check_png_header'::`2'::png_sig
	DB	050H
	DB	04eH
	DB	047H
	DB	0dH
	DB	0aH
	DB	01aH
	DB	0aH
CONST	ENDS
;	COMDAT ?length_dezigzag@?1??stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z@4QBEB
CONST	SEGMENT
?length_dezigzag@?1??stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z@4QBEB DB 010H ; `stbi__compute_huffman_codes'::`2'::length_dezigzag
	DB	011H
	DB	012H
	DB	00H
	DB	08H
	DB	07H
	DB	09H
	DB	06H
	DB	0aH
	DB	05H
	DB	0bH
	DB	04H
	DB	0cH
	DB	03H
	DB	0dH
	DB	02H
	DB	0eH
	DB	01H
	DB	0fH
CONST	ENDS
;	COMDAT ?rgb@?BG@??stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z@4QBEB
CONST	SEGMENT
?rgb@?BG@??stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z@4QBEB DB 052H ; `stbi__process_frame_header'::`22'::rgb
	DB	047H
	DB	042H
CONST	ENDS
;	COMDAT ?tag@?DG@??stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z@4QBEB
CONST	SEGMENT
?tag@?DG@??stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z@4QBEB DB 041H ; `stbi__process_marker'::`54'::tag
	DB	064H
	DB	06fH
	DB	062H
	DB	065H
	DB	00H
CONST	ENDS
;	COMDAT ?tag@?CN@??stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z@4QBEB
CONST	SEGMENT
?tag@?CN@??stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z@4QBEB DB 04aH ; `stbi__process_marker'::`45'::tag
	DB	046H
	DB	049H
	DB	046H
	DB	00H
CONST	ENDS
_DATA	SEGMENT
?stbi__stdio_callbacks@@3Ustbi_io_callbacks@@A DQ FLAT:?stbi__stdio_read@@YAHPEAXPEADH@Z ; stbi__stdio_callbacks
	DQ	FLAT:?stbi__stdio_skip@@YAXPEAXH@Z
	DQ	FLAT:?stbi__stdio_eof@@YAHPEAX@Z
?stbi__l2h_gamma@@3MA DD 0400ccccdr		; 2.2	; stbi__l2h_gamma
?stbi__l2h_scale@@3MA DD 03f800000r		; 1	; stbi__l2h_scale
?stbi__h2l_gamma_i@@3MA DD 03ee8ba2er		; 0.454545 ; stbi__h2l_gamma_i
?stbi__h2l_scale_i@@3MA DD 03f800000r		; 1	; stbi__h2l_scale_i
?first_row_filter@@3PAEA DB 00H				; first_row_filter
	DB	01H
	DB	00H
	DB	05H
	DB	01H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?sin@@YAMM@Z DD 010a01H
	DD	0420aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pow@@YAMMM@Z DD 011001H
	DD	04210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ldexp@@YAMMH@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?cos@@YAMM@Z DD 010a01H
	DD	0420aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
xdata	SEGMENT
$unwind$HMM_ToRad DD 010a01H
	DD	0220aH
$unwind$HMM_SinF DD 010a01H
	DD	0420aH
$unwind$HMM_CosF DD 010a01H
	DD	0420aH
$unwind$HMM_TanF DD 010a01H
	DD	0420aH
$unwind$HMM_SqrtF DD 010a01H
	DD	0a20aH
$unwind$HMM_InvSqrtF DD 010a01H
	DD	0620aH
$unwind$HMM_V2 DD 011f19H
	DD	02210H
	DD	imagerel __GSHandlerCheck
	DD	08H
$unwind$HMM_V3 DD 032c19H
	DD	07019421dH
	DD	06018H
	DD	imagerel __GSHandlerCheck
	DD	010H
$unwind$HMM_V4V DD 012319H
	DD	06214H
	DD	imagerel __GSHandlerCheck
	DD	020H
$unwind$HMM_AddV3 DD 032419H
	DD	070114215H
	DD	06010H
	DD	imagerel __GSHandlerCheck
	DD	010H
$unwind$HMM_SubV3 DD 032419H
	DD	070114215H
	DD	06010H
	DD	imagerel __GSHandlerCheck
	DD	010H
$unwind$HMM_MulV3F DD 032519H
	DD	070124216H
	DD	06011H
	DD	imagerel __GSHandlerCheck
	DD	010H
$unwind$HMM_DivV3F DD 032519H
	DD	070124216H
	DD	06011H
	DD	imagerel __GSHandlerCheck
	DD	010H
$unwind$HMM_Cross DD 032419H
	DD	070114215H
	DD	06010H
	DD	imagerel __GSHandlerCheck
	DD	010H
$unwind$HMM_NormV3 DD 042219H
	DD	0110113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$HMM_LinearCombineV4M4 DD 022819H
	DD	01b0116H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$HMM_M4D DD 032019H
	DD	0700da211H
	DD	0600cH
	DD	imagerel __GSHandlerCheck
	DD	040H
$unwind$HMM_MulM4 DD 042a19H
	DD	0470118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	0220H
$unwind$HMM_MulM4V4 DD 042a19H
	DD	0150118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$HMM_Perspective_RH_NO DD 042f19H
	DD	0110120H
	DD	060187019H
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$HMM_Translate DD 042519H
	DD	01f0113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0e0H
$unwind$HMM_Rotate_RH DD 042b19H
	DD	0270119H
	DD	060117012H
	DD	imagerel __GSHandlerCheck
	DD	0120H
$unwind$HMM_Scale DD 042519H
	DD	01f0113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0e0H
$unwind$_HMM_LookAt DD 042f19H
	DD	01b011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$HMM_LookAt_RH DD 042f19H
	DD	04b011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0240H
$unwind$?_stack_resize@@YAHPEAPEAXII@Z DD 011201H
	DD	0c212H
$unwind$?_stack_fit@@YAPEAXPEAPEAXII@Z DD 011201H
	DD	08212H
$unwind$?_stack_push@@YAPEAXPEAPEAXII@Z DD 011201H
	DD	08212H
$unwind$stbi_load_from_memory DD 022c19H
	DD	025011aH
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$stbi_load_from_callbacks DD 022d19H
	DD	025011bH
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$stbi_load DD 011801H
	DD	0a218H
$unwind$stbi_load_from_file DD 022d19H
	DD	027011bH
	DD	imagerel __GSHandlerCheck
	DD	0120H
$unwind$stbi_load_gif_from_memory DD 022c19H
	DD	029011aH
	DD	imagerel __GSHandlerCheck
	DD	0130H
$unwind$stbi_load_16_from_memory DD 022c19H
	DD	025011aH
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$stbi_load_16_from_callbacks DD 022d19H
	DD	025011bH
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$stbi_load_16 DD 011801H
	DD	0a218H
$unwind$stbi_load_from_file_16 DD 022d19H
	DD	027011bH
	DD	imagerel __GSHandlerCheck
	DD	0120H
$unwind$stbi_loadf_from_memory DD 022c19H
	DD	025011aH
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$stbi_loadf_from_callbacks DD 022d19H
	DD	025011bH
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$stbi_loadf DD 011801H
	DD	0a218H
$unwind$stbi_loadf_from_file DD 022d19H
	DD	025011bH
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$stbi_is_hdr_from_callbacks DD 022319H
	DD	0230111H
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$stbi_is_hdr_from_memory DD 022219H
	DD	0230110H
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$stbi_is_hdr DD 010901H
	DD	06209H
$unwind$stbi_is_hdr_from_file DD 021e19H
	DD	025010cH
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$stbi_image_free DD 010901H
	DD	04209H
$unwind$stbi_info_from_memory DD 022c19H
	DD	023011aH
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$stbi_info_from_callbacks DD 022d19H
	DD	023011bH
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$stbi_is_16_bit_from_memory DD 022219H
	DD	0230110H
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$stbi_is_16_bit_from_callbacks DD 022319H
	DD	0230111H
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$stbi_info DD 011801H
	DD	06218H
$unwind$stbi_info_from_file DD 022d19H
	DD	025011bH
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$stbi_is_16_bit DD 010901H
	DD	06209H
$unwind$stbi_is_16_bit_from_file DD 021e19H
	DD	025010cH
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$stbi_zlib_decode_malloc_guesssize DD 023219H
	DD	020d0120H
	DD	imagerel __GSHandlerCheck
	DD	01050H
$unwind$stbi_zlib_decode_malloc_guesssize_headerflag DD 023219H
	DD	020d0120H
	DD	imagerel __GSHandlerCheck
	DD	01050H
$unwind$stbi_zlib_decode_malloc DD 011201H
	DD	04212H
$unwind$stbi_zlib_decode_buffer DD 023219H
	DD	020b0120H
	DD	imagerel __GSHandlerCheck
	DD	01040H
$unwind$stbi_zlib_decode_noheader_malloc DD 022d19H
	DD	020d011bH
	DD	imagerel __GSHandlerCheck
	DD	01050H
$unwind$stbi_zlib_decode_noheader_buffer DD 023219H
	DD	020b0120H
	DD	imagerel __GSHandlerCheck
	DD	01040H
$unwind$?stbi__cpuid3@@YAHXZ DD 021519H
	DD	030023206H
	DD	imagerel __GSHandlerCheck
	DD	010H
$unwind$?stbi__sse2_available@@YAHXZ DD 010401H
	DD	06204H
$unwind$?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z DD 011301H
	DD	02213H
$unwind$?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z DD 031501H
	DD	070116215H
	DD	06010H
$unwind$?stbi__stdio_read@@YAHPEAXPEADH@Z DD 011301H
	DD	04213H
$unwind$?stbi__stdio_skip@@YAXPEAXH@Z DD 010d01H
	DD	0620dH
$unwind$?stbi__stdio_eof@@YAHPEAX@Z DD 010901H
	DD	06209H
$unwind$?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z DD 010e01H
	DD	0420eH
$unwind$?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__jpeg_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 011801H
	DD	0a218H
$unwind$?stbi__jpeg_info@@YAHPEAUstbi__context@@PEAH11@Z DD 011801H
	DD	06218H
$unwind$?stbi__png_test@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__png_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 011801H
	DD	0c218H
$unwind$?stbi__png_info@@YAHPEAUstbi__context@@PEAH11@Z DD 011801H
	DD	0a218H
$unwind$?stbi__png_is16@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	0a209H
$unwind$?stbi__bmp_test@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 022d19H
	DD	0ad011bH
	DD	imagerel __GSHandlerCheck
	DD	0550H
$unwind$?stbi__bmp_info@@YAHPEAUstbi__context@@PEAH11@Z DD 012719H
	DD	0c218H
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$?stbi__tga_test@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__tga_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 031c01H
	DD	020011cH
	DD	07015H
$unwind$?stbi__tga_info@@YAHPEAUstbi__context@@PEAH11@Z DD 011801H
	DD	0a218H
$unwind$?stbi__psd_test@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z DD 021b01H
	DD	01f011bH
$unwind$?stbi__psd_info@@YAHPEAUstbi__context@@PEAH11@Z DD 011801H
	DD	06218H
$unwind$?stbi__psd_is16@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__hdr_test@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 022d19H
	DD	09d011bH
	DD	imagerel __GSHandlerCheck
	DD	04d0H
$unwind$?stbi__hdr_info@@YAHPEAUstbi__context@@PEAH11@Z DD 022d19H
	DD	089011bH
	DD	imagerel __GSHandlerCheck
	DD	0430H
$unwind$?stbi__pic_test@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 011801H
	DD	0c218H
$unwind$?stbi__pic_info@@YAHPEAUstbi__context@@PEAH11@Z DD 012719H
	DD	0e218H
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$?stbi__gif_test@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__gif_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 023319H
	DD	011190121H
	DD	imagerel __GSHandlerCheck
	DD	088b0H
$unwind$?stbi__load_gif_main@@YAPEAXPEAUstbi__context@@PEAPEAHPEAH222H@Z DD 023319H
	DD	0111f0121H
	DD	imagerel __GSHandlerCheck
	DD	088e0H
$unwind$?stbi__gif_info@@YAHPEAUstbi__context@@PEAH11@Z DD 011801H
	DD	04218H
$unwind$?stbi__pnm_test@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__pnm_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z DD 011801H
	DD	0a218H
$unwind$?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z DD 011801H
	DD	06218H
$unwind$?stbi__pnm_is16@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	04209H
$unwind$?stbi__malloc@@YAPEAX_K@Z DD 010901H
	DD	04209H
$unwind$?stbi__addsizes_valid@@YAHHH@Z DD 010c01H
	DD	0220cH
$unwind$?stbi__mul2sizes_valid@@YAHHH@Z DD 010c01H
	DD	0220cH
$unwind$?stbi__mad2sizes_valid@@YAHHHH@Z DD 011101H
	DD	06211H
$unwind$?stbi__mad3sizes_valid@@YAHHHHH@Z DD 011601H
	DD	06216H
$unwind$?stbi__mad4sizes_valid@@YAHHHHHH@Z DD 011601H
	DD	06216H
$unwind$?stbi__malloc_mad2@@YAPEAXHHH@Z DD 011101H
	DD	04211H
$unwind$?stbi__malloc_mad3@@YAPEAXHHHH@Z DD 011601H
	DD	04216H
$unwind$?stbi__malloc_mad4@@YAPEAXHHHHH@Z DD 011601H
	DD	06216H
$unwind$?stbi__addints_valid@@YAHHH@Z DD 010c01H
	DD	0220cH
$unwind$?stbi__mul2shorts_valid@@YAHHH@Z DD 010c01H
	DD	0420cH
$unwind$?stbi__ldr_to_hdr@@YAPEAMPEAEHHH@Z DD 011701H
	DD	0a217H
$unwind$?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z DD 011701H
	DD	08217H
$unwind$?stbi__load_main@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z DD 011801H
	DD	0a218H
$unwind$?stbi__convert_16_to_8@@YAPEAEPEAGHHH@Z DD 011701H
	DD	08217H
$unwind$?stbi__convert_8_to_16@@YAPEAGPEAEHHH@Z DD 011701H
	DD	08217H
$unwind$?stbi__vertical_flip@@YAXPEAXHHH@Z DD 022c19H
	DD	010f011aH
	DD	imagerel __GSHandlerCheck
	DD	0860H
$unwind$?stbi__vertical_flip_slices@@YAXPEAXHHHH@Z DD 011701H
	DD	06217H
$unwind$?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z DD 022a19H
	DD	011011bH
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$?stbi__load_and_postprocess_16bit@@YAPEAGPEAUstbi__context@@PEAH11H@Z DD 022a19H
	DD	011011bH
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$?stbi__float_postprocess@@YAXPEAMPEAH11H@Z DD 011801H
	DD	06218H
$unwind$?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z DD 010e01H
	DD	0620eH
$unwind$?stbi__loadf_main@@YAPEAMPEAUstbi__context@@PEAH11H@Z DD 012719H
	DD	0c218H
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$?stbi__get8@@YAEPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__at_eof@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__skip@@YAXPEAUstbi__context@@H@Z DD 010d01H
	DD	0620dH
$unwind$?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z DD 011301H
	DD	06213H
$unwind$?stbi__get16be@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__get32be@@YAIPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__get16le@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__get32le@@YAIPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__convert_format@@YAPEAEPEAEHHII@Z DD 011701H
	DD	0c217H
$unwind$?stbi__convert_format16@@YAPEAGPEAGHHII@Z DD 011701H
	DD	0c217H
$unwind$?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z DD 010e01H
	DD	0820eH
$unwind$?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z DD 010e01H
	DD	0620eH
$unwind$?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z DD 010e01H
	DD	0a20eH
$unwind$?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z DD 010d01H
	DD	0620dH
$unwind$?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z DD 010d01H
	DD	0620dH
$unwind$?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z DD 011801H
	DD	0a218H
$unwind$?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z DD 011801H
	DD	08218H
$unwind$?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z DD 021b01H
	DD	011011bH
$unwind$?stbi__idct_block@@YAXPEAEHQEAF@Z DD 022719H
	DD	0390115H
	DD	imagerel __GSHandlerCheck
	DD	01b0H
$unwind$?stbi__idct_simd@@YAXPEAEHQEAF@Z DD 021b01H
	DD	036b011bH
$unwind$?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z DD 010901H
	DD	02209H
$unwind$?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z DD 021e19H
	DD	03f010cH
	DD	imagerel __GSHandlerCheck
	DD	01e0H
$unwind$?stbi__jpeg_dequantize@@YAXPEAFPEAG@Z DD 010e01H
	DD	0220eH
$unwind$?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z DD 010901H
	DD	08209H
$unwind$?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z DD 022219H
	DD	01b0110H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z DD 010901H
	DD	08209H
$unwind$?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z DD 011201H
	DD	06212H
$unwind$?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z DD 010d01H
	DD	0c20dH
$unwind$?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z DD 010d01H
	DD	0620dH
$unwind$?stbi__skip_jpeg_junk_at_end@@YAEPEAUstbi__jpeg@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z DD 011801H
	DD	02218H
$unwind$?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z DD 011801H
	DD	02218H
$unwind$?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z DD 011801H
	DD	02218H
$unwind$?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z DD 021b01H
	DD	063011bH
$unwind$?stbi__resample_row_generic@@YAPEAEPEAE00HH@Z DD 011801H
	DD	02218H
$unwind$?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z DD 011801H
	DD	04218H
$unwind$?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z DD 021b01H
	DD	08d011bH
$unwind$?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z DD 010901H
	DD	04209H
$unwind$?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z DD 010901H
	DD	04209H
$unwind$?stbi__blinn_8x8@@YAEEE@Z DD 010c01H
	DD	0220cH
$unwind$?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z DD 022d19H
	DD	03d011bH
	DD	imagerel __GSHandlerCheck
	DD	01d0H
$unwind$?stbi__jpeg_info_raw@@YAHPEAUstbi__jpeg@@PEAH11@Z DD 011801H
	DD	06218H
$unwind$?stbi__bit_reverse@@YAHHH@Z DD 010c01H
	DD	0420cH
$unwind$?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z DD 022819H
	DD	01d0116H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$?stbi__zeof@@YAHPEAUstbi__zbuf@@@Z DD 010901H
	DD	02209H
$unwind$?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z DD 010d01H
	DD	0620dH
$unwind$?stbi__zhuffman_decode_slowpath@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z DD 010e01H
	DD	0820eH
$unwind$?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z DD 010e01H
	DD	0620eH
$unwind$?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z DD 011301H
	DD	08213H
$unwind$?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z DD 010901H
	DD	08209H
$unwind$?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z DD 021e19H
	DD	0149010cH
	DD	imagerel __GSHandlerCheck
	DD	0a30H
$unwind$?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__parse_zlib_header@@YAHPEAUstbi__zbuf@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z DD 010d01H
	DD	0620dH
$unwind$?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z DD 011801H
	DD	04218H
$unwind$?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__check_png_header@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__paeth@@YAHHHH@Z DD 011101H
	DD	06211H
$unwind$?stbi__create_png_alpha_expand8@@YAXPEAE0IH@Z DD 011801H
	DD	06218H
$unwind$?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z DD 021b01H
	DD	01b011bH
$unwind$?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z DD 022d19H
	DD	023011bH
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$?stbi__compute_transparency@@YAHPEAUstbi__png@@QEAEH@Z DD 011301H
	DD	08213H
$unwind$?stbi__compute_transparency16@@YAHPEAUstbi__png@@QEAGH@Z DD 011301H
	DD	08213H
$unwind$?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z DD 011801H
	DD	0a218H
$unwind$?stbi__de_iphone@@YAXPEAUstbi__png@@@Z DD 010901H
	DD	0a209H
$unwind$?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z DD 032819H
	DD	09c0116H
	DD	0700fH
	DD	imagerel __GSHandlerCheck
	DD	04d0H
$unwind$?stbi__do_png@@YAPEAXPEAUstbi__png@@PEAH11HPEAUstbi__result_info@@@Z DD 011801H
	DD	08218H
$unwind$?stbi__png_info_raw@@YAHPEAUstbi__png@@PEAH11@Z DD 011801H
	DD	04218H
$unwind$?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__high_bit@@YAHI@Z DD 010801H
	DD	02208H
$unwind$?stbi__shiftsigned@@YAHIHH@Z DD 011101H
	DD	04211H
$unwind$?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z DD 010e01H
	DD	0c20eH
$unwind$?stbi__tga_get_comp@@YAHHHPEAH@Z DD 011101H
	DD	02211H
$unwind$?stbi__tga_read_rgb16@@YAXPEAUstbi__context@@PEAE@Z DD 010e01H
	DD	0820eH
$unwind$?stbi__psd_decode_rle@@YAHPEAUstbi__context@@PEAEH@Z DD 011301H
	DD	06213H
$unwind$?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z DD 010e01H
	DD	0620eH
$unwind$?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z DD 011201H
	DD	06212H
$unwind$?stbi__copyval@@YAXHPEAEPEBE@Z DD 011201H
	DD	02212H
$unwind$?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z DD 022c19H
	DD	01b011aH
	DD	imagerel __GSHandlerCheck
	DD	0c8H
$unwind$?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	06209H
$unwind$?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z DD 011801H
	DD	06218H
$unwind$?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z DD 011801H
	DD	06218H
$unwind$?stbi__gif_info_raw@@YAHPEAUstbi__context@@PEAH11@Z DD 011801H
	DD	06218H
$unwind$?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z DD 010e01H
	DD	0820eH
$unwind$?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z DD 021101H
	DD	0110111H
$unwind$?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHHPEAE@Z DD 021b01H
	DD	011011bH
$unwind$?stbi__load_gif_main_outofmem@@YAPEAXPEAUstbi__gif@@PEAEPEAPEAH@Z DD 011301H
	DD	06213H
$unwind$?stbi__hdr_test_core@@YAHPEAUstbi__context@@PEBD@Z DD 010e01H
	DD	0620eH
$unwind$?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z DD 010e01H
	DD	0620eH
$unwind$?stbi__hdr_convert@@YAXPEAMPEAEH@Z DD 011301H
	DD	06213H
$unwind$?stbi__pnm_isspace@@YAHD@Z DD 010801H
	DD	02208H
$unwind$?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z DD 010e01H
	DD	0420eH
$unwind$?stbi__pnm_isdigit@@YAHD@Z DD 010801H
	DD	02208H
$unwind$?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z DD 010e01H
	DD	0620eH
$unwind$?stbi__info_main@@YAHPEAUstbi__context@@PEAH11@Z DD 011801H
	DD	04218H
$unwind$?stbi__is_16_main@@YAHPEAUstbi__context@@@Z DD 010901H
	DD	04209H
$unwind$?read_file@@YAXPEADPEAPEAEPEA_K@Z DD 011301H
	DD	08213H
$unwind$?parse_int@@YAHPEAPEAE@Z DD 010901H
	DD	06209H
$unwind$?parse_double@@YANPEAPEAE@Z DD 010901H
	DD	06209H
$unwind$?parse_v2@@YAXPEAMPEAPEAE@Z DD 010e01H
	DD	0420eH
$unwind$?parse_v3@@YAXPEAMPEAPEAE@Z DD 010e01H
	DD	0420eH
$unwind$?parse_indices@@YA?ATvert_idx_t@@PEAPEAE@Z DD 031f19H
	DD	0700c8210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	030H
$unwind$?parse_name@@YAIPEAPEAEPEAPEAD@Z DD 010e01H
	DD	0820eH
$unwind$?parse_obj@@YAXPEAUobj_info_t@@PEAEPEAPEAD@Z DD 042a19H
	DD	01f0118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	0e0H
$unwind$?init_obj_material@@YAXPEAUobj_mat_t@@@Z DD 010901H
	DD	04209H
$unwind$?parse_mtl@@YAXPEAUobj_info_t@@PEAE@Z DD 010e01H
	DD	0a20eH
$unwind$?load_obj@@YA?AUobj_info_t@@PEAD@Z DD 042519H
	DD	0350113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0190H
$unwind$?free_obj@@YAXPEAUobj_info_t@@@Z DD 010901H
	DD	0a209H
$unwind$?load_shader_source@@YAPEADPEBD@Z DD 042019H
	DD	02d010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	0150H
$unwind$?compile_shader@@YAIPEADI@Z DD 022219H
	DD	0490110H
	DD	imagerel __GSHandlerCheck
	DD	0230H
$unwind$?compile_shader_from_file@@YAIPEBDI@Z DD 010d01H
	DD	0620dH
$unwind$?create_program@@YAIPEAII@Z DD 022219H
	DD	0490110H
	DD	imagerel __GSHandlerCheck
	DD	0230H
$unwind$?add_shader@@YAIPEAUgl_renderer@@IZZ DD 011701H
	DD	0c217H
$unwind$?set_uniform_int@@YAXIPEBDH@Z DD 011201H
	DD	06212H
$unwind$?set_uniform_float@@YAXIPEBDM@Z DD 011301H
	DD	06213H
$unwind$?set_uniform_vec3@@YAXIPEBDTHMM_Vec3@@@Z DD 011201H
	DD	06212H
$unwind$?set_uniform_mat4@@YAXIPEBDTHMM_Mat4@@@Z DD 011201H
	DD	06212H
$unwind$?create_texture_from_bitmap@@YAIPEAUasset_manager_t@@PEAEHHH@Z DD 011801H
	DD	0e218H
$unwind$?init_asset_manager@@YAXPEAUasset_manager_t@@@Z DD 010901H
	DD	08209H
$unwind$?hash_vert_idx@@YA_KPEAH@Z DD 010901H
	DD	08209H
$unwind$?kh_init_vertex_map_t@@YAPEAUkh_vertex_map_t_s@@XZ DD 010401H
	DD	04204H
$unwind$?kh_destroy_vertex_map_t@@YAXPEAUkh_vertex_map_t_s@@@Z DD 010901H
	DD	04209H
$unwind$?kh_get_vertex_map_t@@YAIPEBUkh_vertex_map_t_s@@Tvert_idx_t@@@Z DD 010e01H
	DD	0a20eH
$unwind$?kh_resize_vertex_map_t@@YAHPEAUkh_vertex_map_t_s@@I@Z DD 042419H
	DD	0170112H
	DD	0600a700bH
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$?kh_put_vertex_map_t@@YAIPEAUkh_vertex_map_t_s@@Tvert_idx_t@@PEAH@Z DD 041801H
	DD	0130118H
	DD	060107011H
$unwind$?kh_del_vertex_map_t@@YAXPEAUkh_vertex_map_t_s@@I@Z DD 010d01H
	DD	0220dH
$unwind$?create_model@@YAXPEAUmesh_t@@PEAUobj_info_t@@IUcolor_t@@@Z DD 042f19H
	DD	02f011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0168H
$unwind$?create_texture@@YAIPEAUasset_manager_t@@PEAD@Z DD 010e01H
	DD	0a20eH
$unwind$?create_materials@@YAXPEAUasset_manager_t@@PEAUmaterial_t@@PEAUobj_info_t@@@Z DD 042a19H
	DD	0430118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	0200H
$unwind$?add_model@@YAXPEAUasset_manager_t@@PEADPEAUmodel_info_t@@Ucolor_t@@@Z DD 041d01H
	DD	023011dH
	DD	060157016H
$unwind$?init_gl_renderer@@YAXPEAUgl_renderer@@PEAUcamera_t@@@Z DD 010e01H
	DD	0420eH
$unwind$?update_camera@@YAXPEAUcamera_t@@@Z DD 042019H
	DD	03f010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	01e0H
$unwind$?init_camera@@YAXPEAUcamera_t@@THMM_Vec3@@MMMMMM@Z DD 032b19H
	DD	07018e21cH
	DD	06017H
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$?init_light@@YAXPEAUlight_t@@THMM_Vec3@@MMM@Z DD 021801H
	DD	060177018H
$unwind$?add_light@@YAXPEAUgl_renderer@@THMM_Vec3@@MMM@Z DD 031c01H
	DD	07018a21cH
	DD	06017H
$unwind$?init_framebuffer@@YAXPEAUgl_renderer@@PEBD1@Z DD 022819H
	DD	01d0116H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$?update_transform@@YAXPEAUgl_renderer@@PEATHMM_Mat4@@THMM_Vec3@@22@Z DD 042f19H
	DD	0125011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0910H
$unwind$?add_entity@@YAIPEAUgl_renderer@@PEAUmodel_info_t@@THMM_Vec3@@22@Z DD 041d01H
	DD	011011dH
	DD	060157016H
$unwind$?push_mesh@@YAXPEAUgl_renderer@@PEAUasset_manager_t@@PEAUmodel_info_t@@Ucolor_t@@@Z DD 041d01H
	DD	017011dH
	DD	060157016H
$unwind$?adjust_bezier_c1@@YAXPEATHMM_Vec3@@I@Z DD 042419H
	DD	01d0112H
	DD	0600a700bH
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$?adjust_bezier_g1@@YAXPEATHMM_Vec3@@I@Z DD 042419H
	DD	0390112H
	DD	0600a700bH
	DD	imagerel __GSHandlerCheck
	DD	01b0H
$unwind$?render_mesh@@YAXPEAUgl_renderer@@Umodel_info_t@@@Z DD 031f19H
	DD	0700ca210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	040H
$unwind$?bind_material@@YAXPEAUasset_manager_t@@PEAUmaterial_t@@II@Z DD 041d01H
	DD	011011dH
	DD	060157016H
$unwind$?bind_lights@@YAXPEAUlight_t@@II@Z DD 032319H
	DD	07010e214H
	DD	0600fH
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$?render@@YAXPEAUgl_renderer@@PEAUasset_manager_t@@I@Z DD 042a19H
	DD	010d0118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	0850H
$unwind$?framebuffer_size_callback@@YAXPEAUGLFWwindow@@HH@Z DD 011201H
	DD	04212H
$unwind$?draw_vec3_widget@@YAXPEBDPEATHMM_Vec3@@@Z DD 010e01H
	DD	0c20eH
$unwind$?process_input@@YAXPEAUGLFWwindow@@PEAUgl_renderer@@I@Z DD 011301H
	DD	08213H
$unwind$main DD	042219H
	DD	08270110H
	DD	060027003H
	DD	imagerel __GSHandlerCheck_EH4
	DD	imagerel $cppxdata$main
	DD	04122H
$cppxdata$main DB 028H
	DD	imagerel $stateUnwindMap$main
	DD	imagerel $ip2state$main
$stateUnwindMap$main DB 02H
	DB	0eH
	DD	imagerel main$dtor$0
$ip2state$main DB 06H
	DB	00H
	DB	00H
	DB	0a5H, 'e'
	DB	02H
	DB	01dH, 09H
	DB	00H
$unwind$main$dtor$0 DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ldexpf DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ImGuiIO@@QEAA@AEBU0@@Z DD 031001H
	DD	0700c4210H
	DD	0600bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ImGuiIO@@QEAA@XZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$ImVector@G@@QEAAXH@Z DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$ImVector@G@@QEAAXH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_grow_capacity@?$ImVector@G@@QEBAHH@Z DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$ImVector@G@@QEAAXXZ DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$ImVector@G@@QEAA@XZ DB 02H
	DB	00H
	DB	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$cppxdata$??1?$ImVector@G@@QEAA@XZ DB 060H
	DD	imagerel $ip2state$??1?$ImVector@G@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$ImVector@G@@QEAA@XZ DD 010919H
	DD	04209H
	DD	imagerel __CxxFrameHandler4
	DD	imagerel $cppxdata$??1?$ImVector@G@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$ImVector@G@@QEAAAEAU0@AEBU0@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$ImVector@G@@QEAA@AEBU0@@Z DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?strrchr@@YAPEADQEADH@Z DD 010d01H
	DD	0420dH
xdata	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\main.cpp
_TEXT	SEGMENT
i$1 = 64
is_selected$2 = 68
is_selected$3 = 69
tv880 = 70
tv893 = 71
i$4 = 72
model_combo_idx$ = 76
p$ = 80
i$5 = 88
n$6 = 92
n$7 = 96
i$8 = 100
i$9 = 104
i$10 = 108
$T11 = 112
$T12 = 116
$T13 = 120
$T14 = 124
shader_combo_idx$ = 128
temp$15 = 132
c_selected$ = 136
frame_count$ = 140
$T16 = 144
window$ = 152
entity$17 = 160
prev_p_id$18 = 168
io$ = 176
shader$ = 184
tv732 = 188
tv804 = 192
a_selected$ = 196
tv936 = 200
p_count$19 = 204
tv1026 = 208
size$20 = 216
z_prime_id$ = 224
window_flags$21 = 228
dock_space_id$22 = 232
tv575 = 236
light_count$23 = 240
t$ = 244
debug$ = 248
debug_t$ = 252
c_count$24 = 256
h$25 = 260
w$26 = 264
tv1084 = 268
no_shade_id$ = 272
tv1092 = 276
tv1096 = 280
tv1100 = 284
tv1104 = 288
gouraud_id$ = 292
phong_id$ = 296
tv1088 = 300
flat_id$ = 304
z_id$ = 308
viewport$27 = 312
rp$28 = 320
delta$29 = 328
current_time$30 = 336
last_time$ = 344
tv623 = 352
tv630 = 360
tv637 = 368
tv642 = 376
np$31 = 384
transform$32 = 392
backup$33 = 400
fps$34 = 408
assets$ = 416
$T35 = 440
$T36 = 456
$T37 = 472
$T38 = 488
$T39 = 504
a_type$ = 520
$T40 = 536
$T41 = 560
$T42 = 576
$T43 = 592
$T44 = 608
$T45 = 624
$T46 = 640
$T47 = 656
$T48 = 672
$T49 = 688
$T50 = 704
$T51 = 712
$T52 = 720
$T53 = 728
$T54 = 736
$T55 = 744
$T56 = 752
$T57 = 760
$T58 = 768
$T59 = 784
$T60 = 800
$T61 = 808
$T62 = 824
$T63 = 840
$T64 = 856
$T65 = 872
$T66 = 888
$T67 = 904
$T68 = 920
$T69 = 936
$T70 = 952
$T71 = 968
$T72 = 984
gl$ = 1008
prev_p$73 = 1296
tempf$74 = 1312
$T75 = 1328
$T76 = 1344
$T77 = 1360
$T78 = 1376
$T79 = 1392
$T80 = 1408
$T81 = 1424
$T82 = 1440
$T83 = 1456
$T84 = 1472
camera$ = 1488
io$85 = 1648
colors$ = 16272
combo_models$ = 16288
c_type$ = 16320
paths$ = 16344
color$ = 16384
shader_combo_items$ = 16448
models$ = 16544
buffer$86 = 16608
buffer$87 = 16640
__$ArrayPad$ = 16672
main	PROC

; 128  : int main() {

$LN85:
  00000	40 56		 push	 rsi
  00002	57		 push	 rdi
  00003	b8 38 41 00 00	 mov	 eax, 16696		; 00004138H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	48 2b e0	 sub	 rsp, rax
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 20
	41 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 129  :     glfwInit();

  00022	e8 00 00 00 00	 call	 glfwInit

; 130  :     glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);

  00027	ba 03 00 00 00	 mov	 edx, 3
  0002c	b9 02 20 02 00	 mov	 ecx, 139266		; 00022002H
  00031	e8 00 00 00 00	 call	 glfwWindowHint

; 131  :     glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);

  00036	ba 03 00 00 00	 mov	 edx, 3
  0003b	b9 03 20 02 00	 mov	 ecx, 139267		; 00022003H
  00040	e8 00 00 00 00	 call	 glfwWindowHint

; 132  :     glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

  00045	ba 01 20 03 00	 mov	 edx, 204801		; 00032001H
  0004a	b9 08 20 02 00	 mov	 ecx, 139272		; 00022008H
  0004f	e8 00 00 00 00	 call	 glfwWindowHint

; 133  :     
; 134  :     GLFWwindow *window = glfwCreateWindow(SRC_WIDTH, SRC_HEIGHT, 

  00054	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0005d	45 33 c9	 xor	 r9d, r9d
  00060	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG84821
  00067	ba 58 02 00 00	 mov	 edx, 600		; 00000258H
  0006c	b9 20 03 00 00	 mov	 ecx, 800		; 00000320H
  00071	e8 00 00 00 00	 call	 glfwCreateWindow
  00076	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR window$[rsp], rax

; 135  :                                           "Model Transforms",
; 136  :                                           NULL, NULL);
; 137  :     if (window == NULL) {

  0007e	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR window$[rsp], 0
  00087	75 0f		 jne	 SHORT $LN31@main

; 138  :         glfwTerminate();

  00089	e8 00 00 00 00	 call	 glfwTerminate

; 139  :         return -1;

  0008e	b8 ff ff ff ff	 mov	 eax, -1
  00093	e9 30 1b 00 00	 jmp	 $LN82@main
$LN31@main:

; 140  :     }
; 141  :     
; 142  :     glfwMakeContextCurrent(window);

  00098	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR window$[rsp]
  000a0	e8 00 00 00 00	 call	 glfwMakeContextCurrent

; 143  :     glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?framebuffer_size_callback@@YAXPEAUGLFWwindow@@HH@Z ; framebuffer_size_callback
  000ac	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR window$[rsp]
  000b4	e8 00 00 00 00	 call	 glfwSetFramebufferSizeCallback

; 144  :     
; 145  :     glewInit();

  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glewInit

; 146  :     
; 147  :     IMGUI_CHECKVERSION();

  000bf	48 c7 44 24 30
	02 00 00 00	 mov	 QWORD PTR [rsp+48], 2
  000c8	48 c7 44 24 28
	14 00 00 00	 mov	 QWORD PTR [rsp+40], 20
  000d1	48 c7 44 24 20
	10 00 00 00	 mov	 QWORD PTR [rsp+32], 16
  000da	41 b9 08 00 00
	00		 mov	 r9d, 8
  000e0	41 b8 6c 04 00
	00		 mov	 r8d, 1132		; 0000046cH
  000e6	ba 18 39 00 00	 mov	 edx, 14616		; 00003918H
  000eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG84823
  000f2	e8 00 00 00 00	 call	 ?DebugCheckVersionAndDataLayout@ImGui@@YA_NPEBD_K11111@Z ; ImGui::DebugCheckVersionAndDataLayout

; 148  :     ImGui::CreateContext();

  000f7	33 c9		 xor	 ecx, ecx
  000f9	e8 00 00 00 00	 call	 ?CreateContext@ImGui@@YAPEAUImGuiContext@@PEAUImFontAtlas@@@Z ; ImGui::CreateContext

; 149  :     ImGuiIO& io = ImGui::GetIO(); (void)io;

  000fe	e8 00 00 00 00	 call	 ?GetIO@ImGui@@YAAEAUImGuiIO@@XZ ; ImGui::GetIO
  00103	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR io$[rsp], rax

; 150  :     io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;

  0010b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR io$[rsp]
  00113	8b 00		 mov	 eax, DWORD PTR [rax]
  00115	83 c8 01	 or	 eax, 1
  00118	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR io$[rsp]
  00120	89 01		 mov	 DWORD PTR [rcx], eax

; 151  :     io.ConfigFlags |= ImGuiConfigFlags_DockingEnable; 

  00122	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR io$[rsp]
  0012a	8b 00		 mov	 eax, DWORD PTR [rax]
  0012c	83 c8 40	 or	 eax, 64			; 00000040H
  0012f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR io$[rsp]
  00137	89 01		 mov	 DWORD PTR [rcx], eax

; 152  :     io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable; 

  00139	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR io$[rsp]
  00141	8b 00		 mov	 eax, DWORD PTR [rax]
  00143	0f ba e8 0a	 bts	 eax, 10
  00147	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR io$[rsp]
  0014f	89 01		 mov	 DWORD PTR [rcx], eax

; 153  :     
; 154  :     ImGui::StyleColorsDark();

  00151	33 c9		 xor	 ecx, ecx
  00153	e8 00 00 00 00	 call	 ?StyleColorsDark@ImGui@@YAXPEAUImGuiStyle@@@Z ; ImGui::StyleColorsDark

; 155  :     
; 156  :     ImGui_ImplGlfw_InitForOpenGL(window, true);

  00158	b2 01		 mov	 dl, 1
  0015a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR window$[rsp]
  00162	e8 00 00 00 00	 call	 ?ImGui_ImplGlfw_InitForOpenGL@@YA_NPEAUGLFWwindow@@_N@Z ; ImGui_ImplGlfw_InitForOpenGL

; 157  :     ImGui_ImplOpenGL3_Init("#version 330");

  00167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG84824
  0016e	e8 00 00 00 00	 call	 ?ImGui_ImplOpenGL3_Init@@YA_NPEBD@Z ; ImGui_ImplOpenGL3_Init

; 158  :     
; 159  :     
; 160  :     camera_t camera = {0};

  00173	0f 57 c0	 xorps	 xmm0, xmm0
  00176	f3 0f 11 84 24
	d0 05 00 00	 movss	 DWORD PTR camera$[rsp], xmm0
  0017f	48 8d 84 24 d4
	05 00 00	 lea	 rax, QWORD PTR camera$[rsp+4]
  00187	48 8b f8	 mov	 rdi, rax
  0018a	33 c0		 xor	 eax, eax
  0018c	b9 9c 00 00 00	 mov	 ecx, 156		; 0000009cH
  00191	f3 aa		 rep stosb

; 161  :     init_camera(&camera, HMM_V3(0.0f, 0.0f, 10.0f), 1.0f, 1.0f,

  00193	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@41200000
  0019b	0f 57 d2	 xorps	 xmm2, xmm2
  0019e	0f 57 c9	 xorps	 xmm1, xmm1
  001a1	48 8d 8c 24 a8
	03 00 00	 lea	 rcx, QWORD PTR $T69[rsp]
  001a9	e8 00 00 00 00	 call	 HMM_V3
  001ae	48 8d 8c 24 30
	05 00 00	 lea	 rcx, QWORD PTR $T75[rsp]
  001b6	48 8b f9	 mov	 rdi, rcx
  001b9	48 8b f0	 mov	 rsi, rax
  001bc	b9 0c 00 00 00	 mov	 ecx, 12
  001c1	f3 a4		 rep movsb
  001c3	48 8d 84 24 90
	02 00 00	 lea	 rax, QWORD PTR $T47[rsp]
  001cb	48 8d 8c 24 30
	05 00 00	 lea	 rcx, QWORD PTR $T75[rsp]
  001d3	48 8b f8	 mov	 rdi, rax
  001d6	48 8b f1	 mov	 rsi, rcx
  001d9	b9 0c 00 00 00	 mov	 ecx, 12
  001de	f3 a4		 rep movsb
  001e0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42480000
  001e8	f3 0f 11 44 24
	38		 movss	 DWORD PTR [rsp+56], xmm0
  001ee	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3dcccccd
  001f6	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  001fc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42340000
  00204	f3 0f 11 44 24
	28		 movss	 DWORD PTR [rsp+40], xmm0
  0020a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3faaaaab
  00212	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00218	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f800000
  00220	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f800000
  00228	48 8d 94 24 90
	02 00 00	 lea	 rdx, QWORD PTR $T47[rsp]
  00230	48 8d 8c 24 d0
	05 00 00	 lea	 rcx, QWORD PTR camera$[rsp]
  00238	e8 00 00 00 00	 call	 ?init_camera@@YAXPEAUcamera_t@@THMM_Vec3@@MMMMMM@Z ; init_camera

; 162  :                 (f32)SRC_WIDTH/SRC_HEIGHT);
; 163  :     
; 164  :     gl_renderer gl = {0};

  0023d	48 8d 84 24 f0
	03 00 00	 lea	 rax, QWORD PTR gl$[rsp]
  00245	48 8b f8	 mov	 rdi, rax
  00248	33 c0		 xor	 eax, eax
  0024a	b9 18 01 00 00	 mov	 ecx, 280		; 00000118H
  0024f	f3 aa		 rep stosb

; 165  :     init_gl_renderer(&gl, &camera);

  00251	48 8d 94 24 d0
	05 00 00	 lea	 rdx, QWORD PTR camera$[rsp]
  00259	48 8d 8c 24 f0
	03 00 00	 lea	 rcx, QWORD PTR gl$[rsp]
  00261	e8 00 00 00 00	 call	 ?init_gl_renderer@@YAXPEAUgl_renderer@@PEAUcamera_t@@@Z ; init_gl_renderer

; 166  :     init_framebuffer(&gl, "framebuffer_vert.glsl", "framebuffer_frag.glsl");

  00266	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG84825
  0026d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG84826
  00274	48 8d 8c 24 f0
	03 00 00	 lea	 rcx, QWORD PTR gl$[rsp]
  0027c	e8 00 00 00 00	 call	 ?init_framebuffer@@YAXPEAUgl_renderer@@PEBD1@Z ; init_framebuffer

; 167  :     
; 168  :     add_light(&gl, HMM_V3(5.0f, 2.0f, 3.0f));

  00281	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@40400000
  00289	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@40000000
  00291	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40a00000
  00299	48 8d 8c 24 b8
	03 00 00	 lea	 rcx, QWORD PTR $T70[rsp]
  002a1	e8 00 00 00 00	 call	 HMM_V3
  002a6	48 8d 8c 24 40
	05 00 00	 lea	 rcx, QWORD PTR $T76[rsp]
  002ae	48 8b f9	 mov	 rdi, rcx
  002b1	48 8b f0	 mov	 rsi, rax
  002b4	b9 0c 00 00 00	 mov	 ecx, 12
  002b9	f3 a4		 rep movsb
  002bb	48 8d 84 24 a0
	02 00 00	 lea	 rax, QWORD PTR $T48[rsp]
  002c3	48 8d 8c 24 40
	05 00 00	 lea	 rcx, QWORD PTR $T76[rsp]
  002cb	48 8b f8	 mov	 rdi, rax
  002ce	48 8b f1	 mov	 rsi, rcx
  002d1	b9 0c 00 00 00	 mov	 ecx, 12
  002d6	f3 a4		 rep movsb
  002d8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3d03126f
  002e0	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  002e6	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3db851ec
  002ee	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f800000
  002f6	48 8d 94 24 a0
	02 00 00	 lea	 rdx, QWORD PTR $T48[rsp]
  002fe	48 8d 8c 24 f0
	03 00 00	 lea	 rcx, QWORD PTR gl$[rsp]
  00306	e8 00 00 00 00	 call	 ?add_light@@YAXPEAUgl_renderer@@THMM_Vec3@@MMM@Z ; add_light

; 169  :     
; 170  :     asset_manager_t assets = {0};

  0030b	48 8d 84 24 a0
	01 00 00	 lea	 rax, QWORD PTR assets$[rsp]
  00313	48 8b f8	 mov	 rdi, rax
  00316	33 c0		 xor	 eax, eax
  00318	b9 18 00 00 00	 mov	 ecx, 24
  0031d	f3 aa		 rep stosb

; 171  :     init_asset_manager(&assets);

  0031f	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR assets$[rsp]
  00327	e8 00 00 00 00	 call	 ?init_asset_manager@@YAXPEAUasset_manager_t@@@Z ; init_asset_manager

; 172  :     
; 173  :     u32 no_shade_id = add_shader(&gl, 2, "vert.glsl", GL_VERTEX_SHADER,

  0032c	c7 44 24 28 30
	8b 00 00	 mov	 DWORD PTR [rsp+40], 35632 ; 00008b30H
  00334	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG84827
  0033b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00340	41 b9 31 8b 00
	00		 mov	 r9d, 35633		; 00008b31H
  00346	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG84828
  0034d	ba 02 00 00 00	 mov	 edx, 2
  00352	48 8d 8c 24 f0
	03 00 00	 lea	 rcx, QWORD PTR gl$[rsp]
  0035a	e8 00 00 00 00	 call	 ?add_shader@@YAIPEAUgl_renderer@@IZZ ; add_shader
  0035f	89 84 24 10 01
	00 00		 mov	 DWORD PTR no_shade_id$[rsp], eax

; 174  :                                  "frag.glsl", GL_FRAGMENT_SHADER);
; 175  :     
; 176  :     u32 flat_id = add_shader(&gl, 3, "flat_vert.glsl", GL_VERTEX_SHADER, "flat_geo.glsl", GL_GEOMETRY_SHADER, "flat_frag.glsl", GL_FRAGMENT_SHADER);

  00366	c7 44 24 38 30
	8b 00 00	 mov	 DWORD PTR [rsp+56], 35632 ; 00008b30H
  0036e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG84829
  00375	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0037a	c7 44 24 28 d9
	8d 00 00	 mov	 DWORD PTR [rsp+40], 36313 ; 00008dd9H
  00382	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG84830
  00389	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0038e	41 b9 31 8b 00
	00		 mov	 r9d, 35633		; 00008b31H
  00394	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG84831
  0039b	ba 03 00 00 00	 mov	 edx, 3
  003a0	48 8d 8c 24 f0
	03 00 00	 lea	 rcx, QWORD PTR gl$[rsp]
  003a8	e8 00 00 00 00	 call	 ?add_shader@@YAIPEAUgl_renderer@@IZZ ; add_shader
  003ad	89 84 24 30 01
	00 00		 mov	 DWORD PTR flat_id$[rsp], eax

; 177  :     
; 178  :     u32 gouraud_id = add_shader(&gl, 2, "gouraud_vert.glsl", GL_VERTEX_SHADER,

  003b4	c7 44 24 28 30
	8b 00 00	 mov	 DWORD PTR [rsp+40], 35632 ; 00008b30H
  003bc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG84832
  003c3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003c8	41 b9 31 8b 00
	00		 mov	 r9d, 35633		; 00008b31H
  003ce	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG84833
  003d5	ba 02 00 00 00	 mov	 edx, 2
  003da	48 8d 8c 24 f0
	03 00 00	 lea	 rcx, QWORD PTR gl$[rsp]
  003e2	e8 00 00 00 00	 call	 ?add_shader@@YAIPEAUgl_renderer@@IZZ ; add_shader
  003e7	89 84 24 24 01
	00 00		 mov	 DWORD PTR gouraud_id$[rsp], eax

; 179  :                                 "gouraud_frag.glsl", GL_FRAGMENT_SHADER);
; 180  :     
; 181  :     u32 phong_id = add_shader(&gl, 2, "phong_vert.glsl", GL_VERTEX_SHADER,

  003ee	c7 44 24 28 30
	8b 00 00	 mov	 DWORD PTR [rsp+40], 35632 ; 00008b30H
  003f6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG84834
  003fd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00402	41 b9 31 8b 00
	00		 mov	 r9d, 35633		; 00008b31H
  00408	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG84835
  0040f	ba 02 00 00 00	 mov	 edx, 2
  00414	48 8d 8c 24 f0
	03 00 00	 lea	 rcx, QWORD PTR gl$[rsp]
  0041c	e8 00 00 00 00	 call	 ?add_shader@@YAIPEAUgl_renderer@@IZZ ; add_shader
  00421	89 84 24 28 01
	00 00		 mov	 DWORD PTR phong_id$[rsp], eax

; 182  :                               "phong_frag.glsl", GL_FRAGMENT_SHADER);
; 183  :     
; 184  :     u32 z_id = add_shader(&gl, 2, "depth_vert.glsl", GL_VERTEX_SHADER,

  00428	c7 44 24 28 30
	8b 00 00	 mov	 DWORD PTR [rsp+40], 35632 ; 00008b30H
  00430	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG84836
  00437	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0043c	41 b9 31 8b 00
	00		 mov	 r9d, 35633		; 00008b31H
  00442	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG84837
  00449	ba 02 00 00 00	 mov	 edx, 2
  0044e	48 8d 8c 24 f0
	03 00 00	 lea	 rcx, QWORD PTR gl$[rsp]
  00456	e8 00 00 00 00	 call	 ?add_shader@@YAIPEAUgl_renderer@@IZZ ; add_shader
  0045b	89 84 24 34 01
	00 00		 mov	 DWORD PTR z_id$[rsp], eax

; 185  :                           "depth_frag.glsl", GL_FRAGMENT_SHADER);
; 186  :     
; 187  :     u32 z_prime_id = add_shader(&gl, 2, "linear_depth_vert.glsl", GL_VERTEX_SHADER,

  00462	c7 44 24 28 30
	8b 00 00	 mov	 DWORD PTR [rsp+40], 35632 ; 00008b30H
  0046a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG84838
  00471	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00476	41 b9 31 8b 00
	00		 mov	 r9d, 35633		; 00008b31H
  0047c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG84839
  00483	ba 02 00 00 00	 mov	 edx, 2
  00488	48 8d 8c 24 f0
	03 00 00	 lea	 rcx, QWORD PTR gl$[rsp]
  00490	e8 00 00 00 00	 call	 ?add_shader@@YAIPEAUgl_renderer@@IZZ ; add_shader
  00495	89 84 24 e0 00
	00 00		 mov	 DWORD PTR z_prime_id$[rsp], eax

; 188  :                                 "linear_depth_frag.glsl", GL_FRAGMENT_SHADER);
; 189  :     
; 190  :     
; 191  :     u32 shader = get_shader(&gl, gl.fb.id);

  0049c	8b 94 24 e4 04
	00 00		 mov	 edx, DWORD PTR gl$[rsp+244]
  004a3	48 8d 8c 24 f0
	03 00 00	 lea	 rcx, QWORD PTR gl$[rsp]
  004ab	e8 00 00 00 00	 call	 ?get_shader@@YAIPEAUgl_renderer@@I@Z ; get_shader
  004b0	89 84 24 b8 00
	00 00		 mov	 DWORD PTR shader$[rsp], eax

; 192  :     glUseProgram(shader);

  004b7	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR shader$[rsp]
  004be	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewUseProgram
  004c5	ff 10		 call	 QWORD PTR [rax]

; 193  :     set_uniform_int(shader, "tex", 0);

  004c7	45 33 c0	 xor	 r8d, r8d
  004ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG84840
  004d1	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR shader$[rsp]
  004d8	e8 00 00 00 00	 call	 ?set_uniform_int@@YAXIPEBDH@Z ; set_uniform_int

; 194  :     
; 195  :     
; 196  :     char *paths[4] = {
; 197  :         "backpack\\backpack.obj",

  004dd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG84841
  004e4	48 89 84 24 d8
	3f 00 00	 mov	 QWORD PTR paths$[rsp], rax

; 198  :         "smooth_monkey\\monkey.obj",

  004ec	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG84842
  004f3	48 89 84 24 e0
	3f 00 00	 mov	 QWORD PTR paths$[rsp+8], rax

; 199  :         "dragon\\dragon.obj",

  004fb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG84843
  00502	48 89 84 24 e8
	3f 00 00	 mov	 QWORD PTR paths$[rsp+16], rax

; 200  :         "cow\\cow.obj"

  0050a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG84844
  00511	48 89 84 24 f0
	3f 00 00	 mov	 QWORD PTR paths$[rsp+24], rax

; 201  :     };
; 202  :     
; 203  :     color_t colors[4] {
; 204  :         color_t{255, 255, 255, 255},

  00519	c6 84 24 90 00
	00 00 ff	 mov	 BYTE PTR $T16[rsp], 255	; 000000ffH
  00521	c6 84 24 91 00
	00 00 ff	 mov	 BYTE PTR $T16[rsp+1], 255 ; 000000ffH
  00529	c6 84 24 92 00
	00 00 ff	 mov	 BYTE PTR $T16[rsp+2], 255 ; 000000ffH
  00531	c6 84 24 93 00
	00 00 ff	 mov	 BYTE PTR $T16[rsp+3], 255 ; 000000ffH
  00539	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR $T16[rsp]
  00540	89 84 24 90 3f
	00 00		 mov	 DWORD PTR colors$[rsp], eax

; 205  :         color_t{ 135, 0, 0, 255 },

  00547	c6 44 24 70 87	 mov	 BYTE PTR $T11[rsp], 135	; 00000087H
  0054c	c6 44 24 71 00	 mov	 BYTE PTR $T11[rsp+1], 0
  00551	c6 44 24 72 00	 mov	 BYTE PTR $T11[rsp+2], 0
  00556	c6 44 24 73 ff	 mov	 BYTE PTR $T11[rsp+3], 255 ; 000000ffH
  0055b	8b 44 24 70	 mov	 eax, DWORD PTR $T11[rsp]
  0055f	89 84 24 94 3f
	00 00		 mov	 DWORD PTR colors$[rsp+4], eax

; 206  :         color_t{255, 255, 255, 255},

  00566	c6 44 24 74 ff	 mov	 BYTE PTR $T12[rsp], 255	; 000000ffH
  0056b	c6 44 24 75 ff	 mov	 BYTE PTR $T12[rsp+1], 255 ; 000000ffH
  00570	c6 44 24 76 ff	 mov	 BYTE PTR $T12[rsp+2], 255 ; 000000ffH
  00575	c6 44 24 77 ff	 mov	 BYTE PTR $T12[rsp+3], 255 ; 000000ffH
  0057a	8b 44 24 74	 mov	 eax, DWORD PTR $T12[rsp]
  0057e	89 84 24 98 3f
	00 00		 mov	 DWORD PTR colors$[rsp+8], eax

; 207  :         color_t{ 0, 100, 135, 255 },

  00585	c6 44 24 78 00	 mov	 BYTE PTR $T13[rsp], 0
  0058a	c6 44 24 79 64	 mov	 BYTE PTR $T13[rsp+1], 100 ; 00000064H
  0058f	c6 44 24 7a 87	 mov	 BYTE PTR $T13[rsp+2], 135 ; 00000087H
  00594	c6 44 24 7b ff	 mov	 BYTE PTR $T13[rsp+3], 255 ; 000000ffH
  00599	8b 44 24 78	 mov	 eax, DWORD PTR $T13[rsp]
  0059d	89 84 24 9c 3f
	00 00		 mov	 DWORD PTR colors$[rsp+12], eax

; 208  :     };
; 209  :     
; 210  :     char *combo_models[4] = {
; 211  :         "Backpack",

  005a4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG84845
  005ab	48 89 84 24 a0
	3f 00 00	 mov	 QWORD PTR combo_models$[rsp], rax

; 212  :         "Monkey",

  005b3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG84846
  005ba	48 89 84 24 a8
	3f 00 00	 mov	 QWORD PTR combo_models$[rsp+8], rax

; 213  :         "Dragon",

  005c2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG84847
  005c9	48 89 84 24 b0
	3f 00 00	 mov	 QWORD PTR combo_models$[rsp+16], rax

; 214  :         "Cow"

  005d1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG84848
  005d8	48 89 84 24 b8
	3f 00 00	 mov	 QWORD PTR combo_models$[rsp+24], rax

; 215  :     };
; 216  :     
; 217  :     model_info_t models[ARRAY_COUNT(combo_models)];
; 218  :     
; 219  :     for(u32 i = 0; i < ARRAY_COUNT(combo_models); i++) {

  005e0	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR i$5[rsp], 0
  005e8	eb 0a		 jmp	 SHORT $LN4@main
$LN2@main:
  005ea	8b 44 24 58	 mov	 eax, DWORD PTR i$5[rsp]
  005ee	ff c0		 inc	 eax
  005f0	89 44 24 58	 mov	 DWORD PTR i$5[rsp], eax
$LN4@main:
  005f4	8b 44 24 58	 mov	 eax, DWORD PTR i$5[rsp]
  005f8	48 83 f8 04	 cmp	 rax, 4
  005fc	0f 83 6e 01 00
	00		 jae	 $LN3@main

; 220  :         add_model(&assets, paths[i], models+i);

  00602	c6 44 24 7c 00	 mov	 BYTE PTR $T14[rsp], 0
  00607	c6 44 24 7d 00	 mov	 BYTE PTR $T14[rsp+1], 0
  0060c	c6 44 24 7e 00	 mov	 BYTE PTR $T14[rsp+2], 0
  00611	c6 44 24 7f ff	 mov	 BYTE PTR $T14[rsp+3], 255 ; 000000ffH
  00616	8b 44 24 58	 mov	 eax, DWORD PTR i$5[rsp]
  0061a	48 6b c0 10	 imul	 rax, rax, 16
  0061e	48 8d 84 04 a0
	40 00 00	 lea	 rax, QWORD PTR models$[rsp+rax]
  00626	8b 4c 24 58	 mov	 ecx, DWORD PTR i$5[rsp]
  0062a	44 8b 4c 24 7c	 mov	 r9d, DWORD PTR $T14[rsp]
  0062f	4c 8b c0	 mov	 r8, rax
  00632	48 8b 94 cc d8
	3f 00 00	 mov	 rdx, QWORD PTR paths$[rsp+rcx*8]
  0063a	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR assets$[rsp]
  00642	e8 00 00 00 00	 call	 ?add_model@@YAXPEAUasset_manager_t@@PEADPEAUmodel_info_t@@Ucolor_t@@@Z ; add_model

; 221  :         add_entity(&gl, models+i, HMM_V3(0.0f, 0.0f, 0.0f),

  00647	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f800000
  0064f	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f800000
  00657	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  0065f	48 8d 8c 24 98
	03 00 00	 lea	 rcx, QWORD PTR $T68[rsp]
  00667	e8 00 00 00 00	 call	 HMM_V3
  0066c	48 8d 8c 24 50
	05 00 00	 lea	 rcx, QWORD PTR $T77[rsp]
  00674	48 8b f9	 mov	 rdi, rcx
  00677	48 8b f0	 mov	 rsi, rax
  0067a	b9 0c 00 00 00	 mov	 ecx, 12
  0067f	f3 a4		 rep movsb
  00681	0f 57 db	 xorps	 xmm3, xmm3
  00684	0f 57 d2	 xorps	 xmm2, xmm2
  00687	0f 57 c9	 xorps	 xmm1, xmm1
  0068a	48 8d 8c 24 28
	03 00 00	 lea	 rcx, QWORD PTR $T61[rsp]
  00692	e8 00 00 00 00	 call	 HMM_V3
  00697	48 8d 8c 24 60
	05 00 00	 lea	 rcx, QWORD PTR $T78[rsp]
  0069f	48 8b f9	 mov	 rdi, rcx
  006a2	48 8b f0	 mov	 rsi, rax
  006a5	b9 0c 00 00 00	 mov	 ecx, 12
  006aa	f3 a4		 rep movsb
  006ac	0f 57 db	 xorps	 xmm3, xmm3
  006af	0f 57 d2	 xorps	 xmm2, xmm2
  006b2	0f 57 c9	 xorps	 xmm1, xmm1
  006b5	48 8d 8c 24 38
	03 00 00	 lea	 rcx, QWORD PTR $T62[rsp]
  006bd	e8 00 00 00 00	 call	 HMM_V3
  006c2	48 8d 8c 24 70
	05 00 00	 lea	 rcx, QWORD PTR $T79[rsp]
  006ca	48 8b f9	 mov	 rdi, rcx
  006cd	48 8b f0	 mov	 rsi, rax
  006d0	b9 0c 00 00 00	 mov	 ecx, 12
  006d5	f3 a4		 rep movsb
  006d7	48 8d 84 24 40
	02 00 00	 lea	 rax, QWORD PTR $T42[rsp]
  006df	48 8d 8c 24 50
	05 00 00	 lea	 rcx, QWORD PTR $T77[rsp]
  006e7	48 8b f8	 mov	 rdi, rax
  006ea	48 8b f1	 mov	 rsi, rcx
  006ed	b9 0c 00 00 00	 mov	 ecx, 12
  006f2	f3 a4		 rep movsb
  006f4	48 8d 84 24 50
	02 00 00	 lea	 rax, QWORD PTR $T43[rsp]
  006fc	48 8d 8c 24 60
	05 00 00	 lea	 rcx, QWORD PTR $T78[rsp]
  00704	48 8b f8	 mov	 rdi, rax
  00707	48 8b f1	 mov	 rsi, rcx
  0070a	b9 0c 00 00 00	 mov	 ecx, 12
  0070f	f3 a4		 rep movsb
  00711	48 8d 84 24 60
	02 00 00	 lea	 rax, QWORD PTR $T44[rsp]
  00719	48 8d 8c 24 70
	05 00 00	 lea	 rcx, QWORD PTR $T79[rsp]
  00721	48 8b f8	 mov	 rdi, rax
  00724	48 8b f1	 mov	 rsi, rcx
  00727	b9 0c 00 00 00	 mov	 ecx, 12
  0072c	f3 a4		 rep movsb
  0072e	8b 44 24 58	 mov	 eax, DWORD PTR i$5[rsp]
  00732	48 6b c0 10	 imul	 rax, rax, 16
  00736	48 8d 84 04 a0
	40 00 00	 lea	 rax, QWORD PTR models$[rsp+rax]
  0073e	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR $T42[rsp]
  00746	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0074b	4c 8d 8c 24 50
	02 00 00	 lea	 r9, QWORD PTR $T43[rsp]
  00753	4c 8d 84 24 60
	02 00 00	 lea	 r8, QWORD PTR $T44[rsp]
  0075b	48 8b d0	 mov	 rdx, rax
  0075e	48 8d 8c 24 f0
	03 00 00	 lea	 rcx, QWORD PTR gl$[rsp]
  00766	e8 00 00 00 00	 call	 ?add_entity@@YAIPEAUgl_renderer@@PEAUmodel_info_t@@THMM_Vec3@@22@Z ; add_entity

; 222  :                    HMM_V3(0.0f, 0.0f, 0.0f),  HMM_V3(1.0f, 1.0f, 1.0f));
; 223  :     }

  0076b	e9 7a fe ff ff	 jmp	 $LN2@main
$LN3@main:

; 224  :     
; 225  :     shader_combo_item_t shader_combo_items[] = {
; 226  :         SHADER_COMBO("None", no_shade_id),

  00770	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG84849
  00777	48 89 84 24 18
	02 00 00	 mov	 QWORD PTR $T40[rsp], rax
  0077f	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR no_shade_id$[rsp]
  00786	89 84 24 20 02
	00 00		 mov	 DWORD PTR $T40[rsp+8], eax
  0078d	48 8d 84 24 40
	40 00 00	 lea	 rax, QWORD PTR shader_combo_items$[rsp]
  00795	48 8d 8c 24 18
	02 00 00	 lea	 rcx, QWORD PTR $T40[rsp]
  0079d	48 8b f8	 mov	 rdi, rax
  007a0	48 8b f1	 mov	 rsi, rcx
  007a3	b9 10 00 00 00	 mov	 ecx, 16
  007a8	f3 a4		 rep movsb

; 227  :         SHADER_COMBO("Gouraud", gouraud_id),

  007aa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG84850
  007b1	48 89 84 24 e8
	01 00 00	 mov	 QWORD PTR $T38[rsp], rax
  007b9	8b 84 24 24 01
	00 00		 mov	 eax, DWORD PTR gouraud_id$[rsp]
  007c0	89 84 24 f0 01
	00 00		 mov	 DWORD PTR $T38[rsp+8], eax
  007c7	48 8d 84 24 50
	40 00 00	 lea	 rax, QWORD PTR shader_combo_items$[rsp+16]
  007cf	48 8d 8c 24 e8
	01 00 00	 lea	 rcx, QWORD PTR $T38[rsp]
  007d7	48 8b f8	 mov	 rdi, rax
  007da	48 8b f1	 mov	 rsi, rcx
  007dd	b9 10 00 00 00	 mov	 ecx, 16
  007e2	f3 a4		 rep movsb

; 228  :         SHADER_COMBO("Phong", phong_id),

  007e4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG84851
  007eb	48 89 84 24 d8
	01 00 00	 mov	 QWORD PTR $T37[rsp], rax
  007f3	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR phong_id$[rsp]
  007fa	89 84 24 e0 01
	00 00		 mov	 DWORD PTR $T37[rsp+8], eax
  00801	48 8d 84 24 60
	40 00 00	 lea	 rax, QWORD PTR shader_combo_items$[rsp+32]
  00809	48 8d 8c 24 d8
	01 00 00	 lea	 rcx, QWORD PTR $T37[rsp]
  00811	48 8b f8	 mov	 rdi, rax
  00814	48 8b f1	 mov	 rsi, rcx
  00817	b9 10 00 00 00	 mov	 ecx, 16
  0081c	f3 a4		 rep movsb

; 229  :         SHADER_COMBO("Flat", flat_id),

  0081e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG84852
  00825	48 89 84 24 c8
	01 00 00	 mov	 QWORD PTR $T36[rsp], rax
  0082d	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR flat_id$[rsp]
  00834	89 84 24 d0 01
	00 00		 mov	 DWORD PTR $T36[rsp+8], eax
  0083b	48 8d 84 24 70
	40 00 00	 lea	 rax, QWORD PTR shader_combo_items$[rsp+48]
  00843	48 8d 8c 24 c8
	01 00 00	 lea	 rcx, QWORD PTR $T36[rsp]
  0084b	48 8b f8	 mov	 rdi, rax
  0084e	48 8b f1	 mov	 rsi, rcx
  00851	b9 10 00 00 00	 mov	 ecx, 16
  00856	f3 a4		 rep movsb

; 230  :         SHADER_COMBO("Z Buffer", z_id),

  00858	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG84853
  0085f	48 89 84 24 b8
	01 00 00	 mov	 QWORD PTR $T35[rsp], rax
  00867	8b 84 24 34 01
	00 00		 mov	 eax, DWORD PTR z_id$[rsp]
  0086e	89 84 24 c0 01
	00 00		 mov	 DWORD PTR $T35[rsp+8], eax
  00875	48 8d 84 24 80
	40 00 00	 lea	 rax, QWORD PTR shader_combo_items$[rsp+64]
  0087d	48 8d 8c 24 b8
	01 00 00	 lea	 rcx, QWORD PTR $T35[rsp]
  00885	48 8b f8	 mov	 rdi, rax
  00888	48 8b f1	 mov	 rsi, rcx
  0088b	b9 10 00 00 00	 mov	 ecx, 16
  00890	f3 a4		 rep movsb

; 231  :         SHADER_COMBO("Z' Buffer", z_prime_id),

  00892	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG84854
  00899	48 89 84 24 f8
	01 00 00	 mov	 QWORD PTR $T39[rsp], rax
  008a1	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR z_prime_id$[rsp]
  008a8	89 84 24 00 02
	00 00		 mov	 DWORD PTR $T39[rsp+8], eax
  008af	48 8d 84 24 90
	40 00 00	 lea	 rax, QWORD PTR shader_combo_items$[rsp+80]
  008b7	48 8d 8c 24 f8
	01 00 00	 lea	 rcx, QWORD PTR $T39[rsp]
  008bf	48 8b f8	 mov	 rdi, rax
  008c2	48 8b f1	 mov	 rsi, rcx
  008c5	b9 10 00 00 00	 mov	 ecx, 16
  008ca	f3 a4		 rep movsb

; 232  :     };
; 233  :     
; 234  :     u32 shader_combo_idx = 0, model_combo_idx = 0;

  008cc	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR shader_combo_idx$[rsp], 0
  008d7	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR model_combo_idx$[rsp], 0

; 235  :     
; 236  :     v4 color[ARRAY_COUNT(combo_models)];
; 237  :     for (u32 i = 0; i < ARRAY_COUNT(combo_models); i++) {

  008df	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR i$4[rsp], 0
  008e7	eb 0a		 jmp	 SHORT $LN7@main
$LN5@main:
  008e9	8b 44 24 48	 mov	 eax, DWORD PTR i$4[rsp]
  008ed	ff c0		 inc	 eax
  008ef	89 44 24 48	 mov	 DWORD PTR i$4[rsp], eax
$LN7@main:
  008f3	8b 44 24 48	 mov	 eax, DWORD PTR i$4[rsp]
  008f7	48 83 f8 04	 cmp	 rax, 4
  008fb	0f 83 a9 00 00
	00		 jae	 $LN6@main

; 238  :         color[i].X = colors[i].r/255;

  00901	8b 44 24 48	 mov	 eax, DWORD PTR i$4[rsp]
  00905	0f b6 84 84 90
	3f 00 00	 movzx	 eax, BYTE PTR colors$[rsp+rax*4]
  0090d	99		 cdq
  0090e	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00913	f7 f9		 idiv	 ecx
  00915	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00919	8b 44 24 48	 mov	 eax, DWORD PTR i$4[rsp]
  0091d	48 6b c0 10	 imul	 rax, rax, 16
  00921	f3 0f 11 84 04
	00 40 00 00	 movss	 DWORD PTR color$[rsp+rax], xmm0

; 239  :         color[i].Y = colors[i].g/255;

  0092a	8b 44 24 48	 mov	 eax, DWORD PTR i$4[rsp]
  0092e	0f b6 84 84 91
	3f 00 00	 movzx	 eax, BYTE PTR colors$[rsp+rax*4+1]
  00936	99		 cdq
  00937	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  0093c	f7 f9		 idiv	 ecx
  0093e	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00942	8b 44 24 48	 mov	 eax, DWORD PTR i$4[rsp]
  00946	48 6b c0 10	 imul	 rax, rax, 16
  0094a	f3 0f 11 84 04
	04 40 00 00	 movss	 DWORD PTR color$[rsp+rax+4], xmm0

; 240  :         color[i].Z = colors[i].b/255;

  00953	8b 44 24 48	 mov	 eax, DWORD PTR i$4[rsp]
  00957	0f b6 84 84 92
	3f 00 00	 movzx	 eax, BYTE PTR colors$[rsp+rax*4+2]
  0095f	99		 cdq
  00960	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00965	f7 f9		 idiv	 ecx
  00967	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0096b	8b 44 24 48	 mov	 eax, DWORD PTR i$4[rsp]
  0096f	48 6b c0 10	 imul	 rax, rax, 16
  00973	f3 0f 11 84 04
	08 40 00 00	 movss	 DWORD PTR color$[rsp+rax+8], xmm0

; 241  :         color[i].W = colors[i].a/255;

  0097c	8b 44 24 48	 mov	 eax, DWORD PTR i$4[rsp]
  00980	0f b6 84 84 93
	3f 00 00	 movzx	 eax, BYTE PTR colors$[rsp+rax*4+3]
  00988	99		 cdq
  00989	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  0098e	f7 f9		 idiv	 ecx
  00990	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00994	8b 44 24 48	 mov	 eax, DWORD PTR i$4[rsp]
  00998	48 6b c0 10	 imul	 rax, rax, 16
  0099c	f3 0f 11 84 04
	0c 40 00 00	 movss	 DWORD PTR color$[rsp+rax+12], xmm0

; 242  :     }

  009a5	e9 3f ff ff ff	 jmp	 $LN5@main
$LN6@main:

; 243  :     
; 244  :     f64 last_time = glfwGetTime();

  009aa	e8 00 00 00 00	 call	 glfwGetTime
  009af	f2 0f 11 84 24
	58 01 00 00	 movsd	 QWORD PTR last_time$[rsp], xmm0

; 245  :     u32 frame_count = 0;

  009b8	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR frame_count$[rsp], 0

; 246  :     
; 247  :     v3 *p = NULL;

  009c3	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR p$[rsp], 0

; 248  :     p = (v3 *)stack_push_array(&p, 4);

  009cc	41 b8 0c 00 00
	00		 mov	 r8d, 12
  009d2	ba 04 00 00 00	 mov	 edx, 4
  009d7	48 8d 4c 24 50	 lea	 rcx, QWORD PTR p$[rsp]
  009dc	e8 00 00 00 00	 call	 ?_stack_push@@YAPEAXPEAPEAXII@Z ; _stack_push
  009e1	48 89 44 24 50	 mov	 QWORD PTR p$[rsp], rax

; 249  :     p[0] = HMM_V3(0.0f, 0.0f, 0.0f);

  009e6	0f 57 db	 xorps	 xmm3, xmm3
  009e9	0f 57 d2	 xorps	 xmm2, xmm2
  009ec	0f 57 c9	 xorps	 xmm1, xmm1
  009ef	48 8d 8c 24 48
	03 00 00	 lea	 rcx, QWORD PTR $T63[rsp]
  009f7	e8 00 00 00 00	 call	 HMM_V3
  009fc	48 8d 8c 24 80
	05 00 00	 lea	 rcx, QWORD PTR $T80[rsp]
  00a04	48 8b f9	 mov	 rdi, rcx
  00a07	48 8b f0	 mov	 rsi, rax
  00a0a	b9 0c 00 00 00	 mov	 ecx, 12
  00a0f	f3 a4		 rep movsb
  00a11	b8 0c 00 00 00	 mov	 eax, 12
  00a16	48 6b c0 00	 imul	 rax, rax, 0
  00a1a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$[rsp]
  00a1f	48 8d 94 24 80
	05 00 00	 lea	 rdx, QWORD PTR $T80[rsp]
  00a27	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]
  00a2b	48 8b f2	 mov	 rsi, rdx
  00a2e	b9 0c 00 00 00	 mov	 ecx, 12
  00a33	f3 a4		 rep movsb

; 250  :     p[1] = HMM_V3(0.0f, 5.0f, 0.0f);

  00a35	0f 57 db	 xorps	 xmm3, xmm3
  00a38	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@40a00000
  00a40	0f 57 c9	 xorps	 xmm1, xmm1
  00a43	48 8d 8c 24 58
	03 00 00	 lea	 rcx, QWORD PTR $T64[rsp]
  00a4b	e8 00 00 00 00	 call	 HMM_V3
  00a50	48 8d 8c 24 90
	05 00 00	 lea	 rcx, QWORD PTR $T81[rsp]
  00a58	48 8b f9	 mov	 rdi, rcx
  00a5b	48 8b f0	 mov	 rsi, rax
  00a5e	b9 0c 00 00 00	 mov	 ecx, 12
  00a63	f3 a4		 rep movsb
  00a65	b8 0c 00 00 00	 mov	 eax, 12
  00a6a	48 6b c0 01	 imul	 rax, rax, 1
  00a6e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$[rsp]
  00a73	48 8d 94 24 90
	05 00 00	 lea	 rdx, QWORD PTR $T81[rsp]
  00a7b	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]
  00a7f	48 8b f2	 mov	 rsi, rdx
  00a82	b9 0c 00 00 00	 mov	 ecx, 12
  00a87	f3 a4		 rep movsb

; 251  :     p[2] = HMM_V3(5.0f, 5.0f, 0.0f);

  00a89	0f 57 db	 xorps	 xmm3, xmm3
  00a8c	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@40a00000
  00a94	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40a00000
  00a9c	48 8d 8c 24 68
	03 00 00	 lea	 rcx, QWORD PTR $T65[rsp]
  00aa4	e8 00 00 00 00	 call	 HMM_V3
  00aa9	48 8d 8c 24 a0
	05 00 00	 lea	 rcx, QWORD PTR $T82[rsp]
  00ab1	48 8b f9	 mov	 rdi, rcx
  00ab4	48 8b f0	 mov	 rsi, rax
  00ab7	b9 0c 00 00 00	 mov	 ecx, 12
  00abc	f3 a4		 rep movsb
  00abe	b8 0c 00 00 00	 mov	 eax, 12
  00ac3	48 6b c0 02	 imul	 rax, rax, 2
  00ac7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$[rsp]
  00acc	48 8d 94 24 a0
	05 00 00	 lea	 rdx, QWORD PTR $T82[rsp]
  00ad4	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]
  00ad8	48 8b f2	 mov	 rsi, rdx
  00adb	b9 0c 00 00 00	 mov	 ecx, 12
  00ae0	f3 a4		 rep movsb

; 252  :     p[3] = HMM_V3(7.0f, 2.5f, 0.0f);

  00ae2	0f 57 db	 xorps	 xmm3, xmm3
  00ae5	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@40200000
  00aed	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@40e00000
  00af5	48 8d 8c 24 78
	03 00 00	 lea	 rcx, QWORD PTR $T66[rsp]
  00afd	e8 00 00 00 00	 call	 HMM_V3
  00b02	48 8d 8c 24 c0
	05 00 00	 lea	 rcx, QWORD PTR $T84[rsp]
  00b0a	48 8b f9	 mov	 rdi, rcx
  00b0d	48 8b f0	 mov	 rsi, rax
  00b10	b9 0c 00 00 00	 mov	 ecx, 12
  00b15	f3 a4		 rep movsb
  00b17	b8 0c 00 00 00	 mov	 eax, 12
  00b1c	48 6b c0 03	 imul	 rax, rax, 3
  00b20	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$[rsp]
  00b25	48 8d 94 24 c0
	05 00 00	 lea	 rdx, QWORD PTR $T84[rsp]
  00b2d	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]
  00b31	48 8b f2	 mov	 rsi, rdx
  00b34	b9 0c 00 00 00	 mov	 ecx, 12
  00b39	f3 a4		 rep movsb

; 253  :     
; 254  :     char *c_type[] = { "None", "C1", "G1" };

  00b3b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG84855
  00b42	48 89 84 24 c0
	3f 00 00	 mov	 QWORD PTR c_type$[rsp], rax
  00b4a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG84856
  00b51	48 89 84 24 c8
	3f 00 00	 mov	 QWORD PTR c_type$[rsp+8], rax
  00b59	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG84857
  00b60	48 89 84 24 d0
	3f 00 00	 mov	 QWORD PTR c_type$[rsp+16], rax

; 255  :     u32 c_selected = 0;

  00b68	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR c_selected$[rsp], 0

; 256  :     char *a_type[] = { "De Castelgau", "Matrix Form" };

  00b73	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG84858
  00b7a	48 89 84 24 08
	02 00 00	 mov	 QWORD PTR a_type$[rsp], rax
  00b82	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG84859
  00b89	48 89 84 24 10
	02 00 00	 mov	 QWORD PTR a_type$[rsp+8], rax

; 257  :     u32 a_selected = 0;

  00b91	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR a_selected$[rsp], 0

; 258  :     f32 t = 0.05f;

  00b9c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3d4ccccd
  00ba4	f3 0f 11 84 24
	f4 00 00 00	 movss	 DWORD PTR t$[rsp], xmm0

; 259  :     f32 debug_t = 0.5f;

  00bad	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00bb5	f3 0f 11 84 24
	fc 00 00 00	 movss	 DWORD PTR debug_t$[rsp], xmm0

; 260  :     u32 debug = 0;

  00bbe	c7 84 24 f8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR debug$[rsp], 0

; 261  :     
; 262  :     glLineWidth(3.0f);

  00bc9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40400000
  00bd1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glLineWidth
$LN8@main:

; 263  :     
; 264  :     while(!glfwWindowShouldClose(window)) {

  00bd7	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR window$[rsp]
  00bdf	e8 00 00 00 00	 call	 glfwWindowShouldClose
  00be4	85 c0		 test	 eax, eax
  00be6	0f 85 d6 0f 00
	00		 jne	 $LN9@main

; 265  :         
; 266  :         process_input(window, &gl, model_combo_idx);

  00bec	44 8b 44 24 4c	 mov	 r8d, DWORD PTR model_combo_idx$[rsp]
  00bf1	48 8d 94 24 f0
	03 00 00	 lea	 rdx, QWORD PTR gl$[rsp]
  00bf9	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR window$[rsp]
  00c01	e8 00 00 00 00	 call	 ?process_input@@YAXPEAUGLFWwindow@@PEAUgl_renderer@@I@Z ; process_input

; 267  :         
; 268  :         ImGui_ImplOpenGL3_NewFrame();

  00c06	e8 00 00 00 00	 call	 ?ImGui_ImplOpenGL3_NewFrame@@YAXXZ ; ImGui_ImplOpenGL3_NewFrame

; 269  :         ImGui_ImplGlfw_NewFrame();

  00c0b	e8 00 00 00 00	 call	 ?ImGui_ImplGlfw_NewFrame@@YAXXZ ; ImGui_ImplGlfw_NewFrame

; 270  :         ImGui::NewFrame();

  00c10	e8 00 00 00 00	 call	 ?NewFrame@ImGui@@YAXXZ	; ImGui::NewFrame

; 271  :         
; 272  :         ImGuiWindowFlags window_flags = ImGuiWindowFlags_NoDocking | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoBackground;

  00c15	c7 84 24 e4 00
	00 00 a7 00 08
	00		 mov	 DWORD PTR window_flags$21[rsp], 524455 ; 000800a7H

; 273  :         
; 274  :         ImGuiViewport *viewport = ImGui::GetMainViewport();

  00c20	e8 00 00 00 00	 call	 ?GetMainViewport@ImGui@@YAPEAUImGuiViewport@@XZ ; ImGui::GetMainViewport
  00c25	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR viewport$27[rsp], rax

; 275  :         ImGui::SetNextWindowPos(viewport->Pos);

  00c2d	0f 57 d2	 xorps	 xmm2, xmm2
  00c30	0f 57 c9	 xorps	 xmm1, xmm1
  00c33	48 8d 8c 24 c0
	02 00 00	 lea	 rcx, QWORD PTR $T50[rsp]
  00c3b	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  00c40	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR viewport$27[rsp]
  00c48	48 83 c1 08	 add	 rcx, 8
  00c4c	4c 8b c0	 mov	 r8, rax
  00c4f	33 d2		 xor	 edx, edx
  00c51	e8 00 00 00 00	 call	 ?SetNextWindowPos@ImGui@@YAXAEBUImVec2@@H0@Z ; ImGui::SetNextWindowPos

; 276  :         ImGui::SetNextWindowSize(viewport->Size);

  00c56	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR viewport$27[rsp]
  00c5e	48 83 c0 10	 add	 rax, 16
  00c62	33 d2		 xor	 edx, edx
  00c64	48 8b c8	 mov	 rcx, rax
  00c67	e8 00 00 00 00	 call	 ?SetNextWindowSize@ImGui@@YAXAEBUImVec2@@H@Z ; ImGui::SetNextWindowSize

; 277  :         ImGui::SetNextWindowViewport(viewport->ID);

  00c6c	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR viewport$27[rsp]
  00c74	8b 08		 mov	 ecx, DWORD PTR [rax]
  00c76	e8 00 00 00 00	 call	 ?SetNextWindowViewport@ImGui@@YAXI@Z ; ImGui::SetNextWindowViewport

; 278  :         
; 279  :         ImGui::PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);

  00c7b	0f 57 c9	 xorps	 xmm1, xmm1
  00c7e	b9 03 00 00 00	 mov	 ecx, 3
  00c83	e8 00 00 00 00	 call	 ?PushStyleVar@ImGui@@YAXHM@Z ; ImGui::PushStyleVar

; 280  :         ImGui::PushStyleVar(ImGuiStyleVar_WindowBorderSize, 0.0f);

  00c88	0f 57 c9	 xorps	 xmm1, xmm1
  00c8b	b9 04 00 00 00	 mov	 ecx, 4
  00c90	e8 00 00 00 00	 call	 ?PushStyleVar@ImGui@@YAXHM@Z ; ImGui::PushStyleVar

; 281  :         ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0.0f, 0.0f));

  00c95	0f 57 d2	 xorps	 xmm2, xmm2
  00c98	0f 57 c9	 xorps	 xmm1, xmm1
  00c9b	48 8d 8c 24 c8
	02 00 00	 lea	 rcx, QWORD PTR $T51[rsp]
  00ca3	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  00ca8	48 8b d0	 mov	 rdx, rax
  00cab	b9 02 00 00 00	 mov	 ecx, 2
  00cb0	e8 00 00 00 00	 call	 ?PushStyleVar@ImGui@@YAXHAEBUImVec2@@@Z ; ImGui::PushStyleVar

; 282  :         ImGui::Begin("InvisibleWindow", nullptr, window_flags);

  00cb5	44 8b 84 24 e4
	00 00 00	 mov	 r8d, DWORD PTR window_flags$21[rsp]
  00cbd	33 d2		 xor	 edx, edx
  00cbf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG84860
  00cc6	e8 00 00 00 00	 call	 ?Begin@ImGui@@YA_NPEBDPEA_NH@Z ; ImGui::Begin

; 283  :         ImGui::PopStyleVar(3);

  00ccb	b9 03 00 00 00	 mov	 ecx, 3
  00cd0	e8 00 00 00 00	 call	 ?PopStyleVar@ImGui@@YAXH@Z ; ImGui::PopStyleVar

; 284  :         ImGuiID dock_space_id = ImGui::GetID("InvisibleWindowSockSpace");

  00cd5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG84861
  00cdc	e8 00 00 00 00	 call	 ?GetID@ImGui@@YAIPEBD@Z	; ImGui::GetID
  00ce1	89 84 24 e8 00
	00 00		 mov	 DWORD PTR dock_space_id$22[rsp], eax

; 285  :         ImGui::DockSpace(dock_space_id, ImVec2(0.0f, 0.0f), ImGuiDockNodeFlags_PassthruCentralNode);

  00ce8	0f 57 d2	 xorps	 xmm2, xmm2
  00ceb	0f 57 c9	 xorps	 xmm1, xmm1
  00cee	48 8d 8c 24 d0
	02 00 00	 lea	 rcx, QWORD PTR $T52[rsp]
  00cf6	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  00cfb	45 33 c9	 xor	 r9d, r9d
  00cfe	41 b8 08 00 00
	00		 mov	 r8d, 8
  00d04	48 8b d0	 mov	 rdx, rax
  00d07	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR dock_space_id$22[rsp]
  00d0e	e8 00 00 00 00	 call	 ?DockSpace@ImGui@@YAIIAEBUImVec2@@HPEBUImGuiWindowClass@@@Z ; ImGui::DockSpace

; 286  :         ImGui::End();

  00d13	e8 00 00 00 00	 call	 ?End@ImGui@@YAXXZ	; ImGui::End

; 287  :         
; 288  :         
; 289  :         push_mesh(&gl, &assets, models+model_combo_idx, colors[model_combo_idx]);

  00d18	8b 44 24 4c	 mov	 eax, DWORD PTR model_combo_idx$[rsp]
  00d1c	8b 4c 24 4c	 mov	 ecx, DWORD PTR model_combo_idx$[rsp]
  00d20	48 6b c9 10	 imul	 rcx, rcx, 16
  00d24	48 8d 8c 0c a0
	40 00 00	 lea	 rcx, QWORD PTR models$[rsp+rcx]
  00d2c	44 8b 8c 84 90
	3f 00 00	 mov	 r9d, DWORD PTR colors$[rsp+rax*4]
  00d34	4c 8b c1	 mov	 r8, rcx
  00d37	48 8d 94 24 a0
	01 00 00	 lea	 rdx, QWORD PTR assets$[rsp]
  00d3f	48 8d 8c 24 f0
	03 00 00	 lea	 rcx, QWORD PTR gl$[rsp]
  00d47	e8 00 00 00 00	 call	 ?push_mesh@@YAXPEAUgl_renderer@@PEAUasset_manager_t@@PEAUmodel_info_t@@Ucolor_t@@@Z ; push_mesh

; 290  :         
; 291  :         render_mesh(&gl, gl.entities[model_combo_idx].m_info);

  00d4c	8b 44 24 4c	 mov	 eax, DWORD PTR model_combo_idx$[rsp]
  00d50	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  00d54	48 8d 8c 24 10
	03 00 00	 lea	 rcx, QWORD PTR $T59[rsp]
  00d5c	48 8b 94 24 28
	04 00 00	 mov	 rdx, QWORD PTR gl$[rsp+56]
  00d64	48 8b f9	 mov	 rdi, rcx
  00d67	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  00d6b	b9 10 00 00 00	 mov	 ecx, 16
  00d70	f3 a4		 rep movsb
  00d72	48 8d 94 24 10
	03 00 00	 lea	 rdx, QWORD PTR $T59[rsp]
  00d7a	48 8d 8c 24 f0
	03 00 00	 lea	 rcx, QWORD PTR gl$[rsp]
  00d82	e8 00 00 00 00	 call	 ?render_mesh@@YAXPEAUgl_renderer@@Umodel_info_t@@@Z ; render_mesh

; 292  :         
; 293  :         v3 *rp = NULL;

  00d87	48 c7 84 24 40
	01 00 00 00 00
	00 00		 mov	 QWORD PTR rp$28[rsp], 0

; 294  :         
; 295  :         /*if (a_selected == 0) {
; 296  :             u32 p_count = get_stack_count(p);
; 297  :             u32 cp_count;
; 298  :             for (u32 i = 0; i < p_count-1; i += 3) {
; 299  :                 cp_count = MIN(p_count-i, 4);
; 300  :                 de_castelgau(p+i, cp_count, t, &rp, 0, 0, NULL);
; 301  :                 
; 302  :                 push_curve(&gl, rp, get_stack_count(rp), color_t{255, 255, 255, 255});
; 303  :                 stack_clear(rp);
; 304  :                 
; 305  :                 de_castelgau(p+i, cp_count, t, &rp, debug, debug_t, &gl);
; 306  :             }
; 307  :         }
; 308  :         else {
; 309  :             u32 p_count = get_stack_count(p);
; 310  :             for (u32 i = 4; i <= p_count; i += 3) {
; 311  :                 matrix_bezier_cubic(p+i-4, t, &rp);
; 312  :                 
; 313  :                 push_curve(&gl, rp, get_stack_count(rp), color_t{255, 255, 255, 255});
; 314  :                 if (debug)
; 315  :                     push_curve(&gl, p, 4, color_t{125, 0, 0, 255});
; 316  :             }
; 317  :         }*/
; 318  :         
; 319  :         stack_clear(rp);

  00d93	48 83 bc 24 40
	01 00 00 00	 cmp	 QWORD PTR rp$28[rsp], 0
  00d9c	74 1c		 je	 SHORT $LN55@main
  00d9e	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR rp$28[rsp]
  00da6	c7 40 fc 00 00
	00 00		 mov	 DWORD PTR [rax-4], 0
  00dad	c7 84 24 ec 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv575[rsp], 0
  00db8	eb 0b		 jmp	 SHORT $LN56@main
$LN55@main:
  00dba	c7 84 24 ec 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv575[rsp], 0
$LN56@main:

; 320  :         
; 321  :         render(&gl, &assets, shader_combo_items[shader_combo_idx].shader);

  00dc5	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR shader_combo_idx$[rsp]
  00dcc	48 6b c0 10	 imul	 rax, rax, 16
  00dd0	44 8b 84 04 48
	40 00 00	 mov	 r8d, DWORD PTR shader_combo_items$[rsp+rax+8]
  00dd8	48 8d 94 24 a0
	01 00 00	 lea	 rdx, QWORD PTR assets$[rsp]
  00de0	48 8d 8c 24 f0
	03 00 00	 lea	 rcx, QWORD PTR gl$[rsp]
  00de8	e8 00 00 00 00	 call	 ?render@@YAXPEAUgl_renderer@@PEAUasset_manager_t@@I@Z ; render

; 322  :         
; 323  :         glBindFramebuffer(GL_FRAMEBUFFER, 0);

  00ded	33 d2		 xor	 edx, edx
  00def	b9 40 8d 00 00	 mov	 ecx, 36160		; 00008d40H
  00df4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewBindFramebuffer
  00dfb	ff 10		 call	 QWORD PTR [rax]

; 324  :         
; 325  :         ImGui::Begin("Scene");

  00dfd	45 33 c0	 xor	 r8d, r8d
  00e00	33 d2		 xor	 edx, edx
  00e02	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG84862
  00e09	e8 00 00 00 00	 call	 ?Begin@ImGui@@YA_NPEBDPEA_NH@Z ; ImGui::Begin

; 326  :         ImVec2 size = ImGui::GetContentRegionAvail();

  00e0e	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR size$20[rsp]
  00e16	e8 00 00 00 00	 call	 ?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionAvail

; 327  :         
; 328  :         camera.aspect_ratio = size.x/size.y;

  00e1b	f3 0f 10 84 24
	d8 00 00 00	 movss	 xmm0, DWORD PTR size$20[rsp]
  00e24	f3 0f 5e 84 24
	dc 00 00 00	 divss	 xmm0, DWORD PTR size$20[rsp+4]
  00e2d	f3 0f 11 84 24
	24 06 00 00	 movss	 DWORD PTR camera$[rsp+84], xmm0

; 329  :         
; 330  :         ImGui::Image((ImTextureID)gl.fb.tex, ImVec2(size.x, size.y), 

  00e36	0f 57 c0	 xorps	 xmm0, xmm0
  00e39	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00e3f	0f 57 db	 xorps	 xmm3, xmm3
  00e42	0f 57 d2	 xorps	 xmm2, xmm2
  00e45	0f 57 c9	 xorps	 xmm1, xmm1
  00e48	48 8d 8c 24 c8
	03 00 00	 lea	 rcx, QWORD PTR $T71[rsp]
  00e50	e8 00 00 00 00	 call	 ??0ImVec4@@QEAA@MMMM@Z	; ImVec4::ImVec4
  00e55	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR tv623[rsp], rax
  00e5d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00e65	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00e6b	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f800000
  00e73	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f800000
  00e7b	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00e83	48 8d 8c 24 d8
	03 00 00	 lea	 rcx, QWORD PTR $T72[rsp]
  00e8b	e8 00 00 00 00	 call	 ??0ImVec4@@QEAA@MMMM@Z	; ImVec4::ImVec4
  00e90	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR tv630[rsp], rax
  00e98	0f 57 d2	 xorps	 xmm2, xmm2
  00e9b	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00ea3	48 8d 8c 24 d8
	02 00 00	 lea	 rcx, QWORD PTR $T53[rsp]
  00eab	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  00eb0	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR tv637[rsp], rax
  00eb8	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f800000
  00ec0	0f 57 c9	 xorps	 xmm1, xmm1
  00ec3	48 8d 8c 24 e0
	02 00 00	 lea	 rcx, QWORD PTR $T54[rsp]
  00ecb	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  00ed0	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR tv642[rsp], rax
  00ed8	f3 0f 10 94 24
	dc 00 00 00	 movss	 xmm2, DWORD PTR size$20[rsp+4]
  00ee1	f3 0f 10 8c 24
	d8 00 00 00	 movss	 xmm1, DWORD PTR size$20[rsp]
  00eea	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR $T58[rsp]
  00ef2	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  00ef7	8b 8c 24 ec 04
	00 00		 mov	 ecx, DWORD PTR gl$[rsp+252]
  00efe	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR tv623[rsp]
  00f06	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  00f0b	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR tv630[rsp]
  00f13	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00f18	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR tv637[rsp]
  00f20	4c 8b ca	 mov	 r9, rdx
  00f23	48 8b 94 24 78
	01 00 00	 mov	 rdx, QWORD PTR tv642[rsp]
  00f2b	4c 8b c2	 mov	 r8, rdx
  00f2e	48 8b d0	 mov	 rdx, rax
  00f31	e8 00 00 00 00	 call	 ?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z ; ImGui::Image

; 331  :                      ImVec2(0, 1), ImVec2(1, 0));
; 332  :         
; 333  :         ImGui::End();

  00f36	e8 00 00 00 00	 call	 ?End@ImGui@@YAXXZ	; ImGui::End

; 334  :         
; 335  :         ImGui::Begin("Properties");

  00f3b	45 33 c0	 xor	 r8d, r8d
  00f3e	33 d2		 xor	 edx, edx
  00f40	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG84863
  00f47	e8 00 00 00 00	 call	 ?Begin@ImGui@@YA_NPEBDPEA_NH@Z ; ImGui::Begin

; 336  :         
; 337  :         if (ImGui::CollapsingHeader("Perspective"))

  00f4c	33 d2		 xor	 edx, edx
  00f4e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG84865
  00f55	e8 00 00 00 00	 call	 ?CollapsingHeader@ImGui@@YA_NPEBDH@Z ; ImGui::CollapsingHeader
  00f5a	0f b6 c0	 movzx	 eax, al
  00f5d	85 c0		 test	 eax, eax
  00f5f	0f 84 bf 00 00
	00		 je	 $LN32@main

; 338  :         {
; 339  :             ImGui::SliderFloat("FOV", &camera.fov, 0.0f, 90.0f);

  00f65	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00f6d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG84866
  00f74	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00f79	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@42b40000
  00f81	0f 57 d2	 xorps	 xmm2, xmm2
  00f84	48 8d 94 24 20
	06 00 00	 lea	 rdx, QWORD PTR camera$[rsp+80]
  00f8c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG84867
  00f93	e8 00 00 00 00	 call	 ?SliderFloat@ImGui@@YA_NPEBDPEAMMM0H@Z ; ImGui::SliderFloat

; 340  :             ImGui::DragFloat("Near Plane", &camera.near, 0.1f, 0.1f, 100.0f);

  00f98	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00fa0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG84868
  00fa7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00fac	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42c80000
  00fb4	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00fba	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3dcccccd
  00fc2	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3dcccccd
  00fca	48 8d 94 24 28
	06 00 00	 lea	 rdx, QWORD PTR camera$[rsp+88]
  00fd2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG84869
  00fd9	e8 00 00 00 00	 call	 ?DragFloat@ImGui@@YA_NPEBDPEAMMMM0H@Z ; ImGui::DragFloat

; 341  :             ImGui::DragFloat("Far Plane", &camera.far, 0.1f, 0.1f, 100.0f);

  00fde	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00fe6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG84870
  00fed	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00ff2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42c80000
  00ffa	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  01000	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3dcccccd
  01008	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3dcccccd
  01010	48 8d 94 24 2c
	06 00 00	 lea	 rdx, QWORD PTR camera$[rsp+92]
  01018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG84871
  0101f	e8 00 00 00 00	 call	 ?DragFloat@ImGui@@YA_NPEBDPEAMMMM0H@Z ; ImGui::DragFloat
$LN32@main:

; 342  :         }
; 343  :         
; 344  :         if (ImGui::CollapsingHeader("Shader")) {

  01024	33 d2		 xor	 edx, edx
  01026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG84873
  0102d	e8 00 00 00 00	 call	 ?CollapsingHeader@ImGui@@YA_NPEBDH@Z ; ImGui::CollapsingHeader
  01032	0f b6 c0	 movzx	 eax, al
  01035	85 c0		 test	 eax, eax
  01037	0f 84 f9 01 00
	00		 je	 $LN33@main

; 345  :             if (ImGui::Button("Add Light")) {

  0103d	0f 57 d2	 xorps	 xmm2, xmm2
  01040	0f 57 c9	 xorps	 xmm1, xmm1
  01043	48 8d 8c 24 e8
	02 00 00	 lea	 rcx, QWORD PTR $T55[rsp]
  0104b	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  01050	48 8b d0	 mov	 rdx, rax
  01053	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG84875
  0105a	e8 00 00 00 00	 call	 ?Button@ImGui@@YA_NPEBDAEBUImVec2@@@Z ; ImGui::Button
  0105f	0f b6 c0	 movzx	 eax, al
  01062	85 c0		 test	 eax, eax
  01064	0f 84 85 00 00
	00		 je	 $LN34@main

; 346  :                 if (gl.light_count < 6)

  0106a	83 bc 24 e0 04
	00 00 06	 cmp	 DWORD PTR gl$[rsp+240], 6
  01072	73 7b		 jae	 SHORT $LN34@main

; 347  :                     add_light(&gl, HMM_V3(0.0f, 0.0f, 0.0f));

  01074	0f 57 db	 xorps	 xmm3, xmm3
  01077	0f 57 d2	 xorps	 xmm2, xmm2
  0107a	0f 57 c9	 xorps	 xmm1, xmm1
  0107d	48 8d 8c 24 88
	03 00 00	 lea	 rcx, QWORD PTR $T67[rsp]
  01085	e8 00 00 00 00	 call	 HMM_V3
  0108a	48 8d 8c 24 b0
	05 00 00	 lea	 rcx, QWORD PTR $T83[rsp]
  01092	48 8b f9	 mov	 rdi, rcx
  01095	48 8b f0	 mov	 rsi, rax
  01098	b9 0c 00 00 00	 mov	 ecx, 12
  0109d	f3 a4		 rep movsb
  0109f	48 8d 84 24 b0
	02 00 00	 lea	 rax, QWORD PTR $T49[rsp]
  010a7	48 8d 8c 24 b0
	05 00 00	 lea	 rcx, QWORD PTR $T83[rsp]
  010af	48 8b f8	 mov	 rdi, rax
  010b2	48 8b f1	 mov	 rsi, rcx
  010b5	b9 0c 00 00 00	 mov	 ecx, 12
  010ba	f3 a4		 rep movsb
  010bc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3d03126f
  010c4	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  010ca	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3db851ec
  010d2	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f800000
  010da	48 8d 94 24 b0
	02 00 00	 lea	 rdx, QWORD PTR $T49[rsp]
  010e2	48 8d 8c 24 f0
	03 00 00	 lea	 rcx, QWORD PTR gl$[rsp]
  010ea	e8 00 00 00 00	 call	 ?add_light@@YAXPEAUgl_renderer@@THMM_Vec3@@MMM@Z ; add_light
$LN34@main:

; 348  :             }
; 349  :             
; 350  :             u32 light_count = gl.light_count;

  010ef	8b 84 24 e0 04
	00 00		 mov	 eax, DWORD PTR gl$[rsp+240]
  010f6	89 84 24 f0 00
	00 00		 mov	 DWORD PTR light_count$23[rsp], eax

; 351  :             char buffer[32];
; 352  :             for (u32 i = 0; i < light_count; i++) {

  010fd	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR i$10[rsp], 0
  01105	eb 0a		 jmp	 SHORT $LN12@main
$LN10@main:
  01107	8b 44 24 6c	 mov	 eax, DWORD PTR i$10[rsp]
  0110b	ff c0		 inc	 eax
  0110d	89 44 24 6c	 mov	 DWORD PTR i$10[rsp], eax
$LN12@main:
  01111	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR light_count$23[rsp]
  01118	39 44 24 6c	 cmp	 DWORD PTR i$10[rsp], eax
  0111c	73 3b		 jae	 SHORT $LN11@main

; 353  :                 sprintf(buffer, "Light Pos %u", i);

  0111e	44 8b 44 24 6c	 mov	 r8d, DWORD PTR i$10[rsp]
  01123	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG84877
  0112a	48 8d 8c 24 e0
	40 00 00	 lea	 rcx, QWORD PTR buffer$86[rsp]
  01132	e8 00 00 00 00	 call	 sprintf

; 354  :                 draw_vec3_widget(buffer, &gl.lights[i].pos);

  01137	8b 44 24 6c	 mov	 eax, DWORD PTR i$10[rsp]
  0113b	48 6b c0 18	 imul	 rax, rax, 24
  0113f	48 8d 84 04 50
	04 00 00	 lea	 rax, QWORD PTR gl$[rsp+rax+96]
  01147	48 8b d0	 mov	 rdx, rax
  0114a	48 8d 8c 24 e0
	40 00 00	 lea	 rcx, QWORD PTR buffer$86[rsp]
  01152	e8 00 00 00 00	 call	 ?draw_vec3_widget@@YAXPEBDPEATHMM_Vec3@@@Z ; draw_vec3_widget

; 355  :             }

  01157	eb ae		 jmp	 SHORT $LN10@main
$LN11@main:

; 356  :             
; 357  :             if (ImGui::BeginCombo("Shaders", shader_combo_items[shader_combo_idx].name))

  01159	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR shader_combo_idx$[rsp]
  01160	48 6b c0 10	 imul	 rax, rax, 16
  01164	45 33 c0	 xor	 r8d, r8d
  01167	48 8b 94 04 40
	40 00 00	 mov	 rdx, QWORD PTR shader_combo_items$[rsp+rax]
  0116f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG84879
  01176	e8 00 00 00 00	 call	 ?BeginCombo@ImGui@@YA_NPEBD0H@Z ; ImGui::BeginCombo
  0117b	0f b6 c0	 movzx	 eax, al
  0117e	85 c0		 test	 eax, eax
  01180	0f 84 b0 00 00
	00		 je	 $LN33@main

; 358  :             {
; 359  :                 for(u32 n = 0; n < ARRAY_COUNT(shader_combo_items); n++)

  01186	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR n$6[rsp], 0
  0118e	eb 0a		 jmp	 SHORT $LN15@main
$LN13@main:
  01190	8b 44 24 5c	 mov	 eax, DWORD PTR n$6[rsp]
  01194	ff c0		 inc	 eax
  01196	89 44 24 5c	 mov	 DWORD PTR n$6[rsp], eax
$LN15@main:
  0119a	8b 44 24 5c	 mov	 eax, DWORD PTR n$6[rsp]
  0119e	48 83 f8 06	 cmp	 rax, 6
  011a2	0f 83 89 00 00
	00		 jae	 $LN14@main

; 360  :                 {
; 361  :                     bool is_selected = shader_combo_idx == n;

  011a8	8b 44 24 5c	 mov	 eax, DWORD PTR n$6[rsp]
  011ac	39 84 24 80 00
	00 00		 cmp	 DWORD PTR shader_combo_idx$[rsp], eax
  011b3	75 0d		 jne	 SHORT $LN57@main
  011b5	c7 84 24 bc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv732[rsp], 1
  011c0	eb 0b		 jmp	 SHORT $LN58@main
$LN57@main:
  011c2	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv732[rsp], 0
$LN58@main:
  011cd	0f b6 84 24 bc
	00 00 00	 movzx	 eax, BYTE PTR tv732[rsp]
  011d5	88 44 24 44	 mov	 BYTE PTR is_selected$2[rsp], al

; 362  :                     if (ImGui::Selectable(shader_combo_items[n].name, is_selected))

  011d9	0f 57 d2	 xorps	 xmm2, xmm2
  011dc	0f 57 c9	 xorps	 xmm1, xmm1
  011df	48 8d 8c 24 20
	03 00 00	 lea	 rcx, QWORD PTR $T60[rsp]
  011e7	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  011ec	8b 4c 24 5c	 mov	 ecx, DWORD PTR n$6[rsp]
  011f0	48 6b c9 10	 imul	 rcx, rcx, 16
  011f4	4c 8b c8	 mov	 r9, rax
  011f7	45 33 c0	 xor	 r8d, r8d
  011fa	0f b6 54 24 44	 movzx	 edx, BYTE PTR is_selected$2[rsp]
  011ff	48 8b 8c 0c 40
	40 00 00	 mov	 rcx, QWORD PTR shader_combo_items$[rsp+rcx]
  01207	e8 00 00 00 00	 call	 ?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z ; ImGui::Selectable
  0120c	0f b6 c0	 movzx	 eax, al
  0120f	85 c0		 test	 eax, eax
  01211	74 0b		 je	 SHORT $LN37@main

; 363  :                         shader_combo_idx = n;

  01213	8b 44 24 5c	 mov	 eax, DWORD PTR n$6[rsp]
  01217	89 84 24 80 00
	00 00		 mov	 DWORD PTR shader_combo_idx$[rsp], eax
$LN37@main:

; 364  :                     
; 365  :                     if (is_selected)

  0121e	0f b6 44 24 44	 movzx	 eax, BYTE PTR is_selected$2[rsp]
  01223	85 c0		 test	 eax, eax
  01225	74 05		 je	 SHORT $LN38@main

; 366  :                         ImGui::SetItemDefaultFocus();

  01227	e8 00 00 00 00	 call	 ?SetItemDefaultFocus@ImGui@@YAXXZ ; ImGui::SetItemDefaultFocus
$LN38@main:

; 367  :                 }

  0122c	e9 5f ff ff ff	 jmp	 $LN13@main
$LN14@main:

; 368  :                 
; 369  :                 ImGui::EndCombo();

  01231	e8 00 00 00 00	 call	 ?EndCombo@ImGui@@YAXXZ	; ImGui::EndCombo
$LN33@main:

; 370  :             }
; 371  :         }
; 372  :         
; 373  :         entity_t *entity = gl.entities+model_combo_idx;

  01236	8b 44 24 4c	 mov	 eax, DWORD PTR model_combo_idx$[rsp]
  0123a	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  0123e	48 8b 8c 24 28
	04 00 00	 mov	 rcx, QWORD PTR gl$[rsp+56]
  01246	48 03 c8	 add	 rcx, rax
  01249	48 8b c1	 mov	 rax, rcx
  0124c	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR entity$17[rsp], rax

; 374  :         if (ImGui::CollapsingHeader("Model")) {

  01254	33 d2		 xor	 edx, edx
  01256	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG84883
  0125d	e8 00 00 00 00	 call	 ?CollapsingHeader@ImGui@@YA_NPEBDH@Z ; ImGui::CollapsingHeader
  01262	0f b6 c0	 movzx	 eax, al
  01265	85 c0		 test	 eax, eax
  01267	0f 84 f0 01 00
	00		 je	 $LN39@main

; 375  :             if (ImGui::BeginCombo("Models", combo_models[model_combo_idx]))

  0126d	8b 44 24 4c	 mov	 eax, DWORD PTR model_combo_idx$[rsp]
  01271	45 33 c0	 xor	 r8d, r8d
  01274	48 8b 94 c4 a0
	3f 00 00	 mov	 rdx, QWORD PTR combo_models$[rsp+rax*8]
  0127c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG84885
  01283	e8 00 00 00 00	 call	 ?BeginCombo@ImGui@@YA_NPEBD0H@Z ; ImGui::BeginCombo
  01288	0f b6 c0	 movzx	 eax, al
  0128b	85 c0		 test	 eax, eax
  0128d	0f 84 a2 00 00
	00		 je	 $LN40@main

; 376  :             {
; 377  :                 for(u32 n = 0; n < ARRAY_COUNT(combo_models); n++)

  01293	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR n$7[rsp], 0
  0129b	eb 0a		 jmp	 SHORT $LN18@main
$LN16@main:
  0129d	8b 44 24 60	 mov	 eax, DWORD PTR n$7[rsp]
  012a1	ff c0		 inc	 eax
  012a3	89 44 24 60	 mov	 DWORD PTR n$7[rsp], eax
$LN18@main:
  012a7	8b 44 24 60	 mov	 eax, DWORD PTR n$7[rsp]
  012ab	48 83 f8 04	 cmp	 rax, 4
  012af	73 7f		 jae	 SHORT $LN17@main

; 378  :                 {
; 379  :                     bool is_selected = model_combo_idx == n;

  012b1	8b 44 24 60	 mov	 eax, DWORD PTR n$7[rsp]
  012b5	39 44 24 4c	 cmp	 DWORD PTR model_combo_idx$[rsp], eax
  012b9	75 0d		 jne	 SHORT $LN59@main
  012bb	c7 84 24 c0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv804[rsp], 1
  012c6	eb 0b		 jmp	 SHORT $LN60@main
$LN59@main:
  012c8	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv804[rsp], 0
$LN60@main:
  012d3	0f b6 84 24 c0
	00 00 00	 movzx	 eax, BYTE PTR tv804[rsp]
  012db	88 44 24 45	 mov	 BYTE PTR is_selected$3[rsp], al

; 380  :                     if (ImGui::Selectable(combo_models[n], is_selected))

  012df	0f 57 d2	 xorps	 xmm2, xmm2
  012e2	0f 57 c9	 xorps	 xmm1, xmm1
  012e5	48 8d 8c 24 f8
	02 00 00	 lea	 rcx, QWORD PTR $T57[rsp]
  012ed	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  012f2	8b 4c 24 60	 mov	 ecx, DWORD PTR n$7[rsp]
  012f6	4c 8b c8	 mov	 r9, rax
  012f9	45 33 c0	 xor	 r8d, r8d
  012fc	0f b6 54 24 45	 movzx	 edx, BYTE PTR is_selected$3[rsp]
  01301	48 8b 8c cc a0
	3f 00 00	 mov	 rcx, QWORD PTR combo_models$[rsp+rcx*8]
  01309	e8 00 00 00 00	 call	 ?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z ; ImGui::Selectable
  0130e	0f b6 c0	 movzx	 eax, al
  01311	85 c0		 test	 eax, eax
  01313	74 08		 je	 SHORT $LN41@main

; 381  :                         model_combo_idx = n;

  01315	8b 44 24 60	 mov	 eax, DWORD PTR n$7[rsp]
  01319	89 44 24 4c	 mov	 DWORD PTR model_combo_idx$[rsp], eax
$LN41@main:

; 382  :                     
; 383  :                     if (is_selected)

  0131d	0f b6 44 24 45	 movzx	 eax, BYTE PTR is_selected$3[rsp]
  01322	85 c0		 test	 eax, eax
  01324	74 05		 je	 SHORT $LN42@main

; 384  :                         ImGui::SetItemDefaultFocus();

  01326	e8 00 00 00 00	 call	 ?SetItemDefaultFocus@ImGui@@YAXXZ ; ImGui::SetItemDefaultFocus
$LN42@main:

; 385  :                 }

  0132b	e9 6d ff ff ff	 jmp	 $LN16@main
$LN17@main:

; 386  :                 
; 387  :                 ImGui::EndCombo();

  01330	e8 00 00 00 00	 call	 ?EndCombo@ImGui@@YAXXZ	; ImGui::EndCombo
$LN40@main:

; 388  :             }
; 389  :             
; 390  :             draw_vec3_widget("Pos", &entity->pos);

  01335	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR entity$17[rsp]
  0133d	48 83 c0 10	 add	 rax, 16
  01341	48 8b d0	 mov	 rdx, rax
  01344	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG84888
  0134b	e8 00 00 00 00	 call	 ?draw_vec3_widget@@YAXPEBDPEATHMM_Vec3@@@Z ; draw_vec3_widget

; 391  :             draw_vec3_widget("Rot", &entity->rot);

  01350	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR entity$17[rsp]
  01358	48 83 c0 1c	 add	 rax, 28
  0135c	48 8b d0	 mov	 rdx, rax
  0135f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG84889
  01366	e8 00 00 00 00	 call	 ?draw_vec3_widget@@YAXPEBDPEATHMM_Vec3@@@Z ; draw_vec3_widget

; 392  :             draw_vec3_widget("Scale", &entity->scale);

  0136b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR entity$17[rsp]
  01373	48 83 c0 28	 add	 rax, 40			; 00000028H
  01377	48 8b d0	 mov	 rdx, rax
  0137a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG84890
  01381	e8 00 00 00 00	 call	 ?draw_vec3_widget@@YAXPEBDPEATHMM_Vec3@@@Z ; draw_vec3_widget

; 393  :             
; 394  :             ImGui::ColorPicker4("Color", (float *)color[model_combo_idx].Elements, ImGuiColorEditFlags_Float);

  01386	8b 44 24 4c	 mov	 eax, DWORD PTR model_combo_idx$[rsp]
  0138a	48 6b c0 10	 imul	 rax, rax, 16
  0138e	48 8d 84 04 00
	40 00 00	 lea	 rax, QWORD PTR color$[rsp+rax]
  01396	45 33 c9	 xor	 r9d, r9d
  01399	41 b8 00 00 00
	01		 mov	 r8d, 16777216		; 01000000H
  0139f	48 8b d0	 mov	 rdx, rax
  013a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG84891
  013a9	e8 00 00 00 00	 call	 ?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z ; ImGui::ColorPicker4

; 395  :             color_t temp; v4 tempf = color[model_combo_idx];

  013ae	8b 44 24 4c	 mov	 eax, DWORD PTR model_combo_idx$[rsp]
  013b2	48 6b c0 10	 imul	 rax, rax, 16
  013b6	0f 10 84 04 00
	40 00 00	 movups	 xmm0, XMMWORD PTR color$[rsp+rax]
  013be	66 0f 7f 84 24
	20 05 00 00	 movdqa	 XMMWORD PTR tempf$74[rsp], xmm0

; 396  :             temp.r = tempf.X*255; temp.g = tempf.Y*255; temp.b = tempf.Z*255; temp.a = tempf.W*255;

  013c7	f3 0f 10 84 24
	20 05 00 00	 movss	 xmm0, DWORD PTR tempf$74[rsp]
  013d0	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  013d8	f3 0f 2c c0	 cvttss2si eax, xmm0
  013dc	88 84 24 84 00
	00 00		 mov	 BYTE PTR temp$15[rsp], al
  013e3	f3 0f 10 84 24
	24 05 00 00	 movss	 xmm0, DWORD PTR tempf$74[rsp+4]
  013ec	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  013f4	f3 0f 2c c0	 cvttss2si eax, xmm0
  013f8	88 84 24 85 00
	00 00		 mov	 BYTE PTR temp$15[rsp+1], al
  013ff	f3 0f 10 84 24
	28 05 00 00	 movss	 xmm0, DWORD PTR tempf$74[rsp+8]
  01408	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  01410	f3 0f 2c c0	 cvttss2si eax, xmm0
  01414	88 84 24 86 00
	00 00		 mov	 BYTE PTR temp$15[rsp+2], al
  0141b	f3 0f 10 84 24
	2c 05 00 00	 movss	 xmm0, DWORD PTR tempf$74[rsp+12]
  01424	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0142c	f3 0f 2c c0	 cvttss2si eax, xmm0
  01430	88 84 24 87 00
	00 00		 mov	 BYTE PTR temp$15[rsp+3], al

; 397  :             colors[model_combo_idx] = temp;

  01437	8b 44 24 4c	 mov	 eax, DWORD PTR model_combo_idx$[rsp]
  0143b	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR temp$15[rsp]
  01442	89 8c 84 90 3f
	00 00		 mov	 DWORD PTR colors$[rsp+rax*4], ecx

; 398  :             
; 399  :             ImGui::Checkbox("Use Textures", (bool *)&gl.use_textures);

  01449	48 8d 94 24 fc
	04 00 00	 lea	 rdx, QWORD PTR gl$[rsp+268]
  01451	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG84892
  01458	e8 00 00 00 00	 call	 ?Checkbox@ImGui@@YA_NPEBDPEA_N@Z ; ImGui::Checkbox
$LN39@main:

; 400  :             
; 401  :         }
; 402  :         
; 403  :         if (ImGui::CollapsingHeader("Curves", ImGuiTreeNodeFlags_DefaultOpen)) {

  0145d	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  01462	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG84894
  01469	e8 00 00 00 00	 call	 ?CollapsingHeader@ImGui@@YA_NPEBDH@Z ; ImGui::CollapsingHeader
  0146e	0f b6 c0	 movzx	 eax, al
  01471	85 c0		 test	 eax, eax
  01473	0f 84 ac 03 00
	00		 je	 $LN43@main

; 404  :             ImGui::SliderFloat("dt", &t, 0.001f, 1.0f);

  01479	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  01481	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG84895
  01488	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0148d	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f800000
  01495	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3a83126f
  0149d	48 8d 94 24 f4
	00 00 00	 lea	 rdx, QWORD PTR t$[rsp]
  014a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG84896
  014ac	e8 00 00 00 00	 call	 ?SliderFloat@ImGui@@YA_NPEBDPEAMMM0H@Z ; ImGui::SliderFloat

; 405  :             
; 406  :             ImGui::Checkbox("Debug", (bool *)&debug);

  014b1	48 8d 94 24 f8
	00 00 00	 lea	 rdx, QWORD PTR debug$[rsp]
  014b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG84897
  014c0	e8 00 00 00 00	 call	 ?Checkbox@ImGui@@YA_NPEBDPEA_N@Z ; ImGui::Checkbox

; 407  :             ImGui::SliderFloat("Debug t", &debug_t, 0.0f, 1.0f);

  014c5	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  014cd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG84898
  014d4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  014d9	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f800000
  014e1	0f 57 d2	 xorps	 xmm2, xmm2
  014e4	48 8d 94 24 fc
	00 00 00	 lea	 rdx, QWORD PTR debug_t$[rsp]
  014ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG84899
  014f3	e8 00 00 00 00	 call	 ?SliderFloat@ImGui@@YA_NPEBDPEAMMM0H@Z ; ImGui::SliderFloat

; 408  :             
; 409  :             for (u32 i = 0; i < ARRAY_COUNT(c_type); i++) 

  014f8	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR i$8[rsp], 0
  01500	eb 0a		 jmp	 SHORT $LN21@main
$LN19@main:
  01502	8b 44 24 64	 mov	 eax, DWORD PTR i$8[rsp]
  01506	ff c0		 inc	 eax
  01508	89 44 24 64	 mov	 DWORD PTR i$8[rsp], eax
$LN21@main:
  0150c	8b 44 24 64	 mov	 eax, DWORD PTR i$8[rsp]
  01510	48 83 f8 03	 cmp	 rax, 3
  01514	73 43		 jae	 SHORT $LN20@main

; 410  :             {
; 411  :                 if (ImGui::RadioButton(c_type[i], c_selected == i))

  01516	8b 44 24 64	 mov	 eax, DWORD PTR i$8[rsp]
  0151a	39 84 24 88 00
	00 00		 cmp	 DWORD PTR c_selected$[rsp], eax
  01521	75 07		 jne	 SHORT $LN61@main
  01523	c6 44 24 46 01	 mov	 BYTE PTR tv880[rsp], 1
  01528	eb 05		 jmp	 SHORT $LN62@main
$LN61@main:
  0152a	c6 44 24 46 00	 mov	 BYTE PTR tv880[rsp], 0
$LN62@main:
  0152f	8b 44 24 64	 mov	 eax, DWORD PTR i$8[rsp]
  01533	0f b6 54 24 46	 movzx	 edx, BYTE PTR tv880[rsp]
  01538	48 8b 8c c4 c0
	3f 00 00	 mov	 rcx, QWORD PTR c_type$[rsp+rax*8]
  01540	e8 00 00 00 00	 call	 ?RadioButton@ImGui@@YA_NPEBD_N@Z ; ImGui::RadioButton
  01545	0f b6 c0	 movzx	 eax, al
  01548	85 c0		 test	 eax, eax
  0154a	74 0b		 je	 SHORT $LN44@main

; 412  :                     c_selected= i;

  0154c	8b 44 24 64	 mov	 eax, DWORD PTR i$8[rsp]
  01550	89 84 24 88 00
	00 00		 mov	 DWORD PTR c_selected$[rsp], eax
$LN44@main:

; 413  :             }

  01557	eb a9		 jmp	 SHORT $LN19@main
$LN20@main:

; 414  :             
; 415  :             ImGui::Spacing();

  01559	e8 00 00 00 00	 call	 ?Spacing@ImGui@@YAXXZ	; ImGui::Spacing

; 416  :             
; 417  :             for (u32 i = 0; i < ARRAY_COUNT(a_type); i++) 

  0155e	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR i$9[rsp], 0
  01566	eb 0a		 jmp	 SHORT $LN24@main
$LN22@main:
  01568	8b 44 24 68	 mov	 eax, DWORD PTR i$9[rsp]
  0156c	ff c0		 inc	 eax
  0156e	89 44 24 68	 mov	 DWORD PTR i$9[rsp], eax
$LN24@main:
  01572	8b 44 24 68	 mov	 eax, DWORD PTR i$9[rsp]
  01576	48 83 f8 02	 cmp	 rax, 2
  0157a	73 43		 jae	 SHORT $LN23@main

; 418  :             {
; 419  :                 if (ImGui::RadioButton(a_type[i], a_selected == i))

  0157c	8b 44 24 68	 mov	 eax, DWORD PTR i$9[rsp]
  01580	39 84 24 c4 00
	00 00		 cmp	 DWORD PTR a_selected$[rsp], eax
  01587	75 07		 jne	 SHORT $LN63@main
  01589	c6 44 24 47 01	 mov	 BYTE PTR tv893[rsp], 1
  0158e	eb 05		 jmp	 SHORT $LN64@main
$LN63@main:
  01590	c6 44 24 47 00	 mov	 BYTE PTR tv893[rsp], 0
$LN64@main:
  01595	8b 44 24 68	 mov	 eax, DWORD PTR i$9[rsp]
  01599	0f b6 54 24 47	 movzx	 edx, BYTE PTR tv893[rsp]
  0159e	48 8b 8c c4 08
	02 00 00	 mov	 rcx, QWORD PTR a_type$[rsp+rax*8]
  015a6	e8 00 00 00 00	 call	 ?RadioButton@ImGui@@YA_NPEBD_N@Z ; ImGui::RadioButton
  015ab	0f b6 c0	 movzx	 eax, al
  015ae	85 c0		 test	 eax, eax
  015b0	74 0b		 je	 SHORT $LN45@main

; 420  :                     a_selected= i;

  015b2	8b 44 24 68	 mov	 eax, DWORD PTR i$9[rsp]
  015b6	89 84 24 c4 00
	00 00		 mov	 DWORD PTR a_selected$[rsp], eax
$LN45@main:

; 421  :             }

  015bd	eb a9		 jmp	 SHORT $LN22@main
$LN23@main:

; 422  :             
; 423  :             char buffer[32];
; 424  :             v3 prev_p;
; 425  :             u32 p_count = get_stack_count(p);

  015bf	48 83 7c 24 50
	00		 cmp	 QWORD PTR p$[rsp], 0
  015c5	74 11		 je	 SHORT $LN65@main
  015c7	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  015cc	8b 40 fc	 mov	 eax, DWORD PTR [rax-4]
  015cf	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv936[rsp], eax
  015d6	eb 0b		 jmp	 SHORT $LN66@main
$LN65@main:
  015d8	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv936[rsp], 0
$LN66@main:
  015e3	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR tv936[rsp]
  015ea	89 84 24 cc 00
	00 00		 mov	 DWORD PTR p_count$19[rsp], eax

; 426  :             u32 c_count = ceilf((p_count-1)/3.0f);

  015f1	8b 84 24 cc 00
	00 00		 mov	 eax, DWORD PTR p_count$19[rsp]
  015f8	ff c8		 dec	 eax
  015fa	8b c0		 mov	 eax, eax
  015fc	f3 48 0f 2a c0	 cvtsi2ss xmm0, rax
  01601	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40400000
  01609	e8 00 00 00 00	 call	 ceilf
  0160e	f3 48 0f 2c c0	 cvttss2si rax, xmm0
  01613	89 84 24 00 01
	00 00		 mov	 DWORD PTR c_count$24[rsp], eax

; 427  :             for (u32 i = 0; i < p_count; i++) {

  0161a	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  01622	eb 0a		 jmp	 SHORT $LN27@main
$LN25@main:
  01624	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  01628	ff c0		 inc	 eax
  0162a	89 44 24 40	 mov	 DWORD PTR i$1[rsp], eax
$LN27@main:
  0162e	8b 84 24 cc 00
	00 00		 mov	 eax, DWORD PTR p_count$19[rsp]
  01635	39 44 24 40	 cmp	 DWORD PTR i$1[rsp], eax
  01639	0f 83 15 01 00
	00		 jae	 $LN26@main

; 428  :                 sprintf(buffer, "Pos %d", i);

  0163f	44 8b 44 24 40	 mov	 r8d, DWORD PTR i$1[rsp]
  01644	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG84902
  0164b	48 8d 8c 24 00
	41 00 00	 lea	 rcx, QWORD PTR buffer$87[rsp]
  01653	e8 00 00 00 00	 call	 sprintf

; 429  :                 
; 430  :                 prev_p = p[i];

  01658	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  0165c	48 6b c0 0c	 imul	 rax, rax, 12
  01660	48 8d 8c 24 10
	05 00 00	 lea	 rcx, QWORD PTR prev_p$73[rsp]
  01668	48 8b 54 24 50	 mov	 rdx, QWORD PTR p$[rsp]
  0166d	48 8b f9	 mov	 rdi, rcx
  01670	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  01674	b9 0c 00 00 00	 mov	 ecx, 12
  01679	f3 a4		 rep movsb

; 431  :                 draw_vec3_widget(buffer, p+i);

  0167b	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  0167f	48 6b c0 0c	 imul	 rax, rax, 12
  01683	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$[rsp]
  01688	48 03 c8	 add	 rcx, rax
  0168b	48 8b c1	 mov	 rax, rcx
  0168e	48 8b d0	 mov	 rdx, rax
  01691	48 8d 8c 24 00
	41 00 00	 lea	 rcx, QWORD PTR buffer$87[rsp]
  01699	e8 00 00 00 00	 call	 ?draw_vec3_widget@@YAXPEBDPEATHMM_Vec3@@@Z ; draw_vec3_widget

; 432  :                 
; 433  :                 if (c_selected != 0 && i > 1 && i < c_count*3-1 && 

  0169e	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR c_selected$[rsp], 0
  016a6	0f 84 a3 00 00
	00		 je	 $LN46@main
  016ac	83 7c 24 40 01	 cmp	 DWORD PTR i$1[rsp], 1
  016b1	0f 86 98 00 00
	00		 jbe	 $LN46@main
  016b7	6b 84 24 00 01
	00 00 03	 imul	 eax, DWORD PTR c_count$24[rsp], 3
  016bf	ff c8		 dec	 eax
  016c1	39 44 24 40	 cmp	 DWORD PTR i$1[rsp], eax
  016c5	0f 83 84 00 00
	00		 jae	 $LN46@main
  016cb	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  016cf	48 6b c0 0c	 imul	 rax, rax, 12
  016d3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$[rsp]
  016d8	f3 0f 10 84 24
	10 05 00 00	 movss	 xmm0, DWORD PTR prev_p$73[rsp]
  016e1	0f 2e 04 01	 ucomiss xmm0, DWORD PTR [rcx+rax]
  016e5	7a 40		 jp	 SHORT $LN47@main
  016e7	75 3e		 jne	 SHORT $LN47@main
  016e9	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  016ed	48 6b c0 0c	 imul	 rax, rax, 12
  016f1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$[rsp]
  016f6	f3 0f 10 84 24
	14 05 00 00	 movss	 xmm0, DWORD PTR prev_p$73[rsp+4]
  016ff	0f 2e 44 01 04	 ucomiss xmm0, DWORD PTR [rcx+rax+4]
  01704	7a 21		 jp	 SHORT $LN47@main
  01706	75 1f		 jne	 SHORT $LN47@main
  01708	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  0170c	48 6b c0 0c	 imul	 rax, rax, 12
  01710	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$[rsp]
  01715	f3 0f 10 84 24
	18 05 00 00	 movss	 xmm0, DWORD PTR prev_p$73[rsp+8]
  0171e	0f 2e 44 01 08	 ucomiss xmm0, DWORD PTR [rcx+rax+8]
  01723	7a 02		 jp	 SHORT $LN47@main
  01725	74 28		 je	 SHORT $LN46@main
$LN47@main:

; 434  :                     (prev_p.X != p[i].X || prev_p.Y != p[i].Y || prev_p.Z != p[i].Z)) 
; 435  :                 {
; 436  :                     if (c_selected == 1) {

  01727	83 bc 24 88 00
	00 00 01	 cmp	 DWORD PTR c_selected$[rsp], 1
  0172f	75 10		 jne	 SHORT $LN48@main

; 437  :                         adjust_bezier_c1(p, i);

  01731	8b 54 24 40	 mov	 edx, DWORD PTR i$1[rsp]
  01735	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$[rsp]
  0173a	e8 00 00 00 00	 call	 ?adjust_bezier_c1@@YAXPEATHMM_Vec3@@I@Z ; adjust_bezier_c1

; 438  :                     }

  0173f	eb 0e		 jmp	 SHORT $LN46@main
$LN48@main:

; 439  :                     else {
; 440  :                         adjust_bezier_g1(p, i);

  01741	8b 54 24 40	 mov	 edx, DWORD PTR i$1[rsp]
  01745	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$[rsp]
  0174a	e8 00 00 00 00	 call	 ?adjust_bezier_g1@@YAXPEATHMM_Vec3@@I@Z ; adjust_bezier_g1
$LN46@main:

; 441  :                     }
; 442  :                 }
; 443  :             }

  0174f	e9 d0 fe ff ff	 jmp	 $LN25@main
$LN26@main:

; 444  :             
; 445  :             ImGui::Spacing();

  01754	e8 00 00 00 00	 call	 ?Spacing@ImGui@@YAXXZ	; ImGui::Spacing

; 446  :             
; 447  :             if (ImGui::Button("Add Point")) {

  01759	0f 57 d2	 xorps	 xmm2, xmm2
  0175c	0f 57 c9	 xorps	 xmm1, xmm1
  0175f	48 8d 8c 24 f0
	02 00 00	 lea	 rcx, QWORD PTR $T56[rsp]
  01767	e8 00 00 00 00	 call	 ??0ImVec2@@QEAA@MM@Z	; ImVec2::ImVec2
  0176c	48 8b d0	 mov	 rdx, rax
  0176f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG84908
  01776	e8 00 00 00 00	 call	 ?Button@ImGui@@YA_NPEBDAEBUImVec2@@@Z ; ImGui::Button
  0177b	0f b6 c0	 movzx	 eax, al
  0177e	85 c0		 test	 eax, eax
  01780	0f 84 9f 00 00
	00		 je	 $LN43@main

; 448  :                 u32 prev_p_id = get_stack_count(p)-1;

  01786	48 83 7c 24 50
	00		 cmp	 QWORD PTR p$[rsp], 0
  0178c	74 11		 je	 SHORT $LN67@main
  0178e	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  01793	8b 40 fc	 mov	 eax, DWORD PTR [rax-4]
  01796	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv1026[rsp], eax
  0179d	eb 0b		 jmp	 SHORT $LN68@main
$LN67@main:
  0179f	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1026[rsp], 0
$LN68@main:
  017aa	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR tv1026[rsp]
  017b1	ff c8		 dec	 eax
  017b3	89 84 24 a8 00
	00 00		 mov	 DWORD PTR prev_p_id$18[rsp], eax

; 449  :                 v3 *np = (v3 *)stack_push(&p);

  017ba	41 b8 0c 00 00
	00		 mov	 r8d, 12
  017c0	ba 01 00 00 00	 mov	 edx, 1
  017c5	48 8d 4c 24 50	 lea	 rcx, QWORD PTR p$[rsp]
  017ca	e8 00 00 00 00	 call	 ?_stack_push@@YAPEAXPEAPEAXII@Z ; _stack_push
  017cf	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR np$31[rsp], rax

; 450  :                 *np = p[prev_p_id];

  017d7	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR prev_p_id$18[rsp]
  017de	48 6b c0 0c	 imul	 rax, rax, 12
  017e2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$[rsp]
  017e7	48 8b bc 24 80
	01 00 00	 mov	 rdi, QWORD PTR np$31[rsp]
  017ef	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  017f3	b9 0c 00 00 00	 mov	 ecx, 12
  017f8	f3 a4		 rep movsb

; 451  :                 
; 452  :                 if (prev_p_id % 3 == 0) {

  017fa	33 d2		 xor	 edx, edx
  017fc	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR prev_p_id$18[rsp]
  01803	b9 03 00 00 00	 mov	 ecx, 3
  01808	f7 f1		 div	 ecx
  0180a	8b c2		 mov	 eax, edx
  0180c	85 c0		 test	 eax, eax
  0180e	75 15		 jne	 SHORT $LN43@main

; 453  :                     adjust_bezier_c1(p, prev_p_id-1);

  01810	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR prev_p_id$18[rsp]
  01817	ff c8		 dec	 eax
  01819	8b d0		 mov	 edx, eax
  0181b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$[rsp]
  01820	e8 00 00 00 00	 call	 ?adjust_bezier_c1@@YAXPEATHMM_Vec3@@I@Z ; adjust_bezier_c1
$LN43@main:

; 454  :                 }
; 455  :                 
; 456  :             }
; 457  :         }
; 458  :         
; 459  :         mat4 *transform = gl.transforms+entity->m_info.trans_id;

  01825	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR entity$17[rsp]
  0182d	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  01830	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  01834	48 8b 8c 24 20
	04 00 00	 mov	 rcx, QWORD PTR gl$[rsp+48]
  0183c	48 03 c8	 add	 rcx, rax
  0183f	48 8b c1	 mov	 rax, rcx
  01842	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR transform$32[rsp], rax

; 460  :         update_transform(&gl, transform, entity->pos, entity->rot, entity->scale);

  0184a	48 8d 84 24 30
	02 00 00	 lea	 rax, QWORD PTR $T41[rsp]
  01852	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR entity$17[rsp]
  0185a	48 8b f8	 mov	 rdi, rax
  0185d	48 8d 71 28	 lea	 rsi, QWORD PTR [rcx+40]
  01861	b9 0c 00 00 00	 mov	 ecx, 12
  01866	f3 a4		 rep movsb
  01868	48 8d 84 24 70
	02 00 00	 lea	 rax, QWORD PTR $T45[rsp]
  01870	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR entity$17[rsp]
  01878	48 8b f8	 mov	 rdi, rax
  0187b	48 8d 71 1c	 lea	 rsi, QWORD PTR [rcx+28]
  0187f	b9 0c 00 00 00	 mov	 ecx, 12
  01884	f3 a4		 rep movsb
  01886	48 8d 84 24 80
	02 00 00	 lea	 rax, QWORD PTR $T46[rsp]
  0188e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR entity$17[rsp]
  01896	48 8b f8	 mov	 rdi, rax
  01899	48 8d 71 10	 lea	 rsi, QWORD PTR [rcx+16]
  0189d	b9 0c 00 00 00	 mov	 ecx, 12
  018a2	f3 a4		 rep movsb
  018a4	48 8d 84 24 30
	02 00 00	 lea	 rax, QWORD PTR $T41[rsp]
  018ac	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  018b1	4c 8d 8c 24 70
	02 00 00	 lea	 r9, QWORD PTR $T45[rsp]
  018b9	4c 8d 84 24 80
	02 00 00	 lea	 r8, QWORD PTR $T46[rsp]
  018c1	48 8b 94 24 88
	01 00 00	 mov	 rdx, QWORD PTR transform$32[rsp]
  018c9	48 8d 8c 24 f0
	03 00 00	 lea	 rcx, QWORD PTR gl$[rsp]
  018d1	e8 00 00 00 00	 call	 ?update_transform@@YAXPEAUgl_renderer@@PEATHMM_Mat4@@THMM_Vec3@@22@Z ; update_transform

; 461  :         
; 462  :         ImGui::End();

  018d6	e8 00 00 00 00	 call	 ?End@ImGui@@YAXXZ	; ImGui::End

; 463  :         
; 464  :         update_camera(&camera);

  018db	48 8d 8c 24 d0
	05 00 00	 lea	 rcx, QWORD PTR camera$[rsp]
  018e3	e8 00 00 00 00	 call	 ?update_camera@@YAXPEAUcamera_t@@@Z ; update_camera

; 465  :         
; 466  :         //render_framebuffer(&gl);
; 467  :         
; 468  :         ImGui::Render();

  018e8	e8 00 00 00 00	 call	 ?Render@ImGui@@YAXXZ	; ImGui::Render

; 469  :         i32 w, h;
; 470  :         glfwGetFramebufferSize(window, &w, &h);

  018ed	4c 8d 84 24 04
	01 00 00	 lea	 r8, QWORD PTR h$25[rsp]
  018f5	48 8d 94 24 08
	01 00 00	 lea	 rdx, QWORD PTR w$26[rsp]
  018fd	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR window$[rsp]
  01905	e8 00 00 00 00	 call	 glfwGetFramebufferSize

; 471  :         glViewport(0, 0, w, h);

  0190a	44 8b 8c 24 04
	01 00 00	 mov	 r9d, DWORD PTR h$25[rsp]
  01912	44 8b 84 24 08
	01 00 00	 mov	 r8d, DWORD PTR w$26[rsp]
  0191a	33 d2		 xor	 edx, edx
  0191c	33 c9		 xor	 ecx, ecx
  0191e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glViewport

; 472  :         glClearColor(0.0f, 0.0f, 0.0f, 1.0f);

  01924	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f800000
  0192c	0f 57 d2	 xorps	 xmm2, xmm2
  0192f	0f 57 c9	 xorps	 xmm1, xmm1
  01932	0f 57 c0	 xorps	 xmm0, xmm0
  01935	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glClearColor

; 473  :         glClear(GL_COLOR_BUFFER_BIT);

  0193b	b9 00 40 00 00	 mov	 ecx, 16384		; 00004000H
  01940	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glClear

; 474  :         ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());

  01946	e8 00 00 00 00	 call	 ?GetDrawData@ImGui@@YAPEAUImDrawData@@XZ ; ImGui::GetDrawData
  0194b	48 8b c8	 mov	 rcx, rax
  0194e	e8 00 00 00 00	 call	 ?ImGui_ImplOpenGL3_RenderDrawData@@YAXPEAUImDrawData@@@Z ; ImGui_ImplOpenGL3_RenderDrawData

; 475  :         ImGuiIO io = ImGui::GetIO();

  01953	e8 00 00 00 00	 call	 ?GetIO@ImGui@@YAAEAUImGuiIO@@XZ ; ImGui::GetIO
  01958	48 8b d0	 mov	 rdx, rax
  0195b	48 8d 8c 24 70
	06 00 00	 lea	 rcx, QWORD PTR io$85[rsp]
  01963	e8 00 00 00 00	 call	 ??0ImGuiIO@@QEAA@AEBU0@@Z
  01968	90		 npad	 1

; 476  :         
; 477  :         if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable) {

  01969	8b 84 24 70 06
	00 00		 mov	 eax, DWORD PTR io$85[rsp]
  01970	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  01975	85 c0		 test	 eax, eax
  01977	74 28		 je	 SHORT $LN52@main

; 478  :             GLFWwindow *backup = glfwGetCurrentContext();

  01979	e8 00 00 00 00	 call	 glfwGetCurrentContext
  0197e	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR backup$33[rsp], rax

; 479  :             ImGui::UpdatePlatformWindows();

  01986	e8 00 00 00 00	 call	 ?UpdatePlatformWindows@ImGui@@YAXXZ ; ImGui::UpdatePlatformWindows

; 480  :             ImGui::RenderPlatformWindowsDefault();

  0198b	33 d2		 xor	 edx, edx
  0198d	33 c9		 xor	 ecx, ecx
  0198f	e8 00 00 00 00	 call	 ?RenderPlatformWindowsDefault@ImGui@@YAXPEAX0@Z ; ImGui::RenderPlatformWindowsDefault

; 481  :             glfwMakeContextCurrent(backup);

  01994	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR backup$33[rsp]
  0199c	e8 00 00 00 00	 call	 glfwMakeContextCurrent
$LN52@main:

; 482  :         }
; 483  :         
; 484  :         glfwSwapBuffers(window);

  019a1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR window$[rsp]
  019a9	e8 00 00 00 00	 call	 glfwSwapBuffers

; 485  :         glfwPollEvents();

  019ae	e8 00 00 00 00	 call	 glfwPollEvents

; 486  :         
; 487  :         stack_clear(gl.cmds);

  019b3	48 83 bc 24 18
	04 00 00 00	 cmp	 QWORD PTR gl$[rsp+40], 0
  019bc	74 1c		 je	 SHORT $LN69@main
  019be	48 8b 84 24 18
	04 00 00	 mov	 rax, QWORD PTR gl$[rsp+40]
  019c6	c7 40 fc 00 00
	00 00		 mov	 DWORD PTR [rax-4], 0
  019cd	c7 84 24 0c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1084[rsp], 0
  019d8	eb 0b		 jmp	 SHORT $LN70@main
$LN69@main:
  019da	c7 84 24 0c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1084[rsp], 0
$LN70@main:

; 488  :         stack_clear(gl.verts);

  019e5	48 83 bc 24 f0
	03 00 00 00	 cmp	 QWORD PTR gl$[rsp], 0
  019ee	74 1c		 je	 SHORT $LN71@main
  019f0	48 8b 84 24 f0
	03 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  019f8	c7 40 fc 00 00
	00 00		 mov	 DWORD PTR [rax-4], 0
  019ff	c7 84 24 2c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1088[rsp], 0
  01a0a	eb 0b		 jmp	 SHORT $LN72@main
$LN71@main:
  01a0c	c7 84 24 2c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1088[rsp], 0
$LN72@main:

; 489  :         stack_clear(gl.uvs);

  01a17	48 83 bc 24 f8
	03 00 00 00	 cmp	 QWORD PTR gl$[rsp+8], 0
  01a20	74 1c		 je	 SHORT $LN73@main
  01a22	48 8b 84 24 f8
	03 00 00	 mov	 rax, QWORD PTR gl$[rsp+8]
  01a2a	c7 40 fc 00 00
	00 00		 mov	 DWORD PTR [rax-4], 0
  01a31	c7 84 24 14 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1092[rsp], 0
  01a3c	eb 0b		 jmp	 SHORT $LN74@main
$LN73@main:
  01a3e	c7 84 24 14 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1092[rsp], 0
$LN74@main:

; 490  :         stack_clear(gl.colors);

  01a49	48 83 bc 24 00
	04 00 00 00	 cmp	 QWORD PTR gl$[rsp+16], 0
  01a52	74 1c		 je	 SHORT $LN75@main
  01a54	48 8b 84 24 00
	04 00 00	 mov	 rax, QWORD PTR gl$[rsp+16]
  01a5c	c7 40 fc 00 00
	00 00		 mov	 DWORD PTR [rax-4], 0
  01a63	c7 84 24 18 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1096[rsp], 0
  01a6e	eb 0b		 jmp	 SHORT $LN76@main
$LN75@main:
  01a70	c7 84 24 18 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1096[rsp], 0
$LN76@main:

; 491  :         stack_clear(gl.norms);

  01a7b	48 83 bc 24 08
	04 00 00 00	 cmp	 QWORD PTR gl$[rsp+24], 0
  01a84	74 1c		 je	 SHORT $LN77@main
  01a86	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR gl$[rsp+24]
  01a8e	c7 40 fc 00 00
	00 00		 mov	 DWORD PTR [rax-4], 0
  01a95	c7 84 24 1c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1100[rsp], 0
  01aa0	eb 0b		 jmp	 SHORT $LN78@main
$LN77@main:
  01aa2	c7 84 24 1c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1100[rsp], 0
$LN78@main:

; 492  :         stack_clear(gl.indices);

  01aad	48 83 bc 24 10
	04 00 00 00	 cmp	 QWORD PTR gl$[rsp+32], 0
  01ab6	74 1c		 je	 SHORT $LN79@main
  01ab8	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR gl$[rsp+32]
  01ac0	c7 40 fc 00 00
	00 00		 mov	 DWORD PTR [rax-4], 0
  01ac7	c7 84 24 20 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1104[rsp], 0
  01ad2	eb 0b		 jmp	 SHORT $LN80@main
$LN79@main:
  01ad4	c7 84 24 20 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1104[rsp], 0
$LN80@main:

; 493  :         
; 494  :         f64 current_time = glfwGetTime();

  01adf	e8 00 00 00 00	 call	 glfwGetTime
  01ae4	f2 0f 11 84 24
	50 01 00 00	 movsd	 QWORD PTR current_time$30[rsp], xmm0

; 495  :         f64 delta = current_time - last_time;

  01aed	f2 0f 10 84 24
	50 01 00 00	 movsd	 xmm0, QWORD PTR current_time$30[rsp]
  01af6	f2 0f 5c 84 24
	58 01 00 00	 subsd	 xmm0, QWORD PTR last_time$[rsp]
  01aff	f2 0f 11 84 24
	48 01 00 00	 movsd	 QWORD PTR delta$29[rsp], xmm0

; 496  :         frame_count++;

  01b08	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR frame_count$[rsp]
  01b0f	ff c0		 inc	 eax
  01b11	89 84 24 8c 00
	00 00		 mov	 DWORD PTR frame_count$[rsp], eax

; 497  :         
; 498  :         if (delta >= 1.0) {

  01b18	f2 0f 10 84 24
	48 01 00 00	 movsd	 xmm0, QWORD PTR delta$29[rsp]
  01b21	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@3ff0000000000000
  01b29	0f 82 81 00 00
	00		 jb	 $LN53@main

; 499  :             f64 fps = frame_count/delta;

  01b2f	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR frame_count$[rsp]
  01b36	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  01b3b	f2 0f 5e 84 24
	48 01 00 00	 divsd	 xmm0, QWORD PTR delta$29[rsp]
  01b44	f2 0f 11 84 24
	98 01 00 00	 movsd	 QWORD PTR fps$34[rsp], xmm0
$LN30@main:

; 500  :             
; 501  :             LOG("FPS: %f", fps);

  01b4d	b9 02 00 00 00	 mov	 ecx, 2
  01b52	e8 00 00 00 00	 call	 __acrt_iob_func
  01b57	f2 0f 10 94 24
	98 01 00 00	 movsd	 xmm2, QWORD PTR fps$34[rsp]
  01b60	66 49 0f 7e d0	 movq	 r8, xmm2
  01b65	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG84912
  01b6c	48 8b c8	 mov	 rcx, rax
  01b6f	e8 00 00 00 00	 call	 fprintf
  01b74	b9 02 00 00 00	 mov	 ecx, 2
  01b79	e8 00 00 00 00	 call	 __acrt_iob_func
  01b7e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG84913
  01b85	48 8b c8	 mov	 rcx, rax
  01b88	e8 00 00 00 00	 call	 fprintf
  01b8d	33 c0		 xor	 eax, eax
  01b8f	85 c0		 test	 eax, eax
  01b91	75 ba		 jne	 SHORT $LN30@main

; 502  :             
; 503  :             frame_count = 0;

  01b93	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR frame_count$[rsp], 0

; 504  :             last_time = current_time;

  01b9e	f2 0f 10 84 24
	50 01 00 00	 movsd	 xmm0, QWORD PTR current_time$30[rsp]
  01ba7	f2 0f 11 84 24
	58 01 00 00	 movsd	 QWORD PTR last_time$[rsp], xmm0
$LN53@main:

; 505  :             
; 506  :         }
; 507  :     }

  01bb0	48 8d 8c 24 70
	06 00 00	 lea	 rcx, QWORD PTR io$85[rsp]
  01bb8	e8 00 00 00 00	 call	 ??1ImGuiIO@@QEAA@XZ
  01bbd	e9 15 f0 ff ff	 jmp	 $LN8@main
$LN9@main:

; 508  :     
; 509  : }

  01bc2	eb 02		 jmp	 SHORT $LN83@main
  01bc4	eb 02		 jmp	 SHORT $LN82@main
$LN83@main:
  01bc6	33 c0		 xor	 eax, eax
$LN82@main:
  01bc8	48 8b 8c 24 20
	41 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01bd0	48 33 cc	 xor	 rcx, rsp
  01bd3	e8 00 00 00 00	 call	 __security_check_cookie
  01bd8	48 81 c4 38 41
	00 00		 add	 rsp, 16696		; 00004138H
  01bdf	5f		 pop	 rdi
  01be0	5e		 pop	 rsi
  01be1	c3		 ret	 0
main	ENDP
_TEXT	ENDS
text$x	SEGMENT
i$1 = 64
is_selected$2 = 68
is_selected$3 = 69
tv880 = 70
tv893 = 71
i$4 = 72
model_combo_idx$ = 76
p$ = 80
i$5 = 88
n$6 = 92
n$7 = 96
i$8 = 100
i$9 = 104
i$10 = 108
$T11 = 112
$T12 = 116
$T13 = 120
$T14 = 124
shader_combo_idx$ = 128
temp$15 = 132
c_selected$ = 136
frame_count$ = 140
$T16 = 144
window$ = 152
entity$17 = 160
prev_p_id$18 = 168
io$ = 176
shader$ = 184
tv732 = 188
tv804 = 192
a_selected$ = 196
tv936 = 200
p_count$19 = 204
tv1026 = 208
size$20 = 216
z_prime_id$ = 224
window_flags$21 = 228
dock_space_id$22 = 232
tv575 = 236
light_count$23 = 240
t$ = 244
debug$ = 248
debug_t$ = 252
c_count$24 = 256
h$25 = 260
w$26 = 264
tv1084 = 268
no_shade_id$ = 272
tv1092 = 276
tv1096 = 280
tv1100 = 284
tv1104 = 288
gouraud_id$ = 292
phong_id$ = 296
tv1088 = 300
flat_id$ = 304
z_id$ = 308
viewport$27 = 312
rp$28 = 320
delta$29 = 328
current_time$30 = 336
last_time$ = 344
tv623 = 352
tv630 = 360
tv637 = 368
tv642 = 376
np$31 = 384
transform$32 = 392
backup$33 = 400
fps$34 = 408
assets$ = 416
$T35 = 440
$T36 = 456
$T37 = 472
$T38 = 488
$T39 = 504
a_type$ = 520
$T40 = 536
$T41 = 560
$T42 = 576
$T43 = 592
$T44 = 608
$T45 = 624
$T46 = 640
$T47 = 656
$T48 = 672
$T49 = 688
$T50 = 704
$T51 = 712
$T52 = 720
$T53 = 728
$T54 = 736
$T55 = 744
$T56 = 752
$T57 = 760
$T58 = 768
$T59 = 784
$T60 = 800
$T61 = 808
$T62 = 824
$T63 = 840
$T64 = 856
$T65 = 872
$T66 = 888
$T67 = 904
$T68 = 920
$T69 = 936
$T70 = 952
$T71 = 968
$T72 = 984
gl$ = 1008
prev_p$73 = 1296
tempf$74 = 1312
$T75 = 1328
$T76 = 1344
$T77 = 1360
$T78 = 1376
$T79 = 1392
$T80 = 1408
$T81 = 1424
$T82 = 1440
$T83 = 1456
$T84 = 1472
camera$ = 1488
io$85 = 1648
colors$ = 16272
combo_models$ = 16288
c_type$ = 16320
paths$ = 16344
color$ = 16384
shader_combo_items$ = 16448
models$ = 16544
buffer$86 = 16608
buffer$87 = 16640
__$ArrayPad$ = 16672
main$dtor$0 PROC
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d 70 06
	00 00		 lea	 rcx, QWORD PTR io$85[rbp]
  00010	e8 00 00 00 00	 call	 ??1ImGuiIO@@QEAA@XZ
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
main$dtor$0 ENDP
text$x	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
i$1 = 64
is_selected$2 = 68
is_selected$3 = 69
tv880 = 70
tv893 = 71
i$4 = 72
model_combo_idx$ = 76
p$ = 80
i$5 = 88
n$6 = 92
n$7 = 96
i$8 = 100
i$9 = 104
i$10 = 108
$T11 = 112
$T12 = 116
$T13 = 120
$T14 = 124
shader_combo_idx$ = 128
temp$15 = 132
c_selected$ = 136
frame_count$ = 140
$T16 = 144
window$ = 152
entity$17 = 160
prev_p_id$18 = 168
io$ = 176
shader$ = 184
tv732 = 188
tv804 = 192
a_selected$ = 196
tv936 = 200
p_count$19 = 204
tv1026 = 208
size$20 = 216
z_prime_id$ = 224
window_flags$21 = 228
dock_space_id$22 = 232
tv575 = 236
light_count$23 = 240
t$ = 244
debug$ = 248
debug_t$ = 252
c_count$24 = 256
h$25 = 260
w$26 = 264
tv1084 = 268
no_shade_id$ = 272
tv1092 = 276
tv1096 = 280
tv1100 = 284
tv1104 = 288
gouraud_id$ = 292
phong_id$ = 296
tv1088 = 300
flat_id$ = 304
z_id$ = 308
viewport$27 = 312
rp$28 = 320
delta$29 = 328
current_time$30 = 336
last_time$ = 344
tv623 = 352
tv630 = 360
tv637 = 368
tv642 = 376
np$31 = 384
transform$32 = 392
backup$33 = 400
fps$34 = 408
assets$ = 416
$T35 = 440
$T36 = 456
$T37 = 472
$T38 = 488
$T39 = 504
a_type$ = 520
$T40 = 536
$T41 = 560
$T42 = 576
$T43 = 592
$T44 = 608
$T45 = 624
$T46 = 640
$T47 = 656
$T48 = 672
$T49 = 688
$T50 = 704
$T51 = 712
$T52 = 720
$T53 = 728
$T54 = 736
$T55 = 744
$T56 = 752
$T57 = 760
$T58 = 768
$T59 = 784
$T60 = 800
$T61 = 808
$T62 = 824
$T63 = 840
$T64 = 856
$T65 = 872
$T66 = 888
$T67 = 904
$T68 = 920
$T69 = 936
$T70 = 952
$T71 = 968
$T72 = 984
gl$ = 1008
prev_p$73 = 1296
tempf$74 = 1312
$T75 = 1328
$T76 = 1344
$T77 = 1360
$T78 = 1376
$T79 = 1392
$T80 = 1408
$T81 = 1424
$T82 = 1440
$T83 = 1456
$T84 = 1472
camera$ = 1488
io$85 = 1648
colors$ = 16272
combo_models$ = 16288
c_type$ = 16320
paths$ = 16344
color$ = 16384
shader_combo_items$ = 16448
models$ = 16544
buffer$86 = 16608
buffer$87 = 16640
__$ArrayPad$ = 16672
main$dtor$0 PROC
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	48 8d 8d 70 06
	00 00		 lea	 rcx, QWORD PTR io$85[rbp]
  00010	e8 00 00 00 00	 call	 ??1ImGuiIO@@QEAA@XZ
  00015	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00019	5d		 pop	 rbp
  0001a	c3		 ret	 0
main$dtor$0 ENDP
text$x	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\main.cpp
_TEXT	SEGMENT
mov_speed$ = 32
rot_speed$ = 36
update$ = 40
entity$ = 48
window$ = 80
gl$ = 88
select$ = 96
?process_input@@YAXPEAUGLFWwindow@@PEAUgl_renderer@@I@Z PROC ; process_input

; 69   : {

$LN26:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 70   :     if(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)

  00013	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00018	48 8b 4c 24 50	 mov	 rcx, QWORD PTR window$[rsp]
  0001d	e8 00 00 00 00	 call	 glfwGetKey
  00022	83 f8 01	 cmp	 eax, 1
  00025	75 0f		 jne	 SHORT $LN2@process_in

; 71   :         glfwSetWindowShouldClose(window, true);

  00027	ba 01 00 00 00	 mov	 edx, 1
  0002c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR window$[rsp]
  00031	e8 00 00 00 00	 call	 glfwSetWindowShouldClose
$LN2@process_in:

; 72   :     
; 73   :     u32 update = 0;

  00036	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR update$[rsp], 0

; 74   :     f32 mov_speed = 0.01f;

  0003e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3c23d70a
  00046	f3 0f 11 44 24
	20		 movss	 DWORD PTR mov_speed$[rsp], xmm0

; 75   :     f32 rot_speed = 0.5f;

  0004c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00054	f3 0f 11 44 24
	24		 movss	 DWORD PTR rot_speed$[rsp], xmm0

; 76   :     
; 77   :     
; 78   :     entity_t *entity = gl->entities+select;

  0005a	8b 44 24 60	 mov	 eax, DWORD PTR select$[rsp]
  0005e	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  00062	48 8b 4c 24 58	 mov	 rcx, QWORD PTR gl$[rsp]
  00067	48 03 41 38	 add	 rax, QWORD PTR [rcx+56]
  0006b	48 89 44 24 30	 mov	 QWORD PTR entity$[rsp], rax

; 79   :     if(glfwGetKey(window, GLFW_KEY_UP) == GLFW_PRESS)

  00070	ba 09 01 00 00	 mov	 edx, 265		; 00000109H
  00075	48 8b 4c 24 50	 mov	 rcx, QWORD PTR window$[rsp]
  0007a	e8 00 00 00 00	 call	 glfwGetKey
  0007f	83 f8 01	 cmp	 eax, 1
  00082	75 1a		 jne	 SHORT $LN3@process_in

; 80   :         entity->rot.X += rot_speed;

  00084	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  00089	f3 0f 10 40 1c	 movss	 xmm0, DWORD PTR [rax+28]
  0008e	f3 0f 58 44 24
	24		 addss	 xmm0, DWORD PTR rot_speed$[rsp]
  00094	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  00099	f3 0f 11 40 1c	 movss	 DWORD PTR [rax+28], xmm0
$LN3@process_in:

; 81   :     if(glfwGetKey(window, GLFW_KEY_DOWN) == GLFW_PRESS)

  0009e	ba 08 01 00 00	 mov	 edx, 264		; 00000108H
  000a3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR window$[rsp]
  000a8	e8 00 00 00 00	 call	 glfwGetKey
  000ad	83 f8 01	 cmp	 eax, 1
  000b0	75 1a		 jne	 SHORT $LN4@process_in

; 82   :         entity->rot.X -= rot_speed;

  000b2	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  000b7	f3 0f 10 40 1c	 movss	 xmm0, DWORD PTR [rax+28]
  000bc	f3 0f 5c 44 24
	24		 subss	 xmm0, DWORD PTR rot_speed$[rsp]
  000c2	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  000c7	f3 0f 11 40 1c	 movss	 DWORD PTR [rax+28], xmm0
$LN4@process_in:

; 83   :     if(glfwGetKey(window, GLFW_KEY_LEFT) == GLFW_PRESS) {

  000cc	ba 07 01 00 00	 mov	 edx, 263		; 00000107H
  000d1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR window$[rsp]
  000d6	e8 00 00 00 00	 call	 glfwGetKey
  000db	83 f8 01	 cmp	 eax, 1
  000de	75 4a		 jne	 SHORT $LN5@process_in

; 84   :         if(glfwGetKey(window, GLFW_KEY_LEFT_ALT) == GLFW_PRESS)

  000e0	ba 56 01 00 00	 mov	 edx, 342		; 00000156H
  000e5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR window$[rsp]
  000ea	e8 00 00 00 00	 call	 glfwGetKey
  000ef	83 f8 01	 cmp	 eax, 1
  000f2	75 1c		 jne	 SHORT $LN6@process_in

; 85   :             entity->rot.Z += rot_speed;

  000f4	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  000f9	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [rax+36]
  000fe	f3 0f 58 44 24
	24		 addss	 xmm0, DWORD PTR rot_speed$[rsp]
  00104	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  00109	f3 0f 11 40 24	 movss	 DWORD PTR [rax+36], xmm0
  0010e	eb 1a		 jmp	 SHORT $LN7@process_in
$LN6@process_in:

; 86   :         else
; 87   :             entity->rot.Y += rot_speed;

  00110	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  00115	f3 0f 10 40 20	 movss	 xmm0, DWORD PTR [rax+32]
  0011a	f3 0f 58 44 24
	24		 addss	 xmm0, DWORD PTR rot_speed$[rsp]
  00120	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  00125	f3 0f 11 40 20	 movss	 DWORD PTR [rax+32], xmm0
$LN7@process_in:
$LN5@process_in:

; 88   :     }
; 89   :     if(glfwGetKey(window, GLFW_KEY_RIGHT) == GLFW_PRESS) {

  0012a	ba 06 01 00 00	 mov	 edx, 262		; 00000106H
  0012f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR window$[rsp]
  00134	e8 00 00 00 00	 call	 glfwGetKey
  00139	83 f8 01	 cmp	 eax, 1
  0013c	75 4a		 jne	 SHORT $LN8@process_in

; 90   :         if(glfwGetKey(window, GLFW_KEY_LEFT_ALT) == GLFW_PRESS)

  0013e	ba 56 01 00 00	 mov	 edx, 342		; 00000156H
  00143	48 8b 4c 24 50	 mov	 rcx, QWORD PTR window$[rsp]
  00148	e8 00 00 00 00	 call	 glfwGetKey
  0014d	83 f8 01	 cmp	 eax, 1
  00150	75 1c		 jne	 SHORT $LN9@process_in

; 91   :             entity->rot.Z -= rot_speed;

  00152	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  00157	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [rax+36]
  0015c	f3 0f 5c 44 24
	24		 subss	 xmm0, DWORD PTR rot_speed$[rsp]
  00162	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  00167	f3 0f 11 40 24	 movss	 DWORD PTR [rax+36], xmm0
  0016c	eb 1a		 jmp	 SHORT $LN10@process_in
$LN9@process_in:

; 92   :         else
; 93   :             entity->rot.Y -= rot_speed;

  0016e	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  00173	f3 0f 10 40 20	 movss	 xmm0, DWORD PTR [rax+32]
  00178	f3 0f 5c 44 24
	24		 subss	 xmm0, DWORD PTR rot_speed$[rsp]
  0017e	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  00183	f3 0f 11 40 20	 movss	 DWORD PTR [rax+32], xmm0
$LN10@process_in:
$LN8@process_in:

; 94   :     }
; 95   :     
; 96   :     if(glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)

  00188	ba 57 00 00 00	 mov	 edx, 87			; 00000057H
  0018d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR window$[rsp]
  00192	e8 00 00 00 00	 call	 glfwGetKey
  00197	83 f8 01	 cmp	 eax, 1
  0019a	75 1a		 jne	 SHORT $LN11@process_in

; 97   :         entity->pos.Z += mov_speed;

  0019c	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  001a1	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [rax+24]
  001a6	f3 0f 58 44 24
	20		 addss	 xmm0, DWORD PTR mov_speed$[rsp]
  001ac	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  001b1	f3 0f 11 40 18	 movss	 DWORD PTR [rax+24], xmm0
$LN11@process_in:

; 98   :     if(glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)

  001b6	ba 53 00 00 00	 mov	 edx, 83			; 00000053H
  001bb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR window$[rsp]
  001c0	e8 00 00 00 00	 call	 glfwGetKey
  001c5	83 f8 01	 cmp	 eax, 1
  001c8	75 1a		 jne	 SHORT $LN12@process_in

; 99   :         entity->pos.Z -= mov_speed;

  001ca	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  001cf	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [rax+24]
  001d4	f3 0f 5c 44 24
	20		 subss	 xmm0, DWORD PTR mov_speed$[rsp]
  001da	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  001df	f3 0f 11 40 18	 movss	 DWORD PTR [rax+24], xmm0
$LN12@process_in:

; 100  :     if(glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)

  001e4	ba 41 00 00 00	 mov	 edx, 65			; 00000041H
  001e9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR window$[rsp]
  001ee	e8 00 00 00 00	 call	 glfwGetKey
  001f3	83 f8 01	 cmp	 eax, 1
  001f6	75 1a		 jne	 SHORT $LN13@process_in

; 101  :         entity->pos.X += mov_speed;

  001f8	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  001fd	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [rax+16]
  00202	f3 0f 58 44 24
	20		 addss	 xmm0, DWORD PTR mov_speed$[rsp]
  00208	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  0020d	f3 0f 11 40 10	 movss	 DWORD PTR [rax+16], xmm0
$LN13@process_in:

; 102  :     if(glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)

  00212	ba 44 00 00 00	 mov	 edx, 68			; 00000044H
  00217	48 8b 4c 24 50	 mov	 rcx, QWORD PTR window$[rsp]
  0021c	e8 00 00 00 00	 call	 glfwGetKey
  00221	83 f8 01	 cmp	 eax, 1
  00224	75 1a		 jne	 SHORT $LN14@process_in

; 103  :         entity->pos.X -= mov_speed;

  00226	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  0022b	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [rax+16]
  00230	f3 0f 5c 44 24
	20		 subss	 xmm0, DWORD PTR mov_speed$[rsp]
  00236	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  0023b	f3 0f 11 40 10	 movss	 DWORD PTR [rax+16], xmm0
$LN14@process_in:

; 104  :     if(glfwGetKey(window, GLFW_KEY_SPACE) == GLFW_PRESS)

  00240	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00245	48 8b 4c 24 50	 mov	 rcx, QWORD PTR window$[rsp]
  0024a	e8 00 00 00 00	 call	 glfwGetKey
  0024f	83 f8 01	 cmp	 eax, 1
  00252	75 1a		 jne	 SHORT $LN15@process_in

; 105  :         entity->pos.Y += mov_speed;

  00254	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  00259	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [rax+20]
  0025e	f3 0f 58 44 24
	20		 addss	 xmm0, DWORD PTR mov_speed$[rsp]
  00264	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  00269	f3 0f 11 40 14	 movss	 DWORD PTR [rax+20], xmm0
$LN15@process_in:

; 106  :     if(glfwGetKey(window, GLFW_KEY_LEFT_CONTROL) == GLFW_PRESS)

  0026e	ba 55 01 00 00	 mov	 edx, 341		; 00000155H
  00273	48 8b 4c 24 50	 mov	 rcx, QWORD PTR window$[rsp]
  00278	e8 00 00 00 00	 call	 glfwGetKey
  0027d	83 f8 01	 cmp	 eax, 1
  00280	75 1a		 jne	 SHORT $LN16@process_in

; 107  :         entity->pos.Y -= mov_speed;

  00282	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  00287	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [rax+20]
  0028c	f3 0f 5c 44 24
	20		 subss	 xmm0, DWORD PTR mov_speed$[rsp]
  00292	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  00297	f3 0f 11 40 14	 movss	 DWORD PTR [rax+20], xmm0
$LN16@process_in:

; 108  :     
; 109  :     if(glfwGetKey(window, GLFW_KEY_T) == GLFW_PRESS)

  0029c	ba 54 00 00 00	 mov	 edx, 84			; 00000054H
  002a1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR window$[rsp]
  002a6	e8 00 00 00 00	 call	 glfwGetKey
  002ab	83 f8 01	 cmp	 eax, 1
  002ae	75 1a		 jne	 SHORT $LN17@process_in

; 110  :         entity->scale.Z += mov_speed;

  002b0	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  002b5	f3 0f 10 40 30	 movss	 xmm0, DWORD PTR [rax+48]
  002ba	f3 0f 58 44 24
	20		 addss	 xmm0, DWORD PTR mov_speed$[rsp]
  002c0	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  002c5	f3 0f 11 40 30	 movss	 DWORD PTR [rax+48], xmm0
$LN17@process_in:

; 111  :     if(glfwGetKey(window, GLFW_KEY_G) == GLFW_PRESS)

  002ca	ba 47 00 00 00	 mov	 edx, 71			; 00000047H
  002cf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR window$[rsp]
  002d4	e8 00 00 00 00	 call	 glfwGetKey
  002d9	83 f8 01	 cmp	 eax, 1
  002dc	75 1a		 jne	 SHORT $LN18@process_in

; 112  :         entity->scale.Z -= mov_speed;

  002de	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  002e3	f3 0f 10 40 30	 movss	 xmm0, DWORD PTR [rax+48]
  002e8	f3 0f 5c 44 24
	20		 subss	 xmm0, DWORD PTR mov_speed$[rsp]
  002ee	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  002f3	f3 0f 11 40 30	 movss	 DWORD PTR [rax+48], xmm0
$LN18@process_in:

; 113  :     if(glfwGetKey(window, GLFW_KEY_F) == GLFW_PRESS)

  002f8	ba 46 00 00 00	 mov	 edx, 70			; 00000046H
  002fd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR window$[rsp]
  00302	e8 00 00 00 00	 call	 glfwGetKey
  00307	83 f8 01	 cmp	 eax, 1
  0030a	75 1a		 jne	 SHORT $LN19@process_in

; 114  :         entity->scale.X += mov_speed;

  0030c	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  00311	f3 0f 10 40 28	 movss	 xmm0, DWORD PTR [rax+40]
  00316	f3 0f 58 44 24
	20		 addss	 xmm0, DWORD PTR mov_speed$[rsp]
  0031c	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  00321	f3 0f 11 40 28	 movss	 DWORD PTR [rax+40], xmm0
$LN19@process_in:

; 115  :     if(glfwGetKey(window, GLFW_KEY_H) == GLFW_PRESS)

  00326	ba 48 00 00 00	 mov	 edx, 72			; 00000048H
  0032b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR window$[rsp]
  00330	e8 00 00 00 00	 call	 glfwGetKey
  00335	83 f8 01	 cmp	 eax, 1
  00338	75 1a		 jne	 SHORT $LN20@process_in

; 116  :         entity->scale.X -= mov_speed;

  0033a	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  0033f	f3 0f 10 40 28	 movss	 xmm0, DWORD PTR [rax+40]
  00344	f3 0f 5c 44 24
	20		 subss	 xmm0, DWORD PTR mov_speed$[rsp]
  0034a	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  0034f	f3 0f 11 40 28	 movss	 DWORD PTR [rax+40], xmm0
$LN20@process_in:

; 117  :     if(glfwGetKey(window, GLFW_KEY_R) == GLFW_PRESS)

  00354	ba 52 00 00 00	 mov	 edx, 82			; 00000052H
  00359	48 8b 4c 24 50	 mov	 rcx, QWORD PTR window$[rsp]
  0035e	e8 00 00 00 00	 call	 glfwGetKey
  00363	83 f8 01	 cmp	 eax, 1
  00366	75 1a		 jne	 SHORT $LN21@process_in

; 118  :         entity->scale.Y += mov_speed;

  00368	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  0036d	f3 0f 10 40 2c	 movss	 xmm0, DWORD PTR [rax+44]
  00372	f3 0f 58 44 24
	20		 addss	 xmm0, DWORD PTR mov_speed$[rsp]
  00378	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  0037d	f3 0f 11 40 2c	 movss	 DWORD PTR [rax+44], xmm0
$LN21@process_in:

; 119  :     if(glfwGetKey(window, GLFW_KEY_Y) == GLFW_PRESS)

  00382	ba 59 00 00 00	 mov	 edx, 89			; 00000059H
  00387	48 8b 4c 24 50	 mov	 rcx, QWORD PTR window$[rsp]
  0038c	e8 00 00 00 00	 call	 glfwGetKey
  00391	83 f8 01	 cmp	 eax, 1
  00394	75 1a		 jne	 SHORT $LN22@process_in

; 120  :         entity->scale.Y -= mov_speed;

  00396	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  0039b	f3 0f 10 40 2c	 movss	 xmm0, DWORD PTR [rax+44]
  003a0	f3 0f 5c 44 24
	20		 subss	 xmm0, DWORD PTR mov_speed$[rsp]
  003a6	48 8b 44 24 30	 mov	 rax, QWORD PTR entity$[rsp]
  003ab	f3 0f 11 40 2c	 movss	 DWORD PTR [rax+44], xmm0
$LN22@process_in:

; 121  :     
; 122  :     if(glfwGetKey(window, GLFW_KEY_G) == GLFW_PRESS)

  003b0	ba 47 00 00 00	 mov	 edx, 71			; 00000047H
  003b5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR window$[rsp]
  003ba	e8 00 00 00 00	 call	 glfwGetKey
  003bf	83 f8 01	 cmp	 eax, 1
  003c2	75 0f		 jne	 SHORT $LN23@process_in

; 123  :         gl->gpu_transform = 1;

  003c4	48 8b 44 24 58	 mov	 rax, QWORD PTR gl$[rsp]
  003c9	c7 80 08 01 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+264], 1
$LN23@process_in:

; 124  :     if(glfwGetKey(window, GLFW_KEY_C) == GLFW_PRESS)

  003d3	ba 43 00 00 00	 mov	 edx, 67			; 00000043H
  003d8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR window$[rsp]
  003dd	e8 00 00 00 00	 call	 glfwGetKey
  003e2	83 f8 01	 cmp	 eax, 1
  003e5	75 0f		 jne	 SHORT $LN24@process_in

; 125  :         gl->gpu_transform = 0;

  003e7	48 8b 44 24 58	 mov	 rax, QWORD PTR gl$[rsp]
  003ec	c7 80 08 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+264], 0
$LN24@process_in:

; 126  : }

  003f6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  003fa	c3		 ret	 0
?process_input@@YAXPEAUGLFWwindow@@PEAUgl_renderer@@I@Z ENDP ; process_input
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\main.cpp
_TEXT	SEGMENT
item_width$ = 64
tv65 = 72
$T1 = 80
name$ = 112
value$ = 120
?draw_vec3_widget@@YAXPEBDPEATHMM_Vec3@@@Z PROC		; draw_vec3_widget

; 44   : draw_vec3_widget(const char *name, v3 *value) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 45   :     ImGui::PushID(name);

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR name$[rsp]
  00013	e8 00 00 00 00	 call	 ?PushID@ImGui@@YAXPEBD@Z ; ImGui::PushID

; 46   :     
; 47   :     f32 item_width = (ImGui::GetContentRegionAvail().x - ImGui::GetStyle().ItemSpacing.x * 2) / 4;

  00018	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T1[rsp]
  0001d	e8 00 00 00 00	 call	 ?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ ; ImGui::GetContentRegionAvail
  00022	48 89 44 24 48	 mov	 QWORD PTR tv65[rsp], rax
  00027	e8 00 00 00 00	 call	 ?GetStyle@ImGui@@YAAEAUImGuiStyle@@XZ ; ImGui::GetStyle
  0002c	f3 0f 10 40 4c	 movss	 xmm0, DWORD PTR [rax+76]
  00031	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40000000
  00039	48 8b 44 24 48	 mov	 rax, QWORD PTR tv65[rsp]
  0003e	f3 0f 10 08	 movss	 xmm1, DWORD PTR [rax]
  00042	f3 0f 5c c8	 subss	 xmm1, xmm0
  00046	0f 28 c1	 movaps	 xmm0, xmm1
  00049	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40800000
  00051	f3 0f 11 44 24
	40		 movss	 DWORD PTR item_width$[rsp], xmm0

; 48   :     
; 49   :     ImGui::Text(name);

  00057	48 8b 4c 24 70	 mov	 rcx, QWORD PTR name$[rsp]
  0005c	e8 00 00 00 00	 call	 ?Text@ImGui@@YAXPEBDZZ	; ImGui::Text

; 50   :     
; 51   :     ImGui::PushItemWidth(item_width);

  00061	f3 0f 10 44 24
	40		 movss	 xmm0, DWORD PTR item_width$[rsp]
  00067	e8 00 00 00 00	 call	 ?PushItemWidth@ImGui@@YAXM@Z ; ImGui::PushItemWidth

; 52   :     ImGui::DragFloat("X", &value->X, 0.1f);

  0006c	48 8b 44 24 78	 mov	 rax, QWORD PTR value$[rsp]
  00071	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00079	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG84596
  00080	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00085	0f 57 c0	 xorps	 xmm0, xmm0
  00088	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  0008e	0f 57 db	 xorps	 xmm3, xmm3
  00091	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3dcccccd
  00099	48 8b d0	 mov	 rdx, rax
  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG84597
  000a3	e8 00 00 00 00	 call	 ?DragFloat@ImGui@@YA_NPEBDPEAMMMM0H@Z ; ImGui::DragFloat

; 53   :     ImGui::PopItemWidth();

  000a8	e8 00 00 00 00	 call	 ?PopItemWidth@ImGui@@YAXXZ ; ImGui::PopItemWidth

; 54   :     ImGui::SameLine();

  000ad	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@bf800000
  000b5	0f 57 c0	 xorps	 xmm0, xmm0
  000b8	e8 00 00 00 00	 call	 ?SameLine@ImGui@@YAXMM@Z ; ImGui::SameLine

; 55   :     
; 56   :     ImGui::PushItemWidth(item_width);

  000bd	f3 0f 10 44 24
	40		 movss	 xmm0, DWORD PTR item_width$[rsp]
  000c3	e8 00 00 00 00	 call	 ?PushItemWidth@ImGui@@YAXM@Z ; ImGui::PushItemWidth

; 57   :     ImGui::DragFloat("Y", &value->Y, 0.1f);

  000c8	48 8b 44 24 78	 mov	 rax, QWORD PTR value$[rsp]
  000cd	48 83 c0 04	 add	 rax, 4
  000d1	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  000d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG84598
  000e0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000e5	0f 57 c0	 xorps	 xmm0, xmm0
  000e8	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  000ee	0f 57 db	 xorps	 xmm3, xmm3
  000f1	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3dcccccd
  000f9	48 8b d0	 mov	 rdx, rax
  000fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG84599
  00103	e8 00 00 00 00	 call	 ?DragFloat@ImGui@@YA_NPEBDPEAMMMM0H@Z ; ImGui::DragFloat

; 58   :     ImGui::PopItemWidth();

  00108	e8 00 00 00 00	 call	 ?PopItemWidth@ImGui@@YAXXZ ; ImGui::PopItemWidth

; 59   :     ImGui::SameLine();

  0010d	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@bf800000
  00115	0f 57 c0	 xorps	 xmm0, xmm0
  00118	e8 00 00 00 00	 call	 ?SameLine@ImGui@@YAXMM@Z ; ImGui::SameLine

; 60   :     
; 61   :     ImGui::PushItemWidth(item_width);

  0011d	f3 0f 10 44 24
	40		 movss	 xmm0, DWORD PTR item_width$[rsp]
  00123	e8 00 00 00 00	 call	 ?PushItemWidth@ImGui@@YAXM@Z ; ImGui::PushItemWidth

; 62   :     ImGui::DragFloat("Z", &value->Z, 0.1f);

  00128	48 8b 44 24 78	 mov	 rax, QWORD PTR value$[rsp]
  0012d	48 83 c0 08	 add	 rax, 8
  00131	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00139	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG84600
  00140	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00145	0f 57 c0	 xorps	 xmm0, xmm0
  00148	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  0014e	0f 57 db	 xorps	 xmm3, xmm3
  00151	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3dcccccd
  00159	48 8b d0	 mov	 rdx, rax
  0015c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG84601
  00163	e8 00 00 00 00	 call	 ?DragFloat@ImGui@@YA_NPEBDPEAMMMM0H@Z ; ImGui::DragFloat

; 63   :     ImGui::PopItemWidth();

  00168	e8 00 00 00 00	 call	 ?PopItemWidth@ImGui@@YAXXZ ; ImGui::PopItemWidth

; 64   :     
; 65   :     ImGui::PopID();

  0016d	e8 00 00 00 00	 call	 ?PopID@ImGui@@YAXXZ	; ImGui::PopID

; 66   : }

  00172	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00176	c3		 ret	 0
?draw_vec3_widget@@YAXPEBDPEATHMM_Vec3@@@Z ENDP		; draw_vec3_widget
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\main.cpp
_TEXT	SEGMENT
window$ = 48
width$ = 56
height$ = 64
?framebuffer_size_callback@@YAXPEAUGLFWwindow@@HH@Z PROC ; framebuffer_size_callback

; 39   : {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 40   :     glViewport(0, 0, width, height);

  00012	44 8b 4c 24 40	 mov	 r9d, DWORD PTR height$[rsp]
  00017	44 8b 44 24 38	 mov	 r8d, DWORD PTR width$[rsp]
  0001c	33 d2		 xor	 edx, edx
  0001e	33 c9		 xor	 ecx, ecx
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glViewport

; 41   : }

  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
?framebuffer_size_callback@@YAXPEAUGLFWwindow@@HH@Z ENDP ; framebuffer_size_callback
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\renderer.cpp
_TEXT	SEGMENT
shader$ = 48
cmd$ = 56
i$1 = 64
cam$ = 72
i$2 = 80
i$3 = 84
tv79 = 88
idx$4 = 92
cmd_count$ = 96
verts$5 = 104
v_count$6 = 112
tv147 = 120
tv174 = 128
tv185 = 136
tv249 = 144
tv307 = 152
tv332 = 160
tv357 = 168
tv382 = 176
mat$7 = 184
$T8 = 192
$T9 = 208
$T10 = 224
$T11 = 240
$T12 = 256
$T13 = 272
$T14 = 288
$T15 = 304
$T16 = 320
$T17 = 336
$T18 = 352
$T19 = 368
$T20 = 384
$T21 = 448
$T22 = 512
$T23 = 576
$T24 = 640
$T25 = 704
$T26 = 768
$T27 = 832
$T28 = 896
$T29 = 960
$T30 = 1024
$T31 = 1088
$T32 = 1152
$T33 = 1216
$T34 = 1280
$T35 = 1344
$T36 = 1408
temp$37 = 1472
$T38 = 1488
$T39 = 1504
$T40 = 1520
$T41 = 1536
view$ = 1552
$T42 = 1616
$T43 = 1680
$T44 = 1744
vp$45 = 1808
$T46 = 1872
mvp$47 = 1936
$T48 = 2000
$T49 = 2064
__$ArrayPad$ = 2128
gl$ = 2176
am$ = 2184
p_id$ = 2192
?render@@YAXPEAUgl_renderer@@PEAUasset_manager_t@@I@Z PROC ; render

; 487  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 68 08
	00 00		 sub	 rsp, 2152		; 00000868H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 50
	08 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 488  :     glBindFramebuffer(GL_FRAMEBUFFER, gl->fb.id);

  0002a	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  00032	8b 90 f4 00 00
	00		 mov	 edx, DWORD PTR [rax+244]
  00038	b9 40 8d 00 00	 mov	 ecx, 36160		; 00008d40H
  0003d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewBindFramebuffer
  00044	ff 10		 call	 QWORD PTR [rax]

; 489  :     glEnable(GL_DEPTH_TEST);

  00046	b9 71 0b 00 00	 mov	 ecx, 2929		; 00000b71H
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glEnable

; 490  :     
; 491  :     glClearColor(0.1f, 0.1f, 0.1f, 1.0f);

  00051	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f800000
  00059	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3dcccccd
  00061	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3dcccccd
  00069	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3dcccccd
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glClearColor

; 492  :     glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  00077	b9 00 41 00 00	 mov	 ecx, 16640		; 00004100H
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glClear

; 493  :     
; 494  :     u32 cmd_count = get_stack_count(gl->cmds);

  00082	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  0008a	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0008f	74 15		 je	 SHORT $LN19@render
  00091	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  00099	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0009d	8b 40 fc	 mov	 eax, DWORD PTR [rax-4]
  000a0	89 44 24 58	 mov	 DWORD PTR tv79[rsp], eax
  000a4	eb 08		 jmp	 SHORT $LN20@render
$LN19@render:
  000a6	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN20@render:
  000ae	8b 44 24 58	 mov	 eax, DWORD PTR tv79[rsp]
  000b2	89 44 24 60	 mov	 DWORD PTR cmd_count$[rsp], eax

; 495  :     render_cmd_t *cmd;
; 496  :     
; 497  :     camera_t *cam = gl->camera;

  000b6	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  000be	48 8b 80 10 01
	00 00		 mov	 rax, QWORD PTR [rax+272]
  000c5	48 89 44 24 48	 mov	 QWORD PTR cam$[rsp], rax

; 498  :     mat4 view = HMM_LookAt_RH(cam->pos, HMM_AddV3(cam->pos, cam->front), cam->up);

  000ca	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR $T8[rsp]
  000d2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cam$[rsp]
  000d7	48 8b f8	 mov	 rdi, rax
  000da	48 8d 71 18	 lea	 rsi, QWORD PTR [rcx+24]
  000de	b9 0c 00 00 00	 mov	 ecx, 12
  000e3	f3 a4		 rep movsb
  000e5	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR $T9[rsp]
  000ed	48 8b f8	 mov	 rdi, rax
  000f0	48 8b 74 24 48	 mov	 rsi, QWORD PTR cam$[rsp]
  000f5	b9 0c 00 00 00	 mov	 ecx, 12
  000fa	f3 a4		 rep movsb
  000fc	4c 8d 84 24 c0
	00 00 00	 lea	 r8, QWORD PTR $T8[rsp]
  00104	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR $T9[rsp]
  0010c	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR $T16[rsp]
  00114	e8 00 00 00 00	 call	 HMM_AddV3
  00119	48 8d 8c 24 e0
	05 00 00	 lea	 rcx, QWORD PTR $T39[rsp]
  00121	48 8b f9	 mov	 rdi, rcx
  00124	48 8b f0	 mov	 rsi, rax
  00127	b9 0c 00 00 00	 mov	 ecx, 12
  0012c	f3 a4		 rep movsb
  0012e	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR $T10[rsp]
  00136	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cam$[rsp]
  0013b	48 8b f8	 mov	 rdi, rax
  0013e	48 8d 71 24	 lea	 rsi, QWORD PTR [rcx+36]
  00142	b9 0c 00 00 00	 mov	 ecx, 12
  00147	f3 a4		 rep movsb
  00149	48 8d 84 24 f0
	00 00 00	 lea	 rax, QWORD PTR $T11[rsp]
  00151	48 8d 8c 24 e0
	05 00 00	 lea	 rcx, QWORD PTR $T39[rsp]
  00159	48 8b f8	 mov	 rdi, rax
  0015c	48 8b f1	 mov	 rsi, rcx
  0015f	b9 0c 00 00 00	 mov	 ecx, 12
  00164	f3 a4		 rep movsb
  00166	48 8d 84 24 00
	01 00 00	 lea	 rax, QWORD PTR $T12[rsp]
  0016e	48 8b f8	 mov	 rdi, rax
  00171	48 8b 74 24 48	 mov	 rsi, QWORD PTR cam$[rsp]
  00176	b9 0c 00 00 00	 mov	 ecx, 12
  0017b	f3 a4		 rep movsb
  0017d	4c 8d 8c 24 e0
	00 00 00	 lea	 r9, QWORD PTR $T10[rsp]
  00185	4c 8d 84 24 f0
	00 00 00	 lea	 r8, QWORD PTR $T11[rsp]
  0018d	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR $T12[rsp]
  00195	48 8d 8c 24 80
	04 00 00	 lea	 rcx, QWORD PTR $T32[rsp]
  0019d	e8 00 00 00 00	 call	 HMM_LookAt_RH
  001a2	48 8d 8c 24 d0
	07 00 00	 lea	 rcx, QWORD PTR $T48[rsp]
  001aa	48 8b f9	 mov	 rdi, rcx
  001ad	48 8b f0	 mov	 rsi, rax
  001b0	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  001b5	f3 a4		 rep movsb
  001b7	48 8d 84 24 10
	06 00 00	 lea	 rax, QWORD PTR view$[rsp]
  001bf	48 8d 8c 24 d0
	07 00 00	 lea	 rcx, QWORD PTR $T48[rsp]
  001c7	48 8b f8	 mov	 rdi, rax
  001ca	48 8b f1	 mov	 rsi, rcx
  001cd	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  001d2	f3 a4		 rep movsb

; 499  :     
; 500  :     
; 501  :     glBindVertexArray(gl->vao);

  001d4	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  001dc	8b 48 54	 mov	 ecx, DWORD PTR [rax+84]
  001df	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewBindVertexArray
  001e6	ff 10		 call	 QWORD PTR [rax]

; 502  :     
; 503  :     if(gl->gpu_transform) {

  001e8	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  001f0	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  001f7	0f 84 b1 00 00
	00		 je	 $LN11@render

; 504  :         glBindBuffer(GL_ARRAY_BUFFER, gl->vbos[VBO_VERTS]);

  001fd	b8 04 00 00 00	 mov	 eax, 4
  00202	48 6b c0 00	 imul	 rax, rax, 0
  00206	48 8b 8c 24 80
	08 00 00	 mov	 rcx, QWORD PTR gl$[rsp]
  0020e	8b 54 01 40	 mov	 edx, DWORD PTR [rcx+rax+64]
  00212	b9 92 88 00 00	 mov	 ecx, 34962		; 00008892H
  00217	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewBindBuffer
  0021e	ff 10		 call	 QWORD PTR [rax]

; 505  :         glBufferData(GL_ARRAY_BUFFER, get_stack_size(gl->verts),

  00220	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  00228	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0022c	74 19		 je	 SHORT $LN21@render
  0022e	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  00236	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00239	8b 40 fc	 mov	 eax, DWORD PTR [rax-4]
  0023c	48 6b c0 0c	 imul	 rax, rax, 12
  00240	48 89 44 24 78	 mov	 QWORD PTR tv147[rsp], rax
  00245	eb 09		 jmp	 SHORT $LN22@render
$LN21@render:
  00247	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR tv147[rsp], 0
$LN22@render:
  00250	41 b9 e8 88 00
	00		 mov	 r9d, 35048		; 000088e8H
  00256	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  0025e	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00261	48 8b 54 24 78	 mov	 rdx, QWORD PTR tv147[rsp]
  00266	b9 92 88 00 00	 mov	 ecx, 34962		; 00008892H
  0026b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewBufferData
  00272	ff 10		 call	 QWORD PTR [rax]

; 506  :                      (f32 *)gl->verts, GL_DYNAMIC_DRAW);
; 507  :         glVertexAttribPointer(0, 3, GL_FLOAT, 0, 0, 0);

  00274	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0027d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00285	45 33 c9	 xor	 r9d, r9d
  00288	41 b8 06 14 00
	00		 mov	 r8d, 5126		; 00001406H
  0028e	ba 03 00 00 00	 mov	 edx, 3
  00293	33 c9		 xor	 ecx, ecx
  00295	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewVertexAttribPointer
  0029c	ff 10		 call	 QWORD PTR [rax]

; 508  :         glEnableVertexAttribArray(0);

  0029e	33 c9		 xor	 ecx, ecx
  002a0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewEnableVertexAttribArray
  002a7	ff 10		 call	 QWORD PTR [rax]

; 509  :     }

  002a9	e9 4d 04 00 00	 jmp	 $LN12@render
$LN11@render:

; 510  :     else 
; 511  :     {
; 512  :         cmd = gl->cmds;

  002ae	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  002b6	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  002ba	48 89 44 24 38	 mov	 QWORD PTR cmd$[rsp], rax

; 513  :         
; 514  :         mat4 vp = HMM_MulM4(cam->proj, view);

  002bf	48 8d 84 24 80
	01 00 00	 lea	 rax, QWORD PTR $T20[rsp]
  002c7	48 8d 8c 24 10
	06 00 00	 lea	 rcx, QWORD PTR view$[rsp]
  002cf	48 8b f8	 mov	 rdi, rax
  002d2	48 8b f1	 mov	 rsi, rcx
  002d5	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  002da	f3 a4		 rep movsb
  002dc	48 8d 84 24 c0
	01 00 00	 lea	 rax, QWORD PTR $T21[rsp]
  002e4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cam$[rsp]
  002e9	48 8b f8	 mov	 rdi, rax
  002ec	48 8d 71 60	 lea	 rsi, QWORD PTR [rcx+96]
  002f0	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  002f5	f3 a4		 rep movsb
  002f7	4c 8d 84 24 80
	01 00 00	 lea	 r8, QWORD PTR $T20[rsp]
  002ff	48 8d 94 24 c0
	01 00 00	 lea	 rdx, QWORD PTR $T21[rsp]
  00307	48 8d 8c 24 c0
	04 00 00	 lea	 rcx, QWORD PTR $T33[rsp]
  0030f	e8 00 00 00 00	 call	 HMM_MulM4
  00314	48 8d 8c 24 d0
	06 00 00	 lea	 rcx, QWORD PTR $T44[rsp]
  0031c	48 8b f9	 mov	 rdi, rcx
  0031f	48 8b f0	 mov	 rsi, rax
  00322	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00327	f3 a4		 rep movsb
  00329	48 8d 84 24 10
	07 00 00	 lea	 rax, QWORD PTR vp$45[rsp]
  00331	48 8d 8c 24 d0
	06 00 00	 lea	 rcx, QWORD PTR $T44[rsp]
  00339	48 8b f8	 mov	 rdi, rax
  0033c	48 8b f1	 mov	 rsi, rcx
  0033f	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00344	f3 a4		 rep movsb

; 515  :         mat4 mvp;
; 516  :         
; 517  :         v3 *verts = (v3 *)malloc(get_stack_size(gl->verts));

  00346	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  0034e	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00352	74 1c		 je	 SHORT $LN23@render
  00354	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  0035c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0035f	8b 40 fc	 mov	 eax, DWORD PTR [rax-4]
  00362	48 6b c0 0c	 imul	 rax, rax, 12
  00366	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv174[rsp], rax
  0036e	eb 0c		 jmp	 SHORT $LN24@render
$LN23@render:
  00370	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv174[rsp], 0
$LN24@render:
  0037c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv174[rsp]
  00384	e8 00 00 00 00	 call	 malloc
  00389	48 89 44 24 68	 mov	 QWORD PTR verts$5[rsp], rax

; 518  :         memcpy(verts, gl->verts, get_stack_size(gl->verts));

  0038e	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  00396	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0039a	74 1c		 je	 SHORT $LN25@render
  0039c	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  003a4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003a7	8b 40 fc	 mov	 eax, DWORD PTR [rax-4]
  003aa	48 6b c0 0c	 imul	 rax, rax, 12
  003ae	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv185[rsp], rax
  003b6	eb 0c		 jmp	 SHORT $LN26@render
$LN25@render:
  003b8	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv185[rsp], 0
$LN26@render:
  003c4	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR tv185[rsp]
  003cc	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  003d4	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  003d7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR verts$5[rsp]
  003dc	e8 00 00 00 00	 call	 memcpy

; 519  :         
; 520  :         for(u32 i = 0; i < cmd_count; i++, cmd++) {

  003e1	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  003e9	eb 18		 jmp	 SHORT $LN4@render
$LN2@render:
  003eb	8b 44 24 50	 mov	 eax, DWORD PTR i$2[rsp]
  003ef	ff c0		 inc	 eax
  003f1	89 44 24 50	 mov	 DWORD PTR i$2[rsp], eax
  003f5	48 8b 44 24 38	 mov	 rax, QWORD PTR cmd$[rsp]
  003fa	48 83 c0 18	 add	 rax, 24
  003fe	48 89 44 24 38	 mov	 QWORD PTR cmd$[rsp], rax
$LN4@render:
  00403	8b 44 24 60	 mov	 eax, DWORD PTR cmd_count$[rsp]
  00407	39 44 24 50	 cmp	 DWORD PTR i$2[rsp], eax
  0040b	0f 83 31 02 00
	00		 jae	 $LN3@render

; 521  :             u32 v_count = am->meshes[cmd->mesh_id].vert_count;

  00411	48 8b 44 24 38	 mov	 rax, QWORD PTR cmd$[rsp]
  00416	8b 00		 mov	 eax, DWORD PTR [rax]
  00418	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  0041c	48 8b 8c 24 88
	08 00 00	 mov	 rcx, QWORD PTR am$[rsp]
  00424	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00427	8b 44 01 28	 mov	 eax, DWORD PTR [rcx+rax+40]
  0042b	89 44 24 70	 mov	 DWORD PTR v_count$6[rsp], eax

; 522  :             u32 idx = cmd->vert_idx;

  0042f	48 8b 44 24 38	 mov	 rax, QWORD PTR cmd$[rsp]
  00434	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00437	89 44 24 5c	 mov	 DWORD PTR idx$4[rsp], eax

; 523  :             
; 524  :             mvp = HMM_MulM4(vp, gl->transforms[cmd->trans_id]);

  0043b	48 8b 44 24 38	 mov	 rax, QWORD PTR cmd$[rsp]
  00440	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00443	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  00447	48 8b 8c 24 80
	08 00 00	 mov	 rcx, QWORD PTR gl$[rsp]
  0044f	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00453	48 8d 94 24 00
	02 00 00	 lea	 rdx, QWORD PTR $T22[rsp]
  0045b	48 8b fa	 mov	 rdi, rdx
  0045e	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  00462	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00467	f3 a4		 rep movsb
  00469	48 8d 84 24 40
	02 00 00	 lea	 rax, QWORD PTR $T23[rsp]
  00471	48 8d 8c 24 10
	07 00 00	 lea	 rcx, QWORD PTR vp$45[rsp]
  00479	48 8b f8	 mov	 rdi, rax
  0047c	48 8b f1	 mov	 rsi, rcx
  0047f	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00484	f3 a4		 rep movsb
  00486	4c 8d 84 24 00
	02 00 00	 lea	 r8, QWORD PTR $T22[rsp]
  0048e	48 8d 94 24 40
	02 00 00	 lea	 rdx, QWORD PTR $T23[rsp]
  00496	48 8d 8c 24 00
	05 00 00	 lea	 rcx, QWORD PTR $T34[rsp]
  0049e	e8 00 00 00 00	 call	 HMM_MulM4
  004a3	48 8d 8c 24 50
	07 00 00	 lea	 rcx, QWORD PTR $T46[rsp]
  004ab	48 8b f9	 mov	 rdi, rcx
  004ae	48 8b f0	 mov	 rsi, rax
  004b1	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  004b6	f3 a4		 rep movsb
  004b8	48 8d 84 24 90
	07 00 00	 lea	 rax, QWORD PTR mvp$47[rsp]
  004c0	48 8d 8c 24 50
	07 00 00	 lea	 rcx, QWORD PTR $T46[rsp]
  004c8	48 8b f8	 mov	 rdi, rax
  004cb	48 8b f1	 mov	 rsi, rcx
  004ce	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  004d3	f3 a4		 rep movsb

; 525  :             
; 526  :             for(u32 i = 0; i < v_count; i++) {

  004d5	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  004dd	eb 0a		 jmp	 SHORT $LN7@render
$LN5@render:
  004df	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  004e3	ff c0		 inc	 eax
  004e5	89 44 24 40	 mov	 DWORD PTR i$1[rsp], eax
$LN7@render:
  004e9	8b 44 24 70	 mov	 eax, DWORD PTR v_count$6[rsp]
  004ed	39 44 24 40	 cmp	 DWORD PTR i$1[rsp], eax
  004f1	0f 83 46 01 00
	00		 jae	 $LN6@render

; 527  :                 v4 temp =HMM_MulM4V4(mvp, HMM_V4V(gl->verts[i+idx], 1.0f));

  004f7	8b 44 24 5c	 mov	 eax, DWORD PTR idx$4[rsp]
  004fb	8b 4c 24 40	 mov	 ecx, DWORD PTR i$1[rsp]
  004ff	03 c8		 add	 ecx, eax
  00501	8b c1		 mov	 eax, ecx
  00503	8b c0		 mov	 eax, eax
  00505	48 6b c0 0c	 imul	 rax, rax, 12
  00509	48 8b 8c 24 80
	08 00 00	 mov	 rcx, QWORD PTR gl$[rsp]
  00511	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00514	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR $T13[rsp]
  0051c	48 8b fa	 mov	 rdi, rdx
  0051f	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  00523	b9 0c 00 00 00	 mov	 ecx, 12
  00528	f3 a4		 rep movsb
  0052a	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f800000
  00532	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR $T13[rsp]
  0053a	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR $T18[rsp]
  00542	e8 00 00 00 00	 call	 HMM_V4V
  00547	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  0054a	66 0f 7f 84 24
	00 06 00 00	 movdqa	 XMMWORD PTR $T41[rsp], xmm0
  00553	0f 28 84 24 00
	06 00 00	 movaps	 xmm0, XMMWORD PTR $T41[rsp]
  0055b	66 0f 7f 84 24
	30 01 00 00	 movdqa	 XMMWORD PTR $T15[rsp], xmm0
  00564	48 8d 84 24 80
	02 00 00	 lea	 rax, QWORD PTR $T24[rsp]
  0056c	48 8d 8c 24 90
	07 00 00	 lea	 rcx, QWORD PTR mvp$47[rsp]
  00574	48 8b f8	 mov	 rdi, rax
  00577	48 8b f1	 mov	 rsi, rcx
  0057a	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0057f	f3 a4		 rep movsb
  00581	4c 8d 84 24 30
	01 00 00	 lea	 r8, QWORD PTR $T15[rsp]
  00589	48 8d 94 24 80
	02 00 00	 lea	 rdx, QWORD PTR $T24[rsp]
  00591	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR $T19[rsp]
  00599	e8 00 00 00 00	 call	 HMM_MulM4V4
  0059e	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  005a1	66 0f 7f 84 24
	f0 05 00 00	 movdqa	 XMMWORD PTR $T40[rsp], xmm0
  005aa	0f 28 84 24 f0
	05 00 00	 movaps	 xmm0, XMMWORD PTR $T40[rsp]
  005b2	66 0f 7f 84 24
	c0 05 00 00	 movdqa	 XMMWORD PTR temp$37[rsp], xmm0

; 528  :                 verts[i+idx] = HMM_DivV3F(temp.XYZ, temp.W);

  005bb	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR $T14[rsp]
  005c3	48 8d 8c 24 c0
	05 00 00	 lea	 rcx, QWORD PTR temp$37[rsp]
  005cb	48 8b f8	 mov	 rdi, rax
  005ce	48 8b f1	 mov	 rsi, rcx
  005d1	b9 0c 00 00 00	 mov	 ecx, 12
  005d6	f3 a4		 rep movsb
  005d8	f3 0f 10 94 24
	cc 05 00 00	 movss	 xmm2, DWORD PTR temp$37[rsp+12]
  005e1	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR $T14[rsp]
  005e9	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR $T17[rsp]
  005f1	e8 00 00 00 00	 call	 HMM_DivV3F
  005f6	48 8d 8c 24 d0
	05 00 00	 lea	 rcx, QWORD PTR $T38[rsp]
  005fe	48 8b f9	 mov	 rdi, rcx
  00601	48 8b f0	 mov	 rsi, rax
  00604	b9 0c 00 00 00	 mov	 ecx, 12
  00609	f3 a4		 rep movsb
  0060b	8b 44 24 5c	 mov	 eax, DWORD PTR idx$4[rsp]
  0060f	8b 4c 24 40	 mov	 ecx, DWORD PTR i$1[rsp]
  00613	03 c8		 add	 ecx, eax
  00615	8b c1		 mov	 eax, ecx
  00617	8b c0		 mov	 eax, eax
  00619	48 6b c0 0c	 imul	 rax, rax, 12
  0061d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR verts$5[rsp]
  00622	48 8d 94 24 d0
	05 00 00	 lea	 rdx, QWORD PTR $T38[rsp]
  0062a	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]
  0062e	48 8b f2	 mov	 rsi, rdx
  00631	b9 0c 00 00 00	 mov	 ecx, 12
  00636	f3 a4		 rep movsb

; 529  :             }

  00638	e9 a2 fe ff ff	 jmp	 $LN5@render
$LN6@render:

; 530  :         }

  0063d	e9 a9 fd ff ff	 jmp	 $LN2@render
$LN3@render:

; 531  :         
; 532  :         glBindBuffer(GL_ARRAY_BUFFER, gl->vbos[VBO_VERTS]);

  00642	b8 04 00 00 00	 mov	 eax, 4
  00647	48 6b c0 00	 imul	 rax, rax, 0
  0064b	48 8b 8c 24 80
	08 00 00	 mov	 rcx, QWORD PTR gl$[rsp]
  00653	8b 54 01 40	 mov	 edx, DWORD PTR [rcx+rax+64]
  00657	b9 92 88 00 00	 mov	 ecx, 34962		; 00008892H
  0065c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewBindBuffer
  00663	ff 10		 call	 QWORD PTR [rax]

; 533  :         glBufferData(GL_ARRAY_BUFFER, get_stack_size(gl->verts),

  00665	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  0066d	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00671	74 1c		 je	 SHORT $LN27@render
  00673	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  0067b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0067e	8b 40 fc	 mov	 eax, DWORD PTR [rax-4]
  00681	48 6b c0 0c	 imul	 rax, rax, 12
  00685	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv249[rsp], rax
  0068d	eb 0c		 jmp	 SHORT $LN28@render
$LN27@render:
  0068f	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv249[rsp], 0
$LN28@render:
  0069b	41 b9 e8 88 00
	00		 mov	 r9d, 35048		; 000088e8H
  006a1	4c 8b 44 24 68	 mov	 r8, QWORD PTR verts$5[rsp]
  006a6	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR tv249[rsp]
  006ae	b9 92 88 00 00	 mov	 ecx, 34962		; 00008892H
  006b3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewBufferData
  006ba	ff 10		 call	 QWORD PTR [rax]

; 534  :                      (f32 *)verts, GL_DYNAMIC_DRAW);
; 535  :         glVertexAttribPointer(0, 3, GL_FLOAT, 0, 0, 0);

  006bc	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  006c5	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  006cd	45 33 c9	 xor	 r9d, r9d
  006d0	41 b8 06 14 00
	00		 mov	 r8d, 5126		; 00001406H
  006d6	ba 03 00 00 00	 mov	 edx, 3
  006db	33 c9		 xor	 ecx, ecx
  006dd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewVertexAttribPointer
  006e4	ff 10		 call	 QWORD PTR [rax]

; 536  :         glEnableVertexAttribArray(0);

  006e6	33 c9		 xor	 ecx, ecx
  006e8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewEnableVertexAttribArray
  006ef	ff 10		 call	 QWORD PTR [rax]

; 537  :         
; 538  :         free(verts);

  006f1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR verts$5[rsp]
  006f6	e8 00 00 00 00	 call	 free
$LN12@render:

; 539  :     }
; 540  :     
; 541  :     glBindBuffer(GL_ARRAY_BUFFER, gl->vbos[VBO_UVS]);

  006fb	b8 04 00 00 00	 mov	 eax, 4
  00700	48 6b c0 01	 imul	 rax, rax, 1
  00704	48 8b 8c 24 80
	08 00 00	 mov	 rcx, QWORD PTR gl$[rsp]
  0070c	8b 54 01 40	 mov	 edx, DWORD PTR [rcx+rax+64]
  00710	b9 92 88 00 00	 mov	 ecx, 34962		; 00008892H
  00715	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewBindBuffer
  0071c	ff 10		 call	 QWORD PTR [rax]

; 542  :     glBufferData(GL_ARRAY_BUFFER, get_stack_size(gl->uvs),

  0071e	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  00726	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0072b	74 1d		 je	 SHORT $LN29@render
  0072d	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  00735	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00739	8b 40 fc	 mov	 eax, DWORD PTR [rax-4]
  0073c	48 c1 e0 03	 shl	 rax, 3
  00740	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv307[rsp], rax
  00748	eb 0c		 jmp	 SHORT $LN30@render
$LN29@render:
  0074a	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv307[rsp], 0
$LN30@render:
  00756	41 b9 e8 88 00
	00		 mov	 r9d, 35048		; 000088e8H
  0075c	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  00764	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  00768	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR tv307[rsp]
  00770	b9 92 88 00 00	 mov	 ecx, 34962		; 00008892H
  00775	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewBufferData
  0077c	ff 10		 call	 QWORD PTR [rax]

; 543  :                  (f32 *)gl->uvs, GL_DYNAMIC_DRAW);
; 544  :     glVertexAttribPointer(1, 2, GL_FLOAT, 0, 0, 0);

  0077e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00787	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0078f	45 33 c9	 xor	 r9d, r9d
  00792	41 b8 06 14 00
	00		 mov	 r8d, 5126		; 00001406H
  00798	ba 02 00 00 00	 mov	 edx, 2
  0079d	b9 01 00 00 00	 mov	 ecx, 1
  007a2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewVertexAttribPointer
  007a9	ff 10		 call	 QWORD PTR [rax]

; 545  :     glEnableVertexAttribArray(1);

  007ab	b9 01 00 00 00	 mov	 ecx, 1
  007b0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewEnableVertexAttribArray
  007b7	ff 10		 call	 QWORD PTR [rax]

; 546  :     
; 547  :     glBindBuffer(GL_ARRAY_BUFFER, gl->vbos[VBO_COLORS]);

  007b9	b8 04 00 00 00	 mov	 eax, 4
  007be	48 6b c0 02	 imul	 rax, rax, 2
  007c2	48 8b 8c 24 80
	08 00 00	 mov	 rcx, QWORD PTR gl$[rsp]
  007ca	8b 54 01 40	 mov	 edx, DWORD PTR [rcx+rax+64]
  007ce	b9 92 88 00 00	 mov	 ecx, 34962		; 00008892H
  007d3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewBindBuffer
  007da	ff 10		 call	 QWORD PTR [rax]

; 548  :     glBufferData(GL_ARRAY_BUFFER, get_stack_size(gl->colors),

  007dc	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  007e4	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  007e9	74 1d		 je	 SHORT $LN31@render
  007eb	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  007f3	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  007f7	8b 40 fc	 mov	 eax, DWORD PTR [rax-4]
  007fa	48 c1 e0 02	 shl	 rax, 2
  007fe	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv332[rsp], rax
  00806	eb 0c		 jmp	 SHORT $LN32@render
$LN31@render:
  00808	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv332[rsp], 0
$LN32@render:
  00814	41 b9 e8 88 00
	00		 mov	 r9d, 35048		; 000088e8H
  0081a	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  00822	4c 8b 40 10	 mov	 r8, QWORD PTR [rax+16]
  00826	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR tv332[rsp]
  0082e	b9 92 88 00 00	 mov	 ecx, 34962		; 00008892H
  00833	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewBufferData
  0083a	ff 10		 call	 QWORD PTR [rax]

; 549  :                  (f32 *)gl->colors, GL_DYNAMIC_DRAW);
; 550  :     glVertexAttribPointer(2, 4, GL_UNSIGNED_BYTE, GL_TRUE, 0, 0);

  0083c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00845	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0084d	41 b1 01	 mov	 r9b, 1
  00850	41 b8 01 14 00
	00		 mov	 r8d, 5121		; 00001401H
  00856	ba 04 00 00 00	 mov	 edx, 4
  0085b	b9 02 00 00 00	 mov	 ecx, 2
  00860	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewVertexAttribPointer
  00867	ff 10		 call	 QWORD PTR [rax]

; 551  :     glEnableVertexAttribArray(2);

  00869	b9 02 00 00 00	 mov	 ecx, 2
  0086e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewEnableVertexAttribArray
  00875	ff 10		 call	 QWORD PTR [rax]

; 552  :     
; 553  :     glBindBuffer(GL_ARRAY_BUFFER, gl->vbos[VBO_NORMS]);

  00877	b8 04 00 00 00	 mov	 eax, 4
  0087c	48 6b c0 03	 imul	 rax, rax, 3
  00880	48 8b 8c 24 80
	08 00 00	 mov	 rcx, QWORD PTR gl$[rsp]
  00888	8b 54 01 40	 mov	 edx, DWORD PTR [rcx+rax+64]
  0088c	b9 92 88 00 00	 mov	 ecx, 34962		; 00008892H
  00891	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewBindBuffer
  00898	ff 10		 call	 QWORD PTR [rax]

; 554  :     glBufferData(GL_ARRAY_BUFFER, get_stack_size(gl->norms),

  0089a	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  008a2	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  008a7	74 1d		 je	 SHORT $LN33@render
  008a9	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  008b1	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  008b5	8b 40 fc	 mov	 eax, DWORD PTR [rax-4]
  008b8	48 6b c0 0c	 imul	 rax, rax, 12
  008bc	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv357[rsp], rax
  008c4	eb 0c		 jmp	 SHORT $LN34@render
$LN33@render:
  008c6	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv357[rsp], 0
$LN34@render:
  008d2	41 b9 e8 88 00
	00		 mov	 r9d, 35048		; 000088e8H
  008d8	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  008e0	4c 8b 40 18	 mov	 r8, QWORD PTR [rax+24]
  008e4	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR tv357[rsp]
  008ec	b9 92 88 00 00	 mov	 ecx, 34962		; 00008892H
  008f1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewBufferData
  008f8	ff 10		 call	 QWORD PTR [rax]

; 555  :                  (f32 *)gl->norms, GL_DYNAMIC_DRAW);
; 556  :     glVertexAttribPointer(3, 3, GL_FLOAT, 0, 0, 0);

  008fa	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00903	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0090b	45 33 c9	 xor	 r9d, r9d
  0090e	41 b8 06 14 00
	00		 mov	 r8d, 5126		; 00001406H
  00914	ba 03 00 00 00	 mov	 edx, 3
  00919	b9 03 00 00 00	 mov	 ecx, 3
  0091e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewVertexAttribPointer
  00925	ff 10		 call	 QWORD PTR [rax]

; 557  :     glEnableVertexAttribArray(3);

  00927	b9 03 00 00 00	 mov	 ecx, 3
  0092c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewEnableVertexAttribArray
  00933	ff 10		 call	 QWORD PTR [rax]

; 558  :     
; 559  :     glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, gl->vbos[VBO_INDICES]);

  00935	b8 04 00 00 00	 mov	 eax, 4
  0093a	48 6b c0 04	 imul	 rax, rax, 4
  0093e	48 8b 8c 24 80
	08 00 00	 mov	 rcx, QWORD PTR gl$[rsp]
  00946	8b 54 01 40	 mov	 edx, DWORD PTR [rcx+rax+64]
  0094a	b9 93 88 00 00	 mov	 ecx, 34963		; 00008893H
  0094f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewBindBuffer
  00956	ff 10		 call	 QWORD PTR [rax]

; 560  :     glBufferData(GL_ELEMENT_ARRAY_BUFFER, get_stack_size(gl->indices),

  00958	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  00960	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00965	74 1d		 je	 SHORT $LN35@render
  00967	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  0096f	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00973	8b 40 fc	 mov	 eax, DWORD PTR [rax-4]
  00976	48 c1 e0 02	 shl	 rax, 2
  0097a	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv382[rsp], rax
  00982	eb 0c		 jmp	 SHORT $LN36@render
$LN35@render:
  00984	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv382[rsp], 0
$LN36@render:
  00990	41 b9 e8 88 00
	00		 mov	 r9d, 35048		; 000088e8H
  00996	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  0099e	4c 8b 40 20	 mov	 r8, QWORD PTR [rax+32]
  009a2	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR tv382[rsp]
  009aa	b9 93 88 00 00	 mov	 ecx, 34963		; 00008893H
  009af	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewBufferData
  009b6	ff 10		 call	 QWORD PTR [rax]

; 561  :                  gl->indices, GL_DYNAMIC_DRAW);
; 562  :     
; 563  :     u32 shader = get_shader(gl, p_id);

  009b8	8b 94 24 90 08
	00 00		 mov	 edx, DWORD PTR p_id$[rsp]
  009bf	48 8b 8c 24 80
	08 00 00	 mov	 rcx, QWORD PTR gl$[rsp]
  009c7	e8 00 00 00 00	 call	 ?get_shader@@YAIPEAUgl_renderer@@I@Z ; get_shader
  009cc	89 44 24 30	 mov	 DWORD PTR shader$[rsp], eax

; 564  :     glUseProgram(shader);

  009d0	8b 4c 24 30	 mov	 ecx, DWORD PTR shader$[rsp]
  009d4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewUseProgram
  009db	ff 10		 call	 QWORD PTR [rax]

; 565  :     
; 566  :     if(gl->gpu_transform) {

  009dd	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  009e5	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  009ec	74 6d		 je	 SHORT $LN13@render

; 567  :         set_uniform_mat4(shader, "proj", cam->proj);

  009ee	48 8d 84 24 c0
	02 00 00	 lea	 rax, QWORD PTR $T25[rsp]
  009f6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cam$[rsp]
  009fb	48 8b f8	 mov	 rdi, rax
  009fe	48 8d 71 60	 lea	 rsi, QWORD PTR [rcx+96]
  00a02	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00a07	f3 a4		 rep movsb
  00a09	4c 8d 84 24 c0
	02 00 00	 lea	 r8, QWORD PTR $T25[rsp]
  00a11	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG84556
  00a18	8b 4c 24 30	 mov	 ecx, DWORD PTR shader$[rsp]
  00a1c	e8 00 00 00 00	 call	 ?set_uniform_mat4@@YAXIPEBDTHMM_Mat4@@@Z ; set_uniform_mat4

; 568  :         set_uniform_mat4(shader, "view", view);

  00a21	48 8d 84 24 00
	03 00 00	 lea	 rax, QWORD PTR $T26[rsp]
  00a29	48 8d 8c 24 10
	06 00 00	 lea	 rcx, QWORD PTR view$[rsp]
  00a31	48 8b f8	 mov	 rdi, rax
  00a34	48 8b f1	 mov	 rsi, rcx
  00a37	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00a3c	f3 a4		 rep movsb
  00a3e	4c 8d 84 24 00
	03 00 00	 lea	 r8, QWORD PTR $T26[rsp]
  00a46	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG84557
  00a4d	8b 4c 24 30	 mov	 ecx, DWORD PTR shader$[rsp]
  00a51	e8 00 00 00 00	 call	 ?set_uniform_mat4@@YAXIPEBDTHMM_Mat4@@@Z ; set_uniform_mat4

; 569  :     }

  00a56	e9 be 00 00 00	 jmp	 $LN14@render
$LN13@render:

; 570  :     else {
; 571  :         set_uniform_mat4(shader, "proj", HMM_M4D(1.0f));

  00a5b	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00a63	48 8d 8c 24 40
	05 00 00	 lea	 rcx, QWORD PTR $T35[rsp]
  00a6b	e8 00 00 00 00	 call	 HMM_M4D
  00a70	48 8d 8c 24 50
	06 00 00	 lea	 rcx, QWORD PTR $T42[rsp]
  00a78	48 8b f9	 mov	 rdi, rcx
  00a7b	48 8b f0	 mov	 rsi, rax
  00a7e	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00a83	f3 a4		 rep movsb
  00a85	48 8d 84 24 40
	03 00 00	 lea	 rax, QWORD PTR $T27[rsp]
  00a8d	48 8d 8c 24 50
	06 00 00	 lea	 rcx, QWORD PTR $T42[rsp]
  00a95	48 8b f8	 mov	 rdi, rax
  00a98	48 8b f1	 mov	 rsi, rcx
  00a9b	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00aa0	f3 a4		 rep movsb
  00aa2	4c 8d 84 24 40
	03 00 00	 lea	 r8, QWORD PTR $T27[rsp]
  00aaa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG84558
  00ab1	8b 4c 24 30	 mov	 ecx, DWORD PTR shader$[rsp]
  00ab5	e8 00 00 00 00	 call	 ?set_uniform_mat4@@YAXIPEBDTHMM_Mat4@@@Z ; set_uniform_mat4

; 572  :         set_uniform_mat4(shader, "view", HMM_M4D(1.0f));

  00aba	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00ac2	48 8d 8c 24 80
	05 00 00	 lea	 rcx, QWORD PTR $T36[rsp]
  00aca	e8 00 00 00 00	 call	 HMM_M4D
  00acf	48 8d 8c 24 90
	06 00 00	 lea	 rcx, QWORD PTR $T43[rsp]
  00ad7	48 8b f9	 mov	 rdi, rcx
  00ada	48 8b f0	 mov	 rsi, rax
  00add	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00ae2	f3 a4		 rep movsb
  00ae4	48 8d 84 24 80
	03 00 00	 lea	 rax, QWORD PTR $T28[rsp]
  00aec	48 8d 8c 24 90
	06 00 00	 lea	 rcx, QWORD PTR $T43[rsp]
  00af4	48 8b f8	 mov	 rdi, rax
  00af7	48 8b f1	 mov	 rsi, rcx
  00afa	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00aff	f3 a4		 rep movsb
  00b01	4c 8d 84 24 80
	03 00 00	 lea	 r8, QWORD PTR $T28[rsp]
  00b09	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG84559
  00b10	8b 4c 24 30	 mov	 ecx, DWORD PTR shader$[rsp]
  00b14	e8 00 00 00 00	 call	 ?set_uniform_mat4@@YAXIPEBDTHMM_Mat4@@@Z ; set_uniform_mat4
$LN14@render:

; 573  :     }
; 574  :     
; 575  :     bind_lights(gl->lights, gl->light_count, shader);

  00b19	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  00b21	48 83 c0 60	 add	 rax, 96			; 00000060H
  00b25	44 8b 44 24 30	 mov	 r8d, DWORD PTR shader$[rsp]
  00b2a	48 8b 8c 24 80
	08 00 00	 mov	 rcx, QWORD PTR gl$[rsp]
  00b32	8b 91 f0 00 00
	00		 mov	 edx, DWORD PTR [rcx+240]
  00b38	48 8b c8	 mov	 rcx, rax
  00b3b	e8 00 00 00 00	 call	 ?bind_lights@@YAXPEAUlight_t@@II@Z ; bind_lights

; 576  :     
; 577  :     set_uniform_float(shader, "near", cam->near);

  00b40	48 8b 44 24 48	 mov	 rax, QWORD PTR cam$[rsp]
  00b45	f3 0f 10 50 58	 movss	 xmm2, DWORD PTR [rax+88]
  00b4a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG84560
  00b51	8b 4c 24 30	 mov	 ecx, DWORD PTR shader$[rsp]
  00b55	e8 00 00 00 00	 call	 ?set_uniform_float@@YAXIPEBDM@Z ; set_uniform_float

; 578  :     set_uniform_float(shader, "far", cam->far);

  00b5a	48 8b 44 24 48	 mov	 rax, QWORD PTR cam$[rsp]
  00b5f	f3 0f 10 50 5c	 movss	 xmm2, DWORD PTR [rax+92]
  00b64	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG84561
  00b6b	8b 4c 24 30	 mov	 ecx, DWORD PTR shader$[rsp]
  00b6f	e8 00 00 00 00	 call	 ?set_uniform_float@@YAXIPEBDM@Z ; set_uniform_float

; 579  :     
; 580  :     cmd = gl->cmds;

  00b74	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  00b7c	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00b80	48 89 44 24 38	 mov	 QWORD PTR cmd$[rsp], rax

; 581  :     for(u32 i = 0; i < cmd_count; i++, cmd++) {

  00b85	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$3[rsp], 0
  00b8d	eb 18		 jmp	 SHORT $LN10@render
$LN8@render:
  00b8f	8b 44 24 54	 mov	 eax, DWORD PTR i$3[rsp]
  00b93	ff c0		 inc	 eax
  00b95	89 44 24 54	 mov	 DWORD PTR i$3[rsp], eax
  00b99	48 8b 44 24 38	 mov	 rax, QWORD PTR cmd$[rsp]
  00b9e	48 83 c0 18	 add	 rax, 24
  00ba2	48 89 44 24 38	 mov	 QWORD PTR cmd$[rsp], rax
$LN10@render:
  00ba7	8b 44 24 60	 mov	 eax, DWORD PTR cmd_count$[rsp]
  00bab	39 44 24 54	 cmp	 DWORD PTR i$3[rsp], eax
  00baf	0f 83 38 01 00
	00		 jae	 $LN9@render

; 582  :         
; 583  :         material_t *mat = get_mesh_material(am, cmd->mesh_id);

  00bb5	48 8b 44 24 38	 mov	 rax, QWORD PTR cmd$[rsp]
  00bba	8b 10		 mov	 edx, DWORD PTR [rax]
  00bbc	48 8b 8c 24 88
	08 00 00	 mov	 rcx, QWORD PTR am$[rsp]
  00bc4	e8 00 00 00 00	 call	 ?get_mesh_material@@YAPEAUmaterial_t@@PEAUasset_manager_t@@I@Z ; get_mesh_material
  00bc9	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR mat$7[rsp], rax

; 584  :         if(mat)

  00bd1	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR mat$7[rsp], 0
  00bda	74 29		 je	 SHORT $LN15@render

; 585  :             bind_material(am, mat, shader, gl->use_textures);

  00bdc	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  00be4	44 8b 88 0c 01
	00 00		 mov	 r9d, DWORD PTR [rax+268]
  00beb	44 8b 44 24 30	 mov	 r8d, DWORD PTR shader$[rsp]
  00bf0	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR mat$7[rsp]
  00bf8	48 8b 8c 24 88
	08 00 00	 mov	 rcx, QWORD PTR am$[rsp]
  00c00	e8 00 00 00 00	 call	 ?bind_material@@YAXPEAUasset_manager_t@@PEAUmaterial_t@@II@Z ; bind_material
$LN15@render:

; 586  :         
; 587  :         if(gl->gpu_transform) {

  00c05	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  00c0d	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  00c14	74 48		 je	 SHORT $LN16@render

; 588  :             set_uniform_mat4(shader, "model", gl->transforms[cmd->trans_id]);

  00c16	48 8b 44 24 38	 mov	 rax, QWORD PTR cmd$[rsp]
  00c1b	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00c1e	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  00c22	48 8b 8c 24 80
	08 00 00	 mov	 rcx, QWORD PTR gl$[rsp]
  00c2a	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00c2e	48 8d 94 24 c0
	03 00 00	 lea	 rdx, QWORD PTR $T29[rsp]
  00c36	48 8b fa	 mov	 rdi, rdx
  00c39	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  00c3d	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00c42	f3 a4		 rep movsb
  00c44	4c 8d 84 24 c0
	03 00 00	 lea	 r8, QWORD PTR $T29[rsp]
  00c4c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG84565
  00c53	8b 4c 24 30	 mov	 ecx, DWORD PTR shader$[rsp]
  00c57	e8 00 00 00 00	 call	 ?set_uniform_mat4@@YAXIPEBDTHMM_Mat4@@@Z ; set_uniform_mat4

; 589  :         }

  00c5c	eb 5f		 jmp	 SHORT $LN17@render
$LN16@render:

; 590  :         else {
; 591  :             set_uniform_mat4(shader, "model", HMM_M4D(1.0f));

  00c5e	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00c66	48 8d 8c 24 40
	04 00 00	 lea	 rcx, QWORD PTR $T31[rsp]
  00c6e	e8 00 00 00 00	 call	 HMM_M4D
  00c73	48 8d 8c 24 10
	08 00 00	 lea	 rcx, QWORD PTR $T49[rsp]
  00c7b	48 8b f9	 mov	 rdi, rcx
  00c7e	48 8b f0	 mov	 rsi, rax
  00c81	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00c86	f3 a4		 rep movsb
  00c88	48 8d 84 24 00
	04 00 00	 lea	 rax, QWORD PTR $T30[rsp]
  00c90	48 8d 8c 24 10
	08 00 00	 lea	 rcx, QWORD PTR $T49[rsp]
  00c98	48 8b f8	 mov	 rdi, rax
  00c9b	48 8b f1	 mov	 rsi, rcx
  00c9e	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00ca3	f3 a4		 rep movsb
  00ca5	4c 8d 84 24 00
	04 00 00	 lea	 r8, QWORD PTR $T30[rsp]
  00cad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG84566
  00cb4	8b 4c 24 30	 mov	 ecx, DWORD PTR shader$[rsp]
  00cb8	e8 00 00 00 00	 call	 ?set_uniform_mat4@@YAXIPEBDTHMM_Mat4@@@Z ; set_uniform_mat4
$LN17@render:

; 592  :         }
; 593  :         
; 594  :         glDrawElements(cmd->prim_type, cmd->indices_count,

  00cbd	48 8b 44 24 38	 mov	 rax, QWORD PTR cmd$[rsp]
  00cc2	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00cc5	48 c1 e0 02	 shl	 rax, 2
  00cc9	4c 8b c8	 mov	 r9, rax
  00ccc	41 b8 05 14 00
	00		 mov	 r8d, 5125		; 00001405H
  00cd2	48 8b 44 24 38	 mov	 rax, QWORD PTR cmd$[rsp]
  00cd7	8b 50 10	 mov	 edx, DWORD PTR [rax+16]
  00cda	48 8b 44 24 38	 mov	 rax, QWORD PTR cmd$[rsp]
  00cdf	8b 48 14	 mov	 ecx, DWORD PTR [rax+20]
  00ce2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glDrawElements

; 595  :                        GL_UNSIGNED_INT, (void *)(cmd->indices_idx*sizeof(u32)));
; 596  :     }

  00ce8	e9 a2 fe ff ff	 jmp	 $LN8@render
$LN9@render:

; 597  :     
; 598  :     glBindVertexArray(0);

  00ced	33 c9		 xor	 ecx, ecx
  00cef	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewBindVertexArray
  00cf6	ff 10		 call	 QWORD PTR [rax]

; 599  :     glActiveTexture(GL_TEXTURE0);

  00cf8	b9 c0 84 00 00	 mov	 ecx, 33984		; 000084c0H
  00cfd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewActiveTexture
  00d04	ff 10		 call	 QWORD PTR [rax]

; 600  : }

  00d06	48 8b 8c 24 50
	08 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00d0e	48 33 cc	 xor	 rcx, rsp
  00d11	e8 00 00 00 00	 call	 __security_check_cookie
  00d16	48 81 c4 68 08
	00 00		 add	 rsp, 2152		; 00000868H
  00d1d	5f		 pop	 rdi
  00d1e	5e		 pop	 rsi
  00d1f	c3		 ret	 0
?render@@YAXPEAUgl_renderer@@PEAUasset_manager_t@@I@Z ENDP ; render
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\renderer.cpp
_TEXT	SEGMENT
i$1 = 32
$T2 = 48
buffer$ = 64
__$ArrayPad$ = 96
lights$ = 144
light_count$ = 152
p_id$ = 160
?bind_lights@@YAXPEAUlight_t@@II@Z PROC			; bind_lights

; 468  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	56		 push	 rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 469  :     set_uniform_int(p_id, "point_light_count", light_count);

  00023	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR light_count$[rsp]
  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG84459
  00032	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR p_id$[rsp]
  00039	e8 00 00 00 00	 call	 ?set_uniform_int@@YAXIPEBDH@Z ; set_uniform_int

; 470  :     
; 471  :     char buffer[32];
; 472  :     for(u32 i = 0; i < light_count; i++) {

  0003e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00046	eb 0a		 jmp	 SHORT $LN4@bind_light
$LN2@bind_light:
  00048	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0004c	ff c0		 inc	 eax
  0004e	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN4@bind_light:
  00052	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR light_count$[rsp]
  00059	39 44 24 20	 cmp	 DWORD PTR i$1[rsp], eax
  0005d	0f 83 0b 01 00
	00		 jae	 $LN3@bind_light

; 473  :         sprintf(buffer, "point_lights[%u].pos", i);

  00063	44 8b 44 24 20	 mov	 r8d, DWORD PTR i$1[rsp]
  00068	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG84460
  0006f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buffer$[rsp]
  00074	e8 00 00 00 00	 call	 sprintf

; 474  :         set_uniform_vec3(p_id, buffer, lights[i].pos);

  00079	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0007d	48 6b c0 18	 imul	 rax, rax, 24
  00081	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T2[rsp]
  00086	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR lights$[rsp]
  0008e	48 8b f9	 mov	 rdi, rcx
  00091	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  00095	b9 0c 00 00 00	 mov	 ecx, 12
  0009a	f3 a4		 rep movsb
  0009c	4c 8d 44 24 30	 lea	 r8, QWORD PTR $T2[rsp]
  000a1	48 8d 54 24 40	 lea	 rdx, QWORD PTR buffer$[rsp]
  000a6	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR p_id$[rsp]
  000ad	e8 00 00 00 00	 call	 ?set_uniform_vec3@@YAXIPEBDTHMM_Vec3@@@Z ; set_uniform_vec3

; 475  :         
; 476  :         sprintf(buffer, "point_lights[%u].constant", i);

  000b2	44 8b 44 24 20	 mov	 r8d, DWORD PTR i$1[rsp]
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG84461
  000be	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buffer$[rsp]
  000c3	e8 00 00 00 00	 call	 sprintf

; 477  :         set_uniform_float(p_id, buffer, lights[i].constant);

  000c8	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  000cc	48 6b c0 18	 imul	 rax, rax, 24
  000d0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR lights$[rsp]
  000d8	f3 0f 10 54 01
	0c		 movss	 xmm2, DWORD PTR [rcx+rax+12]
  000de	48 8d 54 24 40	 lea	 rdx, QWORD PTR buffer$[rsp]
  000e3	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR p_id$[rsp]
  000ea	e8 00 00 00 00	 call	 ?set_uniform_float@@YAXIPEBDM@Z ; set_uniform_float

; 478  :         sprintf(buffer, "point_lights[%u].linear", i);

  000ef	44 8b 44 24 20	 mov	 r8d, DWORD PTR i$1[rsp]
  000f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG84462
  000fb	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buffer$[rsp]
  00100	e8 00 00 00 00	 call	 sprintf

; 479  :         set_uniform_float(p_id, buffer, lights[i].linear);

  00105	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00109	48 6b c0 18	 imul	 rax, rax, 24
  0010d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR lights$[rsp]
  00115	f3 0f 10 54 01
	10		 movss	 xmm2, DWORD PTR [rcx+rax+16]
  0011b	48 8d 54 24 40	 lea	 rdx, QWORD PTR buffer$[rsp]
  00120	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR p_id$[rsp]
  00127	e8 00 00 00 00	 call	 ?set_uniform_float@@YAXIPEBDM@Z ; set_uniform_float

; 480  :         sprintf(buffer, "point_lights[%u].quadratic", i);

  0012c	44 8b 44 24 20	 mov	 r8d, DWORD PTR i$1[rsp]
  00131	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG84463
  00138	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buffer$[rsp]
  0013d	e8 00 00 00 00	 call	 sprintf

; 481  :         set_uniform_float(p_id, buffer, lights[i].quadratic);

  00142	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00146	48 6b c0 18	 imul	 rax, rax, 24
  0014a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR lights$[rsp]
  00152	f3 0f 10 54 01
	14		 movss	 xmm2, DWORD PTR [rcx+rax+20]
  00158	48 8d 54 24 40	 lea	 rdx, QWORD PTR buffer$[rsp]
  0015d	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR p_id$[rsp]
  00164	e8 00 00 00 00	 call	 ?set_uniform_float@@YAXIPEBDM@Z ; set_uniform_float

; 482  :     }

  00169	e9 da fe ff ff	 jmp	 $LN2@bind_light
$LN3@bind_light:

; 483  : }

  0016e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00173	48 33 cc	 xor	 rcx, rsp
  00176	e8 00 00 00 00	 call	 __security_check_cookie
  0017b	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0017f	5f		 pop	 rdi
  00180	5e		 pop	 rsi
  00181	c3		 ret	 0
?bind_lights@@YAXPEAUlight_t@@II@Z ENDP			; bind_lights
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\renderer.cpp
_TEXT	SEGMENT
idx$ = 32
tv82 = 36
tv128 = 40
$T1 = 48
$T2 = 64
$T3 = 80
tex$ = 96
am$ = 160
mat$ = 168
p_id$ = 176
use_texture$ = 184
?bind_material@@YAXPEAUasset_manager_t@@PEAUmaterial_t@@II@Z PROC ; bind_material

; 443  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 444  :     set_uniform_vec3(p_id, "mat.ambient", *(v3 *)mat->ambient);

  0001d	48 8d 44 24 30	 lea	 rax, QWORD PTR $T1[rsp]
  00022	48 8b f8	 mov	 rdi, rax
  00025	48 8b b4 24 a8
	00 00 00	 mov	 rsi, QWORD PTR mat$[rsp]
  0002d	b9 0c 00 00 00	 mov	 ecx, 12
  00032	f3 a4		 rep movsb
  00034	4c 8d 44 24 30	 lea	 r8, QWORD PTR $T1[rsp]
  00039	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG84442
  00040	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR p_id$[rsp]
  00047	e8 00 00 00 00	 call	 ?set_uniform_vec3@@YAXIPEBDTHMM_Vec3@@@Z ; set_uniform_vec3

; 445  :     set_uniform_vec3(p_id, "mat.diffuse", *(v3 *)mat->diffuse);

  0004c	48 8d 44 24 40	 lea	 rax, QWORD PTR $T2[rsp]
  00051	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR mat$[rsp]
  00059	48 8b f8	 mov	 rdi, rax
  0005c	48 8d 71 0c	 lea	 rsi, QWORD PTR [rcx+12]
  00060	b9 0c 00 00 00	 mov	 ecx, 12
  00065	f3 a4		 rep movsb
  00067	4c 8d 44 24 40	 lea	 r8, QWORD PTR $T2[rsp]
  0006c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG84443
  00073	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR p_id$[rsp]
  0007a	e8 00 00 00 00	 call	 ?set_uniform_vec3@@YAXIPEBDTHMM_Vec3@@@Z ; set_uniform_vec3

; 446  :     set_uniform_vec3(p_id, "mat.specular", *(v3 *)mat->specular);

  0007f	48 8d 44 24 50	 lea	 rax, QWORD PTR $T3[rsp]
  00084	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR mat$[rsp]
  0008c	48 8b f8	 mov	 rdi, rax
  0008f	48 8d 71 18	 lea	 rsi, QWORD PTR [rcx+24]
  00093	b9 0c 00 00 00	 mov	 ecx, 12
  00098	f3 a4		 rep movsb
  0009a	4c 8d 44 24 50	 lea	 r8, QWORD PTR $T3[rsp]
  0009f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG84444
  000a6	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR p_id$[rsp]
  000ad	e8 00 00 00 00	 call	 ?set_uniform_vec3@@YAXIPEBDTHMM_Vec3@@@Z ; set_uniform_vec3

; 447  :     set_uniform_float(p_id, "mat.shininess", mat->shininess);

  000b2	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR mat$[rsp]
  000ba	f3 0f 10 50 3c	 movss	 xmm2, DWORD PTR [rax+60]
  000bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG84445
  000c6	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR p_id$[rsp]
  000cd	e8 00 00 00 00	 call	 ?set_uniform_float@@YAXIPEBDM@Z ; set_uniform_float

; 448  :     
; 449  :     u32 idx = (use_texture) ? mat->diffuse_tex_id : 0;

  000d2	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR use_texture$[rsp], 0
  000da	74 11		 je	 SHORT $LN3@bind_mater
  000dc	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR mat$[rsp]
  000e4	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  000e7	89 44 24 24	 mov	 DWORD PTR tv82[rsp], eax
  000eb	eb 08		 jmp	 SHORT $LN4@bind_mater
$LN3@bind_mater:
  000ed	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN4@bind_mater:
  000f5	8b 44 24 24	 mov	 eax, DWORD PTR tv82[rsp]
  000f9	89 44 24 20	 mov	 DWORD PTR idx$[rsp], eax

; 450  :     texture_t tex = am->textures[idx];

  000fd	8b 44 24 20	 mov	 eax, DWORD PTR idx$[rsp]
  00101	48 6b c0 18	 imul	 rax, rax, 24
  00105	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR am$[rsp]
  0010d	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00111	48 8d 54 24 60	 lea	 rdx, QWORD PTR tex$[rsp]
  00116	48 8b fa	 mov	 rdi, rdx
  00119	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  0011d	b9 18 00 00 00	 mov	 ecx, 24
  00122	f3 a4		 rep movsb

; 451  :     glActiveTexture(GL_TEXTURE0);

  00124	b9 c0 84 00 00	 mov	 ecx, 33984		; 000084c0H
  00129	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewActiveTexture
  00130	ff 10		 call	 QWORD PTR [rax]

; 452  :     
; 453  :     set_uniform_int(p_id, "mat.diffuse_tex", 0);

  00132	45 33 c0	 xor	 r8d, r8d
  00135	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG84446
  0013c	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR p_id$[rsp]
  00143	e8 00 00 00 00	 call	 ?set_uniform_int@@YAXIPEBDH@Z ; set_uniform_int

; 454  :     
; 455  :     glBindTexture(GL_TEXTURE_2D, tex.id);

  00148	8b 54 24 74	 mov	 edx, DWORD PTR tex$[rsp+20]
  0014c	b9 e1 0d 00 00	 mov	 ecx, 3553		; 00000de1H
  00151	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glBindTexture

; 456  :     
; 457  :     idx = (use_texture) ? mat->specular_tex_id : 0;

  00157	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR use_texture$[rsp], 0
  0015f	74 11		 je	 SHORT $LN5@bind_mater
  00161	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR mat$[rsp]
  00169	8b 40 54	 mov	 eax, DWORD PTR [rax+84]
  0016c	89 44 24 28	 mov	 DWORD PTR tv128[rsp], eax
  00170	eb 08		 jmp	 SHORT $LN6@bind_mater
$LN5@bind_mater:
  00172	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
$LN6@bind_mater:
  0017a	8b 44 24 28	 mov	 eax, DWORD PTR tv128[rsp]
  0017e	89 44 24 20	 mov	 DWORD PTR idx$[rsp], eax

; 458  :     tex = am->textures[idx];

  00182	8b 44 24 20	 mov	 eax, DWORD PTR idx$[rsp]
  00186	48 6b c0 18	 imul	 rax, rax, 24
  0018a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR am$[rsp]
  00192	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00196	48 8d 54 24 60	 lea	 rdx, QWORD PTR tex$[rsp]
  0019b	48 8b fa	 mov	 rdi, rdx
  0019e	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  001a2	b9 18 00 00 00	 mov	 ecx, 24
  001a7	f3 a4		 rep movsb

; 459  :     glActiveTexture(GL_TEXTURE1);

  001a9	b9 c1 84 00 00	 mov	 ecx, 33985		; 000084c1H
  001ae	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewActiveTexture
  001b5	ff 10		 call	 QWORD PTR [rax]

; 460  :     
; 461  :     set_uniform_int(p_id, "mat.specular_tex", 1);

  001b7	41 b8 01 00 00
	00		 mov	 r8d, 1
  001bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG84447
  001c4	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR p_id$[rsp]
  001cb	e8 00 00 00 00	 call	 ?set_uniform_int@@YAXIPEBDH@Z ; set_uniform_int

; 462  :     
; 463  :     glBindTexture(GL_TEXTURE_2D, tex.id);

  001d0	8b 54 24 74	 mov	 edx, DWORD PTR tex$[rsp+20]
  001d4	b9 e1 0d 00 00	 mov	 ecx, 3553		; 00000de1H
  001d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glBindTexture

; 464  : }

  001df	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001e6	5f		 pop	 rdi
  001e7	5e		 pop	 rsi
  001e8	c3		 ret	 0
?bind_material@@YAXPEAUasset_manager_t@@PEAUmaterial_t@@II@Z ENDP ; bind_material
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\renderer.cpp
_TEXT	SEGMENT
m_idx$1 = 32
cmd$ = 40
mesh_info$ = 48
__$ArrayPad$ = 64
gl$ = 112
m_info$ = 120
?render_mesh@@YAXPEAUgl_renderer@@Umodel_info_t@@@Z PROC ; render_mesh

; 415  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 416  :     mesh_info_t mesh_info;
; 417  :     
; 418  :     render_cmd_t *cmd = (render_cmd_t *)stack_push_array(&gl->cmds,

  0001f	48 8b 44 24 70	 mov	 rax, QWORD PTR gl$[rsp]
  00024	48 83 c0 28	 add	 rax, 40			; 00000028H
  00028	41 b8 18 00 00
	00		 mov	 r8d, 24
  0002e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR m_info$[rsp]
  00033	8b 51 08	 mov	 edx, DWORD PTR [rcx+8]
  00036	48 8b c8	 mov	 rcx, rax
  00039	e8 00 00 00 00	 call	 ?_stack_push@@YAPEAXPEAPEAXII@Z ; _stack_push
  0003e	48 89 44 24 28	 mov	 QWORD PTR cmd$[rsp], rax

; 419  :                                                          m_info.mesh_count);
; 420  :     for(u32 m_idx = 0; m_idx < m_info.mesh_count; m_idx++, cmd++) {

  00043	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR m_idx$1[rsp], 0
  0004b	eb 18		 jmp	 SHORT $LN4@render_mes
$LN2@render_mes:
  0004d	8b 44 24 20	 mov	 eax, DWORD PTR m_idx$1[rsp]
  00051	ff c0		 inc	 eax
  00053	89 44 24 20	 mov	 DWORD PTR m_idx$1[rsp], eax
  00057	48 8b 44 24 28	 mov	 rax, QWORD PTR cmd$[rsp]
  0005c	48 83 c0 18	 add	 rax, 24
  00060	48 89 44 24 28	 mov	 QWORD PTR cmd$[rsp], rax
$LN4@render_mes:
  00065	48 8b 44 24 78	 mov	 rax, QWORD PTR m_info$[rsp]
  0006a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0006d	39 44 24 20	 cmp	 DWORD PTR m_idx$1[rsp], eax
  00071	73 73		 jae	 SHORT $LN3@render_mes

; 421  :         mesh_info = m_info.meshes[m_idx];

  00073	8b 44 24 20	 mov	 eax, DWORD PTR m_idx$1[rsp]
  00077	48 6b c0 10	 imul	 rax, rax, 16
  0007b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR m_info$[rsp]
  00080	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00083	48 8d 54 24 30	 lea	 rdx, QWORD PTR mesh_info$[rsp]
  00088	48 8b fa	 mov	 rdi, rdx
  0008b	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  0008f	b9 10 00 00 00	 mov	 ecx, 16
  00094	f3 a4		 rep movsb

; 422  :         
; 423  :         cmd->mesh_id = mesh_info.mesh_id;

  00096	48 8b 44 24 28	 mov	 rax, QWORD PTR cmd$[rsp]
  0009b	8b 4c 24 30	 mov	 ecx, DWORD PTR mesh_info$[rsp]
  0009f	89 08		 mov	 DWORD PTR [rax], ecx

; 424  :         cmd->trans_id = m_info.trans_id;

  000a1	48 8b 44 24 28	 mov	 rax, QWORD PTR cmd$[rsp]
  000a6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR m_info$[rsp]
  000ab	8b 49 0c	 mov	 ecx, DWORD PTR [rcx+12]
  000ae	89 48 04	 mov	 DWORD PTR [rax+4], ecx

; 425  :         cmd->vert_idx = mesh_info.vert_idx;

  000b1	48 8b 44 24 28	 mov	 rax, QWORD PTR cmd$[rsp]
  000b6	8b 4c 24 34	 mov	 ecx, DWORD PTR mesh_info$[rsp+4]
  000ba	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 426  :         cmd->indices_idx = mesh_info.indices_idx;

  000bd	48 8b 44 24 28	 mov	 rax, QWORD PTR cmd$[rsp]
  000c2	8b 4c 24 38	 mov	 ecx, DWORD PTR mesh_info$[rsp+8]
  000c6	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 427  :         cmd->indices_count = mesh_info.indices_count;

  000c9	48 8b 44 24 28	 mov	 rax, QWORD PTR cmd$[rsp]
  000ce	8b 4c 24 3c	 mov	 ecx, DWORD PTR mesh_info$[rsp+12]
  000d2	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 428  :         cmd->prim_type = PRIMITIVE_TRIANGLES;

  000d5	48 8b 44 24 28	 mov	 rax, QWORD PTR cmd$[rsp]
  000da	c7 40 14 04 00
	00 00		 mov	 DWORD PTR [rax+20], 4

; 429  :     }

  000e1	e9 67 ff ff ff	 jmp	 $LN2@render_mes
$LN3@render_mes:

; 430  : }

  000e6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000eb	48 33 cc	 xor	 rcx, rsp
  000ee	e8 00 00 00 00	 call	 __security_check_cookie
  000f3	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f7	5f		 pop	 rdi
  000f8	5e		 pop	 rsi
  000f9	c3		 ret	 0
?render_mesh@@YAXPEAUgl_renderer@@Umodel_info_t@@@Z ENDP ; render_mesh
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\renderer.cpp
_TEXT	SEGMENT
mag$ = 32
tv65 = 36
change_p$ = 40
or$ = 48
$T1 = 64
$T2 = 80
$T3 = 96
$T4 = 112
$T5 = 128
$T6 = 144
$T7 = 160
$T8 = 176
$T9 = 192
$T10 = 208
$T11 = 224
$T12 = 240
$T13 = 256
$T14 = 272
$T15 = 288
m$ = 304
moved_p$ = 320
d$ = 336
$T16 = 352
$T17 = 368
$T18 = 384
$T19 = 400
$T20 = 416
__$ArrayPad$ = 432
p$ = 480
p_id$ = 488
?adjust_bezier_g1@@YAXPEATHMM_Vec3@@I@Z PROC		; adjust_bezier_g1

; 381  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec c8 01
	00 00		 sub	 rsp, 456		; 000001c8H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 382  :     u32 or = p_id % 3;

  00024	33 d2		 xor	 edx, edx
  00026	8b 84 24 e8 01
	00 00		 mov	 eax, DWORD PTR p_id$[rsp]
  0002d	b9 03 00 00 00	 mov	 ecx, 3
  00032	f7 f1		 div	 ecx
  00034	8b c2		 mov	 eax, edx
  00036	89 44 24 30	 mov	 DWORD PTR or$[rsp], eax

; 383  :     
; 384  :     v3 moved_p, m, *change_p;
; 385  :     
; 386  :     switch (or) {

  0003a	8b 44 24 30	 mov	 eax, DWORD PTR or$[rsp]
  0003e	89 44 24 24	 mov	 DWORD PTR tv65[rsp], eax
  00042	83 7c 24 24 00	 cmp	 DWORD PTR tv65[rsp], 0
  00047	74 1b		 je	 SHORT $LN4@adjust_bez
  00049	83 7c 24 24 01	 cmp	 DWORD PTR tv65[rsp], 1
  0004e	0f 84 88 00 00
	00		 je	 $LN5@adjust_bez
  00054	83 7c 24 24 02	 cmp	 DWORD PTR tv65[rsp], 2
  00059	0f 84 f2 00 00
	00		 je	 $LN6@adjust_bez
  0005f	e9 60 01 00 00	 jmp	 $LN2@adjust_bez
$LN4@adjust_bez:

; 387  :         case 0: {
; 388  :             moved_p= p[p_id-1];

  00064	8b 84 24 e8 01
	00 00		 mov	 eax, DWORD PTR p_id$[rsp]
  0006b	ff c8		 dec	 eax
  0006d	8b c0		 mov	 eax, eax
  0006f	48 6b c0 0c	 imul	 rax, rax, 12
  00073	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR moved_p$[rsp]
  0007b	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  00083	48 8b f9	 mov	 rdi, rcx
  00086	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  0008a	b9 0c 00 00 00	 mov	 ecx, 12
  0008f	f3 a4		 rep movsb

; 389  :             m= p[p_id];

  00091	8b 84 24 e8 01
	00 00		 mov	 eax, DWORD PTR p_id$[rsp]
  00098	48 6b c0 0c	 imul	 rax, rax, 12
  0009c	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR m$[rsp]
  000a4	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  000ac	48 8b f9	 mov	 rdi, rcx
  000af	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  000b3	b9 0c 00 00 00	 mov	 ecx, 12
  000b8	f3 a4		 rep movsb

; 390  :             change_p= p+p_id+1;

  000ba	8b 84 24 e8 01
	00 00		 mov	 eax, DWORD PTR p_id$[rsp]
  000c1	48 6b c0 0c	 imul	 rax, rax, 12
  000c5	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  000cd	48 8d 44 01 0c	 lea	 rax, QWORD PTR [rcx+rax+12]
  000d2	48 89 44 24 28	 mov	 QWORD PTR change_p$[rsp], rax

; 391  :         } break;

  000d7	e9 e8 00 00 00	 jmp	 $LN2@adjust_bez
$LN5@adjust_bez:

; 392  :         case 1: {
; 393  :             moved_p = p[p_id];

  000dc	8b 84 24 e8 01
	00 00		 mov	 eax, DWORD PTR p_id$[rsp]
  000e3	48 6b c0 0c	 imul	 rax, rax, 12
  000e7	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR moved_p$[rsp]
  000ef	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  000f7	48 8b f9	 mov	 rdi, rcx
  000fa	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  000fe	b9 0c 00 00 00	 mov	 ecx, 12
  00103	f3 a4		 rep movsb

; 394  :             m = p[p_id-1];

  00105	8b 84 24 e8 01
	00 00		 mov	 eax, DWORD PTR p_id$[rsp]
  0010c	ff c8		 dec	 eax
  0010e	8b c0		 mov	 eax, eax
  00110	48 6b c0 0c	 imul	 rax, rax, 12
  00114	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR m$[rsp]
  0011c	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  00124	48 8b f9	 mov	 rdi, rcx
  00127	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  0012b	b9 0c 00 00 00	 mov	 ecx, 12
  00130	f3 a4		 rep movsb

; 395  :             change_p = p+p_id-2;

  00132	8b 84 24 e8 01
	00 00		 mov	 eax, DWORD PTR p_id$[rsp]
  00139	48 6b c0 0c	 imul	 rax, rax, 12
  0013d	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  00145	48 8d 44 01 e8	 lea	 rax, QWORD PTR [rcx+rax-24]
  0014a	48 89 44 24 28	 mov	 QWORD PTR change_p$[rsp], rax

; 396  :         } break;

  0014f	eb 73		 jmp	 SHORT $LN2@adjust_bez
$LN6@adjust_bez:

; 397  :         case 2: {
; 398  :             moved_p = p[p_id];

  00151	8b 84 24 e8 01
	00 00		 mov	 eax, DWORD PTR p_id$[rsp]
  00158	48 6b c0 0c	 imul	 rax, rax, 12
  0015c	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR moved_p$[rsp]
  00164	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  0016c	48 8b f9	 mov	 rdi, rcx
  0016f	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  00173	b9 0c 00 00 00	 mov	 ecx, 12
  00178	f3 a4		 rep movsb

; 399  :             m = p[p_id+1];

  0017a	8b 84 24 e8 01
	00 00		 mov	 eax, DWORD PTR p_id$[rsp]
  00181	ff c0		 inc	 eax
  00183	8b c0		 mov	 eax, eax
  00185	48 6b c0 0c	 imul	 rax, rax, 12
  00189	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR m$[rsp]
  00191	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  00199	48 8b f9	 mov	 rdi, rcx
  0019c	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  001a0	b9 0c 00 00 00	 mov	 ecx, 12
  001a5	f3 a4		 rep movsb

; 400  :             change_p = p+p_id+2;

  001a7	8b 84 24 e8 01
	00 00		 mov	 eax, DWORD PTR p_id$[rsp]
  001ae	48 6b c0 0c	 imul	 rax, rax, 12
  001b2	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  001ba	48 8d 44 01 18	 lea	 rax, QWORD PTR [rcx+rax+24]
  001bf	48 89 44 24 28	 mov	 QWORD PTR change_p$[rsp], rax
$LN2@adjust_bez:

; 401  :         } break;
; 402  :     }
; 403  :     
; 404  :     v3 d = HMM_NormV3(HMM_SubV3(moved_p, m));

  001c4	48 8d 44 24 40	 lea	 rax, QWORD PTR $T1[rsp]
  001c9	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR m$[rsp]
  001d1	48 8b f8	 mov	 rdi, rax
  001d4	48 8b f1	 mov	 rsi, rcx
  001d7	b9 0c 00 00 00	 mov	 ecx, 12
  001dc	f3 a4		 rep movsb
  001de	48 8d 44 24 50	 lea	 rax, QWORD PTR $T2[rsp]
  001e3	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR moved_p$[rsp]
  001eb	48 8b f8	 mov	 rdi, rax
  001ee	48 8b f1	 mov	 rsi, rcx
  001f1	b9 0c 00 00 00	 mov	 ecx, 12
  001f6	f3 a4		 rep movsb
  001f8	4c 8d 44 24 40	 lea	 r8, QWORD PTR $T1[rsp]
  001fd	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T2[rsp]
  00202	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR $T11[rsp]
  0020a	e8 00 00 00 00	 call	 HMM_SubV3
  0020f	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR $T16[rsp]
  00217	48 8b f9	 mov	 rdi, rcx
  0021a	48 8b f0	 mov	 rsi, rax
  0021d	b9 0c 00 00 00	 mov	 ecx, 12
  00222	f3 a4		 rep movsb
  00224	48 8d 44 24 60	 lea	 rax, QWORD PTR $T3[rsp]
  00229	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR $T16[rsp]
  00231	48 8b f8	 mov	 rdi, rax
  00234	48 8b f1	 mov	 rsi, rcx
  00237	b9 0c 00 00 00	 mov	 ecx, 12
  0023c	f3 a4		 rep movsb
  0023e	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T3[rsp]
  00243	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR $T12[rsp]
  0024b	e8 00 00 00 00	 call	 HMM_NormV3
  00250	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR $T17[rsp]
  00258	48 8b f9	 mov	 rdi, rcx
  0025b	48 8b f0	 mov	 rsi, rax
  0025e	b9 0c 00 00 00	 mov	 ecx, 12
  00263	f3 a4		 rep movsb
  00265	48 8d 84 24 50
	01 00 00	 lea	 rax, QWORD PTR d$[rsp]
  0026d	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR $T17[rsp]
  00275	48 8b f8	 mov	 rdi, rax
  00278	48 8b f1	 mov	 rsi, rcx
  0027b	b9 0c 00 00 00	 mov	 ecx, 12
  00280	f3 a4		 rep movsb

; 405  :     
; 406  :     f32 mag = HMM_DotV3(d, HMM_SubV3(*change_p, m));

  00282	48 8d 44 24 70	 lea	 rax, QWORD PTR $T4[rsp]
  00287	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR m$[rsp]
  0028f	48 8b f8	 mov	 rdi, rax
  00292	48 8b f1	 mov	 rsi, rcx
  00295	b9 0c 00 00 00	 mov	 ecx, 12
  0029a	f3 a4		 rep movsb
  0029c	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR $T5[rsp]
  002a4	48 8b f8	 mov	 rdi, rax
  002a7	48 8b 74 24 28	 mov	 rsi, QWORD PTR change_p$[rsp]
  002ac	b9 0c 00 00 00	 mov	 ecx, 12
  002b1	f3 a4		 rep movsb
  002b3	4c 8d 44 24 70	 lea	 r8, QWORD PTR $T4[rsp]
  002b8	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR $T5[rsp]
  002c0	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR $T13[rsp]
  002c8	e8 00 00 00 00	 call	 HMM_SubV3
  002cd	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR $T18[rsp]
  002d5	48 8b f9	 mov	 rdi, rcx
  002d8	48 8b f0	 mov	 rsi, rax
  002db	b9 0c 00 00 00	 mov	 ecx, 12
  002e0	f3 a4		 rep movsb
  002e2	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR $T6[rsp]
  002ea	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR $T18[rsp]
  002f2	48 8b f8	 mov	 rdi, rax
  002f5	48 8b f1	 mov	 rsi, rcx
  002f8	b9 0c 00 00 00	 mov	 ecx, 12
  002fd	f3 a4		 rep movsb
  002ff	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR $T7[rsp]
  00307	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR d$[rsp]
  0030f	48 8b f8	 mov	 rdi, rax
  00312	48 8b f1	 mov	 rsi, rcx
  00315	b9 0c 00 00 00	 mov	 ecx, 12
  0031a	f3 a4		 rep movsb
  0031c	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR $T6[rsp]
  00324	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR $T7[rsp]
  0032c	e8 00 00 00 00	 call	 HMM_DotV3
  00331	f3 0f 11 44 24
	20		 movss	 DWORD PTR mag$[rsp], xmm0

; 407  :     if (mag > 0.0f)

  00337	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR mag$[rsp]
  0033d	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00344	76 13		 jbe	 SHORT $LN7@adjust_bez

; 408  :         mag = -mag;

  00346	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR mag$[rsp]
  0034c	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00353	f3 0f 11 44 24
	20		 movss	 DWORD PTR mag$[rsp], xmm0
$LN7@adjust_bez:

; 409  :     
; 410  :     *change_p = HMM_AddV3(m, HMM_MulV3F(d, mag));

  00359	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR $T8[rsp]
  00361	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR d$[rsp]
  00369	48 8b f8	 mov	 rdi, rax
  0036c	48 8b f1	 mov	 rsi, rcx
  0036f	b9 0c 00 00 00	 mov	 ecx, 12
  00374	f3 a4		 rep movsb
  00376	f3 0f 10 54 24
	20		 movss	 xmm2, DWORD PTR mag$[rsp]
  0037c	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR $T8[rsp]
  00384	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR $T14[rsp]
  0038c	e8 00 00 00 00	 call	 HMM_MulV3F
  00391	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR $T19[rsp]
  00399	48 8b f9	 mov	 rdi, rcx
  0039c	48 8b f0	 mov	 rsi, rax
  0039f	b9 0c 00 00 00	 mov	 ecx, 12
  003a4	f3 a4		 rep movsb
  003a6	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR $T9[rsp]
  003ae	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR $T19[rsp]
  003b6	48 8b f8	 mov	 rdi, rax
  003b9	48 8b f1	 mov	 rsi, rcx
  003bc	b9 0c 00 00 00	 mov	 ecx, 12
  003c1	f3 a4		 rep movsb
  003c3	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR $T10[rsp]
  003cb	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR m$[rsp]
  003d3	48 8b f8	 mov	 rdi, rax
  003d6	48 8b f1	 mov	 rsi, rcx
  003d9	b9 0c 00 00 00	 mov	 ecx, 12
  003de	f3 a4		 rep movsb
  003e0	4c 8d 84 24 c0
	00 00 00	 lea	 r8, QWORD PTR $T9[rsp]
  003e8	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR $T10[rsp]
  003f0	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR $T15[rsp]
  003f8	e8 00 00 00 00	 call	 HMM_AddV3
  003fd	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR $T20[rsp]
  00405	48 8b f9	 mov	 rdi, rcx
  00408	48 8b f0	 mov	 rsi, rax
  0040b	b9 0c 00 00 00	 mov	 ecx, 12
  00410	f3 a4		 rep movsb
  00412	48 8d 84 24 a0
	01 00 00	 lea	 rax, QWORD PTR $T20[rsp]
  0041a	48 8b 7c 24 28	 mov	 rdi, QWORD PTR change_p$[rsp]
  0041f	48 8b f0	 mov	 rsi, rax
  00422	b9 0c 00 00 00	 mov	 ecx, 12
  00427	f3 a4		 rep movsb

; 411  : }

  00429	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00431	48 33 cc	 xor	 rcx, rsp
  00434	e8 00 00 00 00	 call	 __security_check_cookie
  00439	48 81 c4 c8 01
	00 00		 add	 rsp, 456		; 000001c8H
  00440	5f		 pop	 rdi
  00441	5e		 pop	 rsi
  00442	c3		 ret	 0
?adjust_bezier_g1@@YAXPEATHMM_Vec3@@I@Z ENDP		; adjust_bezier_g1
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\renderer.cpp
_TEXT	SEGMENT
tv65 = 32
or$ = 36
change_p$ = 40
$T1 = 48
$T2 = 64
$T3 = 80
$T4 = 96
$T5 = 112
$T6 = 128
m$ = 144
moved_p$ = 160
$T7 = 176
$T8 = 192
__$ArrayPad$ = 208
p$ = 256
p_id$ = 264
?adjust_bezier_c1@@YAXPEATHMM_Vec3@@I@Z PROC		; adjust_bezier_c1

; 352  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 353  :     u32 or = p_id % 3;

  00024	33 d2		 xor	 edx, edx
  00026	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR p_id$[rsp]
  0002d	b9 03 00 00 00	 mov	 ecx, 3
  00032	f7 f1		 div	 ecx
  00034	8b c2		 mov	 eax, edx
  00036	89 44 24 24	 mov	 DWORD PTR or$[rsp], eax

; 354  :     
; 355  :     v3 moved_p, m, *change_p;
; 356  :     
; 357  :     switch (or) {

  0003a	8b 44 24 24	 mov	 eax, DWORD PTR or$[rsp]
  0003e	89 44 24 20	 mov	 DWORD PTR tv65[rsp], eax
  00042	83 7c 24 20 00	 cmp	 DWORD PTR tv65[rsp], 0
  00047	74 1b		 je	 SHORT $LN4@adjust_bez
  00049	83 7c 24 20 01	 cmp	 DWORD PTR tv65[rsp], 1
  0004e	0f 84 88 00 00
	00		 je	 $LN5@adjust_bez
  00054	83 7c 24 20 02	 cmp	 DWORD PTR tv65[rsp], 2
  00059	0f 84 f2 00 00
	00		 je	 $LN6@adjust_bez
  0005f	e9 60 01 00 00	 jmp	 $LN2@adjust_bez
$LN4@adjust_bez:

; 358  :         case 0: {
; 359  :             moved_p = p[p_id-1];

  00064	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR p_id$[rsp]
  0006b	ff c8		 dec	 eax
  0006d	8b c0		 mov	 eax, eax
  0006f	48 6b c0 0c	 imul	 rax, rax, 12
  00073	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR moved_p$[rsp]
  0007b	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  00083	48 8b f9	 mov	 rdi, rcx
  00086	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  0008a	b9 0c 00 00 00	 mov	 ecx, 12
  0008f	f3 a4		 rep movsb

; 360  :             m = p[p_id];

  00091	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR p_id$[rsp]
  00098	48 6b c0 0c	 imul	 rax, rax, 12
  0009c	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR m$[rsp]
  000a4	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  000ac	48 8b f9	 mov	 rdi, rcx
  000af	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  000b3	b9 0c 00 00 00	 mov	 ecx, 12
  000b8	f3 a4		 rep movsb

; 361  :             change_p = p+p_id+1;

  000ba	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR p_id$[rsp]
  000c1	48 6b c0 0c	 imul	 rax, rax, 12
  000c5	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  000cd	48 8d 44 01 0c	 lea	 rax, QWORD PTR [rcx+rax+12]
  000d2	48 89 44 24 28	 mov	 QWORD PTR change_p$[rsp], rax

; 362  :         } break;

  000d7	e9 e8 00 00 00	 jmp	 $LN2@adjust_bez
$LN5@adjust_bez:

; 363  :         case 1: {
; 364  :             moved_p = p[p_id];

  000dc	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR p_id$[rsp]
  000e3	48 6b c0 0c	 imul	 rax, rax, 12
  000e7	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR moved_p$[rsp]
  000ef	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  000f7	48 8b f9	 mov	 rdi, rcx
  000fa	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  000fe	b9 0c 00 00 00	 mov	 ecx, 12
  00103	f3 a4		 rep movsb

; 365  :             m = p[p_id-1];

  00105	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR p_id$[rsp]
  0010c	ff c8		 dec	 eax
  0010e	8b c0		 mov	 eax, eax
  00110	48 6b c0 0c	 imul	 rax, rax, 12
  00114	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR m$[rsp]
  0011c	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  00124	48 8b f9	 mov	 rdi, rcx
  00127	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  0012b	b9 0c 00 00 00	 mov	 ecx, 12
  00130	f3 a4		 rep movsb

; 366  :             change_p = p+p_id-2;

  00132	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR p_id$[rsp]
  00139	48 6b c0 0c	 imul	 rax, rax, 12
  0013d	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  00145	48 8d 44 01 e8	 lea	 rax, QWORD PTR [rcx+rax-24]
  0014a	48 89 44 24 28	 mov	 QWORD PTR change_p$[rsp], rax

; 367  :         } break;

  0014f	eb 73		 jmp	 SHORT $LN2@adjust_bez
$LN6@adjust_bez:

; 368  :         case 2: {
; 369  :             moved_p = p[p_id];

  00151	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR p_id$[rsp]
  00158	48 6b c0 0c	 imul	 rax, rax, 12
  0015c	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR moved_p$[rsp]
  00164	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  0016c	48 8b f9	 mov	 rdi, rcx
  0016f	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  00173	b9 0c 00 00 00	 mov	 ecx, 12
  00178	f3 a4		 rep movsb

; 370  :             m = p[p_id+1];

  0017a	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR p_id$[rsp]
  00181	ff c0		 inc	 eax
  00183	8b c0		 mov	 eax, eax
  00185	48 6b c0 0c	 imul	 rax, rax, 12
  00189	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR m$[rsp]
  00191	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  00199	48 8b f9	 mov	 rdi, rcx
  0019c	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  001a0	b9 0c 00 00 00	 mov	 ecx, 12
  001a5	f3 a4		 rep movsb

; 371  :             change_p = p+p_id+2;

  001a7	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR p_id$[rsp]
  001ae	48 6b c0 0c	 imul	 rax, rax, 12
  001b2	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  001ba	48 8d 44 01 18	 lea	 rax, QWORD PTR [rcx+rax+24]
  001bf	48 89 44 24 28	 mov	 QWORD PTR change_p$[rsp], rax
$LN2@adjust_bez:

; 372  :         } break;
; 373  :     }
; 374  :     
; 375  :     *change_p = HMM_AddV3(m, HMM_SubV3(m, moved_p));

  001c4	48 8d 44 24 30	 lea	 rax, QWORD PTR $T1[rsp]
  001c9	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR moved_p$[rsp]
  001d1	48 8b f8	 mov	 rdi, rax
  001d4	48 8b f1	 mov	 rsi, rcx
  001d7	b9 0c 00 00 00	 mov	 ecx, 12
  001dc	f3 a4		 rep movsb
  001de	48 8d 44 24 40	 lea	 rax, QWORD PTR $T2[rsp]
  001e3	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR m$[rsp]
  001eb	48 8b f8	 mov	 rdi, rax
  001ee	48 8b f1	 mov	 rsi, rcx
  001f1	b9 0c 00 00 00	 mov	 ecx, 12
  001f6	f3 a4		 rep movsb
  001f8	4c 8d 44 24 30	 lea	 r8, QWORD PTR $T1[rsp]
  001fd	48 8d 54 24 40	 lea	 rdx, QWORD PTR $T2[rsp]
  00202	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T5[rsp]
  00207	e8 00 00 00 00	 call	 HMM_SubV3
  0020c	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR $T7[rsp]
  00214	48 8b f9	 mov	 rdi, rcx
  00217	48 8b f0	 mov	 rsi, rax
  0021a	b9 0c 00 00 00	 mov	 ecx, 12
  0021f	f3 a4		 rep movsb
  00221	48 8d 44 24 50	 lea	 rax, QWORD PTR $T3[rsp]
  00226	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR $T7[rsp]
  0022e	48 8b f8	 mov	 rdi, rax
  00231	48 8b f1	 mov	 rsi, rcx
  00234	b9 0c 00 00 00	 mov	 ecx, 12
  00239	f3 a4		 rep movsb
  0023b	48 8d 44 24 60	 lea	 rax, QWORD PTR $T4[rsp]
  00240	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR m$[rsp]
  00248	48 8b f8	 mov	 rdi, rax
  0024b	48 8b f1	 mov	 rsi, rcx
  0024e	b9 0c 00 00 00	 mov	 ecx, 12
  00253	f3 a4		 rep movsb
  00255	4c 8d 44 24 50	 lea	 r8, QWORD PTR $T3[rsp]
  0025a	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T4[rsp]
  0025f	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR $T6[rsp]
  00267	e8 00 00 00 00	 call	 HMM_AddV3
  0026c	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR $T8[rsp]
  00274	48 8b f9	 mov	 rdi, rcx
  00277	48 8b f0	 mov	 rsi, rax
  0027a	b9 0c 00 00 00	 mov	 ecx, 12
  0027f	f3 a4		 rep movsb
  00281	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR $T8[rsp]
  00289	48 8b 7c 24 28	 mov	 rdi, QWORD PTR change_p$[rsp]
  0028e	48 8b f0	 mov	 rsi, rax
  00291	b9 0c 00 00 00	 mov	 ecx, 12
  00296	f3 a4		 rep movsb

; 376  : }

  00298	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002a0	48 33 cc	 xor	 rcx, rsp
  002a3	e8 00 00 00 00	 call	 __security_check_cookie
  002a8	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  002af	5f		 pop	 rdi
  002b0	5e		 pop	 rsi
  002b1	c3		 ret	 0
?adjust_bezier_c1@@YAXPEATHMM_Vec3@@I@Z ENDP		; adjust_bezier_c1
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\renderer.cpp
_TEXT	SEGMENT
v_count$1 = 32
i$2 = 36
m_idx$3 = 40
i$4 = 44
i_count$5 = 48
tv69 = 52
tv88 = 56
tv95 = 60
mesh_info$ = 64
idx_offset$6 = 72
model_idx_offset$ = 76
verts$7 = 80
uvs$8 = 88
norms$9 = 96
colors$10 = 104
indices$11 = 112
mesh$ = 120
gl$ = 208
am$ = 216
m_info$ = 224
color$ = 232
?push_mesh@@YAXPEAUgl_renderer@@PEAUasset_manager_t@@PEAUmodel_info_t@@Ucolor_t@@@Z PROC ; push_mesh

; 205  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 206  :     mesh_t mesh;
; 207  :     mesh_info_t *mesh_info;
; 208  :     u32 model_idx_offset = get_stack_count(gl->verts);

  0001d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  00025	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00029	74 14		 je	 SHORT $LN12@push_mesh
  0002b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  00033	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00036	8b 40 fc	 mov	 eax, DWORD PTR [rax-4]
  00039	89 44 24 34	 mov	 DWORD PTR tv69[rsp], eax
  0003d	eb 08		 jmp	 SHORT $LN13@push_mesh
$LN12@push_mesh:
  0003f	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
$LN13@push_mesh:
  00047	8b 44 24 34	 mov	 eax, DWORD PTR tv69[rsp]
  0004b	89 44 24 4c	 mov	 DWORD PTR model_idx_offset$[rsp], eax

; 209  :     for(u32 m_idx = 0; m_idx < m_info->mesh_count; m_idx++) {

  0004f	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR m_idx$3[rsp], 0
  00057	eb 0a		 jmp	 SHORT $LN4@push_mesh
$LN2@push_mesh:
  00059	8b 44 24 28	 mov	 eax, DWORD PTR m_idx$3[rsp]
  0005d	ff c0		 inc	 eax
  0005f	89 44 24 28	 mov	 DWORD PTR m_idx$3[rsp], eax
$LN4@push_mesh:
  00063	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR m_info$[rsp]
  0006b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0006e	39 44 24 28	 cmp	 DWORD PTR m_idx$3[rsp], eax
  00072	0f 83 4f 02 00
	00		 jae	 $LN3@push_mesh

; 210  :         mesh_info = m_info->meshes+m_idx;

  00078	8b 44 24 28	 mov	 eax, DWORD PTR m_idx$3[rsp]
  0007c	48 6b c0 10	 imul	 rax, rax, 16
  00080	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR m_info$[rsp]
  00088	48 03 01	 add	 rax, QWORD PTR [rcx]
  0008b	48 89 44 24 40	 mov	 QWORD PTR mesh_info$[rsp], rax

; 211  :         mesh = am->meshes[mesh_info->mesh_id];

  00090	48 8b 44 24 40	 mov	 rax, QWORD PTR mesh_info$[rsp]
  00095	8b 00		 mov	 eax, DWORD PTR [rax]
  00097	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  0009b	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR am$[rsp]
  000a3	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000a6	48 8d 54 24 78	 lea	 rdx, QWORD PTR mesh$[rsp]
  000ab	48 8b fa	 mov	 rdi, rdx
  000ae	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  000b2	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  000b7	f3 a4		 rep movsb

; 212  :         u32 v_count = mesh.vert_count, i_count = mesh.indices_count;

  000b9	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR mesh$[rsp+40]
  000c0	89 44 24 20	 mov	 DWORD PTR v_count$1[rsp], eax
  000c4	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR mesh$[rsp+44]
  000cb	89 44 24 30	 mov	 DWORD PTR i_count$5[rsp], eax

; 213  :         
; 214  :         u32 idx_offset = get_stack_count(gl->indices);

  000cf	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  000d7	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  000dc	74 15		 je	 SHORT $LN14@push_mesh
  000de	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  000e6	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000ea	8b 40 fc	 mov	 eax, DWORD PTR [rax-4]
  000ed	89 44 24 38	 mov	 DWORD PTR tv88[rsp], eax
  000f1	eb 08		 jmp	 SHORT $LN15@push_mesh
$LN14@push_mesh:
  000f3	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv88[rsp], 0
$LN15@push_mesh:
  000fb	8b 44 24 38	 mov	 eax, DWORD PTR tv88[rsp]
  000ff	89 44 24 48	 mov	 DWORD PTR idx_offset$6[rsp], eax

; 215  :         mesh_info->vert_idx = get_stack_count(gl->verts);

  00103	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  0010b	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0010f	74 14		 je	 SHORT $LN16@push_mesh
  00111	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  00119	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0011c	8b 40 fc	 mov	 eax, DWORD PTR [rax-4]
  0011f	89 44 24 3c	 mov	 DWORD PTR tv95[rsp], eax
  00123	eb 08		 jmp	 SHORT $LN17@push_mesh
$LN16@push_mesh:
  00125	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv95[rsp], 0
$LN17@push_mesh:
  0012d	48 8b 44 24 40	 mov	 rax, QWORD PTR mesh_info$[rsp]
  00132	8b 4c 24 3c	 mov	 ecx, DWORD PTR tv95[rsp]
  00136	89 48 04	 mov	 DWORD PTR [rax+4], ecx

; 216  :         mesh_info->indices_idx = idx_offset;

  00139	48 8b 44 24 40	 mov	 rax, QWORD PTR mesh_info$[rsp]
  0013e	8b 4c 24 48	 mov	 ecx, DWORD PTR idx_offset$6[rsp]
  00142	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 217  :         mesh_info->indices_count = i_count;

  00145	48 8b 44 24 40	 mov	 rax, QWORD PTR mesh_info$[rsp]
  0014a	8b 4c 24 30	 mov	 ecx, DWORD PTR i_count$5[rsp]
  0014e	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 218  :         
; 219  :         v3 *verts = (v3 *)stack_push_array(&gl->verts, v_count);

  00151	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  00159	41 b8 0c 00 00
	00		 mov	 r8d, 12
  0015f	8b 54 24 20	 mov	 edx, DWORD PTR v_count$1[rsp]
  00163	48 8b c8	 mov	 rcx, rax
  00166	e8 00 00 00 00	 call	 ?_stack_push@@YAPEAXPEAPEAXII@Z ; _stack_push
  0016b	48 89 44 24 50	 mov	 QWORD PTR verts$7[rsp], rax

; 220  :         v2 *uvs = (v2 *)stack_push_array(&gl->uvs, v_count);

  00170	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  00178	48 83 c0 08	 add	 rax, 8
  0017c	41 b8 08 00 00
	00		 mov	 r8d, 8
  00182	8b 54 24 20	 mov	 edx, DWORD PTR v_count$1[rsp]
  00186	48 8b c8	 mov	 rcx, rax
  00189	e8 00 00 00 00	 call	 ?_stack_push@@YAPEAXPEAPEAXII@Z ; _stack_push
  0018e	48 89 44 24 58	 mov	 QWORD PTR uvs$8[rsp], rax

; 221  :         color_t *colors = (color_t *)stack_push_array(&gl->colors, v_count);

  00193	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  0019b	48 83 c0 10	 add	 rax, 16
  0019f	41 b8 04 00 00
	00		 mov	 r8d, 4
  001a5	8b 54 24 20	 mov	 edx, DWORD PTR v_count$1[rsp]
  001a9	48 8b c8	 mov	 rcx, rax
  001ac	e8 00 00 00 00	 call	 ?_stack_push@@YAPEAXPEAPEAXII@Z ; _stack_push
  001b1	48 89 44 24 68	 mov	 QWORD PTR colors$10[rsp], rax

; 222  :         v3 *norms = (v3 *)stack_push_array(&gl->norms, v_count);

  001b6	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  001be	48 83 c0 18	 add	 rax, 24
  001c2	41 b8 0c 00 00
	00		 mov	 r8d, 12
  001c8	8b 54 24 20	 mov	 edx, DWORD PTR v_count$1[rsp]
  001cc	48 8b c8	 mov	 rcx, rax
  001cf	e8 00 00 00 00	 call	 ?_stack_push@@YAPEAXPEAPEAXII@Z ; _stack_push
  001d4	48 89 44 24 60	 mov	 QWORD PTR norms$9[rsp], rax

; 223  :         u32 *indices = (u32 *)stack_push_array(&gl->indices, i_count);

  001d9	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  001e1	48 83 c0 20	 add	 rax, 32			; 00000020H
  001e5	41 b8 04 00 00
	00		 mov	 r8d, 4
  001eb	8b 54 24 30	 mov	 edx, DWORD PTR i_count$5[rsp]
  001ef	48 8b c8	 mov	 rcx, rax
  001f2	e8 00 00 00 00	 call	 ?_stack_push@@YAPEAXPEAPEAXII@Z ; _stack_push
  001f7	48 89 44 24 70	 mov	 QWORD PTR indices$11[rsp], rax

; 224  :         
; 225  :         memcpy(verts, mesh.verts, v_count*sizeof(v3));

  001fc	8b 44 24 20	 mov	 eax, DWORD PTR v_count$1[rsp]
  00200	48 6b c0 0c	 imul	 rax, rax, 12
  00204	4c 8b c0	 mov	 r8, rax
  00207	48 8b 54 24 78	 mov	 rdx, QWORD PTR mesh$[rsp]
  0020c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR verts$7[rsp]
  00211	e8 00 00 00 00	 call	 memcpy

; 226  :         memcpy(uvs, mesh.uvs, v_count*sizeof(v2));

  00216	8b 44 24 20	 mov	 eax, DWORD PTR v_count$1[rsp]
  0021a	48 c1 e0 03	 shl	 rax, 3
  0021e	4c 8b c0	 mov	 r8, rax
  00221	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR mesh$[rsp+8]
  00229	48 8b 4c 24 58	 mov	 rcx, QWORD PTR uvs$8[rsp]
  0022e	e8 00 00 00 00	 call	 memcpy

; 227  :         memcpy(norms, mesh.norms, v_count*sizeof(v3));

  00233	8b 44 24 20	 mov	 eax, DWORD PTR v_count$1[rsp]
  00237	48 6b c0 0c	 imul	 rax, rax, 12
  0023b	4c 8b c0	 mov	 r8, rax
  0023e	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR mesh$[rsp+24]
  00246	48 8b 4c 24 60	 mov	 rcx, QWORD PTR norms$9[rsp]
  0024b	e8 00 00 00 00	 call	 memcpy

; 228  :         
; 229  :         for(u32 i = 0; i < v_count; i++)

  00250	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR i$4[rsp], 0
  00258	eb 0a		 jmp	 SHORT $LN7@push_mesh
$LN5@push_mesh:
  0025a	8b 44 24 2c	 mov	 eax, DWORD PTR i$4[rsp]
  0025e	ff c0		 inc	 eax
  00260	89 44 24 2c	 mov	 DWORD PTR i$4[rsp], eax
$LN7@push_mesh:
  00264	8b 44 24 20	 mov	 eax, DWORD PTR v_count$1[rsp]
  00268	39 44 24 2c	 cmp	 DWORD PTR i$4[rsp], eax
  0026c	73 15		 jae	 SHORT $LN6@push_mesh

; 230  :             colors[i] = color;

  0026e	8b 44 24 2c	 mov	 eax, DWORD PTR i$4[rsp]
  00272	48 8b 4c 24 68	 mov	 rcx, QWORD PTR colors$10[rsp]
  00277	8b 94 24 e8 00
	00 00		 mov	 edx, DWORD PTR color$[rsp]
  0027e	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx
  00281	eb d7		 jmp	 SHORT $LN5@push_mesh
$LN6@push_mesh:

; 231  :         for(u32 i = 0; i < i_count; i++)

  00283	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  0028b	eb 0a		 jmp	 SHORT $LN10@push_mesh
$LN8@push_mesh:
  0028d	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  00291	ff c0		 inc	 eax
  00293	89 44 24 24	 mov	 DWORD PTR i$2[rsp], eax
$LN10@push_mesh:
  00297	8b 44 24 30	 mov	 eax, DWORD PTR i_count$5[rsp]
  0029b	39 44 24 24	 cmp	 DWORD PTR i$2[rsp], eax
  0029f	73 21		 jae	 SHORT $LN9@push_mesh

; 232  :             indices[i] = mesh.indices[i]+model_idx_offset;

  002a1	8b 44 24 24	 mov	 eax, DWORD PTR i$2[rsp]
  002a5	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR mesh$[rsp+32]
  002ad	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  002b0	03 44 24 4c	 add	 eax, DWORD PTR model_idx_offset$[rsp]
  002b4	8b 4c 24 24	 mov	 ecx, DWORD PTR i$2[rsp]
  002b8	48 8b 54 24 70	 mov	 rdx, QWORD PTR indices$11[rsp]
  002bd	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
  002c0	eb cb		 jmp	 SHORT $LN8@push_mesh
$LN9@push_mesh:

; 233  :     }

  002c2	e9 92 fd ff ff	 jmp	 $LN2@push_mesh
$LN3@push_mesh:

; 234  : }

  002c7	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  002ce	5f		 pop	 rdi
  002cf	5e		 pop	 rsi
  002d0	c3		 ret	 0
?push_mesh@@YAXPEAUgl_renderer@@PEAUasset_manager_t@@PEAUmodel_info_t@@Ucolor_t@@@Z ENDP ; push_mesh
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\renderer.cpp
_TEXT	SEGMENT
tv69 = 48
tv87 = 52
id$ = 56
entity$ = 64
transform$ = 72
$T1 = 80
$T2 = 96
$T3 = 112
gl$ = 160
m_info$ = 168
pos$ = 176
rot$ = 184
scale$ = 192
?add_entity@@YAIPEAUgl_renderer@@PEAUmodel_info_t@@THMM_Vec3@@22@Z PROC ; add_entity

; 183  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 184  :     u32 id = get_stack_count(gl->entities);

  0001d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  00025	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  0002a	74 15		 je	 SHORT $LN3@add_entity
  0002c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  00034	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00038	8b 40 fc	 mov	 eax, DWORD PTR [rax-4]
  0003b	89 44 24 30	 mov	 DWORD PTR tv69[rsp], eax
  0003f	eb 08		 jmp	 SHORT $LN4@add_entity
$LN3@add_entity:
  00041	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
$LN4@add_entity:
  00049	8b 44 24 30	 mov	 eax, DWORD PTR tv69[rsp]
  0004d	89 44 24 38	 mov	 DWORD PTR id$[rsp], eax

; 185  :     
; 186  :     entity_t *entity = (entity_t *)stack_push(&gl->entities);

  00051	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  00059	48 83 c0 38	 add	 rax, 56			; 00000038H
  0005d	41 b8 38 00 00
	00		 mov	 r8d, 56			; 00000038H
  00063	ba 01 00 00 00	 mov	 edx, 1
  00068	48 8b c8	 mov	 rcx, rax
  0006b	e8 00 00 00 00	 call	 ?_stack_push@@YAPEAXPEAPEAXII@Z ; _stack_push
  00070	48 89 44 24 40	 mov	 QWORD PTR entity$[rsp], rax

; 187  :     entity->pos = pos;

  00075	48 8b 44 24 40	 mov	 rax, QWORD PTR entity$[rsp]
  0007a	48 8d 78 10	 lea	 rdi, QWORD PTR [rax+16]
  0007e	48 8b b4 24 b0
	00 00 00	 mov	 rsi, QWORD PTR pos$[rsp]
  00086	b9 0c 00 00 00	 mov	 ecx, 12
  0008b	f3 a4		 rep movsb

; 188  :     entity->rot = rot;

  0008d	48 8b 44 24 40	 mov	 rax, QWORD PTR entity$[rsp]
  00092	48 8d 78 1c	 lea	 rdi, QWORD PTR [rax+28]
  00096	48 8b b4 24 b8
	00 00 00	 mov	 rsi, QWORD PTR rot$[rsp]
  0009e	b9 0c 00 00 00	 mov	 ecx, 12
  000a3	f3 a4		 rep movsb

; 189  :     entity->scale = scale;

  000a5	48 8b 44 24 40	 mov	 rax, QWORD PTR entity$[rsp]
  000aa	48 8d 78 28	 lea	 rdi, QWORD PTR [rax+40]
  000ae	48 8b b4 24 c0
	00 00 00	 mov	 rsi, QWORD PTR scale$[rsp]
  000b6	b9 0c 00 00 00	 mov	 ecx, 12
  000bb	f3 a4		 rep movsb

; 190  :     
; 191  :     m_info->trans_id = get_stack_count(gl->transforms);

  000bd	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  000c5	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  000ca	74 15		 je	 SHORT $LN5@add_entity
  000cc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  000d4	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  000d8	8b 40 fc	 mov	 eax, DWORD PTR [rax-4]
  000db	89 44 24 34	 mov	 DWORD PTR tv87[rsp], eax
  000df	eb 08		 jmp	 SHORT $LN6@add_entity
$LN5@add_entity:
  000e1	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv87[rsp], 0
$LN6@add_entity:
  000e9	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR m_info$[rsp]
  000f1	8b 4c 24 34	 mov	 ecx, DWORD PTR tv87[rsp]
  000f5	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 192  :     
; 193  :     mat4 *transform = (mat4 *)stack_push(&gl->transforms);

  000f8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  00100	48 83 c0 30	 add	 rax, 48			; 00000030H
  00104	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  0010a	ba 01 00 00 00	 mov	 edx, 1
  0010f	48 8b c8	 mov	 rcx, rax
  00112	e8 00 00 00 00	 call	 ?_stack_push@@YAPEAXPEAPEAXII@Z ; _stack_push
  00117	48 89 44 24 48	 mov	 QWORD PTR transform$[rsp], rax

; 194  :     update_transform(gl, transform, pos, rot, scale);

  0011c	48 8d 44 24 50	 lea	 rax, QWORD PTR $T1[rsp]
  00121	48 8b f8	 mov	 rdi, rax
  00124	48 8b b4 24 c0
	00 00 00	 mov	 rsi, QWORD PTR scale$[rsp]
  0012c	b9 0c 00 00 00	 mov	 ecx, 12
  00131	f3 a4		 rep movsb
  00133	48 8d 44 24 60	 lea	 rax, QWORD PTR $T2[rsp]
  00138	48 8b f8	 mov	 rdi, rax
  0013b	48 8b b4 24 b8
	00 00 00	 mov	 rsi, QWORD PTR rot$[rsp]
  00143	b9 0c 00 00 00	 mov	 ecx, 12
  00148	f3 a4		 rep movsb
  0014a	48 8d 44 24 70	 lea	 rax, QWORD PTR $T3[rsp]
  0014f	48 8b f8	 mov	 rdi, rax
  00152	48 8b b4 24 b0
	00 00 00	 mov	 rsi, QWORD PTR pos$[rsp]
  0015a	b9 0c 00 00 00	 mov	 ecx, 12
  0015f	f3 a4		 rep movsb
  00161	48 8d 44 24 50	 lea	 rax, QWORD PTR $T1[rsp]
  00166	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0016b	4c 8d 4c 24 60	 lea	 r9, QWORD PTR $T2[rsp]
  00170	4c 8d 44 24 70	 lea	 r8, QWORD PTR $T3[rsp]
  00175	48 8b 54 24 48	 mov	 rdx, QWORD PTR transform$[rsp]
  0017a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR gl$[rsp]
  00182	e8 00 00 00 00	 call	 ?update_transform@@YAXPEAUgl_renderer@@PEATHMM_Mat4@@THMM_Vec3@@22@Z ; update_transform

; 195  :     
; 196  :     entity->m_info = *m_info;

  00187	48 8b 7c 24 40	 mov	 rdi, QWORD PTR entity$[rsp]
  0018c	48 8b b4 24 a8
	00 00 00	 mov	 rsi, QWORD PTR m_info$[rsp]
  00194	b9 10 00 00 00	 mov	 ecx, 16
  00199	f3 a4		 rep movsb

; 197  :     
; 198  :     return id;

  0019b	8b 44 24 38	 mov	 eax, DWORD PTR id$[rsp]

; 199  : }

  0019f	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001a6	5f		 pop	 rdi
  001a7	5e		 pop	 rsi
  001a8	c3		 ret	 0
?add_entity@@YAIPEAUgl_renderer@@PEAUmodel_info_t@@THMM_Vec3@@22@Z ENDP ; add_entity
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\renderer.cpp
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
$T3 = 64
$T4 = 80
$T5 = 96
$T6 = 112
$T7 = 128
$T8 = 144
$T9 = 160
$T10 = 224
$T11 = 288
$T12 = 352
$T13 = 416
$T14 = 480
$T15 = 544
$T16 = 608
$T17 = 672
$T18 = 736
$T19 = 800
$T20 = 864
$T21 = 928
$T22 = 992
$T23 = 1056
$T24 = 1120
$T25 = 1184
$T26 = 1248
$T27 = 1312
$T28 = 1376
$T29 = 1440
trans$ = 1504
$T30 = 1568
$T31 = 1584
$T32 = 1600
$T33 = 1616
$T34 = 1680
$T35 = 1744
$T36 = 1808
$T37 = 1872
$T38 = 1936
$T39 = 2000
$T40 = 2064
$T41 = 2128
$T42 = 2192
$T43 = 2256
__$ArrayPad$ = 2320
gl$ = 2368
transform$ = 2376
pos$ = 2384
rot$ = 2392
scale$ = 2400
?update_transform@@YAXPEAUgl_renderer@@PEATHMM_Mat4@@THMM_Vec3@@22@Z PROC ; update_transform

; 166  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 28 09
	00 00		 sub	 rsp, 2344		; 00000928H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 10
	09 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 167  :     mat4 trans = HMM_M4D(1.0f);

  0002f	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00037	48 8d 8c 24 20
	03 00 00	 lea	 rcx, QWORD PTR $T19[rsp]
  0003f	e8 00 00 00 00	 call	 HMM_M4D
  00044	48 8d 8c 24 50
	06 00 00	 lea	 rcx, QWORD PTR $T33[rsp]
  0004c	48 8b f9	 mov	 rdi, rcx
  0004f	48 8b f0	 mov	 rsi, rax
  00052	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00057	f3 a4		 rep movsb
  00059	48 8d 84 24 e0
	05 00 00	 lea	 rax, QWORD PTR trans$[rsp]
  00061	48 8d 8c 24 50
	06 00 00	 lea	 rcx, QWORD PTR $T33[rsp]
  00069	48 8b f8	 mov	 rdi, rax
  0006c	48 8b f1	 mov	 rsi, rcx
  0006f	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00074	f3 a4		 rep movsb

; 168  :     trans = HMM_MulM4(trans, HMM_Translate(pos));

  00076	48 8d 44 24 20	 lea	 rax, QWORD PTR $T1[rsp]
  0007b	48 8b f8	 mov	 rdi, rax
  0007e	48 8b b4 24 50
	09 00 00	 mov	 rsi, QWORD PTR pos$[rsp]
  00086	b9 0c 00 00 00	 mov	 ecx, 12
  0008b	f3 a4		 rep movsb
  0008d	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  00092	48 8d 8c 24 60
	03 00 00	 lea	 rcx, QWORD PTR $T20[rsp]
  0009a	e8 00 00 00 00	 call	 HMM_Translate
  0009f	48 8d 8c 24 90
	06 00 00	 lea	 rcx, QWORD PTR $T34[rsp]
  000a7	48 8b f9	 mov	 rdi, rcx
  000aa	48 8b f0	 mov	 rsi, rax
  000ad	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000b2	f3 a4		 rep movsb
  000b4	48 8d 84 24 20
	02 00 00	 lea	 rax, QWORD PTR $T15[rsp]
  000bc	48 8d 8c 24 90
	06 00 00	 lea	 rcx, QWORD PTR $T34[rsp]
  000c4	48 8b f8	 mov	 rdi, rax
  000c7	48 8b f1	 mov	 rsi, rcx
  000ca	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000cf	f3 a4		 rep movsb
  000d1	48 8d 84 24 60
	02 00 00	 lea	 rax, QWORD PTR $T16[rsp]
  000d9	48 8d 8c 24 e0
	05 00 00	 lea	 rcx, QWORD PTR trans$[rsp]
  000e1	48 8b f8	 mov	 rdi, rax
  000e4	48 8b f1	 mov	 rsi, rcx
  000e7	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000ec	f3 a4		 rep movsb
  000ee	4c 8d 84 24 20
	02 00 00	 lea	 r8, QWORD PTR $T15[rsp]
  000f6	48 8d 94 24 60
	02 00 00	 lea	 rdx, QWORD PTR $T16[rsp]
  000fe	48 8d 8c 24 a0
	03 00 00	 lea	 rcx, QWORD PTR $T21[rsp]
  00106	e8 00 00 00 00	 call	 HMM_MulM4
  0010b	48 8d 8c 24 d0
	06 00 00	 lea	 rcx, QWORD PTR $T35[rsp]
  00113	48 8b f9	 mov	 rdi, rcx
  00116	48 8b f0	 mov	 rsi, rax
  00119	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0011e	f3 a4		 rep movsb
  00120	48 8d 84 24 e0
	05 00 00	 lea	 rax, QWORD PTR trans$[rsp]
  00128	48 8d 8c 24 d0
	06 00 00	 lea	 rcx, QWORD PTR $T35[rsp]
  00130	48 8b f8	 mov	 rdi, rax
  00133	48 8b f1	 mov	 rsi, rcx
  00136	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0013b	f3 a4		 rep movsb

; 169  :     
; 170  :     trans = HMM_MulM4(trans, HMM_Rotate_RH(HMM_ToRad(rot.X), HMM_V3(1.0f, 0.0f, 0.0f)));

  0013d	0f 57 db	 xorps	 xmm3, xmm3
  00140	0f 57 d2	 xorps	 xmm2, xmm2
  00143	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  0014b	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T6[rsp]
  00150	e8 00 00 00 00	 call	 HMM_V3
  00155	48 8d 8c 24 20
	06 00 00	 lea	 rcx, QWORD PTR $T30[rsp]
  0015d	48 8b f9	 mov	 rdi, rcx
  00160	48 8b f0	 mov	 rsi, rax
  00163	b9 0c 00 00 00	 mov	 ecx, 12
  00168	f3 a4		 rep movsb
  0016a	48 8d 44 24 30	 lea	 rax, QWORD PTR $T2[rsp]
  0016f	48 8d 8c 24 20
	06 00 00	 lea	 rcx, QWORD PTR $T30[rsp]
  00177	48 8b f8	 mov	 rdi, rax
  0017a	48 8b f1	 mov	 rsi, rcx
  0017d	b9 0c 00 00 00	 mov	 ecx, 12
  00182	f3 a4		 rep movsb
  00184	48 8b 84 24 58
	09 00 00	 mov	 rax, QWORD PTR rot$[rsp]
  0018c	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00190	e8 00 00 00 00	 call	 HMM_ToRad
  00195	4c 8d 44 24 30	 lea	 r8, QWORD PTR $T2[rsp]
  0019a	0f 28 c8	 movaps	 xmm1, xmm0
  0019d	48 8d 8c 24 e0
	03 00 00	 lea	 rcx, QWORD PTR $T22[rsp]
  001a5	e8 00 00 00 00	 call	 HMM_Rotate_RH
  001aa	48 8d 8c 24 90
	07 00 00	 lea	 rcx, QWORD PTR $T38[rsp]
  001b2	48 8b f9	 mov	 rdi, rcx
  001b5	48 8b f0	 mov	 rsi, rax
  001b8	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  001bd	f3 a4		 rep movsb
  001bf	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR $T9[rsp]
  001c7	48 8d 8c 24 90
	07 00 00	 lea	 rcx, QWORD PTR $T38[rsp]
  001cf	48 8b f8	 mov	 rdi, rax
  001d2	48 8b f1	 mov	 rsi, rcx
  001d5	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  001da	f3 a4		 rep movsb
  001dc	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR $T10[rsp]
  001e4	48 8d 8c 24 e0
	05 00 00	 lea	 rcx, QWORD PTR trans$[rsp]
  001ec	48 8b f8	 mov	 rdi, rax
  001ef	48 8b f1	 mov	 rsi, rcx
  001f2	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  001f7	f3 a4		 rep movsb
  001f9	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR $T9[rsp]
  00201	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR $T10[rsp]
  00209	48 8d 8c 24 20
	04 00 00	 lea	 rcx, QWORD PTR $T23[rsp]
  00211	e8 00 00 00 00	 call	 HMM_MulM4
  00216	48 8d 8c 24 10
	07 00 00	 lea	 rcx, QWORD PTR $T36[rsp]
  0021e	48 8b f9	 mov	 rdi, rcx
  00221	48 8b f0	 mov	 rsi, rax
  00224	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00229	f3 a4		 rep movsb
  0022b	48 8d 84 24 e0
	05 00 00	 lea	 rax, QWORD PTR trans$[rsp]
  00233	48 8d 8c 24 10
	07 00 00	 lea	 rcx, QWORD PTR $T36[rsp]
  0023b	48 8b f8	 mov	 rdi, rax
  0023e	48 8b f1	 mov	 rsi, rcx
  00241	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00246	f3 a4		 rep movsb

; 171  :     trans = HMM_MulM4(trans, HMM_Rotate_RH(HMM_ToRad(rot.Y), HMM_V3(0.0f, 1.0f, 0.0f)));

  00248	0f 57 db	 xorps	 xmm3, xmm3
  0024b	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f800000
  00253	0f 57 c9	 xorps	 xmm1, xmm1
  00256	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR $T7[rsp]
  0025e	e8 00 00 00 00	 call	 HMM_V3
  00263	48 8d 8c 24 30
	06 00 00	 lea	 rcx, QWORD PTR $T31[rsp]
  0026b	48 8b f9	 mov	 rdi, rcx
  0026e	48 8b f0	 mov	 rsi, rax
  00271	b9 0c 00 00 00	 mov	 ecx, 12
  00276	f3 a4		 rep movsb
  00278	48 8d 44 24 40	 lea	 rax, QWORD PTR $T3[rsp]
  0027d	48 8d 8c 24 30
	06 00 00	 lea	 rcx, QWORD PTR $T31[rsp]
  00285	48 8b f8	 mov	 rdi, rax
  00288	48 8b f1	 mov	 rsi, rcx
  0028b	b9 0c 00 00 00	 mov	 ecx, 12
  00290	f3 a4		 rep movsb
  00292	48 8b 84 24 58
	09 00 00	 mov	 rax, QWORD PTR rot$[rsp]
  0029a	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  0029f	e8 00 00 00 00	 call	 HMM_ToRad
  002a4	4c 8d 44 24 40	 lea	 r8, QWORD PTR $T3[rsp]
  002a9	0f 28 c8	 movaps	 xmm1, xmm0
  002ac	48 8d 8c 24 60
	04 00 00	 lea	 rcx, QWORD PTR $T24[rsp]
  002b4	e8 00 00 00 00	 call	 HMM_Rotate_RH
  002b9	48 8d 8c 24 50
	07 00 00	 lea	 rcx, QWORD PTR $T37[rsp]
  002c1	48 8b f9	 mov	 rdi, rcx
  002c4	48 8b f0	 mov	 rsi, rax
  002c7	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  002cc	f3 a4		 rep movsb
  002ce	48 8d 84 24 e0
	02 00 00	 lea	 rax, QWORD PTR $T18[rsp]
  002d6	48 8d 8c 24 50
	07 00 00	 lea	 rcx, QWORD PTR $T37[rsp]
  002de	48 8b f8	 mov	 rdi, rax
  002e1	48 8b f1	 mov	 rsi, rcx
  002e4	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  002e9	f3 a4		 rep movsb
  002eb	48 8d 84 24 e0
	01 00 00	 lea	 rax, QWORD PTR $T14[rsp]
  002f3	48 8d 8c 24 e0
	05 00 00	 lea	 rcx, QWORD PTR trans$[rsp]
  002fb	48 8b f8	 mov	 rdi, rax
  002fe	48 8b f1	 mov	 rsi, rcx
  00301	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00306	f3 a4		 rep movsb
  00308	4c 8d 84 24 e0
	02 00 00	 lea	 r8, QWORD PTR $T18[rsp]
  00310	48 8d 94 24 e0
	01 00 00	 lea	 rdx, QWORD PTR $T14[rsp]
  00318	48 8d 8c 24 a0
	04 00 00	 lea	 rcx, QWORD PTR $T25[rsp]
  00320	e8 00 00 00 00	 call	 HMM_MulM4
  00325	48 8d 8c 24 90
	08 00 00	 lea	 rcx, QWORD PTR $T42[rsp]
  0032d	48 8b f9	 mov	 rdi, rcx
  00330	48 8b f0	 mov	 rsi, rax
  00333	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00338	f3 a4		 rep movsb
  0033a	48 8d 84 24 e0
	05 00 00	 lea	 rax, QWORD PTR trans$[rsp]
  00342	48 8d 8c 24 90
	08 00 00	 lea	 rcx, QWORD PTR $T42[rsp]
  0034a	48 8b f8	 mov	 rdi, rax
  0034d	48 8b f1	 mov	 rsi, rcx
  00350	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00355	f3 a4		 rep movsb

; 172  :     trans = HMM_MulM4(trans, HMM_Rotate_RH(HMM_ToRad(rot.Z), HMM_V3(0.0f, 0.0f, 1.0f)));

  00357	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3f800000
  0035f	0f 57 d2	 xorps	 xmm2, xmm2
  00362	0f 57 c9	 xorps	 xmm1, xmm1
  00365	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR $T8[rsp]
  0036d	e8 00 00 00 00	 call	 HMM_V3
  00372	48 8d 8c 24 40
	06 00 00	 lea	 rcx, QWORD PTR $T32[rsp]
  0037a	48 8b f9	 mov	 rdi, rcx
  0037d	48 8b f0	 mov	 rsi, rax
  00380	b9 0c 00 00 00	 mov	 ecx, 12
  00385	f3 a4		 rep movsb
  00387	48 8d 44 24 50	 lea	 rax, QWORD PTR $T4[rsp]
  0038c	48 8d 8c 24 40
	06 00 00	 lea	 rcx, QWORD PTR $T32[rsp]
  00394	48 8b f8	 mov	 rdi, rax
  00397	48 8b f1	 mov	 rsi, rcx
  0039a	b9 0c 00 00 00	 mov	 ecx, 12
  0039f	f3 a4		 rep movsb
  003a1	48 8b 84 24 58
	09 00 00	 mov	 rax, QWORD PTR rot$[rsp]
  003a9	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  003ae	e8 00 00 00 00	 call	 HMM_ToRad
  003b3	4c 8d 44 24 50	 lea	 r8, QWORD PTR $T4[rsp]
  003b8	0f 28 c8	 movaps	 xmm1, xmm0
  003bb	48 8d 8c 24 e0
	04 00 00	 lea	 rcx, QWORD PTR $T26[rsp]
  003c3	e8 00 00 00 00	 call	 HMM_Rotate_RH
  003c8	48 8d 8c 24 50
	08 00 00	 lea	 rcx, QWORD PTR $T41[rsp]
  003d0	48 8b f9	 mov	 rdi, rcx
  003d3	48 8b f0	 mov	 rsi, rax
  003d6	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  003db	f3 a4		 rep movsb
  003dd	48 8d 84 24 a0
	02 00 00	 lea	 rax, QWORD PTR $T17[rsp]
  003e5	48 8d 8c 24 50
	08 00 00	 lea	 rcx, QWORD PTR $T41[rsp]
  003ed	48 8b f8	 mov	 rdi, rax
  003f0	48 8b f1	 mov	 rsi, rcx
  003f3	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  003f8	f3 a4		 rep movsb
  003fa	48 8d 84 24 a0
	01 00 00	 lea	 rax, QWORD PTR $T13[rsp]
  00402	48 8d 8c 24 e0
	05 00 00	 lea	 rcx, QWORD PTR trans$[rsp]
  0040a	48 8b f8	 mov	 rdi, rax
  0040d	48 8b f1	 mov	 rsi, rcx
  00410	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00415	f3 a4		 rep movsb
  00417	4c 8d 84 24 a0
	02 00 00	 lea	 r8, QWORD PTR $T17[rsp]
  0041f	48 8d 94 24 a0
	01 00 00	 lea	 rdx, QWORD PTR $T13[rsp]
  00427	48 8d 8c 24 20
	05 00 00	 lea	 rcx, QWORD PTR $T27[rsp]
  0042f	e8 00 00 00 00	 call	 HMM_MulM4
  00434	48 8d 8c 24 d0
	07 00 00	 lea	 rcx, QWORD PTR $T39[rsp]
  0043c	48 8b f9	 mov	 rdi, rcx
  0043f	48 8b f0	 mov	 rsi, rax
  00442	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00447	f3 a4		 rep movsb
  00449	48 8d 84 24 e0
	05 00 00	 lea	 rax, QWORD PTR trans$[rsp]
  00451	48 8d 8c 24 d0
	07 00 00	 lea	 rcx, QWORD PTR $T39[rsp]
  00459	48 8b f8	 mov	 rdi, rax
  0045c	48 8b f1	 mov	 rsi, rcx
  0045f	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00464	f3 a4		 rep movsb

; 173  :     
; 174  :     trans = HMM_MulM4(trans, HMM_Scale(scale));

  00466	48 8d 44 24 60	 lea	 rax, QWORD PTR $T5[rsp]
  0046b	48 8b f8	 mov	 rdi, rax
  0046e	48 8b b4 24 60
	09 00 00	 mov	 rsi, QWORD PTR scale$[rsp]
  00476	b9 0c 00 00 00	 mov	 ecx, 12
  0047b	f3 a4		 rep movsb
  0047d	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T5[rsp]
  00482	48 8d 8c 24 60
	05 00 00	 lea	 rcx, QWORD PTR $T28[rsp]
  0048a	e8 00 00 00 00	 call	 HMM_Scale
  0048f	48 8d 8c 24 10
	08 00 00	 lea	 rcx, QWORD PTR $T40[rsp]
  00497	48 8b f9	 mov	 rdi, rcx
  0049a	48 8b f0	 mov	 rsi, rax
  0049d	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  004a2	f3 a4		 rep movsb
  004a4	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR $T11[rsp]
  004ac	48 8d 8c 24 10
	08 00 00	 lea	 rcx, QWORD PTR $T40[rsp]
  004b4	48 8b f8	 mov	 rdi, rax
  004b7	48 8b f1	 mov	 rsi, rcx
  004ba	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  004bf	f3 a4		 rep movsb
  004c1	48 8d 84 24 60
	01 00 00	 lea	 rax, QWORD PTR $T12[rsp]
  004c9	48 8d 8c 24 e0
	05 00 00	 lea	 rcx, QWORD PTR trans$[rsp]
  004d1	48 8b f8	 mov	 rdi, rax
  004d4	48 8b f1	 mov	 rsi, rcx
  004d7	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  004dc	f3 a4		 rep movsb
  004de	4c 8d 84 24 20
	01 00 00	 lea	 r8, QWORD PTR $T11[rsp]
  004e6	48 8d 94 24 60
	01 00 00	 lea	 rdx, QWORD PTR $T12[rsp]
  004ee	48 8d 8c 24 a0
	05 00 00	 lea	 rcx, QWORD PTR $T29[rsp]
  004f6	e8 00 00 00 00	 call	 HMM_MulM4
  004fb	48 8d 8c 24 d0
	08 00 00	 lea	 rcx, QWORD PTR $T43[rsp]
  00503	48 8b f9	 mov	 rdi, rcx
  00506	48 8b f0	 mov	 rsi, rax
  00509	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0050e	f3 a4		 rep movsb
  00510	48 8d 84 24 e0
	05 00 00	 lea	 rax, QWORD PTR trans$[rsp]
  00518	48 8d 8c 24 d0
	08 00 00	 lea	 rcx, QWORD PTR $T43[rsp]
  00520	48 8b f8	 mov	 rdi, rax
  00523	48 8b f1	 mov	 rsi, rcx
  00526	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0052b	f3 a4		 rep movsb

; 175  :     
; 176  :     *transform = trans;

  0052d	48 8d 84 24 e0
	05 00 00	 lea	 rax, QWORD PTR trans$[rsp]
  00535	48 8b bc 24 48
	09 00 00	 mov	 rdi, QWORD PTR transform$[rsp]
  0053d	48 8b f0	 mov	 rsi, rax
  00540	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00545	f3 a4		 rep movsb

; 177  : }

  00547	48 8b 8c 24 10
	09 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0054f	48 33 cc	 xor	 rcx, rsp
  00552	e8 00 00 00 00	 call	 __security_check_cookie
  00557	48 81 c4 28 09
	00 00		 add	 rsp, 2344		; 00000928H
  0055e	5f		 pop	 rdi
  0055f	5e		 pop	 rsi
  00560	c3		 ret	 0
?update_transform@@YAXPEAUgl_renderer@@PEATHMM_Mat4@@THMM_Vec3@@22@Z ENDP ; update_transform
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\renderer.cpp
_TEXT	SEGMENT
rbo$ = 80
fb_tex$ = 84
fb$ = 88
vao$ = 92
shader$ = 96
vbo$ = 100
quad$ = 112
__$ArrayPad$ = 208
gl$ = 240
vert$ = 248
frag$ = 256
?init_framebuffer@@YAXPEAUgl_renderer@@PEBD1@Z PROC	; init_framebuffer

; 95   : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 96   :     u32 fb;
; 97   :     glGenFramebuffers(1, &fb);

  00028	48 8d 54 24 58	 lea	 rdx, QWORD PTR fb$[rsp]
  0002d	b9 01 00 00 00	 mov	 ecx, 1
  00032	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewGenFramebuffers
  00039	ff 10		 call	 QWORD PTR [rax]

; 98   :     glBindFramebuffer(GL_FRAMEBUFFER, fb);

  0003b	8b 54 24 58	 mov	 edx, DWORD PTR fb$[rsp]
  0003f	b9 40 8d 00 00	 mov	 ecx, 36160		; 00008d40H
  00044	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewBindFramebuffer
  0004b	ff 10		 call	 QWORD PTR [rax]

; 99   :     
; 100  :     u32 fb_tex;
; 101  :     glGenTextures(1, &fb_tex);

  0004d	48 8d 54 24 54	 lea	 rdx, QWORD PTR fb_tex$[rsp]
  00052	b9 01 00 00 00	 mov	 ecx, 1
  00057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glGenTextures

; 102  :     glBindTexture(GL_TEXTURE_2D, fb_tex);

  0005d	8b 54 24 54	 mov	 edx, DWORD PTR fb_tex$[rsp]
  00061	b9 e1 0d 00 00	 mov	 ecx, 3553		; 00000de1H
  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glBindTexture

; 103  :     glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, SRC_WIDTH, SRC_HEIGHT, 0, GL_RGB,

  0006c	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00075	c7 44 24 38 01
	14 00 00	 mov	 DWORD PTR [rsp+56], 5121 ; 00001401H
  0007d	c7 44 24 30 07
	19 00 00	 mov	 DWORD PTR [rsp+48], 6407 ; 00001907H
  00085	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0008d	c7 44 24 20 58
	02 00 00	 mov	 DWORD PTR [rsp+32], 600	; 00000258H
  00095	41 b9 20 03 00
	00		 mov	 r9d, 800		; 00000320H
  0009b	41 b8 07 19 00
	00		 mov	 r8d, 6407		; 00001907H
  000a1	33 d2		 xor	 edx, edx
  000a3	b9 e1 0d 00 00	 mov	 ecx, 3553		; 00000de1H
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glTexImage2D

; 104  :                  GL_UNSIGNED_BYTE, NULL);
; 105  :     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

  000ae	41 b8 01 26 00
	00		 mov	 r8d, 9729		; 00002601H
  000b4	ba 01 28 00 00	 mov	 edx, 10241		; 00002801H
  000b9	b9 e1 0d 00 00	 mov	 ecx, 3553		; 00000de1H
  000be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glTexParameteri

; 106  :     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

  000c4	41 b8 01 26 00
	00		 mov	 r8d, 9729		; 00002601H
  000ca	ba 00 28 00 00	 mov	 edx, 10240		; 00002800H
  000cf	b9 e1 0d 00 00	 mov	 ecx, 3553		; 00000de1H
  000d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glTexParameteri

; 107  :     glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, fb_tex, 0);

  000da	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  000e2	44 8b 4c 24 54	 mov	 r9d, DWORD PTR fb_tex$[rsp]
  000e7	41 b8 e1 0d 00
	00		 mov	 r8d, 3553		; 00000de1H
  000ed	ba e0 8c 00 00	 mov	 edx, 36064		; 00008ce0H
  000f2	b9 40 8d 00 00	 mov	 ecx, 36160		; 00008d40H
  000f7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewFramebufferTexture2D
  000fe	ff 10		 call	 QWORD PTR [rax]

; 108  :     
; 109  :     u32 rbo;
; 110  :     glGenRenderbuffers(1, &rbo);

  00100	48 8d 54 24 50	 lea	 rdx, QWORD PTR rbo$[rsp]
  00105	b9 01 00 00 00	 mov	 ecx, 1
  0010a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewGenRenderbuffers
  00111	ff 10		 call	 QWORD PTR [rax]

; 111  :     glBindRenderbuffer(GL_RENDERBUFFER, rbo);

  00113	8b 54 24 50	 mov	 edx, DWORD PTR rbo$[rsp]
  00117	b9 41 8d 00 00	 mov	 ecx, 36161		; 00008d41H
  0011c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewBindRenderbuffer
  00123	ff 10		 call	 QWORD PTR [rax]

; 112  :     glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, SRC_WIDTH, SRC_HEIGHT);

  00125	41 b9 58 02 00
	00		 mov	 r9d, 600		; 00000258H
  0012b	41 b8 20 03 00
	00		 mov	 r8d, 800		; 00000320H
  00131	ba f0 88 00 00	 mov	 edx, 35056		; 000088f0H
  00136	b9 41 8d 00 00	 mov	 ecx, 36161		; 00008d41H
  0013b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewRenderbufferStorage
  00142	ff 10		 call	 QWORD PTR [rax]

; 113  :     glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo);

  00144	44 8b 4c 24 50	 mov	 r9d, DWORD PTR rbo$[rsp]
  00149	41 b8 41 8d 00
	00		 mov	 r8d, 36161		; 00008d41H
  0014f	ba 1a 82 00 00	 mov	 edx, 33306		; 0000821aH
  00154	b9 40 8d 00 00	 mov	 ecx, 36160		; 00008d40H
  00159	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewFramebufferRenderbuffer
  00160	ff 10		 call	 QWORD PTR [rax]
$LN4@init_frame:

; 114  :     
; 115  :     ASSERT(glCheckFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE, "Failed to make framebuffer.");

  00162	b9 40 8d 00 00	 mov	 ecx, 36160		; 00008d40H
  00167	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewCheckFramebufferStatus
  0016e	ff 10		 call	 QWORD PTR [rax]
  00170	3d d5 8c 00 00	 cmp	 eax, 36053		; 00008cd5H
  00175	74 30		 je	 SHORT $LN5@init_frame
  00177	b9 02 00 00 00	 mov	 ecx, 2
  0017c	e8 00 00 00 00	 call	 __acrt_iob_func
  00181	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG84118
  00188	41 b8 73 00 00
	00		 mov	 r8d, 115		; 00000073H
  0018e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG84119
  00195	48 8b c8	 mov	 rcx, rax
  00198	e8 00 00 00 00	 call	 fprintf
  0019d	b9 01 00 00 00	 mov	 ecx, 1
  001a2	e8 00 00 00 00	 call	 exit
$LN5@init_frame:
  001a7	33 c0		 xor	 eax, eax
  001a9	85 c0		 test	 eax, eax
  001ab	75 b5		 jne	 SHORT $LN4@init_frame

; 116  :     
; 117  :     glBindFramebuffer(GL_FRAMEBUFFER, 0);

  001ad	33 d2		 xor	 edx, edx
  001af	b9 40 8d 00 00	 mov	 ecx, 36160		; 00008d40H
  001b4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewBindFramebuffer
  001bb	ff 10		 call	 QWORD PTR [rax]

; 118  :     
; 119  :     gl->fb.id = fb;

  001bd	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  001c5	8b 4c 24 58	 mov	 ecx, DWORD PTR fb$[rsp]
  001c9	89 88 f4 00 00
	00		 mov	 DWORD PTR [rax+244], ecx

; 120  :     gl->fb.rbo = rbo;

  001cf	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  001d7	8b 4c 24 50	 mov	 ecx, DWORD PTR rbo$[rsp]
  001db	89 88 f8 00 00
	00		 mov	 DWORD PTR [rax+248], ecx

; 121  :     gl->fb.tex = fb_tex;

  001e1	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  001e9	8b 4c 24 54	 mov	 ecx, DWORD PTR fb_tex$[rsp]
  001ed	89 88 fc 00 00
	00		 mov	 DWORD PTR [rax+252], ecx

; 122  :     
; 123  :     u32 shader = add_shader(gl, 2, vert, GL_VERTEX_SHADER, frag, GL_FRAGMENT_SHADER);

  001f3	c7 44 24 28 30
	8b 00 00	 mov	 DWORD PTR [rsp+40], 35632 ; 00008b30H
  001fb	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR frag$[rsp]
  00203	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00208	41 b9 31 8b 00
	00		 mov	 r9d, 35633		; 00008b31H
  0020e	4c 8b 84 24 f8
	00 00 00	 mov	 r8, QWORD PTR vert$[rsp]
  00216	ba 02 00 00 00	 mov	 edx, 2
  0021b	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR gl$[rsp]
  00223	e8 00 00 00 00	 call	 ?add_shader@@YAIPEAUgl_renderer@@IZZ ; add_shader
  00228	89 44 24 60	 mov	 DWORD PTR shader$[rsp], eax

; 124  :     gl->fb.shader = shader;

  0022c	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  00234	8b 4c 24 60	 mov	 ecx, DWORD PTR shader$[rsp]
  00238	89 88 00 01 00
	00		 mov	 DWORD PTR [rax+256], ecx

; 125  :     
; 126  :     f32 quad[] = {
; 127  :         -1.0f, 1.0f, 0.0f, 1.0f,

  0023e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00246	f3 0f 11 44 24
	70		 movss	 DWORD PTR quad$[rsp], xmm0
  0024c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00254	f3 0f 11 44 24
	74		 movss	 DWORD PTR quad$[rsp+4], xmm0
  0025a	0f 57 c0	 xorps	 xmm0, xmm0
  0025d	f3 0f 11 44 24
	78		 movss	 DWORD PTR quad$[rsp+8], xmm0
  00263	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0026b	f3 0f 11 44 24
	7c		 movss	 DWORD PTR quad$[rsp+12], xmm0

; 128  :         -1.0f,-1.0f, 0.0f, 0.0f,

  00271	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00279	f3 0f 11 84 24
	80 00 00 00	 movss	 DWORD PTR quad$[rsp+16], xmm0
  00282	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0028a	f3 0f 11 84 24
	84 00 00 00	 movss	 DWORD PTR quad$[rsp+20], xmm0
  00293	0f 57 c0	 xorps	 xmm0, xmm0
  00296	f3 0f 11 84 24
	88 00 00 00	 movss	 DWORD PTR quad$[rsp+24], xmm0
  0029f	0f 57 c0	 xorps	 xmm0, xmm0
  002a2	f3 0f 11 84 24
	8c 00 00 00	 movss	 DWORD PTR quad$[rsp+28], xmm0

; 129  :         1.0f, -1.0f, 1.0f, 0.0f,

  002ab	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  002b3	f3 0f 11 84 24
	90 00 00 00	 movss	 DWORD PTR quad$[rsp+32], xmm0
  002bc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  002c4	f3 0f 11 84 24
	94 00 00 00	 movss	 DWORD PTR quad$[rsp+36], xmm0
  002cd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  002d5	f3 0f 11 84 24
	98 00 00 00	 movss	 DWORD PTR quad$[rsp+40], xmm0
  002de	0f 57 c0	 xorps	 xmm0, xmm0
  002e1	f3 0f 11 84 24
	9c 00 00 00	 movss	 DWORD PTR quad$[rsp+44], xmm0

; 130  :         -1.0f, 1.0f, 0.0f, 1.0f,

  002ea	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  002f2	f3 0f 11 84 24
	a0 00 00 00	 movss	 DWORD PTR quad$[rsp+48], xmm0
  002fb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00303	f3 0f 11 84 24
	a4 00 00 00	 movss	 DWORD PTR quad$[rsp+52], xmm0
  0030c	0f 57 c0	 xorps	 xmm0, xmm0
  0030f	f3 0f 11 84 24
	a8 00 00 00	 movss	 DWORD PTR quad$[rsp+56], xmm0
  00318	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00320	f3 0f 11 84 24
	ac 00 00 00	 movss	 DWORD PTR quad$[rsp+60], xmm0

; 131  :         1.0f, -1.0f, 1.0f, 0.0f,

  00329	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00331	f3 0f 11 84 24
	b0 00 00 00	 movss	 DWORD PTR quad$[rsp+64], xmm0
  0033a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00342	f3 0f 11 84 24
	b4 00 00 00	 movss	 DWORD PTR quad$[rsp+68], xmm0
  0034b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00353	f3 0f 11 84 24
	b8 00 00 00	 movss	 DWORD PTR quad$[rsp+72], xmm0
  0035c	0f 57 c0	 xorps	 xmm0, xmm0
  0035f	f3 0f 11 84 24
	bc 00 00 00	 movss	 DWORD PTR quad$[rsp+76], xmm0

; 132  :         1.0f,  1.0f, 1.0f, 1.0f

  00368	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00370	f3 0f 11 84 24
	c0 00 00 00	 movss	 DWORD PTR quad$[rsp+80], xmm0
  00379	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00381	f3 0f 11 84 24
	c4 00 00 00	 movss	 DWORD PTR quad$[rsp+84], xmm0
  0038a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00392	f3 0f 11 84 24
	c8 00 00 00	 movss	 DWORD PTR quad$[rsp+88], xmm0
  0039b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003a3	f3 0f 11 84 24
	cc 00 00 00	 movss	 DWORD PTR quad$[rsp+92], xmm0

; 133  :     };
; 134  :     u32 vao, vbo;
; 135  :     glGenVertexArrays(1, &vao);

  003ac	48 8d 54 24 5c	 lea	 rdx, QWORD PTR vao$[rsp]
  003b1	b9 01 00 00 00	 mov	 ecx, 1
  003b6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewGenVertexArrays
  003bd	ff 10		 call	 QWORD PTR [rax]

; 136  :     glGenBuffers(1, &vbo);

  003bf	48 8d 54 24 64	 lea	 rdx, QWORD PTR vbo$[rsp]
  003c4	b9 01 00 00 00	 mov	 ecx, 1
  003c9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewGenBuffers
  003d0	ff 10		 call	 QWORD PTR [rax]

; 137  :     glBindVertexArray(vao);

  003d2	8b 4c 24 5c	 mov	 ecx, DWORD PTR vao$[rsp]
  003d6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewBindVertexArray
  003dd	ff 10		 call	 QWORD PTR [rax]

; 138  :     glBindBuffer(GL_ARRAY_BUFFER, vbo);

  003df	8b 54 24 64	 mov	 edx, DWORD PTR vbo$[rsp]
  003e3	b9 92 88 00 00	 mov	 ecx, 34962		; 00008892H
  003e8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewBindBuffer
  003ef	ff 10		 call	 QWORD PTR [rax]

; 139  :     glBufferData(GL_ARRAY_BUFFER, sizeof(quad), &quad, GL_STATIC_DRAW);

  003f1	41 b9 e4 88 00
	00		 mov	 r9d, 35044		; 000088e4H
  003f7	4c 8d 44 24 70	 lea	 r8, QWORD PTR quad$[rsp]
  003fc	ba 60 00 00 00	 mov	 edx, 96			; 00000060H
  00401	b9 92 88 00 00	 mov	 ecx, 34962		; 00008892H
  00406	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewBufferData
  0040d	ff 10		 call	 QWORD PTR [rax]

; 140  :     glEnableVertexAttribArray(0);

  0040f	33 c9		 xor	 ecx, ecx
  00411	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewEnableVertexAttribArray
  00418	ff 10		 call	 QWORD PTR [rax]

; 141  :     glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 4*sizeof(float),

  0041a	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00423	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  0042b	45 33 c9	 xor	 r9d, r9d
  0042e	41 b8 06 14 00
	00		 mov	 r8d, 5126		; 00001406H
  00434	ba 02 00 00 00	 mov	 edx, 2
  00439	33 c9		 xor	 ecx, ecx
  0043b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewVertexAttribPointer
  00442	ff 10		 call	 QWORD PTR [rax]

; 142  :                           (void *)0);
; 143  :     glEnableVertexAttribArray(1);

  00444	b9 01 00 00 00	 mov	 ecx, 1
  00449	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewEnableVertexAttribArray
  00450	ff 10		 call	 QWORD PTR [rax]

; 144  :     glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 4*sizeof(float),

  00452	48 c7 44 24 28
	08 00 00 00	 mov	 QWORD PTR [rsp+40], 8
  0045b	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR [rsp+32], 16
  00463	45 33 c9	 xor	 r9d, r9d
  00466	41 b8 06 14 00
	00		 mov	 r8d, 5126		; 00001406H
  0046c	ba 02 00 00 00	 mov	 edx, 2
  00471	b9 01 00 00 00	 mov	 ecx, 1
  00476	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewVertexAttribPointer
  0047d	ff 10		 call	 QWORD PTR [rax]

; 145  :                           (void *)(2*sizeof(float)));
; 146  :     
; 147  :     gl->fb.vao = vao;

  0047f	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR gl$[rsp]
  00487	8b 4c 24 5c	 mov	 ecx, DWORD PTR vao$[rsp]
  0048b	89 88 04 01 00
	00		 mov	 DWORD PTR [rax+260], ecx
$LN6@init_frame:

; 148  : }

  00491	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00499	48 33 cc	 xor	 rcx, rsp
  0049c	e8 00 00 00 00	 call	 __security_check_cookie
  004a1	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  004a8	c3		 ret	 0
?init_framebuffer@@YAXPEAUgl_renderer@@PEBD1@Z ENDP	; init_framebuffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\renderer.cpp
_TEXT	SEGMENT
tv76 = 48
$T1 = 64
gl$ = 112
pos$ = 120
constant$ = 128
linear$ = 136
quadratic$ = 144
?add_light@@YAXPEAUgl_renderer@@THMM_Vec3@@MMM@Z PROC	; add_light

; 88   : {

  00000	f3 0f 11 5c 24
	20		 movss	 DWORD PTR [rsp+32], xmm3
  00006	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000c	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00011	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00016	56		 push	 rsi
  00017	57		 push	 rdi
  00018	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 89   :     init_light(gl->lights+(gl->light_count++),

  0001c	48 8b 44 24 70	 mov	 rax, QWORD PTR gl$[rsp]
  00021	48 83 c0 60	 add	 rax, 96			; 00000060H
  00025	48 8b 4c 24 70	 mov	 rcx, QWORD PTR gl$[rsp]
  0002a	8b 89 f0 00 00
	00		 mov	 ecx, DWORD PTR [rcx+240]
  00030	48 6b c9 18	 imul	 rcx, rcx, 24
  00034	48 03 c1	 add	 rax, rcx
  00037	48 89 44 24 30	 mov	 QWORD PTR tv76[rsp], rax
  0003c	48 8b 44 24 70	 mov	 rax, QWORD PTR gl$[rsp]
  00041	8b 80 f0 00 00
	00		 mov	 eax, DWORD PTR [rax+240]
  00047	ff c0		 inc	 eax
  00049	48 8b 4c 24 70	 mov	 rcx, QWORD PTR gl$[rsp]
  0004e	89 81 f0 00 00
	00		 mov	 DWORD PTR [rcx+240], eax
  00054	48 8d 44 24 40	 lea	 rax, QWORD PTR $T1[rsp]
  00059	48 8b f8	 mov	 rdi, rax
  0005c	48 8b 74 24 78	 mov	 rsi, QWORD PTR pos$[rsp]
  00061	b9 0c 00 00 00	 mov	 ecx, 12
  00066	f3 a4		 rep movsb
  00068	f3 0f 10 84 24
	90 00 00 00	 movss	 xmm0, DWORD PTR quadratic$[rsp]
  00071	f3 0f 11 44 24
	20		 movss	 DWORD PTR [rsp+32], xmm0
  00077	f3 0f 10 9c 24
	88 00 00 00	 movss	 xmm3, DWORD PTR linear$[rsp]
  00080	f3 0f 10 94 24
	80 00 00 00	 movss	 xmm2, DWORD PTR constant$[rsp]
  00089	48 8d 54 24 40	 lea	 rdx, QWORD PTR $T1[rsp]
  0008e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv76[rsp]
  00093	e8 00 00 00 00	 call	 ?init_light@@YAXPEAUlight_t@@THMM_Vec3@@MMM@Z ; init_light

; 90   :                pos, constant, linear, quadratic);
; 91   : }

  00098	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0009c	5f		 pop	 rdi
  0009d	5e		 pop	 rsi
  0009e	c3		 ret	 0
?add_light@@YAXPEAUgl_renderer@@THMM_Vec3@@MMM@Z ENDP	; add_light
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\renderer.cpp
_TEXT	SEGMENT
light$ = 24
pos$ = 32
constant$ = 40
linear$ = 48
quadratic$ = 56
?init_light@@YAXPEAUlight_t@@THMM_Vec3@@MMM@Z PROC	; init_light

; 78   : {

  00000	f3 0f 11 5c 24
	20		 movss	 DWORD PTR [rsp+32], xmm3
  00006	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000c	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00011	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00016	56		 push	 rsi
  00017	57		 push	 rdi

; 79   :     light->pos = pos;

  00018	48 8b 7c 24 18	 mov	 rdi, QWORD PTR light$[rsp]
  0001d	48 8b 74 24 20	 mov	 rsi, QWORD PTR pos$[rsp]
  00022	b9 0c 00 00 00	 mov	 ecx, 12
  00027	f3 a4		 rep movsb

; 80   :     light->constant = constant;

  00029	48 8b 44 24 18	 mov	 rax, QWORD PTR light$[rsp]
  0002e	f3 0f 10 44 24
	28		 movss	 xmm0, DWORD PTR constant$[rsp]
  00034	f3 0f 11 40 0c	 movss	 DWORD PTR [rax+12], xmm0

; 81   :     light->linear = linear;

  00039	48 8b 44 24 18	 mov	 rax, QWORD PTR light$[rsp]
  0003e	f3 0f 10 44 24
	30		 movss	 xmm0, DWORD PTR linear$[rsp]
  00044	f3 0f 11 40 10	 movss	 DWORD PTR [rax+16], xmm0

; 82   :     light->quadratic = quadratic;

  00049	48 8b 44 24 18	 mov	 rax, QWORD PTR light$[rsp]
  0004e	f3 0f 10 44 24
	38		 movss	 xmm0, DWORD PTR quadratic$[rsp]
  00054	f3 0f 11 40 14	 movss	 DWORD PTR [rax+20], xmm0

; 83   : }

  00059	5f		 pop	 rdi
  0005a	5e		 pop	 rsi
  0005b	c3		 ret	 0
?init_light@@YAXPEAUlight_t@@THMM_Vec3@@MMM@Z ENDP	; init_light
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\renderer.cpp
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
$T3 = 64
$T4 = 80
__$ArrayPad$ = 96
cam$ = 144
pos$ = 152
speed$ = 160
sens$ = 168
aspect_ratio$ = 176
fov$ = 184
near$ = 192
far$ = 200
?init_camera@@YAXPEAUcamera_t@@THMM_Vec3@@MMMMMM@Z PROC	; init_camera

; 61   : {

  00000	f3 0f 11 5c 24
	20		 movss	 DWORD PTR [rsp+32], xmm3
  00006	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000c	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00011	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00016	56		 push	 rsi
  00017	57		 push	 rdi
  00018	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 62   :     cam->pos = pos;

  0002b	48 8b bc 24 90
	00 00 00	 mov	 rdi, QWORD PTR cam$[rsp]
  00033	48 8b b4 24 98
	00 00 00	 mov	 rsi, QWORD PTR pos$[rsp]
  0003b	b9 0c 00 00 00	 mov	 ecx, 12
  00040	f3 a4		 rep movsb

; 63   :     cam->world_up = HMM_V3(0.0f, 1.0f, 0.0f);

  00042	0f 57 db	 xorps	 xmm3, xmm3
  00045	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3f800000
  0004d	0f 57 c9	 xorps	 xmm1, xmm1
  00050	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  00055	e8 00 00 00 00	 call	 HMM_V3
  0005a	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T3[rsp]
  0005f	48 8b f9	 mov	 rdi, rcx
  00062	48 8b f0	 mov	 rsi, rax
  00065	b9 0c 00 00 00	 mov	 ecx, 12
  0006a	f3 a4		 rep movsb
  0006c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR cam$[rsp]
  00074	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T3[rsp]
  00079	48 8d 78 3c	 lea	 rdi, QWORD PTR [rax+60]
  0007d	48 8b f1	 mov	 rsi, rcx
  00080	b9 0c 00 00 00	 mov	 ecx, 12
  00085	f3 a4		 rep movsb

; 64   :     cam->rot = HMM_V3(-90.0f, 0.0f, 0.0f);

  00087	0f 57 db	 xorps	 xmm3, xmm3
  0008a	0f 57 d2	 xorps	 xmm2, xmm2
  0008d	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@c2b40000
  00095	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T2[rsp]
  0009a	e8 00 00 00 00	 call	 HMM_V3
  0009f	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T4[rsp]
  000a4	48 8b f9	 mov	 rdi, rcx
  000a7	48 8b f0	 mov	 rsi, rax
  000aa	b9 0c 00 00 00	 mov	 ecx, 12
  000af	f3 a4		 rep movsb
  000b1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR cam$[rsp]
  000b9	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T4[rsp]
  000be	48 8d 78 0c	 lea	 rdi, QWORD PTR [rax+12]
  000c2	48 8b f1	 mov	 rsi, rcx
  000c5	b9 0c 00 00 00	 mov	 ecx, 12
  000ca	f3 a4		 rep movsb

; 65   :     cam->speed = speed;

  000cc	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR cam$[rsp]
  000d4	f3 0f 10 84 24
	a0 00 00 00	 movss	 xmm0, DWORD PTR speed$[rsp]
  000dd	f3 0f 11 40 48	 movss	 DWORD PTR [rax+72], xmm0

; 66   :     cam->sens = sens;

  000e2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR cam$[rsp]
  000ea	f3 0f 10 84 24
	a8 00 00 00	 movss	 xmm0, DWORD PTR sens$[rsp]
  000f3	f3 0f 11 40 4c	 movss	 DWORD PTR [rax+76], xmm0

; 67   :     cam->fov = fov;

  000f8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR cam$[rsp]
  00100	f3 0f 10 84 24
	b8 00 00 00	 movss	 xmm0, DWORD PTR fov$[rsp]
  00109	f3 0f 11 40 50	 movss	 DWORD PTR [rax+80], xmm0

; 68   :     cam->aspect_ratio = aspect_ratio;

  0010e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR cam$[rsp]
  00116	f3 0f 10 84 24
	b0 00 00 00	 movss	 xmm0, DWORD PTR aspect_ratio$[rsp]
  0011f	f3 0f 11 40 54	 movss	 DWORD PTR [rax+84], xmm0

; 69   :     cam->near = near;

  00124	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR cam$[rsp]
  0012c	f3 0f 10 84 24
	c0 00 00 00	 movss	 xmm0, DWORD PTR near$[rsp]
  00135	f3 0f 11 40 58	 movss	 DWORD PTR [rax+88], xmm0

; 70   :     cam->far = far;

  0013a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR cam$[rsp]
  00142	f3 0f 10 84 24
	c8 00 00 00	 movss	 xmm0, DWORD PTR far$[rsp]
  0014b	f3 0f 11 40 5c	 movss	 DWORD PTR [rax+92], xmm0

; 71   :     
; 72   :     update_camera(cam);

  00150	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cam$[rsp]
  00158	e8 00 00 00 00	 call	 ?update_camera@@YAXPEAUcamera_t@@@Z ; update_camera

; 73   : }

  0015d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00162	48 33 cc	 xor	 rcx, rsp
  00165	e8 00 00 00 00	 call	 __security_check_cookie
  0016a	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0016e	5f		 pop	 rdi
  0016f	5e		 pop	 rsi
  00170	c3		 ret	 0
?init_camera@@YAXPEAUcamera_t@@THMM_Vec3@@MMMMMM@Z ENDP	; init_camera
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\renderer.cpp
_TEXT	SEGMENT
pitch$ = 48
yaw$ = 52
tv82 = 56
tv95 = 60
$T1 = 64
$T2 = 80
$T3 = 96
$T4 = 112
$T5 = 128
$T6 = 144
$T7 = 160
$T8 = 176
$T9 = 192
$T10 = 208
$T11 = 224
$T12 = 240
$T13 = 256
front$ = 320
$T14 = 336
$T15 = 352
$T16 = 368
$T17 = 384
$T18 = 400
$T19 = 416
__$ArrayPad$ = 480
camera$ = 528
?update_camera@@YAXPEAUcamera_t@@@Z PROC		; update_camera

; 43   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec f8 01
	00 00		 sub	 rsp, 504		; 000001f8H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 e0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 44   :     camera->proj = HMM_Perspective_RH_NO(HMM_ToRad(camera->fov), camera->aspect_ratio, camera->near, camera->far);

  00020	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR camera$[rsp]
  00028	f3 0f 10 40 50	 movss	 xmm0, DWORD PTR [rax+80]
  0002d	e8 00 00 00 00	 call	 HMM_ToRad
  00032	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR camera$[rsp]
  0003a	f3 0f 10 48 5c	 movss	 xmm1, DWORD PTR [rax+92]
  0003f	f3 0f 11 4c 24
	20		 movss	 DWORD PTR [rsp+32], xmm1
  00045	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR camera$[rsp]
  0004d	f3 0f 10 58 58	 movss	 xmm3, DWORD PTR [rax+88]
  00052	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR camera$[rsp]
  0005a	f3 0f 10 50 54	 movss	 xmm2, DWORD PTR [rax+84]
  0005f	0f 28 c8	 movaps	 xmm1, xmm0
  00062	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR $T13[rsp]
  0006a	e8 00 00 00 00	 call	 HMM_Perspective_RH_NO
  0006f	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR $T19[rsp]
  00077	48 8b f9	 mov	 rdi, rcx
  0007a	48 8b f0	 mov	 rsi, rax
  0007d	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00082	f3 a4		 rep movsb
  00084	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR camera$[rsp]
  0008c	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR $T19[rsp]
  00094	48 8d 78 60	 lea	 rdi, QWORD PTR [rax+96]
  00098	48 8b f1	 mov	 rsi, rcx
  0009b	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000a0	f3 a4		 rep movsb

; 45   :     
; 46   :     f32 yaw = camera->rot.X, pitch = camera->rot.Y;

  000a2	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR camera$[rsp]
  000aa	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [rax+12]
  000af	f3 0f 11 44 24
	34		 movss	 DWORD PTR yaw$[rsp], xmm0
  000b5	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR camera$[rsp]
  000bd	f3 0f 10 40 10	 movss	 xmm0, DWORD PTR [rax+16]
  000c2	f3 0f 11 44 24
	30		 movss	 DWORD PTR pitch$[rsp], xmm0

; 47   :     
; 48   :     v3 front;
; 49   :     front.X = cos(HMM_ToRad(yaw))*cos(HMM_ToRad(pitch));

  000c8	f3 0f 10 44 24
	34		 movss	 xmm0, DWORD PTR yaw$[rsp]
  000ce	e8 00 00 00 00	 call	 HMM_ToRad
  000d3	e8 00 00 00 00	 call	 ?cos@@YAMM@Z		; cos
  000d8	f3 0f 11 44 24
	38		 movss	 DWORD PTR tv82[rsp], xmm0
  000de	f3 0f 10 44 24
	30		 movss	 xmm0, DWORD PTR pitch$[rsp]
  000e4	e8 00 00 00 00	 call	 HMM_ToRad
  000e9	e8 00 00 00 00	 call	 ?cos@@YAMM@Z		; cos
  000ee	f3 0f 10 4c 24
	38		 movss	 xmm1, DWORD PTR tv82[rsp]
  000f4	f3 0f 59 c8	 mulss	 xmm1, xmm0
  000f8	0f 28 c1	 movaps	 xmm0, xmm1
  000fb	f3 0f 11 84 24
	40 01 00 00	 movss	 DWORD PTR front$[rsp], xmm0

; 50   :     front.Y = sin(HMM_ToRad(pitch));

  00104	f3 0f 10 44 24
	30		 movss	 xmm0, DWORD PTR pitch$[rsp]
  0010a	e8 00 00 00 00	 call	 HMM_ToRad
  0010f	e8 00 00 00 00	 call	 ?sin@@YAMM@Z		; sin
  00114	f3 0f 11 84 24
	44 01 00 00	 movss	 DWORD PTR front$[rsp+4], xmm0

; 51   :     front.Z = sin(HMM_ToRad(yaw))*cos(HMM_ToRad(pitch));

  0011d	f3 0f 10 44 24
	34		 movss	 xmm0, DWORD PTR yaw$[rsp]
  00123	e8 00 00 00 00	 call	 HMM_ToRad
  00128	e8 00 00 00 00	 call	 ?sin@@YAMM@Z		; sin
  0012d	f3 0f 11 44 24
	3c		 movss	 DWORD PTR tv95[rsp], xmm0
  00133	f3 0f 10 44 24
	30		 movss	 xmm0, DWORD PTR pitch$[rsp]
  00139	e8 00 00 00 00	 call	 HMM_ToRad
  0013e	e8 00 00 00 00	 call	 ?cos@@YAMM@Z		; cos
  00143	f3 0f 10 4c 24
	3c		 movss	 xmm1, DWORD PTR tv95[rsp]
  00149	f3 0f 59 c8	 mulss	 xmm1, xmm0
  0014d	0f 28 c1	 movaps	 xmm0, xmm1
  00150	f3 0f 11 84 24
	48 01 00 00	 movss	 DWORD PTR front$[rsp+8], xmm0

; 52   :     
; 53   :     camera->front = HMM_NormV3(front);

  00159	48 8d 44 24 40	 lea	 rax, QWORD PTR $T1[rsp]
  0015e	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR front$[rsp]
  00166	48 8b f8	 mov	 rdi, rax
  00169	48 8b f1	 mov	 rsi, rcx
  0016c	b9 0c 00 00 00	 mov	 ecx, 12
  00171	f3 a4		 rep movsb
  00173	48 8d 54 24 40	 lea	 rdx, QWORD PTR $T1[rsp]
  00178	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR $T8[rsp]
  00180	e8 00 00 00 00	 call	 HMM_NormV3
  00185	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR $T14[rsp]
  0018d	48 8b f9	 mov	 rdi, rcx
  00190	48 8b f0	 mov	 rsi, rax
  00193	b9 0c 00 00 00	 mov	 ecx, 12
  00198	f3 a4		 rep movsb
  0019a	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR camera$[rsp]
  001a2	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR $T14[rsp]
  001aa	48 8d 78 18	 lea	 rdi, QWORD PTR [rax+24]
  001ae	48 8b f1	 mov	 rsi, rcx
  001b1	b9 0c 00 00 00	 mov	 ecx, 12
  001b6	f3 a4		 rep movsb

; 54   :     camera->right = HMM_NormV3(HMM_Cross(camera->front, camera->world_up));

  001b8	48 8d 44 24 50	 lea	 rax, QWORD PTR $T2[rsp]
  001bd	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR camera$[rsp]
  001c5	48 8b f8	 mov	 rdi, rax
  001c8	48 8d 71 3c	 lea	 rsi, QWORD PTR [rcx+60]
  001cc	b9 0c 00 00 00	 mov	 ecx, 12
  001d1	f3 a4		 rep movsb
  001d3	48 8d 44 24 60	 lea	 rax, QWORD PTR $T3[rsp]
  001d8	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR camera$[rsp]
  001e0	48 8b f8	 mov	 rdi, rax
  001e3	48 8d 71 18	 lea	 rsi, QWORD PTR [rcx+24]
  001e7	b9 0c 00 00 00	 mov	 ecx, 12
  001ec	f3 a4		 rep movsb
  001ee	4c 8d 44 24 50	 lea	 r8, QWORD PTR $T2[rsp]
  001f3	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T3[rsp]
  001f8	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR $T9[rsp]
  00200	e8 00 00 00 00	 call	 HMM_Cross
  00205	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR $T15[rsp]
  0020d	48 8b f9	 mov	 rdi, rcx
  00210	48 8b f0	 mov	 rsi, rax
  00213	b9 0c 00 00 00	 mov	 ecx, 12
  00218	f3 a4		 rep movsb
  0021a	48 8d 44 24 70	 lea	 rax, QWORD PTR $T4[rsp]
  0021f	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR $T15[rsp]
  00227	48 8b f8	 mov	 rdi, rax
  0022a	48 8b f1	 mov	 rsi, rcx
  0022d	b9 0c 00 00 00	 mov	 ecx, 12
  00232	f3 a4		 rep movsb
  00234	48 8d 54 24 70	 lea	 rdx, QWORD PTR $T4[rsp]
  00239	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR $T10[rsp]
  00241	e8 00 00 00 00	 call	 HMM_NormV3
  00246	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR $T16[rsp]
  0024e	48 8b f9	 mov	 rdi, rcx
  00251	48 8b f0	 mov	 rsi, rax
  00254	b9 0c 00 00 00	 mov	 ecx, 12
  00259	f3 a4		 rep movsb
  0025b	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR camera$[rsp]
  00263	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR $T16[rsp]
  0026b	48 8d 78 30	 lea	 rdi, QWORD PTR [rax+48]
  0026f	48 8b f1	 mov	 rsi, rcx
  00272	b9 0c 00 00 00	 mov	 ecx, 12
  00277	f3 a4		 rep movsb

; 55   :     camera->up = HMM_NormV3(HMM_Cross(camera->right, camera->front));

  00279	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR $T5[rsp]
  00281	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR camera$[rsp]
  00289	48 8b f8	 mov	 rdi, rax
  0028c	48 8d 71 18	 lea	 rsi, QWORD PTR [rcx+24]
  00290	b9 0c 00 00 00	 mov	 ecx, 12
  00295	f3 a4		 rep movsb
  00297	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR $T6[rsp]
  0029f	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR camera$[rsp]
  002a7	48 8b f8	 mov	 rdi, rax
  002aa	48 8d 71 30	 lea	 rsi, QWORD PTR [rcx+48]
  002ae	b9 0c 00 00 00	 mov	 ecx, 12
  002b3	f3 a4		 rep movsb
  002b5	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR $T5[rsp]
  002bd	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR $T6[rsp]
  002c5	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR $T11[rsp]
  002cd	e8 00 00 00 00	 call	 HMM_Cross
  002d2	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR $T17[rsp]
  002da	48 8b f9	 mov	 rdi, rcx
  002dd	48 8b f0	 mov	 rsi, rax
  002e0	b9 0c 00 00 00	 mov	 ecx, 12
  002e5	f3 a4		 rep movsb
  002e7	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR $T7[rsp]
  002ef	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR $T17[rsp]
  002f7	48 8b f8	 mov	 rdi, rax
  002fa	48 8b f1	 mov	 rsi, rcx
  002fd	b9 0c 00 00 00	 mov	 ecx, 12
  00302	f3 a4		 rep movsb
  00304	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR $T7[rsp]
  0030c	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR $T12[rsp]
  00314	e8 00 00 00 00	 call	 HMM_NormV3
  00319	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR $T18[rsp]
  00321	48 8b f9	 mov	 rdi, rcx
  00324	48 8b f0	 mov	 rsi, rax
  00327	b9 0c 00 00 00	 mov	 ecx, 12
  0032c	f3 a4		 rep movsb
  0032e	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR camera$[rsp]
  00336	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR $T18[rsp]
  0033e	48 8d 78 24	 lea	 rdi, QWORD PTR [rax+36]
  00342	48 8b f1	 mov	 rsi, rcx
  00345	b9 0c 00 00 00	 mov	 ecx, 12
  0034a	f3 a4		 rep movsb

; 56   : }

  0034c	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00354	48 33 cc	 xor	 rcx, rsp
  00357	e8 00 00 00 00	 call	 __security_check_cookie
  0035c	48 81 c4 f8 01
	00 00		 add	 rsp, 504		; 000001f8H
  00363	5f		 pop	 rdi
  00364	5e		 pop	 rsi
  00365	c3		 ret	 0
?update_camera@@YAXPEAUcamera_t@@@Z ENDP		; update_camera
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\renderer.cpp
_TEXT	SEGMENT
gl$ = 48
camera$ = 56
?init_gl_renderer@@YAXPEAUgl_renderer@@PEAUcamera_t@@@Z PROC ; init_gl_renderer

; 4    : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 5    :     glGenVertexArrays(1, &gl->vao);

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR gl$[rsp]
  00013	48 83 c0 54	 add	 rax, 84			; 00000054H
  00017	48 8b d0	 mov	 rdx, rax
  0001a	b9 01 00 00 00	 mov	 ecx, 1
  0001f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewGenVertexArrays
  00026	ff 10		 call	 QWORD PTR [rax]

; 6    :     glGenBuffers(VBO_COUNT, gl->vbos);

  00028	48 8b 44 24 30	 mov	 rax, QWORD PTR gl$[rsp]
  0002d	48 83 c0 40	 add	 rax, 64			; 00000040H
  00031	48 8b d0	 mov	 rdx, rax
  00034	b9 05 00 00 00	 mov	 ecx, 5
  00039	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewGenBuffers
  00040	ff 10		 call	 QWORD PTR [rax]

; 7    :     
; 8    :     gl->verts = NULL;

  00042	48 8b 44 24 30	 mov	 rax, QWORD PTR gl$[rsp]
  00047	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 9    :     gl->uvs = NULL;

  0004e	48 8b 44 24 30	 mov	 rax, QWORD PTR gl$[rsp]
  00053	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 10   :     gl->colors = NULL;

  0005b	48 8b 44 24 30	 mov	 rax, QWORD PTR gl$[rsp]
  00060	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 11   :     gl->indices = NULL;

  00068	48 8b 44 24 30	 mov	 rax, QWORD PTR gl$[rsp]
  0006d	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 12   :     
; 13   :     gl->cmds = NULL;

  00075	48 8b 44 24 30	 mov	 rax, QWORD PTR gl$[rsp]
  0007a	48 c7 40 28 00
	00 00 00	 mov	 QWORD PTR [rax+40], 0

; 14   :     gl->transforms = NULL;

  00082	48 8b 44 24 30	 mov	 rax, QWORD PTR gl$[rsp]
  00087	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0

; 15   :     gl->entities = NULL;

  0008f	48 8b 44 24 30	 mov	 rax, QWORD PTR gl$[rsp]
  00094	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 16   :     
; 17   :     gl->shaders = NULL;

  0009c	48 8b 44 24 30	 mov	 rax, QWORD PTR gl$[rsp]
  000a1	48 c7 40 58 00
	00 00 00	 mov	 QWORD PTR [rax+88], 0

; 18   :     
; 19   :     gl->camera = camera;

  000a9	48 8b 44 24 30	 mov	 rax, QWORD PTR gl$[rsp]
  000ae	48 8b 4c 24 38	 mov	 rcx, QWORD PTR camera$[rsp]
  000b3	48 89 88 10 01
	00 00		 mov	 QWORD PTR [rax+272], rcx

; 20   :     gl->light_count = 0;

  000ba	48 8b 44 24 30	 mov	 rax, QWORD PTR gl$[rsp]
  000bf	c7 80 f0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+240], 0

; 21   :     
; 22   :     gl->gpu_transform = 1;

  000c9	48 8b 44 24 30	 mov	 rax, QWORD PTR gl$[rsp]
  000ce	c7 80 08 01 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+264], 1

; 23   :     gl->use_textures = 1;

  000d8	48 8b 44 24 30	 mov	 rax, QWORD PTR gl$[rsp]
  000dd	c7 80 0c 01 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+268], 1

; 24   : }

  000e7	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000eb	c3		 ret	 0
?init_gl_renderer@@YAXPEAUgl_renderer@@PEAUcamera_t@@@Z ENDP ; init_gl_renderer
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\assets.cpp
_TEXT	SEGMENT
mesh_count$ = 32
i$1 = 36
i$2 = 40
tv71 = 44
tv75 = 48
tv81 = 52
tv87 = 56
mat_count$ = 60
mat_idx$ = 64
mesh_idx$ = 68
meshes$3 = 72
mesh_infos$ = 80
mats$4 = 88
info$ = 96
$T5 = 152
$T6 = 208
am$ = 304
filename$ = 312
m_info$ = 320
color$ = 328
?add_model@@YAXPEAUasset_manager_t@@PEADPEAUmodel_info_t@@Ucolor_t@@@Z PROC ; add_model

; 283  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H

; 284  :     obj_info_t info = load_obj(filename);

  0001d	48 8b 94 24 38
	01 00 00	 mov	 rdx, QWORD PTR filename$[rsp]
  00025	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR $T6[rsp]
  0002d	e8 00 00 00 00	 call	 ?load_obj@@YA?AUobj_info_t@@PEAD@Z ; load_obj
  00032	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR $T5[rsp]
  0003a	48 8b f9	 mov	 rdi, rcx
  0003d	48 8b f0	 mov	 rsi, rax
  00040	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00045	f3 a4		 rep movsb
  00047	48 8d 44 24 60	 lea	 rax, QWORD PTR info$[rsp]
  0004c	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR $T5[rsp]
  00054	48 8b f8	 mov	 rdi, rax
  00057	48 8b f1	 mov	 rsi, rcx
  0005a	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  0005f	f3 a4		 rep movsb

; 285  :     
; 286  :     u32 mesh_count = get_stack_count(info.objs);

  00061	48 83 7c 24 68
	00		 cmp	 QWORD PTR info$[rsp+8], 0
  00067	74 0e		 je	 SHORT $LN12@add_model
  00069	48 8b 44 24 68	 mov	 rax, QWORD PTR info$[rsp+8]
  0006e	8b 40 fc	 mov	 eax, DWORD PTR [rax-4]
  00071	89 44 24 2c	 mov	 DWORD PTR tv71[rsp], eax
  00075	eb 08		 jmp	 SHORT $LN13@add_model
$LN12@add_model:
  00077	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
$LN13@add_model:
  0007f	8b 44 24 2c	 mov	 eax, DWORD PTR tv71[rsp]
  00083	89 44 24 20	 mov	 DWORD PTR mesh_count$[rsp], eax

; 287  :     u32 mat_count = get_stack_count(info.materials);

  00087	48 83 7c 24 70
	00		 cmp	 QWORD PTR info$[rsp+16], 0
  0008d	74 0e		 je	 SHORT $LN14@add_model
  0008f	48 8b 44 24 70	 mov	 rax, QWORD PTR info$[rsp+16]
  00094	8b 40 fc	 mov	 eax, DWORD PTR [rax-4]
  00097	89 44 24 30	 mov	 DWORD PTR tv75[rsp], eax
  0009b	eb 08		 jmp	 SHORT $LN15@add_model
$LN14@add_model:
  0009d	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN15@add_model:
  000a5	8b 44 24 30	 mov	 eax, DWORD PTR tv75[rsp]
  000a9	89 44 24 3c	 mov	 DWORD PTR mat_count$[rsp], eax

; 288  :     
; 289  :     u32 mesh_idx = get_stack_count(am->meshes);

  000ad	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR am$[rsp]
  000b5	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000b9	74 14		 je	 SHORT $LN16@add_model
  000bb	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR am$[rsp]
  000c3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000c6	8b 40 fc	 mov	 eax, DWORD PTR [rax-4]
  000c9	89 44 24 34	 mov	 DWORD PTR tv81[rsp], eax
  000cd	eb 08		 jmp	 SHORT $LN17@add_model
$LN16@add_model:
  000cf	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN17@add_model:
  000d7	8b 44 24 34	 mov	 eax, DWORD PTR tv81[rsp]
  000db	89 44 24 44	 mov	 DWORD PTR mesh_idx$[rsp], eax

; 290  :     u32 mat_idx = get_stack_count(am->mats);

  000df	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR am$[rsp]
  000e7	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  000ec	74 15		 je	 SHORT $LN18@add_model
  000ee	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR am$[rsp]
  000f6	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000fa	8b 40 fc	 mov	 eax, DWORD PTR [rax-4]
  000fd	89 44 24 38	 mov	 DWORD PTR tv87[rsp], eax
  00101	eb 08		 jmp	 SHORT $LN19@add_model
$LN18@add_model:
  00103	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv87[rsp], 0
$LN19@add_model:
  0010b	8b 44 24 38	 mov	 eax, DWORD PTR tv87[rsp]
  0010f	89 44 24 40	 mov	 DWORD PTR mat_idx$[rsp], eax

; 291  :     
; 292  :     if(mesh_count) {

  00113	83 7c 24 20 00	 cmp	 DWORD PTR mesh_count$[rsp], 0
  00118	0f 84 b3 00 00
	00		 je	 $LN8@add_model

; 293  :         mesh_t *meshes = (mesh_t *)stack_push_array(&am->meshes, mesh_count);

  0011e	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR am$[rsp]
  00126	41 b8 38 00 00
	00		 mov	 r8d, 56			; 00000038H
  0012c	8b 54 24 20	 mov	 edx, DWORD PTR mesh_count$[rsp]
  00130	48 8b c8	 mov	 rcx, rax
  00133	e8 00 00 00 00	 call	 ?_stack_push@@YAPEAXPEAPEAXII@Z ; _stack_push
  00138	48 89 44 24 48	 mov	 QWORD PTR meshes$3[rsp], rax

; 294  :         create_model(meshes, &info, mat_idx, color);

  0013d	44 8b 8c 24 48
	01 00 00	 mov	 r9d, DWORD PTR color$[rsp]
  00145	44 8b 44 24 40	 mov	 r8d, DWORD PTR mat_idx$[rsp]
  0014a	48 8d 54 24 60	 lea	 rdx, QWORD PTR info$[rsp]
  0014f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR meshes$3[rsp]
  00154	e8 00 00 00 00	 call	 ?create_model@@YAXPEAUmesh_t@@PEAUobj_info_t@@IUcolor_t@@@Z ; create_model

; 295  :         
; 296  :         if(mat_count) {

  00159	83 7c 24 3c 00	 cmp	 DWORD PTR mat_count$[rsp], 0
  0015e	74 3c		 je	 SHORT $LN9@add_model

; 297  :             material_t *mats = (material_t *)stack_push_array(&am->mats, mat_count);

  00160	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR am$[rsp]
  00168	48 83 c0 08	 add	 rax, 8
  0016c	41 b8 68 00 00
	00		 mov	 r8d, 104		; 00000068H
  00172	8b 54 24 3c	 mov	 edx, DWORD PTR mat_count$[rsp]
  00176	48 8b c8	 mov	 rcx, rax
  00179	e8 00 00 00 00	 call	 ?_stack_push@@YAPEAXPEAPEAXII@Z ; _stack_push
  0017e	48 89 44 24 58	 mov	 QWORD PTR mats$4[rsp], rax

; 298  :             create_materials(am, mats, &info);

  00183	4c 8d 44 24 60	 lea	 r8, QWORD PTR info$[rsp]
  00188	48 8b 54 24 58	 mov	 rdx, QWORD PTR mats$4[rsp]
  0018d	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR am$[rsp]
  00195	e8 00 00 00 00	 call	 ?create_materials@@YAXPEAUasset_manager_t@@PEAUmaterial_t@@PEAUobj_info_t@@@Z ; create_materials

; 299  :         }

  0019a	eb 35		 jmp	 SHORT $LN10@add_model
$LN9@add_model:

; 300  :         else 
; 301  :         {
; 302  :             for (u32 i = 0; i < mesh_count; i++)

  0019c	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  001a4	eb 0a		 jmp	 SHORT $LN4@add_model
$LN2@add_model:
  001a6	8b 44 24 28	 mov	 eax, DWORD PTR i$2[rsp]
  001aa	ff c0		 inc	 eax
  001ac	89 44 24 28	 mov	 DWORD PTR i$2[rsp], eax
$LN4@add_model:
  001b0	8b 44 24 20	 mov	 eax, DWORD PTR mesh_count$[rsp]
  001b4	39 44 24 28	 cmp	 DWORD PTR i$2[rsp], eax
  001b8	73 17		 jae	 SHORT $LN3@add_model

; 303  :                 meshes[i].mat_id = 0;

  001ba	8b 44 24 28	 mov	 eax, DWORD PTR i$2[rsp]
  001be	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  001c2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR meshes$3[rsp]
  001c7	c7 44 01 30 00
	00 00 00	 mov	 DWORD PTR [rcx+rax+48], 0
  001cf	eb d5		 jmp	 SHORT $LN2@add_model
$LN3@add_model:
$LN10@add_model:
$LN8@add_model:

; 304  :         }
; 305  :     }
; 306  :     
; 307  :     free_obj(&info);

  001d1	48 8d 4c 24 60	 lea	 rcx, QWORD PTR info$[rsp]
  001d6	e8 00 00 00 00	 call	 ?free_obj@@YAXPEAUobj_info_t@@@Z ; free_obj

; 308  :     
; 309  :     mesh_info_t *mesh_infos = (mesh_info_t *)malloc(sizeof(mesh_info_t)*mesh_count);

  001db	8b 44 24 20	 mov	 eax, DWORD PTR mesh_count$[rsp]
  001df	48 6b c0 10	 imul	 rax, rax, 16
  001e3	48 8b c8	 mov	 rcx, rax
  001e6	e8 00 00 00 00	 call	 malloc
  001eb	48 89 44 24 50	 mov	 QWORD PTR mesh_infos$[rsp], rax

; 310  :     
; 311  :     for(u32 i = 0; i < mesh_count; i++)

  001f0	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  001f8	eb 0a		 jmp	 SHORT $LN7@add_model
$LN5@add_model:
  001fa	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  001fe	ff c0		 inc	 eax
  00200	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
$LN7@add_model:
  00204	8b 44 24 20	 mov	 eax, DWORD PTR mesh_count$[rsp]
  00208	39 44 24 24	 cmp	 DWORD PTR i$1[rsp], eax
  0020c	73 1e		 jae	 SHORT $LN6@add_model

; 312  :         mesh_infos[i].mesh_id = mesh_idx+i;

  0020e	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00212	8b 4c 24 44	 mov	 ecx, DWORD PTR mesh_idx$[rsp]
  00216	03 c8		 add	 ecx, eax
  00218	8b c1		 mov	 eax, ecx
  0021a	8b 4c 24 24	 mov	 ecx, DWORD PTR i$1[rsp]
  0021e	48 6b c9 10	 imul	 rcx, rcx, 16
  00222	48 8b 54 24 50	 mov	 rdx, QWORD PTR mesh_infos$[rsp]
  00227	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax
  0022a	eb ce		 jmp	 SHORT $LN5@add_model
$LN6@add_model:

; 313  :     
; 314  :     m_info->meshes = mesh_infos;

  0022c	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR m_info$[rsp]
  00234	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mesh_infos$[rsp]
  00239	48 89 08	 mov	 QWORD PTR [rax], rcx

; 315  :     m_info->mesh_count = mesh_count;

  0023c	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR m_info$[rsp]
  00244	8b 4c 24 20	 mov	 ecx, DWORD PTR mesh_count$[rsp]
  00248	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 316  : }

  0024b	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  00252	5f		 pop	 rdi
  00253	5e		 pop	 rsi
  00254	c3		 ret	 0
?add_model@@YAXPEAUasset_manager_t@@PEADPEAUmodel_info_t@@Ucolor_t@@@Z ENDP ; add_model
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\assets.cpp
_TEXT	SEGMENT
m_idx$1 = 32
mat$ = 40
t_idx$2 = 48
tv75 = 52
tex_name$3 = 56
tex_id$4 = 64
mat_count$ = 72
last_slash$ = 80
obj_mat$ = 96
path$ = 240
__$ArrayPad$ = 512
am$ = 560
mats$ = 568
info$ = 576
?create_materials@@YAXPEAUasset_manager_t@@PEAUmaterial_t@@PEAUobj_info_t@@@Z PROC ; create_materials

; 243  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 18 02
	00 00		 sub	 rsp, 536		; 00000218H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 00
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 244  :     material_t *mat;
; 245  :     obj_mat_t obj_mat;
; 246  :     
; 247  :     char path[PATH_MAX];
; 248  :     strcpy(path, info->path);

  0002a	48 8b 84 24 40
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00032	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00035	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR path$[rsp]
  0003d	e8 00 00 00 00	 call	 strcpy

; 249  :     char *last_slash = strrchr(path, '\\');

  00042	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  00047	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR path$[rsp]
  0004f	e8 00 00 00 00	 call	 ?strrchr@@YAPEADQEADH@Z	; strrchr
  00054	48 89 44 24 50	 mov	 QWORD PTR last_slash$[rsp], rax

; 250  :     
; 251  :     u32 mat_count = get_stack_count(info->materials);

  00059	48 8b 84 24 40
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00061	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00066	74 15		 je	 SHORT $LN11@create_mat
  00068	48 8b 84 24 40
	02 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00070	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00074	8b 40 fc	 mov	 eax, DWORD PTR [rax-4]
  00077	89 44 24 34	 mov	 DWORD PTR tv75[rsp], eax
  0007b	eb 08		 jmp	 SHORT $LN12@create_mat
$LN11@create_mat:
  0007d	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN12@create_mat:
  00085	8b 44 24 34	 mov	 eax, DWORD PTR tv75[rsp]
  00089	89 44 24 48	 mov	 DWORD PTR mat_count$[rsp], eax

; 252  :     for(u32 m_idx = 0; m_idx < mat_count; m_idx++) {

  0008d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR m_idx$1[rsp], 0
  00095	eb 0a		 jmp	 SHORT $LN4@create_mat
$LN2@create_mat:
  00097	8b 44 24 20	 mov	 eax, DWORD PTR m_idx$1[rsp]
  0009b	ff c0		 inc	 eax
  0009d	89 44 24 20	 mov	 DWORD PTR m_idx$1[rsp], eax
$LN4@create_mat:
  000a1	8b 44 24 48	 mov	 eax, DWORD PTR mat_count$[rsp]
  000a5	39 44 24 20	 cmp	 DWORD PTR m_idx$1[rsp], eax
  000a9	0f 83 c3 01 00
	00		 jae	 $LN3@create_mat

; 253  :         mat = mats + m_idx;

  000af	8b 44 24 20	 mov	 eax, DWORD PTR m_idx$1[rsp]
  000b3	48 6b c0 68	 imul	 rax, rax, 104		; 00000068H
  000b7	48 8b 8c 24 38
	02 00 00	 mov	 rcx, QWORD PTR mats$[rsp]
  000bf	48 03 c8	 add	 rcx, rax
  000c2	48 8b c1	 mov	 rax, rcx
  000c5	48 89 44 24 28	 mov	 QWORD PTR mat$[rsp], rax

; 254  :         obj_mat = info->materials[m_idx];

  000ca	8b 44 24 20	 mov	 eax, DWORD PTR m_idx$1[rsp]
  000ce	48 69 c0 90 00
	00 00		 imul	 rax, rax, 144		; 00000090H
  000d5	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  000dd	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000e1	48 8d 54 24 60	 lea	 rdx, QWORD PTR obj_mat$[rsp]
  000e6	48 8b fa	 mov	 rdi, rdx
  000e9	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  000ed	b9 90 00 00 00	 mov	 ecx, 144		; 00000090H
  000f2	f3 a4		 rep movsb

; 255  :         
; 256  :         memcpy(mat->ambient, obj_mat.ambient, sizeof(f32)*3);

  000f4	48 8b 44 24 28	 mov	 rax, QWORD PTR mat$[rsp]
  000f9	41 b8 0c 00 00
	00		 mov	 r8d, 12
  000ff	48 8d 54 24 68	 lea	 rdx, QWORD PTR obj_mat$[rsp+8]
  00104	48 8b c8	 mov	 rcx, rax
  00107	e8 00 00 00 00	 call	 memcpy

; 257  :         memcpy(mat->diffuse, obj_mat.diffuse, sizeof(f32)*3);

  0010c	48 8b 44 24 28	 mov	 rax, QWORD PTR mat$[rsp]
  00111	48 83 c0 0c	 add	 rax, 12
  00115	41 b8 0c 00 00
	00		 mov	 r8d, 12
  0011b	48 8d 54 24 74	 lea	 rdx, QWORD PTR obj_mat$[rsp+20]
  00120	48 8b c8	 mov	 rcx, rax
  00123	e8 00 00 00 00	 call	 memcpy

; 258  :         memcpy(mat->specular, obj_mat.specular, sizeof(f32)*3);

  00128	48 8b 44 24 28	 mov	 rax, QWORD PTR mat$[rsp]
  0012d	48 83 c0 18	 add	 rax, 24
  00131	41 b8 0c 00 00
	00		 mov	 r8d, 12
  00137	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR obj_mat$[rsp+32]
  0013f	48 8b c8	 mov	 rcx, rax
  00142	e8 00 00 00 00	 call	 memcpy

; 259  :         memcpy(mat->transmittance, obj_mat.transmittance, sizeof(f32)*3);

  00147	48 8b 44 24 28	 mov	 rax, QWORD PTR mat$[rsp]
  0014c	48 83 c0 24	 add	 rax, 36			; 00000024H
  00150	41 b8 0c 00 00
	00		 mov	 r8d, 12
  00156	48 8d 94 24 8c
	00 00 00	 lea	 rdx, QWORD PTR obj_mat$[rsp+44]
  0015e	48 8b c8	 mov	 rcx, rax
  00161	e8 00 00 00 00	 call	 memcpy

; 260  :         memcpy(mat->emission, obj_mat.emission, sizeof(f32)*3);

  00166	48 8b 44 24 28	 mov	 rax, QWORD PTR mat$[rsp]
  0016b	48 83 c0 30	 add	 rax, 48			; 00000030H
  0016f	41 b8 0c 00 00
	00		 mov	 r8d, 12
  00175	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR obj_mat$[rsp+56]
  0017d	48 8b c8	 mov	 rcx, rax
  00180	e8 00 00 00 00	 call	 memcpy

; 261  :         mat->shininess = obj_mat.shininess;

  00185	48 8b 44 24 28	 mov	 rax, QWORD PTR mat$[rsp]
  0018a	f3 0f 10 84 24
	a4 00 00 00	 movss	 xmm0, DWORD PTR obj_mat$[rsp+68]
  00193	f3 0f 11 40 3c	 movss	 DWORD PTR [rax+60], xmm0

; 262  :         mat->index_of_refraction = obj_mat.index_of_refraction;

  00198	48 8b 44 24 28	 mov	 rax, QWORD PTR mat$[rsp]
  0019d	f3 0f 10 84 24
	a8 00 00 00	 movss	 xmm0, DWORD PTR obj_mat$[rsp+72]
  001a6	f3 0f 11 40 40	 movss	 DWORD PTR [rax+64], xmm0

; 263  :         mat->dissolve = obj_mat.dissolve;

  001ab	48 8b 44 24 28	 mov	 rax, QWORD PTR mat$[rsp]
  001b0	f3 0f 10 84 24
	ac 00 00 00	 movss	 xmm0, DWORD PTR obj_mat$[rsp+76]
  001b9	f3 0f 11 40 44	 movss	 DWORD PTR [rax+68], xmm0

; 264  :         mat->illum = obj_mat.illum;

  001be	48 8b 44 24 28	 mov	 rax, QWORD PTR mat$[rsp]
  001c3	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR obj_mat$[rsp+80]
  001ca	89 48 48	 mov	 DWORD PTR [rax+72], ecx

; 265  :         
; 266  :         // TODO(ajeej): remove double back slashes
; 267  :         char **tex_name = obj_mat.tex_names;

  001cd	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR obj_mat$[rsp+88]
  001d5	48 89 44 24 38	 mov	 QWORD PTR tex_name$3[rsp], rax

; 268  :         u32 *tex_id = mat->tex_ids;

  001da	48 8b 44 24 28	 mov	 rax, QWORD PTR mat$[rsp]
  001df	48 83 c0 4c	 add	 rax, 76			; 0000004cH
  001e3	48 89 44 24 40	 mov	 QWORD PTR tex_id$4[rsp], rax

; 269  :         for(u32 t_idx = 0; t_idx < 7; t_idx++, tex_name++, tex_id++) {

  001e8	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR t_idx$2[rsp], 0
  001f0	eb 26		 jmp	 SHORT $LN7@create_mat
$LN5@create_mat:
  001f2	8b 44 24 30	 mov	 eax, DWORD PTR t_idx$2[rsp]
  001f6	ff c0		 inc	 eax
  001f8	89 44 24 30	 mov	 DWORD PTR t_idx$2[rsp], eax
  001fc	48 8b 44 24 38	 mov	 rax, QWORD PTR tex_name$3[rsp]
  00201	48 83 c0 08	 add	 rax, 8
  00205	48 89 44 24 38	 mov	 QWORD PTR tex_name$3[rsp], rax
  0020a	48 8b 44 24 40	 mov	 rax, QWORD PTR tex_id$4[rsp]
  0020f	48 83 c0 04	 add	 rax, 4
  00213	48 89 44 24 40	 mov	 QWORD PTR tex_id$4[rsp], rax
$LN7@create_mat:
  00218	83 7c 24 30 07	 cmp	 DWORD PTR t_idx$2[rsp], 7
  0021d	73 4e		 jae	 SHORT $LN6@create_mat

; 270  :             if(*tex_name) {

  0021f	48 8b 44 24 38	 mov	 rax, QWORD PTR tex_name$3[rsp]
  00224	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00228	74 36		 je	 SHORT $LN8@create_mat

; 271  :                 strcpy(last_slash+1, *tex_name);

  0022a	48 8b 44 24 50	 mov	 rax, QWORD PTR last_slash$[rsp]
  0022f	48 ff c0	 inc	 rax
  00232	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tex_name$3[rsp]
  00237	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  0023a	48 8b c8	 mov	 rcx, rax
  0023d	e8 00 00 00 00	 call	 strcpy

; 272  :                 *tex_id = create_texture(am, path);

  00242	48 8d 94 24 f0
	00 00 00	 lea	 rdx, QWORD PTR path$[rsp]
  0024a	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR am$[rsp]
  00252	e8 00 00 00 00	 call	 ?create_texture@@YAIPEAUasset_manager_t@@PEAD@Z ; create_texture
  00257	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tex_id$4[rsp]
  0025c	89 01		 mov	 DWORD PTR [rcx], eax

; 273  :             } else {

  0025e	eb 0b		 jmp	 SHORT $LN9@create_mat
$LN8@create_mat:

; 274  :                 *tex_id = 0;

  00260	48 8b 44 24 40	 mov	 rax, QWORD PTR tex_id$4[rsp]
  00265	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN9@create_mat:

; 275  :             }
; 276  :         }

  0026b	eb 85		 jmp	 SHORT $LN5@create_mat
$LN6@create_mat:

; 277  :     }

  0026d	e9 25 fe ff ff	 jmp	 $LN2@create_mat
$LN3@create_mat:

; 278  : }

  00272	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0027a	48 33 cc	 xor	 rcx, rsp
  0027d	e8 00 00 00 00	 call	 __security_check_cookie
  00282	48 81 c4 18 02
	00 00		 add	 rsp, 536		; 00000218H
  00289	5f		 pop	 rdi
  0028a	5e		 pop	 rsi
  0028b	c3		 ret	 0
?create_materials@@YAXPEAUasset_manager_t@@PEAUmaterial_t@@PEAUobj_info_t@@@Z ENDP ; create_materials
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\assets.cpp
_TEXT	SEGMENT
ch$ = 48
h$ = 52
w$ = 56
id$ = 60
data$ = 64
am$ = 96
filename$ = 104
?create_texture@@YAIPEAUasset_manager_t@@PEAD@Z PROC	; create_texture

; 230  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 231  :     i32 w, h, ch;
; 232  :     u8 *data = (u8 *)stbi_load(filename, &w, &h, &ch, 0);

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00016	4c 8d 4c 24 30	 lea	 r9, QWORD PTR ch$[rsp]
  0001b	4c 8d 44 24 34	 lea	 r8, QWORD PTR h$[rsp]
  00020	48 8d 54 24 38	 lea	 rdx, QWORD PTR w$[rsp]
  00025	48 8b 4c 24 68	 mov	 rcx, QWORD PTR filename$[rsp]
  0002a	e8 00 00 00 00	 call	 stbi_load
  0002f	48 89 44 24 40	 mov	 QWORD PTR data$[rsp], rax

; 233  :     
; 234  :     int id = create_texture_from_bitmap(am, data, w, h, ch);

  00034	8b 44 24 30	 mov	 eax, DWORD PTR ch$[rsp]
  00038	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0003c	44 8b 4c 24 34	 mov	 r9d, DWORD PTR h$[rsp]
  00041	44 8b 44 24 38	 mov	 r8d, DWORD PTR w$[rsp]
  00046	48 8b 54 24 40	 mov	 rdx, QWORD PTR data$[rsp]
  0004b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR am$[rsp]
  00050	e8 00 00 00 00	 call	 ?create_texture_from_bitmap@@YAIPEAUasset_manager_t@@PEAEHHH@Z ; create_texture_from_bitmap
  00055	89 44 24 3c	 mov	 DWORD PTR id$[rsp], eax

; 235  :     
; 236  :     stbi_image_free(data);

  00059	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  0005e	e8 00 00 00 00	 call	 stbi_image_free

; 237  :     
; 238  :     return id;

  00063	8b 44 24 3c	 mov	 eax, DWORD PTR id$[rsp]

; 239  : }

  00067	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0006b	c3		 ret	 0
?create_texture@@YAIPEAUasset_manager_t@@PEAD@Z ENDP	; create_texture
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\assets.cpp
_TEXT	SEGMENT
v_count$1 = 32
mesh$ = 40
o_idx$2 = 48
cur_idx$ = 52
i$3 = 56
idx$4 = 64
i_idx$5 = 72
i_count$6 = 76
indices$ = 80
vertex_map$ = 88
verts$ = 96
uvs$ = 104
norms$ = 112
tv70 = 120
it$7 = 124
k$8 = 128
tv245 = 132
tv249 = 136
obj_count$ = 140
value$9 = 144
tv341 = 148
tv345 = 152
tv349 = 156
tv353 = 160
sv$ = 168
sn$ = 176
i$10 = 184
st$ = 192
v$ = 200
n$ = 208
t$ = 216
$T11 = 224
$T12 = 240
obj$ = 256
$T13 = 288
$T14 = 304
$T15 = 320
$T16 = 328
$T17 = 344
__$ArrayPad$ = 360
meshes$ = 400
info$ = 408
mat_idx$ = 416
color$ = 424
?create_model@@YAXPEAUmesh_t@@PEAUobj_info_t@@IUcolor_t@@@Z PROC ; create_model

; 130  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 131  :     f32 *sv, *sn, *st;
; 132  :     v3 *verts = NULL, *v; v3 *norms = NULL, *n; v2 *uvs = NULL, *t;

  0002f	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR verts$[rsp], 0
  00038	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR norms$[rsp], 0
  00041	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR uvs$[rsp], 0

; 133  :     u32 *indices = NULL;

  0004a	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR indices$[rsp], 0

; 134  :     vertex_t vert;
; 135  :     
; 136  :     khash_t(vertex_map_t) *vertex_map = kh_init(vertex_map_t);;

  00053	e8 00 00 00 00	 call	 ?kh_init_vertex_map_t@@YAPEAUkh_vertex_map_t_s@@XZ ; kh_init_vertex_map_t
  00058	48 89 44 24 58	 mov	 QWORD PTR vertex_map$[rsp], rax

; 137  :     
; 138  :     obj_t obj; mesh_t *mesh;
; 139  :     u32 obj_count = get_stack_count(info->objs);

  0005d	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00065	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0006a	74 15		 je	 SHORT $LN21@create_mod
  0006c	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00074	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00078	8b 40 fc	 mov	 eax, DWORD PTR [rax-4]
  0007b	89 44 24 78	 mov	 DWORD PTR tv70[rsp], eax
  0007f	eb 08		 jmp	 SHORT $LN22@create_mod
$LN21@create_mod:
  00081	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN22@create_mod:
  00089	8b 44 24 78	 mov	 eax, DWORD PTR tv70[rsp]
  0008d	89 84 24 8c 00
	00 00		 mov	 DWORD PTR obj_count$[rsp], eax

; 140  :     
; 141  :     u32 cur_idx = 0;

  00094	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR cur_idx$[rsp], 0

; 142  :     
; 143  :     for(u32 o_idx = 0; o_idx < obj_count; o_idx++) {

  0009c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR o_idx$2[rsp], 0
  000a4	eb 0a		 jmp	 SHORT $LN4@create_mod
$LN2@create_mod:
  000a6	8b 44 24 30	 mov	 eax, DWORD PTR o_idx$2[rsp]
  000aa	ff c0		 inc	 eax
  000ac	89 44 24 30	 mov	 DWORD PTR o_idx$2[rsp], eax
$LN4@create_mod:
  000b0	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR obj_count$[rsp]
  000b7	39 44 24 30	 cmp	 DWORD PTR o_idx$2[rsp], eax
  000bb	0f 83 6c 06 00
	00		 jae	 $LN3@create_mod

; 144  :         obj = info->objs[o_idx];

  000c1	8b 44 24 30	 mov	 eax, DWORD PTR o_idx$2[rsp]
  000c5	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  000c9	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  000d1	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000d5	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR obj$[rsp]
  000dd	48 8b fa	 mov	 rdi, rdx
  000e0	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  000e4	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000e9	f3 a4		 rep movsb

; 145  :         mesh = meshes+o_idx;

  000eb	8b 44 24 30	 mov	 eax, DWORD PTR o_idx$2[rsp]
  000ef	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  000f3	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR meshes$[rsp]
  000fb	48 03 c8	 add	 rcx, rax
  000fe	48 8b c1	 mov	 rax, rcx
  00101	48 89 44 24 28	 mov	 QWORD PTR mesh$[rsp], rax

; 146  :         
; 147  :         vert_idx_t *idx = info->v_idx+obj.idx_offset;

  00106	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR obj$[rsp+16]
  0010d	48 6b c0 0c	 imul	 rax, rax, 12
  00111	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  00119	48 03 41 30	 add	 rax, QWORD PTR [rcx+48]
  0011d	48 89 44 24 40	 mov	 QWORD PTR idx$4[rsp], rax

; 148  :         for(u32 i_idx = 0; i_idx < obj.idx_count; i_idx++, idx++) {

  00122	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR i_idx$5[rsp], 0
  0012a	eb 18		 jmp	 SHORT $LN7@create_mod
$LN5@create_mod:
  0012c	8b 44 24 48	 mov	 eax, DWORD PTR i_idx$5[rsp]
  00130	ff c0		 inc	 eax
  00132	89 44 24 48	 mov	 DWORD PTR i_idx$5[rsp], eax
  00136	48 8b 44 24 40	 mov	 rax, QWORD PTR idx$4[rsp]
  0013b	48 83 c0 0c	 add	 rax, 12
  0013f	48 89 44 24 40	 mov	 QWORD PTR idx$4[rsp], rax
$LN7@create_mod:
  00144	8b 84 24 14 01
	00 00		 mov	 eax, DWORD PTR obj$[rsp+20]
  0014b	39 44 24 48	 cmp	 DWORD PTR i_idx$5[rsp], eax
  0014f	0f 83 23 03 00
	00		 jae	 $LN6@create_mod

; 149  :             
; 150  :             khiter_t it = kh_get(vertex_map_t, vertex_map, *idx);

  00155	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR $T11[rsp]
  0015d	48 8b f8	 mov	 rdi, rax
  00160	48 8b 74 24 40	 mov	 rsi, QWORD PTR idx$4[rsp]
  00165	b9 0c 00 00 00	 mov	 ecx, 12
  0016a	f3 a4		 rep movsb
  0016c	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR $T11[rsp]
  00174	48 8b 4c 24 58	 mov	 rcx, QWORD PTR vertex_map$[rsp]
  00179	e8 00 00 00 00	 call	 ?kh_get_vertex_map_t@@YAIPEBUkh_vertex_map_t_s@@Tvert_idx_t@@@Z ; kh_get_vertex_map_t
  0017e	89 44 24 7c	 mov	 DWORD PTR it$7[rsp], eax

; 151  :             u32 *i = (u32 *)stack_push(&indices);

  00182	41 b8 04 00 00
	00		 mov	 r8d, 4
  00188	ba 01 00 00 00	 mov	 edx, 1
  0018d	48 8d 4c 24 50	 lea	 rcx, QWORD PTR indices$[rsp]
  00192	e8 00 00 00 00	 call	 ?_stack_push@@YAPEAXPEAPEAXII@Z ; _stack_push
  00197	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR i$10[rsp], rax

; 152  :             if (it != kh_end(vertex_map)) {

  0019f	48 8b 44 24 58	 mov	 rax, QWORD PTR vertex_map$[rsp]
  001a4	8b 00		 mov	 eax, DWORD PTR [rax]
  001a6	39 44 24 7c	 cmp	 DWORD PTR it$7[rsp], eax
  001aa	74 1f		 je	 SHORT $LN11@create_mod

; 153  :                 *i = kh_value(vertex_map, it);

  001ac	8b 44 24 7c	 mov	 eax, DWORD PTR it$7[rsp]
  001b0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR vertex_map$[rsp]
  001b5	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  001b9	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR i$10[rsp]
  001c1	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  001c4	89 02		 mov	 DWORD PTR [rdx], eax

; 154  :             } else {

  001c6	e9 a8 02 00 00	 jmp	 $LN12@create_mod
$LN11@create_mod:

; 155  :                 i32 value;
; 156  :                 khint_t k = kh_put(vertex_map_t, vertex_map, *idx, (int *)&value);

  001cb	48 8d 84 24 f0
	00 00 00	 lea	 rax, QWORD PTR $T12[rsp]
  001d3	48 8b f8	 mov	 rdi, rax
  001d6	48 8b 74 24 40	 mov	 rsi, QWORD PTR idx$4[rsp]
  001db	b9 0c 00 00 00	 mov	 ecx, 12
  001e0	f3 a4		 rep movsb
  001e2	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR value$9[rsp]
  001ea	48 8d 94 24 f0
	00 00 00	 lea	 rdx, QWORD PTR $T12[rsp]
  001f2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR vertex_map$[rsp]
  001f7	e8 00 00 00 00	 call	 ?kh_put_vertex_map_t@@YAIPEAUkh_vertex_map_t_s@@Tvert_idx_t@@PEAH@Z ; kh_put_vertex_map_t
  001fc	89 84 24 80 00
	00 00		 mov	 DWORD PTR k$8[rsp], eax

; 157  :                 if(!value) kh_del(vertex_map_t, vertex_map, k);

  00203	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR value$9[rsp], 0
  0020b	75 11		 jne	 SHORT $LN13@create_mod
  0020d	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR k$8[rsp]
  00214	48 8b 4c 24 58	 mov	 rcx, QWORD PTR vertex_map$[rsp]
  00219	e8 00 00 00 00	 call	 ?kh_del_vertex_map_t@@YAXPEAUkh_vertex_map_t_s@@I@Z ; kh_del_vertex_map_t
$LN13@create_mod:

; 158  :                 
; 159  :                 kh_value(vertex_map, k) = cur_idx;

  0021e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR k$8[rsp]
  00225	48 8b 4c 24 58	 mov	 rcx, QWORD PTR vertex_map$[rsp]
  0022a	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  0022e	8b 54 24 34	 mov	 edx, DWORD PTR cur_idx$[rsp]
  00232	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx

; 160  :                 *i = cur_idx++;

  00235	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR i$10[rsp]
  0023d	8b 4c 24 34	 mov	 ecx, DWORD PTR cur_idx$[rsp]
  00241	89 08		 mov	 DWORD PTR [rax], ecx
  00243	8b 44 24 34	 mov	 eax, DWORD PTR cur_idx$[rsp]
  00247	ff c0		 inc	 eax
  00249	89 44 24 34	 mov	 DWORD PTR cur_idx$[rsp], eax

; 161  :                 
; 162  :                 sv = info->v+idx->v*3;

  0024d	48 8b 44 24 40	 mov	 rax, QWORD PTR idx$4[rsp]
  00252	6b 00 03	 imul	 eax, DWORD PTR [rax], 3
  00255	48 98		 cdqe
  00257	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  0025f	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00263	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  00267	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR sv$[rsp], rax

; 163  :                 v = (v3 *)stack_push(&verts);

  0026f	41 b8 0c 00 00
	00		 mov	 r8d, 12
  00275	ba 01 00 00 00	 mov	 edx, 1
  0027a	48 8d 4c 24 60	 lea	 rcx, QWORD PTR verts$[rsp]
  0027f	e8 00 00 00 00	 call	 ?_stack_push@@YAPEAXPEAPEAXII@Z ; _stack_push
  00284	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR v$[rsp], rax

; 164  :                 *v = HMM_V3(sv[0], sv[1], sv[2]);

  0028c	b8 04 00 00 00	 mov	 eax, 4
  00291	48 6b c0 02	 imul	 rax, rax, 2
  00295	b9 04 00 00 00	 mov	 ecx, 4
  0029a	48 6b c9 01	 imul	 rcx, rcx, 1
  0029e	ba 04 00 00 00	 mov	 edx, 4
  002a3	48 6b d2 00	 imul	 rdx, rdx, 0
  002a7	48 8b bc 24 a8
	00 00 00	 mov	 rdi, QWORD PTR sv$[rsp]
  002af	f3 0f 10 1c 07	 movss	 xmm3, DWORD PTR [rdi+rax]
  002b4	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR sv$[rsp]
  002bc	f3 0f 10 14 08	 movss	 xmm2, DWORD PTR [rax+rcx]
  002c1	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR sv$[rsp]
  002c9	f3 0f 10 0c 10	 movss	 xmm1, DWORD PTR [rax+rdx]
  002ce	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR $T13[rsp]
  002d6	e8 00 00 00 00	 call	 HMM_V3
  002db	48 8d 8c 24 48
	01 00 00	 lea	 rcx, QWORD PTR $T16[rsp]
  002e3	48 8b f9	 mov	 rdi, rcx
  002e6	48 8b f0	 mov	 rsi, rax
  002e9	b9 0c 00 00 00	 mov	 ecx, 12
  002ee	f3 a4		 rep movsb
  002f0	48 8d 84 24 48
	01 00 00	 lea	 rax, QWORD PTR $T16[rsp]
  002f8	48 8b bc 24 c8
	00 00 00	 mov	 rdi, QWORD PTR v$[rsp]
  00300	48 8b f0	 mov	 rsi, rax
  00303	b9 0c 00 00 00	 mov	 ecx, 12
  00308	f3 a4		 rep movsb

; 165  :                 
; 166  :                 if(idx->vn != (u32)(-1)) {

  0030a	48 8b 44 24 40	 mov	 rax, QWORD PTR idx$4[rsp]
  0030f	83 78 04 ff	 cmp	 DWORD PTR [rax+4], -1	; ffffffffH
  00313	0f 84 be 00 00
	00		 je	 $LN14@create_mod

; 167  :                     sn = info->vn+idx->vn*3;

  00319	48 8b 44 24 40	 mov	 rax, QWORD PTR idx$4[rsp]
  0031e	6b 40 04 03	 imul	 eax, DWORD PTR [rax+4], 3
  00322	48 98		 cdqe
  00324	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  0032c	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00330	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  00334	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR sn$[rsp], rax

; 168  :                     n = (v3 *)stack_push(&norms);

  0033c	41 b8 0c 00 00
	00		 mov	 r8d, 12
  00342	ba 01 00 00 00	 mov	 edx, 1
  00347	48 8d 4c 24 70	 lea	 rcx, QWORD PTR norms$[rsp]
  0034c	e8 00 00 00 00	 call	 ?_stack_push@@YAPEAXPEAPEAXII@Z ; _stack_push
  00351	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR n$[rsp], rax

; 169  :                     *n = HMM_V3(sn[0], sn[1], sn[2]);

  00359	b8 04 00 00 00	 mov	 eax, 4
  0035e	48 6b c0 02	 imul	 rax, rax, 2
  00362	b9 04 00 00 00	 mov	 ecx, 4
  00367	48 6b c9 01	 imul	 rcx, rcx, 1
  0036b	ba 04 00 00 00	 mov	 edx, 4
  00370	48 6b d2 00	 imul	 rdx, rdx, 0
  00374	48 8b bc 24 b0
	00 00 00	 mov	 rdi, QWORD PTR sn$[rsp]
  0037c	f3 0f 10 1c 07	 movss	 xmm3, DWORD PTR [rdi+rax]
  00381	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sn$[rsp]
  00389	f3 0f 10 14 08	 movss	 xmm2, DWORD PTR [rax+rcx]
  0038e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR sn$[rsp]
  00396	f3 0f 10 0c 10	 movss	 xmm1, DWORD PTR [rax+rdx]
  0039b	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR $T14[rsp]
  003a3	e8 00 00 00 00	 call	 HMM_V3
  003a8	48 8d 8c 24 58
	01 00 00	 lea	 rcx, QWORD PTR $T17[rsp]
  003b0	48 8b f9	 mov	 rdi, rcx
  003b3	48 8b f0	 mov	 rsi, rax
  003b6	b9 0c 00 00 00	 mov	 ecx, 12
  003bb	f3 a4		 rep movsb
  003bd	48 8d 84 24 58
	01 00 00	 lea	 rax, QWORD PTR $T17[rsp]
  003c5	48 8b bc 24 d0
	00 00 00	 mov	 rdi, QWORD PTR n$[rsp]
  003cd	48 8b f0	 mov	 rsi, rax
  003d0	b9 0c 00 00 00	 mov	 ecx, 12
  003d5	f3 a4		 rep movsb
$LN14@create_mod:

; 170  :                 }
; 171  :                 
; 172  :                 if(idx->vt != (u32)(-1)) {

  003d7	48 8b 44 24 40	 mov	 rax, QWORD PTR idx$4[rsp]
  003dc	83 78 08 ff	 cmp	 DWORD PTR [rax+8], -1	; ffffffffH
  003e0	0f 84 8d 00 00
	00		 je	 $LN15@create_mod

; 173  :                     st = info->vt+idx->vt*2;

  003e6	48 8b 44 24 40	 mov	 rax, QWORD PTR idx$4[rsp]
  003eb	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  003ee	d1 e0		 shl	 eax, 1
  003f0	48 98		 cdqe
  003f2	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR info$[rsp]
  003fa	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  003fe	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  00402	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR st$[rsp], rax

; 174  :                     t = (v2 *)stack_push(&uvs);

  0040a	41 b8 08 00 00
	00		 mov	 r8d, 8
  00410	ba 01 00 00 00	 mov	 edx, 1
  00415	48 8d 4c 24 68	 lea	 rcx, QWORD PTR uvs$[rsp]
  0041a	e8 00 00 00 00	 call	 ?_stack_push@@YAPEAXPEAPEAXII@Z ; _stack_push
  0041f	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR t$[rsp], rax

; 175  :                     *t = HMM_V2(st[0], st[1]);

  00427	b8 04 00 00 00	 mov	 eax, 4
  0042c	48 6b c0 01	 imul	 rax, rax, 1
  00430	b9 04 00 00 00	 mov	 ecx, 4
  00435	48 6b c9 00	 imul	 rcx, rcx, 0
  00439	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR st$[rsp]
  00441	f3 0f 10 0c 02	 movss	 xmm1, DWORD PTR [rdx+rax]
  00446	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR st$[rsp]
  0044e	f3 0f 10 04 08	 movss	 xmm0, DWORD PTR [rax+rcx]
  00453	e8 00 00 00 00	 call	 HMM_V2
  00458	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR $T15[rsp], rax
  00460	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR t$[rsp]
  00468	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR $T15[rsp]
  00470	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN15@create_mod:
$LN12@create_mod:

; 176  :                 }
; 177  :             }
; 178  :             
; 179  :         }

  00473	e9 b4 fc ff ff	 jmp	 $LN5@create_mod
$LN6@create_mod:

; 180  :         
; 181  :         u32 v_count = get_stack_count(verts);

  00478	48 83 7c 24 60
	00		 cmp	 QWORD PTR verts$[rsp], 0
  0047e	74 11		 je	 SHORT $LN23@create_mod
  00480	48 8b 44 24 60	 mov	 rax, QWORD PTR verts$[rsp]
  00485	8b 40 fc	 mov	 eax, DWORD PTR [rax-4]
  00488	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv245[rsp], eax
  0048f	eb 0b		 jmp	 SHORT $LN24@create_mod
$LN23@create_mod:
  00491	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv245[rsp], 0
$LN24@create_mod:
  0049c	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv245[rsp]
  004a3	89 44 24 20	 mov	 DWORD PTR v_count$1[rsp], eax

; 182  :         u32 i_count = get_stack_count(indices);

  004a7	48 83 7c 24 50
	00		 cmp	 QWORD PTR indices$[rsp], 0
  004ad	74 11		 je	 SHORT $LN25@create_mod
  004af	48 8b 44 24 50	 mov	 rax, QWORD PTR indices$[rsp]
  004b4	8b 40 fc	 mov	 eax, DWORD PTR [rax-4]
  004b7	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv249[rsp], eax
  004be	eb 0b		 jmp	 SHORT $LN26@create_mod
$LN25@create_mod:
  004c0	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv249[rsp], 0
$LN26@create_mod:
  004cb	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv249[rsp]
  004d2	89 44 24 4c	 mov	 DWORD PTR i_count$6[rsp], eax

; 183  :         
; 184  :         //for(u32 i = 0; i < i_count; i++)
; 185  :         //LOG("%u", indices[i]);
; 186  :         
; 187  :         mesh->verts = (v3 *)malloc(sizeof(v3)*v_count);

  004d6	8b 44 24 20	 mov	 eax, DWORD PTR v_count$1[rsp]
  004da	48 6b c0 0c	 imul	 rax, rax, 12
  004de	48 8b c8	 mov	 rcx, rax
  004e1	e8 00 00 00 00	 call	 malloc
  004e6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR mesh$[rsp]
  004eb	48 89 01	 mov	 QWORD PTR [rcx], rax

; 188  :         mesh->uvs = (v2 *)malloc(sizeof(v2)*v_count);

  004ee	8b 44 24 20	 mov	 eax, DWORD PTR v_count$1[rsp]
  004f2	48 c1 e0 03	 shl	 rax, 3
  004f6	48 8b c8	 mov	 rcx, rax
  004f9	e8 00 00 00 00	 call	 malloc
  004fe	48 8b 4c 24 28	 mov	 rcx, QWORD PTR mesh$[rsp]
  00503	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 189  :         memset(mesh->uvs, 0, sizeof(v2)*v_count);

  00507	8b 44 24 20	 mov	 eax, DWORD PTR v_count$1[rsp]
  0050b	48 c1 e0 03	 shl	 rax, 3
  0050f	4c 8b c0	 mov	 r8, rax
  00512	33 d2		 xor	 edx, edx
  00514	48 8b 44 24 28	 mov	 rax, QWORD PTR mesh$[rsp]
  00519	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0051d	e8 00 00 00 00	 call	 memset

; 190  :         mesh->norms = (v3 *)malloc(sizeof(v3)*v_count);

  00522	8b 44 24 20	 mov	 eax, DWORD PTR v_count$1[rsp]
  00526	48 6b c0 0c	 imul	 rax, rax, 12
  0052a	48 8b c8	 mov	 rcx, rax
  0052d	e8 00 00 00 00	 call	 malloc
  00532	48 8b 4c 24 28	 mov	 rcx, QWORD PTR mesh$[rsp]
  00537	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 191  :         memset(mesh->norms, 0, sizeof(v3)*v_count);

  0053b	8b 44 24 20	 mov	 eax, DWORD PTR v_count$1[rsp]
  0053f	48 6b c0 0c	 imul	 rax, rax, 12
  00543	4c 8b c0	 mov	 r8, rax
  00546	33 d2		 xor	 edx, edx
  00548	48 8b 44 24 28	 mov	 rax, QWORD PTR mesh$[rsp]
  0054d	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00551	e8 00 00 00 00	 call	 memset

; 192  :         mesh->colors = (color_t *)malloc(sizeof(color_t)*v_count);

  00556	8b 44 24 20	 mov	 eax, DWORD PTR v_count$1[rsp]
  0055a	48 c1 e0 02	 shl	 rax, 2
  0055e	48 8b c8	 mov	 rcx, rax
  00561	e8 00 00 00 00	 call	 malloc
  00566	48 8b 4c 24 28	 mov	 rcx, QWORD PTR mesh$[rsp]
  0056b	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 193  :         mesh->indices = (u32 *)malloc(sizeof(u32)*i_count);

  0056f	8b 44 24 4c	 mov	 eax, DWORD PTR i_count$6[rsp]
  00573	48 c1 e0 02	 shl	 rax, 2
  00577	48 8b c8	 mov	 rcx, rax
  0057a	e8 00 00 00 00	 call	 malloc
  0057f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR mesh$[rsp]
  00584	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 194  :         
; 195  :         memcpy(mesh->verts, verts, sizeof(v3)*v_count);

  00588	8b 44 24 20	 mov	 eax, DWORD PTR v_count$1[rsp]
  0058c	48 6b c0 0c	 imul	 rax, rax, 12
  00590	4c 8b c0	 mov	 r8, rax
  00593	48 8b 54 24 60	 mov	 rdx, QWORD PTR verts$[rsp]
  00598	48 8b 44 24 28	 mov	 rax, QWORD PTR mesh$[rsp]
  0059d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  005a0	e8 00 00 00 00	 call	 memcpy

; 196  :         
; 197  :         if(uvs)

  005a5	48 83 7c 24 68
	00		 cmp	 QWORD PTR uvs$[rsp], 0
  005ab	74 1e		 je	 SHORT $LN16@create_mod

; 198  :             memcpy(mesh->uvs, uvs, sizeof(v2)*v_count);

  005ad	8b 44 24 20	 mov	 eax, DWORD PTR v_count$1[rsp]
  005b1	48 c1 e0 03	 shl	 rax, 3
  005b5	4c 8b c0	 mov	 r8, rax
  005b8	48 8b 54 24 68	 mov	 rdx, QWORD PTR uvs$[rsp]
  005bd	48 8b 44 24 28	 mov	 rax, QWORD PTR mesh$[rsp]
  005c2	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  005c6	e8 00 00 00 00	 call	 memcpy
$LN16@create_mod:

; 199  :         if(norms)

  005cb	48 83 7c 24 70
	00		 cmp	 QWORD PTR norms$[rsp], 0
  005d1	74 1e		 je	 SHORT $LN17@create_mod

; 200  :             memcpy(mesh->norms, norms, sizeof(v3)*v_count);

  005d3	8b 44 24 20	 mov	 eax, DWORD PTR v_count$1[rsp]
  005d7	48 6b c0 0c	 imul	 rax, rax, 12
  005db	4c 8b c0	 mov	 r8, rax
  005de	48 8b 54 24 70	 mov	 rdx, QWORD PTR norms$[rsp]
  005e3	48 8b 44 24 28	 mov	 rax, QWORD PTR mesh$[rsp]
  005e8	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  005ec	e8 00 00 00 00	 call	 memcpy
$LN17@create_mod:

; 201  :         
; 202  :         for(u32 i = 0; i < v_count; i ++)

  005f1	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR i$3[rsp], 0
  005f9	eb 0a		 jmp	 SHORT $LN10@create_mod
$LN8@create_mod:
  005fb	8b 44 24 38	 mov	 eax, DWORD PTR i$3[rsp]
  005ff	ff c0		 inc	 eax
  00601	89 44 24 38	 mov	 DWORD PTR i$3[rsp], eax
$LN10@create_mod:
  00605	8b 44 24 20	 mov	 eax, DWORD PTR v_count$1[rsp]
  00609	39 44 24 38	 cmp	 DWORD PTR i$3[rsp], eax
  0060d	73 19		 jae	 SHORT $LN9@create_mod

; 203  :             mesh->colors[i] = color;

  0060f	8b 44 24 38	 mov	 eax, DWORD PTR i$3[rsp]
  00613	48 8b 4c 24 28	 mov	 rcx, QWORD PTR mesh$[rsp]
  00618	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0061c	8b 94 24 a8 01
	00 00		 mov	 edx, DWORD PTR color$[rsp]
  00623	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx
  00626	eb d3		 jmp	 SHORT $LN8@create_mod
$LN9@create_mod:

; 204  :         
; 205  :         memcpy(mesh->indices, indices, sizeof(u32)*i_count);

  00628	8b 44 24 4c	 mov	 eax, DWORD PTR i_count$6[rsp]
  0062c	48 c1 e0 02	 shl	 rax, 2
  00630	4c 8b c0	 mov	 r8, rax
  00633	48 8b 54 24 50	 mov	 rdx, QWORD PTR indices$[rsp]
  00638	48 8b 44 24 28	 mov	 rax, QWORD PTR mesh$[rsp]
  0063d	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  00641	e8 00 00 00 00	 call	 memcpy

; 206  :         
; 207  :         mesh->vert_count = v_count;

  00646	48 8b 44 24 28	 mov	 rax, QWORD PTR mesh$[rsp]
  0064b	8b 4c 24 20	 mov	 ecx, DWORD PTR v_count$1[rsp]
  0064f	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 208  :         mesh->indices_count = i_count;

  00652	48 8b 44 24 28	 mov	 rax, QWORD PTR mesh$[rsp]
  00657	8b 4c 24 4c	 mov	 ecx, DWORD PTR i_count$6[rsp]
  0065b	89 48 2c	 mov	 DWORD PTR [rax+44], ecx

; 209  :         
; 210  :         mesh->mat_id = obj.mat_id + mat_idx;

  0065e	8b 84 24 a0 01
	00 00		 mov	 eax, DWORD PTR mat_idx$[rsp]
  00665	8b 8c 24 18 01
	00 00		 mov	 ecx, DWORD PTR obj$[rsp+24]
  0066c	03 c8		 add	 ecx, eax
  0066e	8b c1		 mov	 eax, ecx
  00670	48 8b 4c 24 28	 mov	 rcx, QWORD PTR mesh$[rsp]
  00675	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 211  :         
; 212  :         stack_clear(verts);

  00678	48 83 7c 24 60
	00		 cmp	 QWORD PTR verts$[rsp], 0
  0067e	74 19		 je	 SHORT $LN27@create_mod
  00680	48 8b 44 24 60	 mov	 rax, QWORD PTR verts$[rsp]
  00685	c7 40 fc 00 00
	00 00		 mov	 DWORD PTR [rax-4], 0
  0068c	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv341[rsp], 0
  00697	eb 0b		 jmp	 SHORT $LN28@create_mod
$LN27@create_mod:
  00699	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv341[rsp], 0
$LN28@create_mod:

; 213  :         stack_clear(uvs);

  006a4	48 83 7c 24 68
	00		 cmp	 QWORD PTR uvs$[rsp], 0
  006aa	74 19		 je	 SHORT $LN29@create_mod
  006ac	48 8b 44 24 68	 mov	 rax, QWORD PTR uvs$[rsp]
  006b1	c7 40 fc 00 00
	00 00		 mov	 DWORD PTR [rax-4], 0
  006b8	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv345[rsp], 0
  006c3	eb 0b		 jmp	 SHORT $LN30@create_mod
$LN29@create_mod:
  006c5	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv345[rsp], 0
$LN30@create_mod:

; 214  :         stack_clear(norms);

  006d0	48 83 7c 24 70
	00		 cmp	 QWORD PTR norms$[rsp], 0
  006d6	74 19		 je	 SHORT $LN31@create_mod
  006d8	48 8b 44 24 70	 mov	 rax, QWORD PTR norms$[rsp]
  006dd	c7 40 fc 00 00
	00 00		 mov	 DWORD PTR [rax-4], 0
  006e4	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv349[rsp], 0
  006ef	eb 0b		 jmp	 SHORT $LN32@create_mod
$LN31@create_mod:
  006f1	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv349[rsp], 0
$LN32@create_mod:

; 215  :         stack_clear(indices);

  006fc	48 83 7c 24 50
	00		 cmp	 QWORD PTR indices$[rsp], 0
  00702	74 19		 je	 SHORT $LN33@create_mod
  00704	48 8b 44 24 50	 mov	 rax, QWORD PTR indices$[rsp]
  00709	c7 40 fc 00 00
	00 00		 mov	 DWORD PTR [rax-4], 0
  00710	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv353[rsp], 0
  0071b	eb 0b		 jmp	 SHORT $LN34@create_mod
$LN33@create_mod:
  0071d	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv353[rsp], 0
$LN34@create_mod:

; 216  :         
; 217  :     }

  00728	e9 79 f9 ff ff	 jmp	 $LN2@create_mod
$LN3@create_mod:

; 218  :     kh_destroy(vertex_map_t, vertex_map);

  0072d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR vertex_map$[rsp]
  00732	e8 00 00 00 00	 call	 ?kh_destroy_vertex_map_t@@YAXPEAUkh_vertex_map_t_s@@@Z ; kh_destroy_vertex_map_t

; 219  :     
; 220  :     stack_free(verts);

  00737	48 8b 44 24 60	 mov	 rax, QWORD PTR verts$[rsp]
  0073c	48 83 e8 08	 sub	 rax, 8
  00740	48 8b c8	 mov	 rcx, rax
  00743	e8 00 00 00 00	 call	 free

; 221  :     if(uvs)

  00748	48 83 7c 24 68
	00		 cmp	 QWORD PTR uvs$[rsp], 0
  0074e	74 11		 je	 SHORT $LN18@create_mod

; 222  :         stack_free(uvs);

  00750	48 8b 44 24 68	 mov	 rax, QWORD PTR uvs$[rsp]
  00755	48 83 e8 08	 sub	 rax, 8
  00759	48 8b c8	 mov	 rcx, rax
  0075c	e8 00 00 00 00	 call	 free
$LN18@create_mod:

; 223  :     if(norms)

  00761	48 83 7c 24 70
	00		 cmp	 QWORD PTR norms$[rsp], 0
  00767	74 11		 je	 SHORT $LN19@create_mod

; 224  :         stack_free(norms);

  00769	48 8b 44 24 70	 mov	 rax, QWORD PTR norms$[rsp]
  0076e	48 83 e8 08	 sub	 rax, 8
  00772	48 8b c8	 mov	 rcx, rax
  00775	e8 00 00 00 00	 call	 free
$LN19@create_mod:

; 225  :     stack_free(indices);

  0077a	48 8b 44 24 50	 mov	 rax, QWORD PTR indices$[rsp]
  0077f	48 83 e8 08	 sub	 rax, 8
  00783	48 8b c8	 mov	 rcx, rax
  00786	e8 00 00 00 00	 call	 free

; 226  : }

  0078b	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00793	48 33 cc	 xor	 rcx, rsp
  00796	e8 00 00 00 00	 call	 __security_check_cookie
  0079b	48 81 c4 78 01
	00 00		 add	 rsp, 376		; 00000178H
  007a2	5f		 pop	 rdi
  007a3	5e		 pop	 rsi
  007a4	c3		 ret	 0
?create_model@@YAXPEAUmesh_t@@PEAUobj_info_t@@IUcolor_t@@@Z ENDP ; create_model
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\assets.cpp
_TEXT	SEGMENT
tv128 = 0
tv95 = 8
h$ = 32
x$ = 40
?kh_del_vertex_map_t@@YAXPEAUkh_vertex_map_t_s@@I@Z PROC ; kh_del_vertex_map_t

; 126  : KHASH_INIT(vertex_map_t, vert_idx_t, u32, 1, kh_hash_func, kh_hash_equal)

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24
  0000d	48 8b 44 24 20	 mov	 rax, QWORD PTR h$[rsp]
  00012	8b 00		 mov	 eax, DWORD PTR [rax]
  00014	39 44 24 28	 cmp	 DWORD PTR x$[rsp], eax
  00018	0f 84 93 00 00
	00		 je	 $LN2@kh_del_ver
  0001e	8b 44 24 28	 mov	 eax, DWORD PTR x$[rsp]
  00022	c1 e8 04	 shr	 eax, 4
  00025	8b c0		 mov	 eax, eax
  00027	48 8b 4c 24 20	 mov	 rcx, QWORD PTR h$[rsp]
  0002c	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00030	48 89 0c 24	 mov	 QWORD PTR tv128[rsp], rcx
  00034	8b 54 24 28	 mov	 edx, DWORD PTR x$[rsp]
  00038	83 e2 0f	 and	 edx, 15
  0003b	d1 e2		 shl	 edx, 1
  0003d	0f b6 ca	 movzx	 ecx, dl
  00040	48 8b 14 24	 mov	 rdx, QWORD PTR tv128[rsp]
  00044	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  00047	d3 e8		 shr	 eax, cl
  00049	83 e0 03	 and	 eax, 3
  0004c	85 c0		 test	 eax, eax
  0004e	75 61		 jne	 SHORT $LN2@kh_del_ver
  00050	8b 44 24 28	 mov	 eax, DWORD PTR x$[rsp]
  00054	c1 e8 04	 shr	 eax, 4
  00057	8b c0		 mov	 eax, eax
  00059	48 8b 4c 24 20	 mov	 rcx, QWORD PTR h$[rsp]
  0005e	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00062	48 89 4c 24 08	 mov	 QWORD PTR tv95[rsp], rcx
  00067	8b 54 24 28	 mov	 edx, DWORD PTR x$[rsp]
  0006b	83 e2 0f	 and	 edx, 15
  0006e	d1 e2		 shl	 edx, 1
  00070	41 b8 01 00 00
	00		 mov	 r8d, 1
  00076	0f b6 ca	 movzx	 ecx, dl
  00079	41 8b d0	 mov	 edx, r8d
  0007c	d3 e2		 shl	 edx, cl
  0007e	8b ca		 mov	 ecx, edx
  00080	48 8b 54 24 08	 mov	 rdx, QWORD PTR tv95[rsp]
  00085	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  00088	0b c1		 or	 eax, ecx
  0008a	8b 4c 24 28	 mov	 ecx, DWORD PTR x$[rsp]
  0008e	c1 e9 04	 shr	 ecx, 4
  00091	8b c9		 mov	 ecx, ecx
  00093	48 8b 54 24 20	 mov	 rdx, QWORD PTR h$[rsp]
  00098	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  0009c	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
  0009f	48 8b 44 24 20	 mov	 rax, QWORD PTR h$[rsp]
  000a4	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  000a7	ff c8		 dec	 eax
  000a9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR h$[rsp]
  000ae	89 41 04	 mov	 DWORD PTR [rcx+4], eax
$LN2@kh_del_ver:
  000b1	48 83 c4 18	 add	 rsp, 24
  000b5	c3		 ret	 0
?kh_del_vertex_map_t@@YAXPEAUkh_vertex_map_t_s@@I@Z ENDP ; kh_del_vertex_map_t
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\assets.cpp
_TEXT	SEGMENT
i$1 = 32
x$ = 36
site$2 = 40
step$3 = 44
mask$4 = 48
k$5 = 52
last$6 = 56
tv291 = 64
tv290 = 72
tv289 = 80
tv285 = 88
tv284 = 96
tv283 = 104
tv281 = 112
tv277 = 120
tv275 = 128
h$ = 176
key$ = 184
ret$ = 192
?kh_put_vertex_map_t@@YAIPEAUkh_vertex_map_t_s@@Tvert_idx_t@@PEAH@Z PROC ; kh_put_vertex_map_t

; 126  : KHASH_INIT(vertex_map_t, vert_idx_t, u32, 1, kh_hash_func, kh_hash_equal)

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00018	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR h$[rsp]
  00020	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  00028	8b 49 0c	 mov	 ecx, DWORD PTR [rcx+12]
  0002b	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  0002e	0f 82 93 00 00
	00		 jb	 $LN4@kh_put_ver
  00034	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR h$[rsp]
  0003c	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0003f	d1 e0		 shl	 eax, 1
  00041	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  00049	39 01		 cmp	 DWORD PTR [rcx], eax
  0004b	76 3e		 jbe	 SHORT $LN5@kh_put_ver
  0004d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR h$[rsp]
  00055	8b 00		 mov	 eax, DWORD PTR [rax]
  00057	ff c8		 dec	 eax
  00059	8b d0		 mov	 edx, eax
  0005b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  00063	e8 00 00 00 00	 call	 ?kh_resize_vertex_map_t@@YAHPEAUkh_vertex_map_t_s@@I@Z ; kh_resize_vertex_map_t
  00068	85 c0		 test	 eax, eax
  0006a	7d 1d		 jge	 SHORT $LN7@kh_put_ver
  0006c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ret$[rsp]
  00074	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [rax], -1
  0007a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR h$[rsp]
  00082	8b 00		 mov	 eax, DWORD PTR [rax]
  00084	e9 8b 04 00 00	 jmp	 $LN1@kh_put_ver
$LN7@kh_put_ver:
  00089	eb 3c		 jmp	 SHORT $LN6@kh_put_ver
$LN5@kh_put_ver:
  0008b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR h$[rsp]
  00093	8b 00		 mov	 eax, DWORD PTR [rax]
  00095	ff c0		 inc	 eax
  00097	8b d0		 mov	 edx, eax
  00099	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  000a1	e8 00 00 00 00	 call	 ?kh_resize_vertex_map_t@@YAHPEAUkh_vertex_map_t_s@@I@Z ; kh_resize_vertex_map_t
  000a6	85 c0		 test	 eax, eax
  000a8	7d 1d		 jge	 SHORT $LN8@kh_put_ver
  000aa	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ret$[rsp]
  000b2	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [rax], -1
  000b8	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR h$[rsp]
  000c0	8b 00		 mov	 eax, DWORD PTR [rax]
  000c2	e9 4d 04 00 00	 jmp	 $LN1@kh_put_ver
$LN8@kh_put_ver:
$LN6@kh_put_ver:
$LN4@kh_put_ver:
  000c7	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR h$[rsp]
  000cf	8b 00		 mov	 eax, DWORD PTR [rax]
  000d1	ff c8		 dec	 eax
  000d3	89 44 24 30	 mov	 DWORD PTR mask$4[rsp], eax
  000d7	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR step$3[rsp], 0
  000df	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR h$[rsp]
  000e7	8b 00		 mov	 eax, DWORD PTR [rax]
  000e9	89 44 24 28	 mov	 DWORD PTR site$2[rsp], eax
  000ed	8b 44 24 28	 mov	 eax, DWORD PTR site$2[rsp]
  000f1	89 44 24 24	 mov	 DWORD PTR x$[rsp], eax
  000f5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR key$[rsp]
  000fd	48 8b c8	 mov	 rcx, rax
  00100	e8 00 00 00 00	 call	 ?hash_vert_idx@@YA_KPEAH@Z ; hash_vert_idx
  00105	89 44 24 34	 mov	 DWORD PTR k$5[rsp], eax
  00109	8b 44 24 30	 mov	 eax, DWORD PTR mask$4[rsp]
  0010d	8b 4c 24 34	 mov	 ecx, DWORD PTR k$5[rsp]
  00111	23 c8		 and	 ecx, eax
  00113	8b c1		 mov	 eax, ecx
  00115	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00119	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0011d	c1 e8 04	 shr	 eax, 4
  00120	8b c0		 mov	 eax, eax
  00122	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  0012a	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0012e	48 89 4c 24 40	 mov	 QWORD PTR tv291[rsp], rcx
  00133	8b 54 24 20	 mov	 edx, DWORD PTR i$1[rsp]
  00137	83 e2 0f	 and	 edx, 15
  0013a	d1 e2		 shl	 edx, 1
  0013c	0f b6 ca	 movzx	 ecx, dl
  0013f	48 8b 54 24 40	 mov	 rdx, QWORD PTR tv291[rsp]
  00144	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  00147	d3 e8		 shr	 eax, cl
  00149	83 e0 02	 and	 eax, 2
  0014c	85 c0		 test	 eax, eax
  0014e	74 0d		 je	 SHORT $LN9@kh_put_ver
  00150	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00154	89 44 24 24	 mov	 DWORD PTR x$[rsp], eax
  00158	e9 c6 01 00 00	 jmp	 $LN10@kh_put_ver
$LN9@kh_put_ver:
  0015d	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00161	89 44 24 38	 mov	 DWORD PTR last$6[rsp], eax
$LN2@kh_put_ver:
  00165	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00169	c1 e8 04	 shr	 eax, 4
  0016c	8b c0		 mov	 eax, eax
  0016e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  00176	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0017a	48 89 4c 24 48	 mov	 QWORD PTR tv290[rsp], rcx
  0017f	8b 54 24 20	 mov	 edx, DWORD PTR i$1[rsp]
  00183	83 e2 0f	 and	 edx, 15
  00186	d1 e2		 shl	 edx, 1
  00188	0f b6 ca	 movzx	 ecx, dl
  0018b	48 8b 54 24 48	 mov	 rdx, QWORD PTR tv290[rsp]
  00190	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  00193	d3 e8		 shr	 eax, cl
  00195	83 e0 02	 and	 eax, 2
  00198	85 c0		 test	 eax, eax
  0019a	0f 85 1a 01 00
	00		 jne	 $LN3@kh_put_ver
  001a0	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  001a4	c1 e8 04	 shr	 eax, 4
  001a7	8b c0		 mov	 eax, eax
  001a9	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  001b1	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  001b5	48 89 4c 24 50	 mov	 QWORD PTR tv289[rsp], rcx
  001ba	8b 54 24 20	 mov	 edx, DWORD PTR i$1[rsp]
  001be	83 e2 0f	 and	 edx, 15
  001c1	d1 e2		 shl	 edx, 1
  001c3	0f b6 ca	 movzx	 ecx, dl
  001c6	48 8b 54 24 50	 mov	 rdx, QWORD PTR tv289[rsp]
  001cb	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  001ce	d3 e8		 shr	 eax, cl
  001d0	83 e0 01	 and	 eax, 1
  001d3	85 c0		 test	 eax, eax
  001d5	75 6d		 jne	 SHORT $LN11@kh_put_ver
  001d7	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  001db	48 6b c0 0c	 imul	 rax, rax, 12
  001df	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  001e7	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  001eb	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  001f3	8b 12		 mov	 edx, DWORD PTR [rdx]
  001f5	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  001f8	75 4a		 jne	 SHORT $LN12@kh_put_ver
  001fa	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  001fe	48 6b c0 0c	 imul	 rax, rax, 12
  00202	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  0020a	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0020e	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  00216	8b 52 04	 mov	 edx, DWORD PTR [rdx+4]
  00219	39 54 01 04	 cmp	 DWORD PTR [rcx+rax+4], edx
  0021d	75 25		 jne	 SHORT $LN12@kh_put_ver
  0021f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00223	48 6b c0 0c	 imul	 rax, rax, 12
  00227	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  0022f	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00233	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  0023b	8b 52 08	 mov	 edx, DWORD PTR [rdx+8]
  0023e	39 54 01 08	 cmp	 DWORD PTR [rcx+rax+8], edx
  00242	74 76		 je	 SHORT $LN3@kh_put_ver
$LN12@kh_put_ver:
$LN11@kh_put_ver:
  00244	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00248	c1 e8 04	 shr	 eax, 4
  0024b	8b c0		 mov	 eax, eax
  0024d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  00255	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00259	48 89 4c 24 58	 mov	 QWORD PTR tv285[rsp], rcx
  0025e	8b 54 24 20	 mov	 edx, DWORD PTR i$1[rsp]
  00262	83 e2 0f	 and	 edx, 15
  00265	d1 e2		 shl	 edx, 1
  00267	0f b6 ca	 movzx	 ecx, dl
  0026a	48 8b 54 24 58	 mov	 rdx, QWORD PTR tv285[rsp]
  0026f	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  00272	d3 e8		 shr	 eax, cl
  00274	83 e0 01	 and	 eax, 1
  00277	85 c0		 test	 eax, eax
  00279	74 08		 je	 SHORT $LN13@kh_put_ver
  0027b	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0027f	89 44 24 28	 mov	 DWORD PTR site$2[rsp], eax
$LN13@kh_put_ver:
  00283	8b 44 24 2c	 mov	 eax, DWORD PTR step$3[rsp]
  00287	ff c0		 inc	 eax
  00289	89 44 24 2c	 mov	 DWORD PTR step$3[rsp], eax
  0028d	8b 44 24 2c	 mov	 eax, DWORD PTR step$3[rsp]
  00291	8b 4c 24 20	 mov	 ecx, DWORD PTR i$1[rsp]
  00295	03 c8		 add	 ecx, eax
  00297	8b c1		 mov	 eax, ecx
  00299	23 44 24 30	 and	 eax, DWORD PTR mask$4[rsp]
  0029d	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  002a1	8b 44 24 38	 mov	 eax, DWORD PTR last$6[rsp]
  002a5	39 44 24 20	 cmp	 DWORD PTR i$1[rsp], eax
  002a9	75 0a		 jne	 SHORT $LN14@kh_put_ver
  002ab	8b 44 24 28	 mov	 eax, DWORD PTR site$2[rsp]
  002af	89 44 24 24	 mov	 DWORD PTR x$[rsp], eax
  002b3	eb 05		 jmp	 SHORT $LN3@kh_put_ver
$LN14@kh_put_ver:
  002b5	e9 ab fe ff ff	 jmp	 $LN2@kh_put_ver
$LN3@kh_put_ver:
  002ba	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR h$[rsp]
  002c2	8b 00		 mov	 eax, DWORD PTR [rax]
  002c4	39 44 24 24	 cmp	 DWORD PTR x$[rsp], eax
  002c8	75 59		 jne	 SHORT $LN15@kh_put_ver
  002ca	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  002ce	c1 e8 04	 shr	 eax, 4
  002d1	8b c0		 mov	 eax, eax
  002d3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  002db	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  002df	48 89 4c 24 60	 mov	 QWORD PTR tv284[rsp], rcx
  002e4	8b 54 24 20	 mov	 edx, DWORD PTR i$1[rsp]
  002e8	83 e2 0f	 and	 edx, 15
  002eb	d1 e2		 shl	 edx, 1
  002ed	0f b6 ca	 movzx	 ecx, dl
  002f0	48 8b 54 24 60	 mov	 rdx, QWORD PTR tv284[rsp]
  002f5	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  002f8	d3 e8		 shr	 eax, cl
  002fa	83 e0 02	 and	 eax, 2
  002fd	85 c0		 test	 eax, eax
  002ff	74 1a		 je	 SHORT $LN16@kh_put_ver
  00301	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR h$[rsp]
  00309	8b 00		 mov	 eax, DWORD PTR [rax]
  0030b	39 44 24 28	 cmp	 DWORD PTR site$2[rsp], eax
  0030f	74 0a		 je	 SHORT $LN16@kh_put_ver
  00311	8b 44 24 28	 mov	 eax, DWORD PTR site$2[rsp]
  00315	89 44 24 24	 mov	 DWORD PTR x$[rsp], eax
  00319	eb 08		 jmp	 SHORT $LN17@kh_put_ver
$LN16@kh_put_ver:
  0031b	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0031f	89 44 24 24	 mov	 DWORD PTR x$[rsp], eax
$LN17@kh_put_ver:
$LN15@kh_put_ver:
$LN10@kh_put_ver:
  00323	8b 44 24 24	 mov	 eax, DWORD PTR x$[rsp]
  00327	c1 e8 04	 shr	 eax, 4
  0032a	8b c0		 mov	 eax, eax
  0032c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  00334	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00338	48 89 4c 24 68	 mov	 QWORD PTR tv283[rsp], rcx
  0033d	8b 54 24 24	 mov	 edx, DWORD PTR x$[rsp]
  00341	83 e2 0f	 and	 edx, 15
  00344	d1 e2		 shl	 edx, 1
  00346	0f b6 ca	 movzx	 ecx, dl
  00349	48 8b 54 24 68	 mov	 rdx, QWORD PTR tv283[rsp]
  0034e	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  00351	d3 e8		 shr	 eax, cl
  00353	83 e0 02	 and	 eax, 2
  00356	85 c0		 test	 eax, eax
  00358	0f 84 bf 00 00
	00		 je	 $LN18@kh_put_ver
  0035e	8b 44 24 24	 mov	 eax, DWORD PTR x$[rsp]
  00362	48 6b c0 0c	 imul	 rax, rax, 12
  00366	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  0036e	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00372	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]
  00376	48 8b b4 24 b8
	00 00 00	 mov	 rsi, QWORD PTR key$[rsp]
  0037e	b9 0c 00 00 00	 mov	 ecx, 12
  00383	f3 a4		 rep movsb
  00385	8b 44 24 24	 mov	 eax, DWORD PTR x$[rsp]
  00389	c1 e8 04	 shr	 eax, 4
  0038c	8b c0		 mov	 eax, eax
  0038e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  00396	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0039a	48 89 4c 24 70	 mov	 QWORD PTR tv281[rsp], rcx
  0039f	8b 54 24 24	 mov	 edx, DWORD PTR x$[rsp]
  003a3	83 e2 0f	 and	 edx, 15
  003a6	d1 e2		 shl	 edx, 1
  003a8	bf 03 00 00 00	 mov	 edi, 3
  003ad	0f b6 ca	 movzx	 ecx, dl
  003b0	8b d7		 mov	 edx, edi
  003b2	d3 e2		 shl	 edx, cl
  003b4	8b ca		 mov	 ecx, edx
  003b6	f7 d1		 not	 ecx
  003b8	48 8b 54 24 70	 mov	 rdx, QWORD PTR tv281[rsp]
  003bd	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  003c0	23 c1		 and	 eax, ecx
  003c2	8b 4c 24 24	 mov	 ecx, DWORD PTR x$[rsp]
  003c6	c1 e9 04	 shr	 ecx, 4
  003c9	8b c9		 mov	 ecx, ecx
  003cb	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR h$[rsp]
  003d3	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  003d7	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
  003da	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR h$[rsp]
  003e2	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  003e5	ff c0		 inc	 eax
  003e7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  003ef	89 41 04	 mov	 DWORD PTR [rcx+4], eax
  003f2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR h$[rsp]
  003fa	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  003fd	ff c0		 inc	 eax
  003ff	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  00407	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  0040a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ret$[rsp]
  00412	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1
  00418	e9 f3 00 00 00	 jmp	 $LN19@kh_put_ver
$LN18@kh_put_ver:
  0041d	8b 44 24 24	 mov	 eax, DWORD PTR x$[rsp]
  00421	c1 e8 04	 shr	 eax, 4
  00424	8b c0		 mov	 eax, eax
  00426	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  0042e	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00432	48 89 4c 24 78	 mov	 QWORD PTR tv277[rsp], rcx
  00437	8b 54 24 24	 mov	 edx, DWORD PTR x$[rsp]
  0043b	83 e2 0f	 and	 edx, 15
  0043e	d1 e2		 shl	 edx, 1
  00440	0f b6 ca	 movzx	 ecx, dl
  00443	48 8b 54 24 78	 mov	 rdx, QWORD PTR tv277[rsp]
  00448	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  0044b	d3 e8		 shr	 eax, cl
  0044d	83 e0 01	 and	 eax, 1
  00450	85 c0		 test	 eax, eax
  00452	0f 84 aa 00 00
	00		 je	 $LN20@kh_put_ver
  00458	8b 44 24 24	 mov	 eax, DWORD PTR x$[rsp]
  0045c	48 6b c0 0c	 imul	 rax, rax, 12
  00460	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  00468	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0046c	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]
  00470	48 8b b4 24 b8
	00 00 00	 mov	 rsi, QWORD PTR key$[rsp]
  00478	b9 0c 00 00 00	 mov	 ecx, 12
  0047d	f3 a4		 rep movsb
  0047f	8b 44 24 24	 mov	 eax, DWORD PTR x$[rsp]
  00483	c1 e8 04	 shr	 eax, 4
  00486	8b c0		 mov	 eax, eax
  00488	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  00490	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00494	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR tv275[rsp], rcx
  0049c	8b 54 24 24	 mov	 edx, DWORD PTR x$[rsp]
  004a0	83 e2 0f	 and	 edx, 15
  004a3	d1 e2		 shl	 edx, 1
  004a5	bf 03 00 00 00	 mov	 edi, 3
  004aa	0f b6 ca	 movzx	 ecx, dl
  004ad	8b d7		 mov	 edx, edi
  004af	d3 e2		 shl	 edx, cl
  004b1	8b ca		 mov	 ecx, edx
  004b3	f7 d1		 not	 ecx
  004b5	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR tv275[rsp]
  004bd	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  004c0	23 c1		 and	 eax, ecx
  004c2	8b 4c 24 24	 mov	 ecx, DWORD PTR x$[rsp]
  004c6	c1 e9 04	 shr	 ecx, 4
  004c9	8b c9		 mov	 ecx, ecx
  004cb	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR h$[rsp]
  004d3	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  004d7	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
  004da	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR h$[rsp]
  004e2	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  004e5	ff c0		 inc	 eax
  004e7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  004ef	89 41 04	 mov	 DWORD PTR [rcx+4], eax
  004f2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ret$[rsp]
  004fa	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2
  00500	eb 0e		 jmp	 SHORT $LN21@kh_put_ver
$LN20@kh_put_ver:
  00502	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ret$[rsp]
  0050a	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN21@kh_put_ver:
$LN19@kh_put_ver:
  00510	8b 44 24 24	 mov	 eax, DWORD PTR x$[rsp]
$LN1@kh_put_ver:
  00514	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0051b	5f		 pop	 rdi
  0051c	5e		 pop	 rsi
  0051d	c3		 ret	 0
?kh_put_vertex_map_t@@YAIPEAUkh_vertex_map_t_s@@Tvert_idx_t@@PEAH@Z ENDP ; kh_put_vertex_map_t
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\assets.cpp
_TEXT	SEGMENT
i$1 = 32
j$ = 36
new_flags$ = 40
step$2 = 48
val$3 = 52
tv89 = 56
tv130 = 60
new_mask$4 = 64
k$5 = 68
tmp$6 = 72
new_keys$7 = 80
new_vals$8 = 88
tv333 = 96
tv330 = 104
tv328 = 112
tv323 = 120
key$9 = 128
tmp$10 = 144
__$ArrayPad$ = 160
h$ = 208
new_n_buckets$ = 216
?kh_resize_vertex_map_t@@YAHPEAUkh_vertex_map_t_s@@I@Z PROC ; kh_resize_vertex_map_t

; 126  : KHASH_INIT(vertex_map_t, vert_idx_t, u32, 1, kh_hash_func, kh_hash_equal)

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00024	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR new_flags$[rsp], 0
  0002d	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR j$[rsp], 1
  00035	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR new_n_buckets$[rsp]
  0003c	ff c8		 dec	 eax
  0003e	89 84 24 d8 00
	00 00		 mov	 DWORD PTR new_n_buckets$[rsp], eax
  00045	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR new_n_buckets$[rsp]
  0004c	d1 e8		 shr	 eax, 1
  0004e	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR new_n_buckets$[rsp]
  00055	0b c8		 or	 ecx, eax
  00057	8b c1		 mov	 eax, ecx
  00059	89 84 24 d8 00
	00 00		 mov	 DWORD PTR new_n_buckets$[rsp], eax
  00060	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR new_n_buckets$[rsp]
  00067	c1 e8 02	 shr	 eax, 2
  0006a	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR new_n_buckets$[rsp]
  00071	0b c8		 or	 ecx, eax
  00073	8b c1		 mov	 eax, ecx
  00075	89 84 24 d8 00
	00 00		 mov	 DWORD PTR new_n_buckets$[rsp], eax
  0007c	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR new_n_buckets$[rsp]
  00083	c1 e8 04	 shr	 eax, 4
  00086	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR new_n_buckets$[rsp]
  0008d	0b c8		 or	 ecx, eax
  0008f	8b c1		 mov	 eax, ecx
  00091	89 84 24 d8 00
	00 00		 mov	 DWORD PTR new_n_buckets$[rsp], eax
  00098	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR new_n_buckets$[rsp]
  0009f	c1 e8 08	 shr	 eax, 8
  000a2	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR new_n_buckets$[rsp]
  000a9	0b c8		 or	 ecx, eax
  000ab	8b c1		 mov	 eax, ecx
  000ad	89 84 24 d8 00
	00 00		 mov	 DWORD PTR new_n_buckets$[rsp], eax
  000b4	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR new_n_buckets$[rsp]
  000bb	c1 e8 10	 shr	 eax, 16
  000be	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR new_n_buckets$[rsp]
  000c5	0b c8		 or	 ecx, eax
  000c7	8b c1		 mov	 eax, ecx
  000c9	89 84 24 d8 00
	00 00		 mov	 DWORD PTR new_n_buckets$[rsp], eax
  000d0	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR new_n_buckets$[rsp]
  000d7	ff c0		 inc	 eax
  000d9	89 84 24 d8 00
	00 00		 mov	 DWORD PTR new_n_buckets$[rsp], eax
  000e0	83 bc 24 d8 00
	00 00 04	 cmp	 DWORD PTR new_n_buckets$[rsp], 4
  000e8	73 0b		 jae	 SHORT $LN9@kh_resize_
  000ea	c7 84 24 d8 00
	00 00 04 00 00
	00		 mov	 DWORD PTR new_n_buckets$[rsp], 4
$LN9@kh_resize_:
  000f5	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR new_n_buckets$[rsp]
  000fc	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  00101	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fe8a3d70a3d70a4
  00109	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  00111	f2 48 0f 2c c0	 cvttsd2si rax, xmm0
  00116	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  0011e	39 41 04	 cmp	 DWORD PTR [rcx+4], eax
  00121	72 0d		 jb	 SHORT $LN10@kh_resize_
  00123	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  0012b	e9 45 01 00 00	 jmp	 $LN11@kh_resize_
$LN10@kh_resize_:
  00130	83 bc 24 d8 00
	00 00 10	 cmp	 DWORD PTR new_n_buckets$[rsp], 16
  00138	73 0a		 jae	 SHORT $LN27@kh_resize_
  0013a	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv89[rsp], 1
  00142	eb 0e		 jmp	 SHORT $LN28@kh_resize_
$LN27@kh_resize_:
  00144	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR new_n_buckets$[rsp]
  0014b	c1 e8 04	 shr	 eax, 4
  0014e	89 44 24 38	 mov	 DWORD PTR tv89[rsp], eax
$LN28@kh_resize_:
  00152	8b 44 24 38	 mov	 eax, DWORD PTR tv89[rsp]
  00156	48 c1 e0 02	 shl	 rax, 2
  0015a	48 8b c8	 mov	 rcx, rax
  0015d	e8 00 00 00 00	 call	 malloc
  00162	48 89 44 24 28	 mov	 QWORD PTR new_flags$[rsp], rax
  00167	48 83 7c 24 28
	00		 cmp	 QWORD PTR new_flags$[rsp], 0
  0016d	75 0a		 jne	 SHORT $LN12@kh_resize_
  0016f	b8 ff ff ff ff	 mov	 eax, -1
  00174	e9 51 05 00 00	 jmp	 $LN1@kh_resize_
$LN12@kh_resize_:
  00179	83 bc 24 d8 00
	00 00 10	 cmp	 DWORD PTR new_n_buckets$[rsp], 16
  00181	73 0a		 jae	 SHORT $LN29@kh_resize_
  00183	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv130[rsp], 1
  0018b	eb 0e		 jmp	 SHORT $LN30@kh_resize_
$LN29@kh_resize_:
  0018d	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR new_n_buckets$[rsp]
  00194	c1 e8 04	 shr	 eax, 4
  00197	89 44 24 3c	 mov	 DWORD PTR tv130[rsp], eax
$LN30@kh_resize_:
  0019b	8b 44 24 3c	 mov	 eax, DWORD PTR tv130[rsp]
  0019f	48 c1 e0 02	 shl	 rax, 2
  001a3	4c 8b c0	 mov	 r8, rax
  001a6	ba aa 00 00 00	 mov	 edx, 170		; 000000aaH
  001ab	48 8b 4c 24 28	 mov	 rcx, QWORD PTR new_flags$[rsp]
  001b0	e8 00 00 00 00	 call	 memset
  001b5	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR h$[rsp]
  001bd	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR new_n_buckets$[rsp]
  001c4	39 08		 cmp	 DWORD PTR [rax], ecx
  001c6	0f 83 a9 00 00
	00		 jae	 $LN13@kh_resize_
  001cc	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR new_n_buckets$[rsp]
  001d3	48 6b c0 0c	 imul	 rax, rax, 12
  001d7	48 8b d0	 mov	 rdx, rax
  001da	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR h$[rsp]
  001e2	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  001e6	e8 00 00 00 00	 call	 realloc
  001eb	48 89 44 24 50	 mov	 QWORD PTR new_keys$7[rsp], rax
  001f0	48 83 7c 24 50
	00		 cmp	 QWORD PTR new_keys$7[rsp], 0
  001f6	75 14		 jne	 SHORT $LN14@kh_resize_
  001f8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR new_flags$[rsp]
  001fd	e8 00 00 00 00	 call	 free
  00202	b8 ff ff ff ff	 mov	 eax, -1
  00207	e9 be 04 00 00	 jmp	 $LN1@kh_resize_
$LN14@kh_resize_:
  0020c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR h$[rsp]
  00214	48 8b 4c 24 50	 mov	 rcx, QWORD PTR new_keys$7[rsp]
  00219	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx
  0021d	33 c0		 xor	 eax, eax
  0021f	83 f8 01	 cmp	 eax, 1
  00222	74 51		 je	 SHORT $LN15@kh_resize_
  00224	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR new_n_buckets$[rsp]
  0022b	48 c1 e0 02	 shl	 rax, 2
  0022f	48 8b d0	 mov	 rdx, rax
  00232	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR h$[rsp]
  0023a	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  0023e	e8 00 00 00 00	 call	 realloc
  00243	48 89 44 24 58	 mov	 QWORD PTR new_vals$8[rsp], rax
  00248	48 83 7c 24 58
	00		 cmp	 QWORD PTR new_vals$8[rsp], 0
  0024e	75 14		 jne	 SHORT $LN16@kh_resize_
  00250	48 8b 4c 24 28	 mov	 rcx, QWORD PTR new_flags$[rsp]
  00255	e8 00 00 00 00	 call	 free
  0025a	b8 ff ff ff ff	 mov	 eax, -1
  0025f	e9 66 04 00 00	 jmp	 $LN1@kh_resize_
$LN16@kh_resize_:
  00264	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR h$[rsp]
  0026c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR new_vals$8[rsp]
  00271	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx
$LN15@kh_resize_:
$LN13@kh_resize_:
$LN11@kh_resize_:
  00275	83 7c 24 24 00	 cmp	 DWORD PTR j$[rsp], 0
  0027a	0f 84 48 04 00
	00		 je	 $LN17@kh_resize_
  00280	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00288	eb 0a		 jmp	 SHORT $LN4@kh_resize_
$LN2@kh_resize_:
  0028a	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  0028e	ff c0		 inc	 eax
  00290	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN4@kh_resize_:
  00294	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR h$[rsp]
  0029c	8b 00		 mov	 eax, DWORD PTR [rax]
  0029e	39 44 24 24	 cmp	 DWORD PTR j$[rsp], eax
  002a2	0f 84 38 03 00
	00		 je	 $LN3@kh_resize_
  002a8	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  002ac	c1 e8 04	 shr	 eax, 4
  002af	8b c0		 mov	 eax, eax
  002b1	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  002b9	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  002bd	48 89 4c 24 60	 mov	 QWORD PTR tv333[rsp], rcx
  002c2	8b 54 24 24	 mov	 edx, DWORD PTR j$[rsp]
  002c6	83 e2 0f	 and	 edx, 15
  002c9	d1 e2		 shl	 edx, 1
  002cb	0f b6 ca	 movzx	 ecx, dl
  002ce	48 8b 54 24 60	 mov	 rdx, QWORD PTR tv333[rsp]
  002d3	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  002d6	d3 e8		 shr	 eax, cl
  002d8	83 e0 03	 and	 eax, 3
  002db	85 c0		 test	 eax, eax
  002dd	0f 85 f8 02 00
	00		 jne	 $LN18@kh_resize_
  002e3	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  002e7	48 6b c0 0c	 imul	 rax, rax, 12
  002eb	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  002f3	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  002f7	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR key$9[rsp]
  002ff	48 8b fa	 mov	 rdi, rdx
  00302	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  00306	b9 0c 00 00 00	 mov	 ecx, 12
  0030b	f3 a4		 rep movsb
  0030d	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR new_n_buckets$[rsp]
  00314	ff c8		 dec	 eax
  00316	89 44 24 40	 mov	 DWORD PTR new_mask$4[rsp], eax
  0031a	33 c0		 xor	 eax, eax
  0031c	83 f8 01	 cmp	 eax, 1
  0031f	74 17		 je	 SHORT $LN19@kh_resize_
  00321	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  00325	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  0032d	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00331	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00334	89 44 24 34	 mov	 DWORD PTR val$3[rsp], eax
$LN19@kh_resize_:
  00338	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  0033c	c1 e8 04	 shr	 eax, 4
  0033f	8b c0		 mov	 eax, eax
  00341	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  00349	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0034d	48 89 4c 24 68	 mov	 QWORD PTR tv330[rsp], rcx
  00352	8b 54 24 24	 mov	 edx, DWORD PTR j$[rsp]
  00356	83 e2 0f	 and	 edx, 15
  00359	d1 e2		 shl	 edx, 1
  0035b	bf 01 00 00 00	 mov	 edi, 1
  00360	0f b6 ca	 movzx	 ecx, dl
  00363	8b d7		 mov	 edx, edi
  00365	d3 e2		 shl	 edx, cl
  00367	8b ca		 mov	 ecx, edx
  00369	48 8b 54 24 68	 mov	 rdx, QWORD PTR tv330[rsp]
  0036e	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  00371	0b c1		 or	 eax, ecx
  00373	8b 4c 24 24	 mov	 ecx, DWORD PTR j$[rsp]
  00377	c1 e9 04	 shr	 ecx, 4
  0037a	8b c9		 mov	 ecx, ecx
  0037c	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR h$[rsp]
  00384	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00388	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
$LN5@kh_resize_:
  0038b	33 c0		 xor	 eax, eax
  0038d	83 f8 01	 cmp	 eax, 1
  00390	0f 84 45 02 00
	00		 je	 $LN6@kh_resize_
  00396	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR step$2[rsp], 0
  0039e	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR key$9[rsp]
  003a6	e8 00 00 00 00	 call	 ?hash_vert_idx@@YA_KPEAH@Z ; hash_vert_idx
  003ab	89 44 24 44	 mov	 DWORD PTR k$5[rsp], eax
  003af	8b 44 24 40	 mov	 eax, DWORD PTR new_mask$4[rsp]
  003b3	8b 4c 24 44	 mov	 ecx, DWORD PTR k$5[rsp]
  003b7	23 c8		 and	 ecx, eax
  003b9	8b c1		 mov	 eax, ecx
  003bb	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN7@kh_resize_:
  003bf	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  003c3	c1 e8 04	 shr	 eax, 4
  003c6	8b c0		 mov	 eax, eax
  003c8	8b 4c 24 20	 mov	 ecx, DWORD PTR i$1[rsp]
  003cc	83 e1 0f	 and	 ecx, 15
  003cf	d1 e1		 shl	 ecx, 1
  003d1	48 8b 54 24 28	 mov	 rdx, QWORD PTR new_flags$[rsp]
  003d6	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  003d9	d3 e8		 shr	 eax, cl
  003db	83 e0 02	 and	 eax, 2
  003de	85 c0		 test	 eax, eax
  003e0	75 20		 jne	 SHORT $LN8@kh_resize_
  003e2	8b 44 24 30	 mov	 eax, DWORD PTR step$2[rsp]
  003e6	ff c0		 inc	 eax
  003e8	89 44 24 30	 mov	 DWORD PTR step$2[rsp], eax
  003ec	8b 44 24 30	 mov	 eax, DWORD PTR step$2[rsp]
  003f0	8b 4c 24 20	 mov	 ecx, DWORD PTR i$1[rsp]
  003f4	03 c8		 add	 ecx, eax
  003f6	8b c1		 mov	 eax, ecx
  003f8	23 44 24 40	 and	 eax, DWORD PTR new_mask$4[rsp]
  003fc	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00400	eb bd		 jmp	 SHORT $LN7@kh_resize_
$LN8@kh_resize_:
  00402	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00406	c1 e8 04	 shr	 eax, 4
  00409	8b c0		 mov	 eax, eax
  0040b	8b 4c 24 20	 mov	 ecx, DWORD PTR i$1[rsp]
  0040f	83 e1 0f	 and	 ecx, 15
  00412	d1 e1		 shl	 ecx, 1
  00414	ba 02 00 00 00	 mov	 edx, 2
  00419	d3 e2		 shl	 edx, cl
  0041b	8b ca		 mov	 ecx, edx
  0041d	f7 d1		 not	 ecx
  0041f	48 8b 54 24 28	 mov	 rdx, QWORD PTR new_flags$[rsp]
  00424	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  00427	23 c1		 and	 eax, ecx
  00429	8b 4c 24 20	 mov	 ecx, DWORD PTR i$1[rsp]
  0042d	c1 e9 04	 shr	 ecx, 4
  00430	8b c9		 mov	 ecx, ecx
  00432	48 8b 54 24 28	 mov	 rdx, QWORD PTR new_flags$[rsp]
  00437	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
  0043a	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR h$[rsp]
  00442	8b 00		 mov	 eax, DWORD PTR [rax]
  00444	39 44 24 20	 cmp	 DWORD PTR i$1[rsp], eax
  00448	0f 83 3e 01 00
	00		 jae	 $LN20@kh_resize_
  0044e	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00452	c1 e8 04	 shr	 eax, 4
  00455	8b c0		 mov	 eax, eax
  00457	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  0045f	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00463	48 89 4c 24 70	 mov	 QWORD PTR tv328[rsp], rcx
  00468	8b 54 24 20	 mov	 edx, DWORD PTR i$1[rsp]
  0046c	83 e2 0f	 and	 edx, 15
  0046f	d1 e2		 shl	 edx, 1
  00471	0f b6 ca	 movzx	 ecx, dl
  00474	48 8b 54 24 70	 mov	 rdx, QWORD PTR tv328[rsp]
  00479	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  0047c	d3 e8		 shr	 eax, cl
  0047e	83 e0 03	 and	 eax, 3
  00481	85 c0		 test	 eax, eax
  00483	0f 85 03 01 00
	00		 jne	 $LN20@kh_resize_
  00489	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0048d	48 6b c0 0c	 imul	 rax, rax, 12
  00491	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  00499	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0049d	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR tmp$10[rsp]
  004a5	48 8b fa	 mov	 rdi, rdx
  004a8	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  004ac	b9 0c 00 00 00	 mov	 ecx, 12
  004b1	f3 a4		 rep movsb
  004b3	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  004b7	48 6b c0 0c	 imul	 rax, rax, 12
  004bb	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  004c3	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  004c7	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR key$9[rsp]
  004cf	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]
  004d3	48 8b f2	 mov	 rsi, rdx
  004d6	b9 0c 00 00 00	 mov	 ecx, 12
  004db	f3 a4		 rep movsb
  004dd	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR key$9[rsp]
  004e5	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR tmp$10[rsp]
  004ed	48 8b f8	 mov	 rdi, rax
  004f0	48 8b f1	 mov	 rsi, rcx
  004f3	b9 0c 00 00 00	 mov	 ecx, 12
  004f8	f3 a4		 rep movsb
  004fa	33 c0		 xor	 eax, eax
  004fc	83 f8 01	 cmp	 eax, 1
  004ff	74 36		 je	 SHORT $LN22@kh_resize_
  00501	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00505	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  0050d	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00511	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00514	89 44 24 48	 mov	 DWORD PTR tmp$6[rsp], eax
  00518	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0051c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  00524	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00528	8b 54 24 34	 mov	 edx, DWORD PTR val$3[rsp]
  0052c	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx
  0052f	8b 44 24 48	 mov	 eax, DWORD PTR tmp$6[rsp]
  00533	89 44 24 34	 mov	 DWORD PTR val$3[rsp], eax
$LN22@kh_resize_:
  00537	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0053b	c1 e8 04	 shr	 eax, 4
  0053e	8b c0		 mov	 eax, eax
  00540	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  00548	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0054c	48 89 4c 24 78	 mov	 QWORD PTR tv323[rsp], rcx
  00551	8b 54 24 20	 mov	 edx, DWORD PTR i$1[rsp]
  00555	83 e2 0f	 and	 edx, 15
  00558	d1 e2		 shl	 edx, 1
  0055a	bf 01 00 00 00	 mov	 edi, 1
  0055f	0f b6 ca	 movzx	 ecx, dl
  00562	8b d7		 mov	 edx, edi
  00564	d3 e2		 shl	 edx, cl
  00566	8b ca		 mov	 ecx, edx
  00568	48 8b 54 24 78	 mov	 rdx, QWORD PTR tv323[rsp]
  0056d	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  00570	0b c1		 or	 eax, ecx
  00572	8b 4c 24 20	 mov	 ecx, DWORD PTR i$1[rsp]
  00576	c1 e9 04	 shr	 ecx, 4
  00579	8b c9		 mov	 ecx, ecx
  0057b	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR h$[rsp]
  00583	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00587	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
  0058a	eb 4a		 jmp	 SHORT $LN21@kh_resize_
$LN20@kh_resize_:
  0058c	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00590	48 6b c0 0c	 imul	 rax, rax, 12
  00594	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  0059c	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  005a0	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR key$9[rsp]
  005a8	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]
  005ac	48 8b f2	 mov	 rsi, rdx
  005af	b9 0c 00 00 00	 mov	 ecx, 12
  005b4	f3 a4		 rep movsb
  005b6	33 c0		 xor	 eax, eax
  005b8	83 f8 01	 cmp	 eax, 1
  005bb	74 17		 je	 SHORT $LN23@kh_resize_
  005bd	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  005c1	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  005c9	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  005cd	8b 54 24 34	 mov	 edx, DWORD PTR val$3[rsp]
  005d1	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx
$LN23@kh_resize_:
  005d4	eb 05		 jmp	 SHORT $LN6@kh_resize_
$LN21@kh_resize_:
  005d6	e9 b0 fd ff ff	 jmp	 $LN5@kh_resize_
$LN6@kh_resize_:
$LN18@kh_resize_:
  005db	e9 aa fc ff ff	 jmp	 $LN2@kh_resize_
$LN3@kh_resize_:
  005e0	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR h$[rsp]
  005e8	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR new_n_buckets$[rsp]
  005ef	39 08		 cmp	 DWORD PTR [rax], ecx
  005f1	76 5d		 jbe	 SHORT $LN24@kh_resize_
  005f3	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR new_n_buckets$[rsp]
  005fa	48 6b c0 0c	 imul	 rax, rax, 12
  005fe	48 8b d0	 mov	 rdx, rax
  00601	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR h$[rsp]
  00609	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0060d	e8 00 00 00 00	 call	 realloc
  00612	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  0061a	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
  0061e	33 c0		 xor	 eax, eax
  00620	83 f8 01	 cmp	 eax, 1
  00623	74 2b		 je	 SHORT $LN25@kh_resize_
  00625	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR new_n_buckets$[rsp]
  0062c	48 c1 e0 02	 shl	 rax, 2
  00630	48 8b d0	 mov	 rdx, rax
  00633	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR h$[rsp]
  0063b	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  0063f	e8 00 00 00 00	 call	 realloc
  00644	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  0064c	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
$LN25@kh_resize_:
$LN24@kh_resize_:
  00650	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR h$[rsp]
  00658	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0065c	e8 00 00 00 00	 call	 free
  00661	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR h$[rsp]
  00669	48 8b 4c 24 28	 mov	 rcx, QWORD PTR new_flags$[rsp]
  0066e	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  00672	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR h$[rsp]
  0067a	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR new_n_buckets$[rsp]
  00681	89 08		 mov	 DWORD PTR [rax], ecx
  00683	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR h$[rsp]
  0068b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  00693	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00696	89 48 08	 mov	 DWORD PTR [rax+8], ecx
  00699	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR h$[rsp]
  006a1	8b 00		 mov	 eax, DWORD PTR [rax]
  006a3	f2 48 0f 2a c0	 cvtsi2sd xmm0, rax
  006a8	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@3fe8a3d70a3d70a4
  006b0	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3fe0000000000000
  006b8	f2 48 0f 2c c0	 cvttsd2si rax, xmm0
  006bd	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR h$[rsp]
  006c5	89 41 0c	 mov	 DWORD PTR [rcx+12], eax
$LN17@kh_resize_:
  006c8	33 c0		 xor	 eax, eax
$LN1@kh_resize_:
  006ca	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  006d2	48 33 cc	 xor	 rcx, rsp
  006d5	e8 00 00 00 00	 call	 __security_check_cookie
  006da	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  006e1	5f		 pop	 rdi
  006e2	5e		 pop	 rsi
  006e3	c3		 ret	 0
?kh_resize_vertex_map_t@@YAHPEAUkh_vertex_map_t_s@@I@Z ENDP ; kh_resize_vertex_map_t
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\assets.cpp
_TEXT	SEGMENT
i$1 = 32
step$2 = 36
mask$3 = 40
tv162 = 44
k$4 = 48
last$5 = 52
tv168 = 56
tv167 = 64
tv163 = 72
h$ = 96
key$ = 104
?kh_get_vertex_map_t@@YAIPEBUkh_vertex_map_t_s@@Tvert_idx_t@@@Z PROC ; kh_get_vertex_map_t

; 126  : KHASH_INIT(vertex_map_t, vert_idx_t, u32, 1, kh_hash_func, kh_hash_equal)

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR h$[rsp]
  00013	83 38 00	 cmp	 DWORD PTR [rax], 0
  00016	0f 84 8c 01 00
	00		 je	 $LN4@kh_get_ver
  0001c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR step$2[rsp], 0
  00024	48 8b 44 24 60	 mov	 rax, QWORD PTR h$[rsp]
  00029	8b 00		 mov	 eax, DWORD PTR [rax]
  0002b	ff c8		 dec	 eax
  0002d	89 44 24 28	 mov	 DWORD PTR mask$3[rsp], eax
  00031	48 8b 44 24 68	 mov	 rax, QWORD PTR key$[rsp]
  00036	48 8b c8	 mov	 rcx, rax
  00039	e8 00 00 00 00	 call	 ?hash_vert_idx@@YA_KPEAH@Z ; hash_vert_idx
  0003e	89 44 24 30	 mov	 DWORD PTR k$4[rsp], eax
  00042	8b 44 24 28	 mov	 eax, DWORD PTR mask$3[rsp]
  00046	8b 4c 24 30	 mov	 ecx, DWORD PTR k$4[rsp]
  0004a	23 c8		 and	 ecx, eax
  0004c	8b c1		 mov	 eax, ecx
  0004e	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00052	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00056	89 44 24 34	 mov	 DWORD PTR last$5[rsp], eax
$LN2@kh_get_ver:
  0005a	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0005e	c1 e8 04	 shr	 eax, 4
  00061	8b c0		 mov	 eax, eax
  00063	48 8b 4c 24 60	 mov	 rcx, QWORD PTR h$[rsp]
  00068	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0006c	48 89 4c 24 38	 mov	 QWORD PTR tv168[rsp], rcx
  00071	8b 54 24 20	 mov	 edx, DWORD PTR i$1[rsp]
  00075	83 e2 0f	 and	 edx, 15
  00078	d1 e2		 shl	 edx, 1
  0007a	0f b6 ca	 movzx	 ecx, dl
  0007d	48 8b 54 24 38	 mov	 rdx, QWORD PTR tv168[rsp]
  00082	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  00085	d3 e8		 shr	 eax, cl
  00087	83 e0 02	 and	 eax, 2
  0008a	85 c0		 test	 eax, eax
  0008c	0f 85 c5 00 00
	00		 jne	 $LN3@kh_get_ver
  00092	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00096	c1 e8 04	 shr	 eax, 4
  00099	8b c0		 mov	 eax, eax
  0009b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR h$[rsp]
  000a0	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000a4	48 89 4c 24 40	 mov	 QWORD PTR tv167[rsp], rcx
  000a9	8b 54 24 20	 mov	 edx, DWORD PTR i$1[rsp]
  000ad	83 e2 0f	 and	 edx, 15
  000b0	d1 e2		 shl	 edx, 1
  000b2	0f b6 ca	 movzx	 ecx, dl
  000b5	48 8b 54 24 40	 mov	 rdx, QWORD PTR tv167[rsp]
  000ba	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  000bd	d3 e8		 shr	 eax, cl
  000bf	83 e0 01	 and	 eax, 1
  000c2	85 c0		 test	 eax, eax
  000c4	75 5b		 jne	 SHORT $LN6@kh_get_ver
  000c6	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  000ca	48 6b c0 0c	 imul	 rax, rax, 12
  000ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR h$[rsp]
  000d3	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000d7	48 8b 54 24 68	 mov	 rdx, QWORD PTR key$[rsp]
  000dc	8b 12		 mov	 edx, DWORD PTR [rdx]
  000de	39 14 01	 cmp	 DWORD PTR [rcx+rax], edx
  000e1	75 3e		 jne	 SHORT $LN7@kh_get_ver
  000e3	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  000e7	48 6b c0 0c	 imul	 rax, rax, 12
  000eb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR h$[rsp]
  000f0	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000f4	48 8b 54 24 68	 mov	 rdx, QWORD PTR key$[rsp]
  000f9	8b 52 04	 mov	 edx, DWORD PTR [rdx+4]
  000fc	39 54 01 04	 cmp	 DWORD PTR [rcx+rax+4], edx
  00100	75 1f		 jne	 SHORT $LN7@kh_get_ver
  00102	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00106	48 6b c0 0c	 imul	 rax, rax, 12
  0010a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR h$[rsp]
  0010f	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00113	48 8b 54 24 68	 mov	 rdx, QWORD PTR key$[rsp]
  00118	8b 52 08	 mov	 edx, DWORD PTR [rdx+8]
  0011b	39 54 01 08	 cmp	 DWORD PTR [rcx+rax+8], edx
  0011f	74 36		 je	 SHORT $LN3@kh_get_ver
$LN7@kh_get_ver:
$LN6@kh_get_ver:
  00121	8b 44 24 24	 mov	 eax, DWORD PTR step$2[rsp]
  00125	ff c0		 inc	 eax
  00127	89 44 24 24	 mov	 DWORD PTR step$2[rsp], eax
  0012b	8b 44 24 24	 mov	 eax, DWORD PTR step$2[rsp]
  0012f	8b 4c 24 20	 mov	 ecx, DWORD PTR i$1[rsp]
  00133	03 c8		 add	 ecx, eax
  00135	8b c1		 mov	 eax, ecx
  00137	23 44 24 28	 and	 eax, DWORD PTR mask$3[rsp]
  0013b	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  0013f	8b 44 24 34	 mov	 eax, DWORD PTR last$5[rsp]
  00143	39 44 24 20	 cmp	 DWORD PTR i$1[rsp], eax
  00147	75 09		 jne	 SHORT $LN8@kh_get_ver
  00149	48 8b 44 24 60	 mov	 rax, QWORD PTR h$[rsp]
  0014e	8b 00		 mov	 eax, DWORD PTR [rax]
  00150	eb 58		 jmp	 SHORT $LN1@kh_get_ver
$LN8@kh_get_ver:
  00152	e9 03 ff ff ff	 jmp	 $LN2@kh_get_ver
$LN3@kh_get_ver:
  00157	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0015b	c1 e8 04	 shr	 eax, 4
  0015e	8b c0		 mov	 eax, eax
  00160	48 8b 4c 24 60	 mov	 rcx, QWORD PTR h$[rsp]
  00165	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00169	48 89 4c 24 48	 mov	 QWORD PTR tv163[rsp], rcx
  0016e	8b 54 24 20	 mov	 edx, DWORD PTR i$1[rsp]
  00172	83 e2 0f	 and	 edx, 15
  00175	d1 e2		 shl	 edx, 1
  00177	0f b6 ca	 movzx	 ecx, dl
  0017a	48 8b 54 24 48	 mov	 rdx, QWORD PTR tv163[rsp]
  0017f	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  00182	d3 e8		 shr	 eax, cl
  00184	83 e0 03	 and	 eax, 3
  00187	85 c0		 test	 eax, eax
  00189	74 0d		 je	 SHORT $LN10@kh_get_ver
  0018b	48 8b 44 24 60	 mov	 rax, QWORD PTR h$[rsp]
  00190	8b 00		 mov	 eax, DWORD PTR [rax]
  00192	89 44 24 2c	 mov	 DWORD PTR tv162[rsp], eax
  00196	eb 08		 jmp	 SHORT $LN11@kh_get_ver
$LN10@kh_get_ver:
  00198	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0019c	89 44 24 2c	 mov	 DWORD PTR tv162[rsp], eax
$LN11@kh_get_ver:
  001a0	8b 44 24 2c	 mov	 eax, DWORD PTR tv162[rsp]
  001a4	eb 04		 jmp	 SHORT $LN1@kh_get_ver
  001a6	eb 02		 jmp	 SHORT $LN5@kh_get_ver
$LN4@kh_get_ver:
  001a8	33 c0		 xor	 eax, eax
$LN5@kh_get_ver:
$LN1@kh_get_ver:
  001aa	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ae	c3		 ret	 0
?kh_get_vertex_map_t@@YAIPEBUkh_vertex_map_t_s@@Tvert_idx_t@@@Z ENDP ; kh_get_vertex_map_t
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\assets.cpp
_TEXT	SEGMENT
h$ = 48
?kh_destroy_vertex_map_t@@YAXPEAUkh_vertex_map_t_s@@@Z PROC ; kh_destroy_vertex_map_t

; 126  : KHASH_INIT(vertex_map_t, vert_idx_t, u32, 1, kh_hash_func, kh_hash_equal)

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 83 7c 24 30
	00		 cmp	 QWORD PTR h$[rsp], 0
  0000f	74 34		 je	 SHORT $LN2@kh_destroy
  00011	48 8b 44 24 30	 mov	 rax, QWORD PTR h$[rsp]
  00016	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0001a	e8 00 00 00 00	 call	 free
  0001f	48 8b 44 24 30	 mov	 rax, QWORD PTR h$[rsp]
  00024	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00028	e8 00 00 00 00	 call	 free
  0002d	48 8b 44 24 30	 mov	 rax, QWORD PTR h$[rsp]
  00032	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  00036	e8 00 00 00 00	 call	 free
  0003b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR h$[rsp]
  00040	e8 00 00 00 00	 call	 free
$LN2@kh_destroy:
  00045	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00049	c3		 ret	 0
?kh_destroy_vertex_map_t@@YAXPEAUkh_vertex_map_t_s@@@Z ENDP ; kh_destroy_vertex_map_t
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\assets.cpp
_TEXT	SEGMENT
?kh_init_vertex_map_t@@YAPEAUkh_vertex_map_t_s@@XZ PROC	; kh_init_vertex_map_t

; 126  : KHASH_INIT(vertex_map_t, vert_idx_t, u32, 1, kh_hash_func, kh_hash_equal)

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00009	b9 01 00 00 00	 mov	 ecx, 1
  0000e	e8 00 00 00 00	 call	 calloc
  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
?kh_init_vertex_map_t@@YAPEAUkh_vertex_map_t_s@@XZ ENDP	; kh_init_vertex_map_t
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\assets.cpp
_TEXT	SEGMENT
i$1 = 32
hash$ = 40
value$2 = 48
indices$ = 80
?hash_vert_idx@@YA_KPEAH@Z PROC				; hash_vert_idx

; 109  : hash_vert_idx(i32 *indices) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 110  :     u64 hash = 0;

  00009	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR hash$[rsp], 0

; 111  :     
; 112  :     for (u32 i = 0; i < 3; i++) {

  00012	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  0001a	eb 0a		 jmp	 SHORT $LN4@hash_vert_
$LN2@hash_vert_:
  0001c	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00020	ff c0		 inc	 eax
  00022	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN4@hash_vert_:
  00026	83 7c 24 20 03	 cmp	 DWORD PTR i$1[rsp], 3
  0002b	73 57		 jae	 SHORT $LN3@hash_vert_

; 113  :         u64 value;
; 114  :         memcpy(&value, &indices[i], sizeof(i32));

  0002d	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00031	48 8b 4c 24 50	 mov	 rcx, QWORD PTR indices$[rsp]
  00036	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  0003a	41 b8 04 00 00
	00		 mov	 r8d, 4
  00040	48 8b d0	 mov	 rdx, rax
  00043	48 8d 4c 24 30	 lea	 rcx, QWORD PTR value$2[rsp]
  00048	e8 00 00 00 00	 call	 memcpy

; 115  :         hash ^= value + 0x9e3779b9 + (hash << 6) + (hash >> 2);

  0004d	48 8b 44 24 28	 mov	 rax, QWORD PTR hash$[rsp]
  00052	48 c1 e0 06	 shl	 rax, 6
  00056	b9 b9 79 37 9e	 mov	 ecx, -1640531527	; ffffffff9e3779b9H
  0005b	48 8b 54 24 30	 mov	 rdx, QWORD PTR value$2[rsp]
  00060	48 03 ca	 add	 rcx, rdx
  00063	48 03 c1	 add	 rax, rcx
  00066	48 8b 4c 24 28	 mov	 rcx, QWORD PTR hash$[rsp]
  0006b	48 c1 e9 02	 shr	 rcx, 2
  0006f	48 03 c1	 add	 rax, rcx
  00072	48 8b 4c 24 28	 mov	 rcx, QWORD PTR hash$[rsp]
  00077	48 33 c8	 xor	 rcx, rax
  0007a	48 8b c1	 mov	 rax, rcx
  0007d	48 89 44 24 28	 mov	 QWORD PTR hash$[rsp], rax

; 116  :     }

  00082	eb 98		 jmp	 SHORT $LN2@hash_vert_
$LN3@hash_vert_:

; 117  :     
; 118  :     return hash;

  00084	48 8b 44 24 28	 mov	 rax, QWORD PTR hash$[rsp]

; 119  : }

  00089	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0008d	c3		 ret	 0
?hash_vert_idx@@YA_KPEAH@Z ENDP				; hash_vert_idx
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\assets.cpp
_TEXT	SEGMENT
am$ = 8
mesh_id$ = 16
?get_mesh_material@@YAPEAUmaterial_t@@PEAUasset_manager_t@@I@Z PROC ; get_mesh_material

; 104  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 105  :     return am->mats+am->meshes[mesh_id].mat_id;

  00009	8b 44 24 10	 mov	 eax, DWORD PTR mesh_id$[rsp]
  0000d	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  00011	48 8b 4c 24 08	 mov	 rcx, QWORD PTR am$[rsp]
  00016	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00019	8b 44 01 30	 mov	 eax, DWORD PTR [rcx+rax+48]
  0001d	48 6b c0 68	 imul	 rax, rax, 104		; 00000068H
  00021	48 8b 4c 24 08	 mov	 rcx, QWORD PTR am$[rsp]
  00026	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]

; 106  : }

  0002a	c3		 ret	 0
?get_mesh_material@@YAPEAUmaterial_t@@PEAUasset_manager_t@@I@Z ENDP ; get_mesh_material
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\assets.cpp
_TEXT	SEGMENT
i$ = 48
white$ = 52
mat$ = 56
am$ = 80
?init_asset_manager@@YAXPEAUasset_manager_t@@@Z PROC	; init_asset_manager

; 53   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 54   :     am->meshes = NULL;

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR am$[rsp]
  0000e	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 55   :     am->mats = NULL;

  00015	48 8b 44 24 50	 mov	 rax, QWORD PTR am$[rsp]
  0001a	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 56   :     am->textures = NULL;

  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR am$[rsp]
  00027	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 57   :     
; 58   :     u32 white = 0xFFFFFFFF;

  0002f	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR white$[rsp], -1 ; ffffffffH

; 59   :     create_texture_from_bitmap(am, (u8 *)&white, 1, 1, 4);

  00037	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0003f	41 b9 01 00 00
	00		 mov	 r9d, 1
  00045	41 b8 01 00 00
	00		 mov	 r8d, 1
  0004b	48 8d 54 24 34	 lea	 rdx, QWORD PTR white$[rsp]
  00050	48 8b 4c 24 50	 mov	 rcx, QWORD PTR am$[rsp]
  00055	e8 00 00 00 00	 call	 ?create_texture_from_bitmap@@YAIPEAUasset_manager_t@@PEAEHHH@Z ; create_texture_from_bitmap

; 60   :     
; 61   :     material_t *mat = (material_t *)stack_push(&am->mats);

  0005a	48 8b 44 24 50	 mov	 rax, QWORD PTR am$[rsp]
  0005f	48 83 c0 08	 add	 rax, 8
  00063	41 b8 68 00 00
	00		 mov	 r8d, 104		; 00000068H
  00069	ba 01 00 00 00	 mov	 edx, 1
  0006e	48 8b c8	 mov	 rcx, rax
  00071	e8 00 00 00 00	 call	 ?_stack_push@@YAPEAXPEAPEAXII@Z ; _stack_push
  00076	48 89 44 24 38	 mov	 QWORD PTR mat$[rsp], rax

; 62   :     memset(mat, 0, sizeof(mat));

  0007b	41 b8 08 00 00
	00		 mov	 r8d, 8
  00081	33 d2		 xor	 edx, edx
  00083	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mat$[rsp]
  00088	e8 00 00 00 00	 call	 memset

; 63   :     u32 i;
; 64   :     for (i = 0; i < 3; i++) 

  0008d	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00095	eb 0a		 jmp	 SHORT $LN4@init_asset
$LN2@init_asset:
  00097	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0009b	ff c0		 inc	 eax
  0009d	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@init_asset:
  000a1	83 7c 24 30 03	 cmp	 DWORD PTR i$[rsp], 3
  000a6	73 18		 jae	 SHORT $LN3@init_asset

; 65   :         mat->ambient[i] = 0.8f;

  000a8	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  000ac	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mat$[rsp]
  000b1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  000b9	f3 0f 11 04 81	 movss	 DWORD PTR [rcx+rax*4], xmm0
  000be	eb d7		 jmp	 SHORT $LN2@init_asset
$LN3@init_asset:

; 66   :     for (i = 0; i < 3; i++)

  000c0	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000c8	eb 0a		 jmp	 SHORT $LN7@init_asset
$LN5@init_asset:
  000ca	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  000ce	ff c0		 inc	 eax
  000d0	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN7@init_asset:
  000d4	83 7c 24 30 03	 cmp	 DWORD PTR i$[rsp], 3
  000d9	73 19		 jae	 SHORT $LN6@init_asset

; 67   :         mat->diffuse[i] = 0.8f;

  000db	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  000df	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mat$[rsp]
  000e4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  000ec	f3 0f 11 44 81
	0c		 movss	 DWORD PTR [rcx+rax*4+12], xmm0
  000f2	eb d6		 jmp	 SHORT $LN5@init_asset
$LN6@init_asset:

; 68   :     for (i = 0; i < 3; i++)

  000f4	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000fc	eb 0a		 jmp	 SHORT $LN10@init_asset
$LN8@init_asset:
  000fe	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00102	ff c0		 inc	 eax
  00104	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@init_asset:
  00108	83 7c 24 30 03	 cmp	 DWORD PTR i$[rsp], 3
  0010d	73 19		 jae	 SHORT $LN9@init_asset

; 69   :         mat->specular[i] = 0.8f;

  0010f	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00113	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mat$[rsp]
  00118	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  00120	f3 0f 11 44 81
	18		 movss	 DWORD PTR [rcx+rax*4+24], xmm0
  00126	eb d6		 jmp	 SHORT $LN8@init_asset
$LN9@init_asset:

; 70   :     mat->shininess = 500;

  00128	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  0012d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@43fa0000
  00135	f3 0f 11 40 3c	 movss	 DWORD PTR [rax+60], xmm0

; 71   : }

  0013a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0013e	c3		 ret	 0
?init_asset_manager@@YAXPEAUasset_manager_t@@@Z ENDP	; init_asset_manager
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\assets.cpp
_TEXT	SEGMENT
tv80 = 80
tv168 = 84
tex_id$ = 88
idx$ = 92
tex$ = 96
am$ = 128
data$ = 136
w$ = 144
h$ = 152
ch$ = 160
?create_texture_from_bitmap@@YAIPEAUasset_manager_t@@PEAEHHH@Z PROC ; create_texture_from_bitmap

; 3    : create_texture_from_bitmap(asset_manager_t *am, u8 *data, i32 w, i32 h, i32 ch) {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 4    :     u32 tex_id;
; 5    :     glGenTextures(1, &tex_id);

  00018	48 8d 54 24 58	 lea	 rdx, QWORD PTR tex_id$[rsp]
  0001d	b9 01 00 00 00	 mov	 ecx, 1
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glGenTextures

; 6    :     glBindTexture(GL_TEXTURE_2D, tex_id);

  00028	8b 54 24 58	 mov	 edx, DWORD PTR tex_id$[rsp]
  0002c	b9 e1 0d 00 00	 mov	 ecx, 3553		; 00000de1H
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glBindTexture

; 7    :     
; 8    :     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);	

  00037	41 b8 01 29 00
	00		 mov	 r8d, 10497		; 00002901H
  0003d	ba 02 28 00 00	 mov	 edx, 10242		; 00002802H
  00042	b9 e1 0d 00 00	 mov	 ecx, 3553		; 00000de1H
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glTexParameteri

; 9    :     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);

  0004d	41 b8 01 29 00
	00		 mov	 r8d, 10497		; 00002901H
  00053	ba 03 28 00 00	 mov	 edx, 10243		; 00002803H
  00058	b9 e1 0d 00 00	 mov	 ecx, 3553		; 00000de1H
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glTexParameteri

; 10   :     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);

  00063	41 b8 03 27 00
	00		 mov	 r8d, 9987		; 00002703H
  00069	ba 01 28 00 00	 mov	 edx, 10241		; 00002801H
  0006e	b9 e1 0d 00 00	 mov	 ecx, 3553		; 00000de1H
  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glTexParameteri

; 11   :     glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

  00079	41 b8 01 26 00
	00		 mov	 r8d, 9729		; 00002601H
  0007f	ba 00 28 00 00	 mov	 edx, 10240		; 00002800H
  00084	b9 e1 0d 00 00	 mov	 ecx, 3553		; 00000de1H
  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glTexParameteri

; 12   :     
; 13   :     switch(ch) {

  0008f	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR ch$[rsp]
  00096	89 44 24 50	 mov	 DWORD PTR tv80[rsp], eax
  0009a	83 7c 24 50 01	 cmp	 DWORD PTR tv80[rsp], 1
  0009f	74 22		 je	 SHORT $LN7@create_tex
  000a1	83 7c 24 50 02	 cmp	 DWORD PTR tv80[rsp], 2
  000a6	74 6b		 je	 SHORT $LN8@create_tex
  000a8	83 7c 24 50 03	 cmp	 DWORD PTR tv80[rsp], 3
  000ad	0f 84 b0 00 00
	00		 je	 $LN9@create_tex
  000b3	83 7c 24 50 04	 cmp	 DWORD PTR tv80[rsp], 4
  000b8	0f 84 f5 00 00
	00		 je	 $LN10@create_tex
  000be	e9 3d 01 00 00	 jmp	 $LN11@create_tex
$LN7@create_tex:

; 14   :         case 1: {
; 15   :             glTexImage2D(GL_TEXTURE_2D, 0, GL_R8, w, h, 0, GL_RED,

  000c3	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR data$[rsp]
  000cb	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  000d0	c7 44 24 38 01
	14 00 00	 mov	 DWORD PTR [rsp+56], 5121 ; 00001401H
  000d8	c7 44 24 30 03
	19 00 00	 mov	 DWORD PTR [rsp+48], 6403 ; 00001903H
  000e0	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  000e8	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR h$[rsp]
  000ef	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000f3	44 8b 8c 24 90
	00 00 00	 mov	 r9d, DWORD PTR w$[rsp]
  000fb	41 b8 29 82 00
	00		 mov	 r8d, 33321		; 00008229H
  00101	33 d2		 xor	 edx, edx
  00103	b9 e1 0d 00 00	 mov	 ecx, 3553		; 00000de1H
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glTexImage2D

; 16   :                          GL_UNSIGNED_BYTE, data);
; 17   :         } break;

  0010e	e9 2a 01 00 00	 jmp	 $LN2@create_tex
$LN8@create_tex:

; 18   :         
; 19   :         case 2: {
; 20   :             glTexImage2D(GL_TEXTURE_2D, 0, GL_RG8, w, h, 0, GL_RG,

  00113	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR data$[rsp]
  0011b	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00120	c7 44 24 38 01
	14 00 00	 mov	 DWORD PTR [rsp+56], 5121 ; 00001401H
  00128	c7 44 24 30 27
	82 00 00	 mov	 DWORD PTR [rsp+48], 33319 ; 00008227H
  00130	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00138	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR h$[rsp]
  0013f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00143	44 8b 8c 24 90
	00 00 00	 mov	 r9d, DWORD PTR w$[rsp]
  0014b	41 b8 2b 82 00
	00		 mov	 r8d, 33323		; 0000822bH
  00151	33 d2		 xor	 edx, edx
  00153	b9 e1 0d 00 00	 mov	 ecx, 3553		; 00000de1H
  00158	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glTexImage2D

; 21   :                          GL_UNSIGNED_BYTE, data);
; 22   :         } break;

  0015e	e9 da 00 00 00	 jmp	 $LN2@create_tex
$LN9@create_tex:

; 23   :         
; 24   :         case 3: {
; 25   :             glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB8, w, h, 0, GL_RGB,

  00163	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR data$[rsp]
  0016b	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00170	c7 44 24 38 01
	14 00 00	 mov	 DWORD PTR [rsp+56], 5121 ; 00001401H
  00178	c7 44 24 30 07
	19 00 00	 mov	 DWORD PTR [rsp+48], 6407 ; 00001907H
  00180	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00188	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR h$[rsp]
  0018f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00193	44 8b 8c 24 90
	00 00 00	 mov	 r9d, DWORD PTR w$[rsp]
  0019b	41 b8 51 80 00
	00		 mov	 r8d, 32849		; 00008051H
  001a1	33 d2		 xor	 edx, edx
  001a3	b9 e1 0d 00 00	 mov	 ecx, 3553		; 00000de1H
  001a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glTexImage2D

; 26   :                          GL_UNSIGNED_BYTE, data);
; 27   :         } break;

  001ae	e9 8a 00 00 00	 jmp	 $LN2@create_tex
$LN10@create_tex:

; 28   :         
; 29   :         case 4: {
; 30   :             glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, w, h, 0, GL_RGBA,

  001b3	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR data$[rsp]
  001bb	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  001c0	c7 44 24 38 01
	14 00 00	 mov	 DWORD PTR [rsp+56], 5121 ; 00001401H
  001c8	c7 44 24 30 08
	19 00 00	 mov	 DWORD PTR [rsp+48], 6408 ; 00001908H
  001d0	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  001d8	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR h$[rsp]
  001df	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001e3	44 8b 8c 24 90
	00 00 00	 mov	 r9d, DWORD PTR w$[rsp]
  001eb	41 b8 58 80 00
	00		 mov	 r8d, 32856		; 00008058H
  001f1	33 d2		 xor	 edx, edx
  001f3	b9 e1 0d 00 00	 mov	 ecx, 3553		; 00000de1H
  001f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glTexImage2D

; 31   :                          GL_UNSIGNED_BYTE, data);
; 32   :         } break;

  001fe	eb 3d		 jmp	 SHORT $LN2@create_tex
$LN11@create_tex:
$LN6@create_tex:

; 33   :         
; 34   :         default: { ASSERT(0, "Unsupported Texture format."); } break;

  00200	33 c0		 xor	 eax, eax
  00202	83 f8 01	 cmp	 eax, 1
  00205	74 30		 je	 SHORT $LN12@create_tex
  00207	b9 02 00 00 00	 mov	 ecx, 2
  0020c	e8 00 00 00 00	 call	 __acrt_iob_func
  00211	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG83468
  00218	41 b8 22 00 00
	00		 mov	 r8d, 34			; 00000022H
  0021e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG83469
  00225	48 8b c8	 mov	 rcx, rax
  00228	e8 00 00 00 00	 call	 fprintf
  0022d	b9 01 00 00 00	 mov	 ecx, 1
  00232	e8 00 00 00 00	 call	 exit
$LN12@create_tex:
  00237	33 c0		 xor	 eax, eax
  00239	85 c0		 test	 eax, eax
  0023b	75 c3		 jne	 SHORT $LN6@create_tex
$LN2@create_tex:

; 35   :     }
; 36   :     
; 37   :     glGenerateMipmap(GL_TEXTURE_2D);

  0023d	b9 e1 0d 00 00	 mov	 ecx, 3553		; 00000de1H
  00242	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewGenerateMipmap
  00249	ff 10		 call	 QWORD PTR [rax]

; 38   :     
; 39   :     u32 idx = get_stack_count(am->textures);

  0024b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR am$[rsp]
  00253	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00258	74 15		 je	 SHORT $LN14@create_tex
  0025a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR am$[rsp]
  00262	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00266	8b 40 fc	 mov	 eax, DWORD PTR [rax-4]
  00269	89 44 24 54	 mov	 DWORD PTR tv168[rsp], eax
  0026d	eb 08		 jmp	 SHORT $LN15@create_tex
$LN14@create_tex:
  0026f	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv168[rsp], 0
$LN15@create_tex:
  00277	8b 44 24 54	 mov	 eax, DWORD PTR tv168[rsp]
  0027b	89 44 24 5c	 mov	 DWORD PTR idx$[rsp], eax

; 40   :     texture_t *tex = (texture_t *)stack_push(&am->textures);

  0027f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR am$[rsp]
  00287	48 83 c0 10	 add	 rax, 16
  0028b	41 b8 18 00 00
	00		 mov	 r8d, 24
  00291	ba 01 00 00 00	 mov	 edx, 1
  00296	48 8b c8	 mov	 rcx, rax
  00299	e8 00 00 00 00	 call	 ?_stack_push@@YAPEAXPEAPEAXII@Z ; _stack_push
  0029e	48 89 44 24 60	 mov	 QWORD PTR tex$[rsp], rax

; 41   :     tex->data = (u8 *)malloc(ch*w*h);

  002a3	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR ch$[rsp]
  002aa	0f af 84 24 90
	00 00 00	 imul	 eax, DWORD PTR w$[rsp]
  002b2	0f af 84 24 98
	00 00 00	 imul	 eax, DWORD PTR h$[rsp]
  002ba	48 98		 cdqe
  002bc	48 8b c8	 mov	 rcx, rax
  002bf	e8 00 00 00 00	 call	 malloc
  002c4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tex$[rsp]
  002c9	48 89 01	 mov	 QWORD PTR [rcx], rax

; 42   :     memcpy(tex->data, data, ch*w*h);

  002cc	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR ch$[rsp]
  002d3	0f af 84 24 90
	00 00 00	 imul	 eax, DWORD PTR w$[rsp]
  002db	0f af 84 24 98
	00 00 00	 imul	 eax, DWORD PTR h$[rsp]
  002e3	48 98		 cdqe
  002e5	4c 8b c0	 mov	 r8, rax
  002e8	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR data$[rsp]
  002f0	48 8b 44 24 60	 mov	 rax, QWORD PTR tex$[rsp]
  002f5	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  002f8	e8 00 00 00 00	 call	 memcpy

; 43   :     tex->w = (u32)w;

  002fd	48 8b 44 24 60	 mov	 rax, QWORD PTR tex$[rsp]
  00302	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR w$[rsp]
  00309	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 44   :     tex->h = (u32)h;

  0030c	48 8b 44 24 60	 mov	 rax, QWORD PTR tex$[rsp]
  00311	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR h$[rsp]
  00318	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 45   :     tex->bytes_per_pixel = ch;

  0031b	48 8b 44 24 60	 mov	 rax, QWORD PTR tex$[rsp]
  00320	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR ch$[rsp]
  00327	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 46   :     tex->id = tex_id;

  0032a	48 8b 44 24 60	 mov	 rax, QWORD PTR tex$[rsp]
  0032f	8b 4c 24 58	 mov	 ecx, DWORD PTR tex_id$[rsp]
  00333	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 47   :     
; 48   :     return idx;

  00336	8b 44 24 5c	 mov	 eax, DWORD PTR idx$[rsp]
$LN13@create_tex:

; 49   : }

  0033a	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0033e	c3		 ret	 0
?create_texture_from_bitmap@@YAIPEAUasset_manager_t@@PEAEHHH@Z ENDP ; create_texture_from_bitmap
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\uniform.cpp
_TEXT	SEGMENT
loc$ = 32
id$ = 64
name$ = 72
val$ = 80
?set_uniform_mat4@@YAXIPEBDTHMM_Mat4@@@Z PROC		; set_uniform_mat4

; 48   : set_uniform_mat4(u32 id, const char *name, mat4 val) {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 49   :     i32 loc = glGetUniformLocation(id, name);

  00012	48 8b 54 24 48	 mov	 rdx, QWORD PTR name$[rsp]
  00017	8b 4c 24 40	 mov	 ecx, DWORD PTR id$[rsp]
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewGetUniformLocation
  00022	ff 10		 call	 QWORD PTR [rax]
  00024	89 44 24 20	 mov	 DWORD PTR loc$[rsp], eax

; 50   :     if (loc == -1)

  00028	83 7c 24 20 ff	 cmp	 DWORD PTR loc$[rsp], -1
  0002d	75 02		 jne	 SHORT $LN2@set_unifor

; 51   :         return;

  0002f	eb 1d		 jmp	 SHORT $LN1@set_unifor
$LN2@set_unifor:

; 52   :     
; 53   :     glUniformMatrix4fv(loc , 1, GL_FALSE, (f32 *)val.Elements);

  00031	48 8b 44 24 50	 mov	 rax, QWORD PTR val$[rsp]
  00036	4c 8b c8	 mov	 r9, rax
  00039	45 33 c0	 xor	 r8d, r8d
  0003c	ba 01 00 00 00	 mov	 edx, 1
  00041	8b 4c 24 20	 mov	 ecx, DWORD PTR loc$[rsp]
  00045	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewUniformMatrix4fv
  0004c	ff 10		 call	 QWORD PTR [rax]
$LN1@set_unifor:

; 54   : }

  0004e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00052	c3		 ret	 0
?set_uniform_mat4@@YAXIPEBDTHMM_Mat4@@@Z ENDP		; set_uniform_mat4
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\uniform.cpp
_TEXT	SEGMENT
loc$ = 32
id$ = 64
name$ = 72
val$ = 80
?set_uniform_vec3@@YAXIPEBDTHMM_Vec3@@@Z PROC		; set_uniform_vec3

; 30   : set_uniform_vec3(u32 id, const char *name, v3 val) {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 31   :     i32 loc = glGetUniformLocation(id, name);

  00012	48 8b 54 24 48	 mov	 rdx, QWORD PTR name$[rsp]
  00017	8b 4c 24 40	 mov	 ecx, DWORD PTR id$[rsp]
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewGetUniformLocation
  00022	ff 10		 call	 QWORD PTR [rax]
  00024	89 44 24 20	 mov	 DWORD PTR loc$[rsp], eax

; 32   :     if (loc == -1)

  00028	83 7c 24 20 ff	 cmp	 DWORD PTR loc$[rsp], -1
  0002d	75 02		 jne	 SHORT $LN2@set_unifor

; 33   :         return;

  0002f	eb 2a		 jmp	 SHORT $LN1@set_unifor
$LN2@set_unifor:

; 34   :     
; 35   :     glUniform3f(loc, val.X, val.Y, val.Z);

  00031	48 8b 44 24 50	 mov	 rax, QWORD PTR val$[rsp]
  00036	f3 0f 10 58 08	 movss	 xmm3, DWORD PTR [rax+8]
  0003b	48 8b 44 24 50	 mov	 rax, QWORD PTR val$[rsp]
  00040	f3 0f 10 50 04	 movss	 xmm2, DWORD PTR [rax+4]
  00045	48 8b 44 24 50	 mov	 rax, QWORD PTR val$[rsp]
  0004a	f3 0f 10 08	 movss	 xmm1, DWORD PTR [rax]
  0004e	8b 4c 24 20	 mov	 ecx, DWORD PTR loc$[rsp]
  00052	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewUniform3f
  00059	ff 10		 call	 QWORD PTR [rax]
$LN1@set_unifor:

; 36   : }

  0005b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005f	c3		 ret	 0
?set_uniform_vec3@@YAXIPEBDTHMM_Vec3@@@Z ENDP		; set_uniform_vec3
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\uniform.cpp
_TEXT	SEGMENT
loc$ = 32
id$ = 64
name$ = 72
val$ = 80
?set_uniform_float@@YAXIPEBDM@Z PROC			; set_uniform_float

; 12   : set_uniform_float(u32 id, const char *name, f32 val) {

  00000	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  00006	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000b	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 13   :     i32 loc = glGetUniformLocation(id, name);

  00013	48 8b 54 24 48	 mov	 rdx, QWORD PTR name$[rsp]
  00018	8b 4c 24 40	 mov	 ecx, DWORD PTR id$[rsp]
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewGetUniformLocation
  00023	ff 10		 call	 QWORD PTR [rax]
  00025	89 44 24 20	 mov	 DWORD PTR loc$[rsp], eax

; 14   :     if (loc == -1)

  00029	83 7c 24 20 ff	 cmp	 DWORD PTR loc$[rsp], -1
  0002e	75 02		 jne	 SHORT $LN2@set_unifor

; 15   :         return;

  00030	eb 13		 jmp	 SHORT $LN1@set_unifor
$LN2@set_unifor:

; 16   :     
; 17   :     glUniform1f(loc, val);

  00032	f3 0f 10 4c 24
	50		 movss	 xmm1, DWORD PTR val$[rsp]
  00038	8b 4c 24 20	 mov	 ecx, DWORD PTR loc$[rsp]
  0003c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewUniform1f
  00043	ff 10		 call	 QWORD PTR [rax]
$LN1@set_unifor:

; 18   : }

  00045	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00049	c3		 ret	 0
?set_uniform_float@@YAXIPEBDM@Z ENDP			; set_uniform_float
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\uniform.cpp
_TEXT	SEGMENT
loc$ = 32
id$ = 64
name$ = 72
val$ = 80
?set_uniform_int@@YAXIPEBDH@Z PROC			; set_uniform_int

; 3    : set_uniform_int(u32 id, const char *name, i32 val) {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4    :     i32 loc = glGetUniformLocation(id, name);

  00012	48 8b 54 24 48	 mov	 rdx, QWORD PTR name$[rsp]
  00017	8b 4c 24 40	 mov	 ecx, DWORD PTR id$[rsp]
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewGetUniformLocation
  00022	ff 10		 call	 QWORD PTR [rax]
  00024	89 44 24 20	 mov	 DWORD PTR loc$[rsp], eax

; 5    :     if (loc == -1)

  00028	83 7c 24 20 ff	 cmp	 DWORD PTR loc$[rsp], -1
  0002d	75 02		 jne	 SHORT $LN2@set_unifor

; 6    :         return;

  0002f	eb 11		 jmp	 SHORT $LN1@set_unifor
$LN2@set_unifor:

; 7    :     
; 8    :     glUniform1i(loc, val);

  00031	8b 54 24 50	 mov	 edx, DWORD PTR val$[rsp]
  00035	8b 4c 24 20	 mov	 ecx, DWORD PTR loc$[rsp]
  00039	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewUniform1i
  00040	ff 10		 call	 QWORD PTR [rax]
$LN1@set_unifor:

; 9    : }

  00042	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00046	c3		 ret	 0
?set_uniform_int@@YAXIPEBDH@Z ENDP			; set_uniform_int
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\shader.cpp
_TEXT	SEGMENT
args$ = 32
i$1 = 40
tv69 = 44
tv132 = 48
type$ = 52
id$ = 56
s$ = 64
tv93 = 72
src$ = 80
shader$ = 88
gl$ = 112
count$ = 120
?add_shader@@YAIPEAUgl_renderer@@IZZ PROC		; add_shader

; 86   : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000e	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00013	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 87   :     u32 id = get_stack_count(gl->shaders);

  00017	48 8b 44 24 70	 mov	 rax, QWORD PTR gl$[rsp]
  0001c	48 83 78 58 00	 cmp	 QWORD PTR [rax+88], 0
  00021	74 12		 je	 SHORT $LN6@add_shader
  00023	48 8b 44 24 70	 mov	 rax, QWORD PTR gl$[rsp]
  00028	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0002c	8b 40 fc	 mov	 eax, DWORD PTR [rax-4]
  0002f	89 44 24 2c	 mov	 DWORD PTR tv69[rsp], eax
  00033	eb 08		 jmp	 SHORT $LN7@add_shader
$LN6@add_shader:
  00035	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
$LN7@add_shader:
  0003d	8b 44 24 2c	 mov	 eax, DWORD PTR tv69[rsp]
  00041	89 44 24 38	 mov	 DWORD PTR id$[rsp], eax

; 88   :     u32 *shader = (u32 *)stack_push(&gl->shaders);

  00045	48 8b 44 24 70	 mov	 rax, QWORD PTR gl$[rsp]
  0004a	48 83 c0 58	 add	 rax, 88			; 00000058H
  0004e	41 b8 04 00 00
	00		 mov	 r8d, 4
  00054	ba 01 00 00 00	 mov	 edx, 1
  00059	48 8b c8	 mov	 rcx, rax
  0005c	e8 00 00 00 00	 call	 ?_stack_push@@YAPEAXPEAPEAXII@Z ; _stack_push
  00061	48 89 44 24 58	 mov	 QWORD PTR shader$[rsp], rax

; 89   :     
; 90   :     u32 *s = (u32 *)malloc(count*sizeof(*s));

  00066	8b 44 24 78	 mov	 eax, DWORD PTR count$[rsp]
  0006a	48 c1 e0 02	 shl	 rax, 2
  0006e	48 8b c8	 mov	 rcx, rax
  00071	e8 00 00 00 00	 call	 malloc
  00076	48 89 44 24 40	 mov	 QWORD PTR s$[rsp], rax

; 91   :     
; 92   :     va_list args;
; 93   :     va_start(args, count);

  0007b	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR count$[rsp+8]
  00083	48 89 44 24 20	 mov	 QWORD PTR args$[rsp], rax

; 94   :     
; 95   :     char *src;
; 96   :     u32 type;
; 97   :     for(u32 i = 0; i < count; i++) {

  00088	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00090	eb 0a		 jmp	 SHORT $LN4@add_shader
$LN2@add_shader:
  00092	8b 44 24 28	 mov	 eax, DWORD PTR i$1[rsp]
  00096	ff c0		 inc	 eax
  00098	89 44 24 28	 mov	 DWORD PTR i$1[rsp], eax
$LN4@add_shader:
  0009c	8b 44 24 78	 mov	 eax, DWORD PTR count$[rsp]
  000a0	39 44 24 28	 cmp	 DWORD PTR i$1[rsp], eax
  000a4	0f 83 b3 00 00
	00		 jae	 $LN3@add_shader

; 98   :         src = va_arg(args, char *);

  000aa	33 c0		 xor	 eax, eax
  000ac	85 c0		 test	 eax, eax
  000ae	74 21		 je	 SHORT $LN8@add_shader
  000b0	48 8b 44 24 20	 mov	 rax, QWORD PTR args$[rsp]
  000b5	48 83 c0 08	 add	 rax, 8
  000b9	48 89 44 24 20	 mov	 QWORD PTR args$[rsp], rax
  000be	48 8b 44 24 20	 mov	 rax, QWORD PTR args$[rsp]
  000c3	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  000c7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ca	48 89 44 24 48	 mov	 QWORD PTR tv93[rsp], rax
  000cf	eb 1c		 jmp	 SHORT $LN9@add_shader
$LN8@add_shader:
  000d1	48 8b 44 24 20	 mov	 rax, QWORD PTR args$[rsp]
  000d6	48 83 c0 08	 add	 rax, 8
  000da	48 89 44 24 20	 mov	 QWORD PTR args$[rsp], rax
  000df	48 8b 44 24 20	 mov	 rax, QWORD PTR args$[rsp]
  000e4	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  000e8	48 89 44 24 48	 mov	 QWORD PTR tv93[rsp], rax
$LN9@add_shader:
  000ed	48 8b 44 24 48	 mov	 rax, QWORD PTR tv93[rsp]
  000f2	48 89 44 24 50	 mov	 QWORD PTR src$[rsp], rax

; 99   :         type = va_arg(args, u32);

  000f7	33 c0		 xor	 eax, eax
  000f9	85 c0		 test	 eax, eax
  000fb	74 1f		 je	 SHORT $LN10@add_shader
  000fd	48 8b 44 24 20	 mov	 rax, QWORD PTR args$[rsp]
  00102	48 83 c0 08	 add	 rax, 8
  00106	48 89 44 24 20	 mov	 QWORD PTR args$[rsp], rax
  0010b	48 8b 44 24 20	 mov	 rax, QWORD PTR args$[rsp]
  00110	48 8b 40 f8	 mov	 rax, QWORD PTR [rax-8]
  00114	8b 00		 mov	 eax, DWORD PTR [rax]
  00116	89 44 24 30	 mov	 DWORD PTR tv132[rsp], eax
  0011a	eb 1a		 jmp	 SHORT $LN11@add_shader
$LN10@add_shader:
  0011c	48 8b 44 24 20	 mov	 rax, QWORD PTR args$[rsp]
  00121	48 83 c0 08	 add	 rax, 8
  00125	48 89 44 24 20	 mov	 QWORD PTR args$[rsp], rax
  0012a	48 8b 44 24 20	 mov	 rax, QWORD PTR args$[rsp]
  0012f	8b 40 f8	 mov	 eax, DWORD PTR [rax-8]
  00132	89 44 24 30	 mov	 DWORD PTR tv132[rsp], eax
$LN11@add_shader:
  00136	8b 44 24 30	 mov	 eax, DWORD PTR tv132[rsp]
  0013a	89 44 24 34	 mov	 DWORD PTR type$[rsp], eax

; 100  :         s[i] = compile_shader_from_file(src, type);

  0013e	8b 54 24 34	 mov	 edx, DWORD PTR type$[rsp]
  00142	48 8b 4c 24 50	 mov	 rcx, QWORD PTR src$[rsp]
  00147	e8 00 00 00 00	 call	 ?compile_shader_from_file@@YAIPEBDI@Z ; compile_shader_from_file
  0014c	8b 4c 24 28	 mov	 ecx, DWORD PTR i$1[rsp]
  00150	48 8b 54 24 40	 mov	 rdx, QWORD PTR s$[rsp]
  00155	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax

; 101  :     }

  00158	e9 35 ff ff ff	 jmp	 $LN2@add_shader
$LN3@add_shader:

; 102  :     
; 103  :     *shader = create_program(s, count);

  0015d	8b 54 24 78	 mov	 edx, DWORD PTR count$[rsp]
  00161	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00166	e8 00 00 00 00	 call	 ?create_program@@YAIPEAII@Z ; create_program
  0016b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR shader$[rsp]
  00170	89 01		 mov	 DWORD PTR [rcx], eax

; 104  :     free(s);

  00172	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00177	e8 00 00 00 00	 call	 free

; 105  :     
; 106  :     return id;

  0017c	8b 44 24 38	 mov	 eax, DWORD PTR id$[rsp]

; 107  : }

  00180	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00184	c3		 ret	 0
?add_shader@@YAIPEAUgl_renderer@@IZZ ENDP		; add_shader
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\shader.cpp
_TEXT	SEGMENT
program$ = 32
i$1 = 36
success$ = 40
info_log$ = 48
__$ArrayPad$ = 560
shaders$ = 592
count$ = 600
?create_program@@YAIPEAII@Z PROC			; create_program

; 62   : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 48 02
	00 00		 sub	 rsp, 584		; 00000248H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 30
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 63   :     u32 program = glCreateProgram();

  00022	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewCreateProgram
  00029	ff 10		 call	 QWORD PTR [rax]
  0002b	89 44 24 20	 mov	 DWORD PTR program$[rsp], eax

; 64   :     
; 65   :     for(u32 i = 0; i < count; i++)

  0002f	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00037	eb 0a		 jmp	 SHORT $LN4@create_pro
$LN2@create_pro:
  00039	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  0003d	ff c0		 inc	 eax
  0003f	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
$LN4@create_pro:
  00043	8b 84 24 58 02
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  0004a	39 44 24 24	 cmp	 DWORD PTR i$1[rsp], eax
  0004e	73 1e		 jae	 SHORT $LN3@create_pro

; 66   :         glAttachShader(program, shaders[i]);

  00050	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00054	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR shaders$[rsp]
  0005c	8b 14 81	 mov	 edx, DWORD PTR [rcx+rax*4]
  0005f	8b 4c 24 20	 mov	 ecx, DWORD PTR program$[rsp]
  00063	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewAttachShader
  0006a	ff 10		 call	 QWORD PTR [rax]
  0006c	eb cb		 jmp	 SHORT $LN2@create_pro
$LN3@create_pro:

; 67   :     glLinkProgram(program);

  0006e	8b 4c 24 20	 mov	 ecx, DWORD PTR program$[rsp]
  00072	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewLinkProgram
  00079	ff 10		 call	 QWORD PTR [rax]

; 68   :     
; 69   :     u32 success;
; 70   :     char info_log[512];
; 71   :     glGetProgramiv(program, GL_LINK_STATUS, (GLint *)&success);

  0007b	4c 8d 44 24 28	 lea	 r8, QWORD PTR success$[rsp]
  00080	ba 82 8b 00 00	 mov	 edx, 35714		; 00008b82H
  00085	8b 4c 24 20	 mov	 ecx, DWORD PTR program$[rsp]
  00089	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewGetProgramiv
  00090	ff 10		 call	 QWORD PTR [rax]

; 72   :     
; 73   :     if(!success) {

  00092	83 7c 24 28 00	 cmp	 DWORD PTR success$[rsp], 0
  00097	75 5b		 jne	 SHORT $LN8@create_pro

; 74   :         glGetProgramInfoLog(program, 512, NULL, info_log);

  00099	4c 8d 4c 24 30	 lea	 r9, QWORD PTR info_log$[rsp]
  0009e	45 33 c0	 xor	 r8d, r8d
  000a1	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  000a6	8b 4c 24 20	 mov	 ecx, DWORD PTR program$[rsp]
  000aa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewGetProgramInfoLog
  000b1	ff 10		 call	 QWORD PTR [rax]
$LN7@create_pro:

; 75   :         
; 76   :         LOG("ERROR::SHADER::LINKING_FAILED: %s", info_log);

  000b3	b9 02 00 00 00	 mov	 ecx, 2
  000b8	e8 00 00 00 00	 call	 __acrt_iob_func
  000bd	4c 8d 44 24 30	 lea	 r8, QWORD PTR info_log$[rsp]
  000c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG83323
  000c9	48 8b c8	 mov	 rcx, rax
  000cc	e8 00 00 00 00	 call	 fprintf
  000d1	b9 02 00 00 00	 mov	 ecx, 2
  000d6	e8 00 00 00 00	 call	 __acrt_iob_func
  000db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG83324
  000e2	48 8b c8	 mov	 rcx, rax
  000e5	e8 00 00 00 00	 call	 fprintf
  000ea	33 c0		 xor	 eax, eax
  000ec	85 c0		 test	 eax, eax
  000ee	75 c3		 jne	 SHORT $LN7@create_pro

; 77   :         
; 78   :         return 0;

  000f0	33 c0		 xor	 eax, eax
  000f2	eb 04		 jmp	 SHORT $LN1@create_pro
$LN8@create_pro:

; 79   :     }
; 80   :     
; 81   :     return program;

  000f4	8b 44 24 20	 mov	 eax, DWORD PTR program$[rsp]
$LN1@create_pro:

; 82   : }

  000f8	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00100	48 33 cc	 xor	 rcx, rsp
  00103	e8 00 00 00 00	 call	 __security_check_cookie
  00108	48 81 c4 48 02
	00 00		 add	 rsp, 584		; 00000248H
  0010f	c3		 ret	 0
?create_program@@YAIPEAII@Z ENDP			; create_program
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\shader.cpp
_TEXT	SEGMENT
shader$ = 32
src$ = 40
filename$ = 64
type$ = 72
?compile_shader_from_file@@YAIPEBDI@Z PROC		; compile_shader_from_file

; 52   : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 53   :     char *src = load_shader_source(filename);

  0000d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR filename$[rsp]
  00012	e8 00 00 00 00	 call	 ?load_shader_source@@YAPEADPEBD@Z ; load_shader_source
  00017	48 89 44 24 28	 mov	 QWORD PTR src$[rsp], rax

; 54   :     u32 shader = compile_shader(src, type);

  0001c	8b 54 24 48	 mov	 edx, DWORD PTR type$[rsp]
  00020	48 8b 4c 24 28	 mov	 rcx, QWORD PTR src$[rsp]
  00025	e8 00 00 00 00	 call	 ?compile_shader@@YAIPEADI@Z ; compile_shader
  0002a	89 44 24 20	 mov	 DWORD PTR shader$[rsp], eax

; 55   :     
; 56   :     free(src);

  0002e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR src$[rsp]
  00033	e8 00 00 00 00	 call	 free

; 57   :     return shader;

  00038	8b 44 24 20	 mov	 eax, DWORD PTR shader$[rsp]

; 58   : }

  0003c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00040	c3		 ret	 0
?compile_shader_from_file@@YAIPEBDI@Z ENDP		; compile_shader_from_file
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\shader.cpp
_TEXT	SEGMENT
shader$ = 32
success$ = 36
info_log$ = 48
__$ArrayPad$ = 560
src$ = 592
type$ = 600
?compile_shader@@YAIPEADI@Z PROC			; compile_shader

; 30   : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 48 02
	00 00		 sub	 rsp, 584		; 00000248H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 30
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 31   :     u32 shader = glCreateShader(type);

  00022	8b 8c 24 58 02
	00 00		 mov	 ecx, DWORD PTR type$[rsp]
  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewCreateShader
  00030	ff 10		 call	 QWORD PTR [rax]
  00032	89 44 24 20	 mov	 DWORD PTR shader$[rsp], eax

; 32   :     glShaderSource(shader, 1, &src, NULL);

  00036	45 33 c9	 xor	 r9d, r9d
  00039	4c 8d 84 24 50
	02 00 00	 lea	 r8, QWORD PTR src$[rsp]
  00041	ba 01 00 00 00	 mov	 edx, 1
  00046	8b 4c 24 20	 mov	 ecx, DWORD PTR shader$[rsp]
  0004a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewShaderSource
  00051	ff 10		 call	 QWORD PTR [rax]

; 33   :     glCompileShader(shader);

  00053	8b 4c 24 20	 mov	 ecx, DWORD PTR shader$[rsp]
  00057	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewCompileShader
  0005e	ff 10		 call	 QWORD PTR [rax]

; 34   :     
; 35   :     int success;
; 36   :     char info_log[512];
; 37   :     glGetShaderiv(shader, GL_COMPILE_STATUS, &success);

  00060	4c 8d 44 24 24	 lea	 r8, QWORD PTR success$[rsp]
  00065	ba 81 8b 00 00	 mov	 edx, 35713		; 00008b81H
  0006a	8b 4c 24 20	 mov	 ecx, DWORD PTR shader$[rsp]
  0006e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewGetShaderiv
  00075	ff 10		 call	 QWORD PTR [rax]

; 38   :     
; 39   :     if(!success) {

  00077	83 7c 24 24 00	 cmp	 DWORD PTR success$[rsp], 0
  0007c	75 5b		 jne	 SHORT $LN5@compile_sh

; 40   :         glGetShaderInfoLog(shader, 512, NULL, info_log);

  0007e	4c 8d 4c 24 30	 lea	 r9, QWORD PTR info_log$[rsp]
  00083	45 33 c0	 xor	 r8d, r8d
  00086	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  0008b	8b 4c 24 20	 mov	 ecx, DWORD PTR shader$[rsp]
  0008f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp___glewGetShaderInfoLog
  00096	ff 10		 call	 QWORD PTR [rax]
$LN4@compile_sh:

; 41   :         
; 42   :         LOG("ERROR::SHADER::COMPILATION: %s", info_log);

  00098	b9 02 00 00 00	 mov	 ecx, 2
  0009d	e8 00 00 00 00	 call	 __acrt_iob_func
  000a2	4c 8d 44 24 30	 lea	 r8, QWORD PTR info_log$[rsp]
  000a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG83299
  000ae	48 8b c8	 mov	 rcx, rax
  000b1	e8 00 00 00 00	 call	 fprintf
  000b6	b9 02 00 00 00	 mov	 ecx, 2
  000bb	e8 00 00 00 00	 call	 __acrt_iob_func
  000c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG83300
  000c7	48 8b c8	 mov	 rcx, rax
  000ca	e8 00 00 00 00	 call	 fprintf
  000cf	33 c0		 xor	 eax, eax
  000d1	85 c0		 test	 eax, eax
  000d3	75 c3		 jne	 SHORT $LN4@compile_sh

; 43   :         
; 44   :         return 0;

  000d5	33 c0		 xor	 eax, eax
  000d7	eb 04		 jmp	 SHORT $LN1@compile_sh
$LN5@compile_sh:

; 45   :     }
; 46   :     
; 47   :     return shader;

  000d9	8b 44 24 20	 mov	 eax, DWORD PTR shader$[rsp]
$LN1@compile_sh:

; 48   : }

  000dd	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000e5	48 33 cc	 xor	 rcx, rsp
  000e8	e8 00 00 00 00	 call	 __security_check_cookie
  000ed	48 81 c4 48 02
	00 00		 add	 rsp, 584		; 00000248H
  000f4	c3		 ret	 0
?compile_shader@@YAIPEADI@Z ENDP			; compile_shader
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\shader.cpp
_TEXT	SEGMENT
file$ = 32
size$ = 40
data$ = 48
tv71 = 56
path$ = 64
__$ArrayPad$ = 336
filename$ = 384
?load_shader_source@@YAPEADPEBD@Z PROC			; load_shader_source

; 4    : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5    :     char path[PATH_MAX] = "..\\data\\shaders\\";

  00020	48 8d 44 24 40	 lea	 rax, QWORD PTR path$[rsp]
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG83280
  0002c	48 8b f8	 mov	 rdi, rax
  0002f	48 8b f1	 mov	 rsi, rcx
  00032	b9 11 00 00 00	 mov	 ecx, 17
  00037	f3 a4		 rep movsb
  00039	48 8d 44 24 51	 lea	 rax, QWORD PTR path$[rsp+17]
  0003e	48 8b f8	 mov	 rdi, rax
  00041	33 c0		 xor	 eax, eax
  00043	b9 f3 00 00 00	 mov	 ecx, 243		; 000000f3H
  00048	f3 aa		 rep stosb
$LN4@load_shade:

; 6    :     
; 7    :     ASSERT(strlen(path)+strlen(filename) < sizeof(path),

  0004a	48 8d 4c 24 40	 lea	 rcx, QWORD PTR path$[rsp]
  0004f	e8 00 00 00 00	 call	 strlen
  00054	48 89 44 24 38	 mov	 QWORD PTR tv71[rsp], rax
  00059	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR filename$[rsp]
  00061	e8 00 00 00 00	 call	 strlen
  00066	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv71[rsp]
  0006b	48 03 c8	 add	 rcx, rax
  0006e	48 8b c1	 mov	 rax, rcx
  00071	48 3d 04 01 00
	00		 cmp	 rax, 260		; 00000104H
  00077	72 30		 jb	 SHORT $LN8@load_shade
  00079	b9 02 00 00 00	 mov	 ecx, 2
  0007e	e8 00 00 00 00	 call	 __acrt_iob_func
  00083	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG83282
  0008a	41 b8 08 00 00
	00		 mov	 r8d, 8
  00090	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG83283
  00097	48 8b c8	 mov	 rcx, rax
  0009a	e8 00 00 00 00	 call	 fprintf
  0009f	b9 01 00 00 00	 mov	 ecx, 1
  000a4	e8 00 00 00 00	 call	 exit
$LN8@load_shade:
  000a9	33 c0		 xor	 eax, eax
  000ab	85 c0		 test	 eax, eax
  000ad	75 9b		 jne	 SHORT $LN4@load_shade

; 8    :            "Shader file path is too long.");
; 9    :     strcat(path, filename);

  000af	48 8b 94 24 80
	01 00 00	 mov	 rdx, QWORD PTR filename$[rsp]
  000b7	48 8d 4c 24 40	 lea	 rcx, QWORD PTR path$[rsp]
  000bc	e8 00 00 00 00	 call	 strcat

; 10   :     
; 11   :     FILE *file = fopen(path, "r");

  000c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG83284
  000c8	48 8d 4c 24 40	 lea	 rcx, QWORD PTR path$[rsp]
  000cd	e8 00 00 00 00	 call	 fopen
  000d2	48 89 44 24 20	 mov	 QWORD PTR file$[rsp], rax
$LN7@load_shade:

; 12   :     ASSERT(file != NULL, "Could not open shader source file.");

  000d7	48 83 7c 24 20
	00		 cmp	 QWORD PTR file$[rsp], 0
  000dd	75 30		 jne	 SHORT $LN9@load_shade
  000df	b9 02 00 00 00	 mov	 ecx, 2
  000e4	e8 00 00 00 00	 call	 __acrt_iob_func
  000e9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG83286
  000f0	41 b8 0c 00 00
	00		 mov	 r8d, 12
  000f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG83287
  000fd	48 8b c8	 mov	 rcx, rax
  00100	e8 00 00 00 00	 call	 fprintf
  00105	b9 01 00 00 00	 mov	 ecx, 1
  0010a	e8 00 00 00 00	 call	 exit
$LN9@load_shade:
  0010f	33 c0		 xor	 eax, eax
  00111	85 c0		 test	 eax, eax
  00113	75 c2		 jne	 SHORT $LN7@load_shade

; 13   :     
; 14   :     u64 size;
; 15   :     fseek(file, 0, SEEK_END);

  00115	41 b8 02 00 00
	00		 mov	 r8d, 2
  0011b	33 d2		 xor	 edx, edx
  0011d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR file$[rsp]
  00122	e8 00 00 00 00	 call	 fseek

; 16   :     size = ftell(file);

  00127	48 8b 4c 24 20	 mov	 rcx, QWORD PTR file$[rsp]
  0012c	e8 00 00 00 00	 call	 ftell
  00131	48 98		 cdqe
  00133	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax

; 17   :     fseek(file, 0, SEEK_SET);

  00138	45 33 c0	 xor	 r8d, r8d
  0013b	33 d2		 xor	 edx, edx
  0013d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR file$[rsp]
  00142	e8 00 00 00 00	 call	 fseek

; 18   :     
; 19   :     char *data = (char *)malloc(size+1);

  00147	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  0014c	48 ff c0	 inc	 rax
  0014f	48 8b c8	 mov	 rcx, rax
  00152	e8 00 00 00 00	 call	 malloc
  00157	48 89 44 24 30	 mov	 QWORD PTR data$[rsp], rax

; 20   :     fread(data, 1, size, file);

  0015c	4c 8b 4c 24 20	 mov	 r9, QWORD PTR file$[rsp]
  00161	4c 8b 44 24 28	 mov	 r8, QWORD PTR size$[rsp]
  00166	ba 01 00 00 00	 mov	 edx, 1
  0016b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  00170	e8 00 00 00 00	 call	 fread

; 21   :     data[size] = '\0';

  00175	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  0017a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  0017f	48 03 c8	 add	 rcx, rax
  00182	48 8b c1	 mov	 rax, rcx
  00185	c6 00 00	 mov	 BYTE PTR [rax], 0

; 22   :     
; 23   :     fclose(file);

  00188	48 8b 4c 24 20	 mov	 rcx, QWORD PTR file$[rsp]
  0018d	e8 00 00 00 00	 call	 fclose

; 24   :     
; 25   :     return data;

  00192	48 8b 44 24 30	 mov	 rax, QWORD PTR data$[rsp]
$LN10@load_shade:

; 26   : }

  00197	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0019f	48 33 cc	 xor	 rcx, rsp
  001a2	e8 00 00 00 00	 call	 __security_check_cookie
  001a7	48 81 c4 68 01
	00 00		 add	 rsp, 360		; 00000168H
  001ae	5f		 pop	 rdi
  001af	5e		 pop	 rsi
  001b0	c3		 ret	 0
?load_shader_source@@YAPEADPEBD@Z ENDP			; load_shader_source
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\obj_loader.cpp
_TEXT	SEGMENT
i$ = 32
tv87 = 36
tv93 = 40
obj_count$ = 44
mat_count$ = 48
mat$ = 56
obj$ = 64
info$ = 96
?free_obj@@YAXPEAUobj_info_t@@@Z PROC			; free_obj

; 341  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 342  :     free(info->path);

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR info$[rsp]
  0000e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00011	e8 00 00 00 00	 call	 free

; 343  :     
; 344  :     stack_free(info->v);

  00016	48 8b 44 24 60	 mov	 rax, QWORD PTR info$[rsp]
  0001b	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0001f	48 83 e8 08	 sub	 rax, 8
  00023	48 8b c8	 mov	 rcx, rax
  00026	e8 00 00 00 00	 call	 free

; 345  :     if(info->vn)

  0002b	48 8b 44 24 60	 mov	 rax, QWORD PTR info$[rsp]
  00030	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00035	74 15		 je	 SHORT $LN8@free_obj

; 346  :         stack_free(info->vn);

  00037	48 8b 44 24 60	 mov	 rax, QWORD PTR info$[rsp]
  0003c	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00040	48 83 e8 08	 sub	 rax, 8
  00044	48 8b c8	 mov	 rcx, rax
  00047	e8 00 00 00 00	 call	 free
$LN8@free_obj:

; 347  :     if(info->vt)

  0004c	48 8b 44 24 60	 mov	 rax, QWORD PTR info$[rsp]
  00051	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00056	74 15		 je	 SHORT $LN9@free_obj

; 348  :         stack_free(info->vt);

  00058	48 8b 44 24 60	 mov	 rax, QWORD PTR info$[rsp]
  0005d	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00061	48 83 e8 08	 sub	 rax, 8
  00065	48 8b c8	 mov	 rcx, rax
  00068	e8 00 00 00 00	 call	 free
$LN9@free_obj:

; 349  :     stack_free(info->idx);

  0006d	48 8b 44 24 60	 mov	 rax, QWORD PTR info$[rsp]
  00072	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00076	48 83 e8 08	 sub	 rax, 8
  0007a	48 8b c8	 mov	 rcx, rax
  0007d	e8 00 00 00 00	 call	 free

; 350  :     
; 351  :     u32 i;
; 352  :     u32 obj_count = get_stack_count(info->objs);

  00082	48 8b 44 24 60	 mov	 rax, QWORD PTR info$[rsp]
  00087	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0008c	74 12		 je	 SHORT $LN20@free_obj
  0008e	48 8b 44 24 60	 mov	 rax, QWORD PTR info$[rsp]
  00093	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00097	8b 40 fc	 mov	 eax, DWORD PTR [rax-4]
  0009a	89 44 24 24	 mov	 DWORD PTR tv87[rsp], eax
  0009e	eb 08		 jmp	 SHORT $LN21@free_obj
$LN20@free_obj:
  000a0	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv87[rsp], 0
$LN21@free_obj:
  000a8	8b 44 24 24	 mov	 eax, DWORD PTR tv87[rsp]
  000ac	89 44 24 2c	 mov	 DWORD PTR obj_count$[rsp], eax

; 353  :     u32 mat_count = get_stack_count(info->materials);

  000b0	48 8b 44 24 60	 mov	 rax, QWORD PTR info$[rsp]
  000b5	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  000ba	74 12		 je	 SHORT $LN22@free_obj
  000bc	48 8b 44 24 60	 mov	 rax, QWORD PTR info$[rsp]
  000c1	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000c5	8b 40 fc	 mov	 eax, DWORD PTR [rax-4]
  000c8	89 44 24 28	 mov	 DWORD PTR tv93[rsp], eax
  000cc	eb 08		 jmp	 SHORT $LN23@free_obj
$LN22@free_obj:
  000ce	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
$LN23@free_obj:
  000d6	8b 44 24 28	 mov	 eax, DWORD PTR tv93[rsp]
  000da	89 44 24 30	 mov	 DWORD PTR mat_count$[rsp], eax

; 354  :     obj_t *obj = info->objs;

  000de	48 8b 44 24 60	 mov	 rax, QWORD PTR info$[rsp]
  000e3	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000e7	48 89 44 24 40	 mov	 QWORD PTR obj$[rsp], rax

; 355  :     obj_mat_t *mat = info->materials;

  000ec	48 8b 44 24 60	 mov	 rax, QWORD PTR info$[rsp]
  000f1	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000f5	48 89 44 24 38	 mov	 QWORD PTR mat$[rsp], rax

; 356  :     
; 357  :     for(i = 0; i < obj_count; i++, obj++)

  000fa	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00102	eb 18		 jmp	 SHORT $LN4@free_obj
$LN2@free_obj:
  00104	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00108	ff c0		 inc	 eax
  0010a	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0010e	48 8b 44 24 40	 mov	 rax, QWORD PTR obj$[rsp]
  00113	48 83 c0 20	 add	 rax, 32			; 00000020H
  00117	48 89 44 24 40	 mov	 QWORD PTR obj$[rsp], rax
$LN4@free_obj:
  0011c	8b 44 24 2c	 mov	 eax, DWORD PTR obj_count$[rsp]
  00120	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00124	73 0f		 jae	 SHORT $LN3@free_obj

; 358  :         free(obj->name);

  00126	48 8b 44 24 40	 mov	 rax, QWORD PTR obj$[rsp]
  0012b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0012e	e8 00 00 00 00	 call	 free
  00133	eb cf		 jmp	 SHORT $LN2@free_obj
$LN3@free_obj:

; 359  :     for(i = 0; i < mat_count; i++, mat++) {

  00135	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0013d	eb 1a		 jmp	 SHORT $LN7@free_obj
$LN5@free_obj:
  0013f	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00143	ff c0		 inc	 eax
  00145	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00149	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  0014e	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  00154	48 89 44 24 38	 mov	 QWORD PTR mat$[rsp], rax
$LN7@free_obj:
  00159	8b 44 24 30	 mov	 eax, DWORD PTR mat_count$[rsp]
  0015d	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00161	0f 83 d4 00 00
	00		 jae	 $LN6@free_obj

; 360  :         free(mat->name);

  00167	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  0016c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0016f	e8 00 00 00 00	 call	 free

; 361  :         
; 362  :         if(mat->ambient_texture_name)

  00174	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  00179	48 83 78 58 00	 cmp	 QWORD PTR [rax+88], 0
  0017e	74 0e		 je	 SHORT $LN10@free_obj

; 363  :             free(mat->ambient_texture_name);

  00180	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  00185	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00189	e8 00 00 00 00	 call	 free
$LN10@free_obj:

; 364  :         if(mat->diffuse_texture_name)

  0018e	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  00193	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00198	74 0e		 je	 SHORT $LN11@free_obj

; 365  :             free(mat->diffuse_texture_name);

  0019a	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  0019f	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  001a3	e8 00 00 00 00	 call	 free
$LN11@free_obj:

; 366  :         if(mat->specular_texture_name)

  001a8	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  001ad	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  001b2	74 0e		 je	 SHORT $LN12@free_obj

; 367  :             free(mat->specular_texture_name);

  001b4	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  001b9	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  001bd	e8 00 00 00 00	 call	 free
$LN12@free_obj:

; 368  :         if(mat->specular_highlight_texture_name)

  001c2	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  001c7	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  001cc	74 0e		 je	 SHORT $LN13@free_obj

; 369  :             free(mat->specular_highlight_texture_name);

  001ce	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  001d3	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  001d7	e8 00 00 00 00	 call	 free
$LN13@free_obj:

; 370  :         if(mat->bump_texture_name)

  001dc	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  001e1	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  001e6	74 0e		 je	 SHORT $LN14@free_obj

; 371  :             free(mat->bump_texture_name);

  001e8	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  001ed	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  001f1	e8 00 00 00 00	 call	 free
$LN14@free_obj:

; 372  :         if(mat->displacement_texture_name)

  001f6	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  001fb	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00203	74 11		 je	 SHORT $LN15@free_obj

; 373  :             free(mat->displacement_texture_name);

  00205	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  0020a	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  00211	e8 00 00 00 00	 call	 free
$LN15@free_obj:

; 374  :         if(mat->alpha_texture_name)

  00216	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  0021b	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  00223	74 11		 je	 SHORT $LN16@free_obj

; 375  :             free(mat->alpha_texture_name);

  00225	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  0022a	48 8b 88 88 00
	00 00		 mov	 rcx, QWORD PTR [rax+136]
  00231	e8 00 00 00 00	 call	 free
$LN16@free_obj:

; 376  :     }

  00236	e9 04 ff ff ff	 jmp	 $LN5@free_obj
$LN6@free_obj:

; 377  :     
; 378  :     if(info->objs)

  0023b	48 8b 44 24 60	 mov	 rax, QWORD PTR info$[rsp]
  00240	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00245	74 15		 je	 SHORT $LN17@free_obj

; 379  :         stack_free(info->objs);

  00247	48 8b 44 24 60	 mov	 rax, QWORD PTR info$[rsp]
  0024c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00250	48 83 e8 08	 sub	 rax, 8
  00254	48 8b c8	 mov	 rcx, rax
  00257	e8 00 00 00 00	 call	 free
$LN17@free_obj:

; 380  :     if(info->materials)

  0025c	48 8b 44 24 60	 mov	 rax, QWORD PTR info$[rsp]
  00261	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00266	74 15		 je	 SHORT $LN18@free_obj

; 381  :         stack_free(info->materials);

  00268	48 8b 44 24 60	 mov	 rax, QWORD PTR info$[rsp]
  0026d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00271	48 83 e8 08	 sub	 rax, 8
  00275	48 8b c8	 mov	 rcx, rax
  00278	e8 00 00 00 00	 call	 free
$LN18@free_obj:

; 382  : }

  0027d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00281	c3		 ret	 0
?free_obj@@YAXPEAUobj_info_t@@@Z ENDP			; free_obj
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\obj_loader.cpp
_TEXT	SEGMENT
last_slash$ = 32
mtl_name$ = 40
mtl_data$ = 48
obj_data$ = 56
tv71 = 64
info$ = 72
path$ = 128
__$ArrayPad$ = 400
$T1 = 448
filename$ = 456
?load_obj@@YA?AUobj_info_t@@PEAD@Z PROC			; load_obj

; 306  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec a8 01
	00 00		 sub	 rsp, 424		; 000001a8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 307  :     char path[PATH_MAX] = "..\\data\\models\\";

  00025	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR path$[rsp]
  0002d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG83209
  00034	48 8b f8	 mov	 rdi, rax
  00037	48 8b f1	 mov	 rsi, rcx
  0003a	b9 10 00 00 00	 mov	 ecx, 16
  0003f	f3 a4		 rep movsb
  00041	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR path$[rsp+16]
  00049	48 8b f8	 mov	 rdi, rax
  0004c	33 c0		 xor	 eax, eax
  0004e	b9 f4 00 00 00	 mov	 ecx, 244		; 000000f4H
  00053	f3 aa		 rep stosb
$LN4@load_obj:

; 308  :     
; 309  :     ASSERT(strlen(path)+strlen(filename) < sizeof(path),

  00055	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR path$[rsp]
  0005d	e8 00 00 00 00	 call	 strlen
  00062	48 89 44 24 40	 mov	 QWORD PTR tv71[rsp], rax
  00067	48 8b 8c 24 c8
	01 00 00	 mov	 rcx, QWORD PTR filename$[rsp]
  0006f	e8 00 00 00 00	 call	 strlen
  00074	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv71[rsp]
  00079	48 03 c8	 add	 rcx, rax
  0007c	48 8b c1	 mov	 rax, rcx
  0007f	48 3d 04 01 00
	00		 cmp	 rax, 260		; 00000104H
  00085	72 30		 jb	 SHORT $LN5@load_obj
  00087	b9 02 00 00 00	 mov	 ecx, 2
  0008c	e8 00 00 00 00	 call	 __acrt_iob_func
  00091	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG83211
  00098	41 b8 36 01 00
	00		 mov	 r8d, 310		; 00000136H
  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG83212
  000a5	48 8b c8	 mov	 rcx, rax
  000a8	e8 00 00 00 00	 call	 fprintf
  000ad	b9 01 00 00 00	 mov	 ecx, 1
  000b2	e8 00 00 00 00	 call	 exit
$LN5@load_obj:
  000b7	33 c0		 xor	 eax, eax
  000b9	85 c0		 test	 eax, eax
  000bb	75 98		 jne	 SHORT $LN4@load_obj

; 310  :            "Shader file path is too long.");
; 311  :     strcat(path, filename);

  000bd	48 8b 94 24 c8
	01 00 00	 mov	 rdx, QWORD PTR filename$[rsp]
  000c5	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR path$[rsp]
  000cd	e8 00 00 00 00	 call	 strcat

; 312  :     
; 313  :     u8 *obj_data;
; 314  :     read_file(path, &obj_data);

  000d2	45 33 c0	 xor	 r8d, r8d
  000d5	48 8d 54 24 38	 lea	 rdx, QWORD PTR obj_data$[rsp]
  000da	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR path$[rsp]
  000e2	e8 00 00 00 00	 call	 ?read_file@@YAXPEADPEAPEAEPEA_K@Z ; read_file

; 315  :     
; 316  :     char *mtl_name = NULL;

  000e7	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR mtl_name$[rsp], 0

; 317  :     obj_info_t info = {0};

  000f0	48 8d 44 24 48	 lea	 rax, QWORD PTR info$[rsp]
  000f5	48 8b f8	 mov	 rdi, rax
  000f8	33 c0		 xor	 eax, eax
  000fa	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  000ff	f3 aa		 rep stosb

; 318  :     
; 319  :     char *last_slash = strrchr(path, '\\');

  00101	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  00106	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR path$[rsp]
  0010e	e8 00 00 00 00	 call	 ?strrchr@@YAPEADQEADH@Z	; strrchr
  00113	48 89 44 24 20	 mov	 QWORD PTR last_slash$[rsp], rax

; 320  :     info.path = (char *)malloc(last_slash-path+2);

  00118	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR path$[rsp]
  00120	48 8b 4c 24 20	 mov	 rcx, QWORD PTR last_slash$[rsp]
  00125	48 2b c8	 sub	 rcx, rax
  00128	48 8b c1	 mov	 rax, rcx
  0012b	48 83 c0 02	 add	 rax, 2
  0012f	48 8b c8	 mov	 rcx, rax
  00132	e8 00 00 00 00	 call	 malloc
  00137	48 89 44 24 48	 mov	 QWORD PTR info$[rsp], rax

; 321  :     memcpy(info.path, path, last_slash-path+1);

  0013c	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR path$[rsp]
  00144	48 8b 4c 24 20	 mov	 rcx, QWORD PTR last_slash$[rsp]
  00149	48 2b c8	 sub	 rcx, rax
  0014c	48 8b c1	 mov	 rax, rcx
  0014f	48 ff c0	 inc	 rax
  00152	4c 8b c0	 mov	 r8, rax
  00155	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR path$[rsp]
  0015d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR info$[rsp]
  00162	e8 00 00 00 00	 call	 memcpy

; 322  :     info.path[last_slash-path+1] = '\0';

  00167	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR path$[rsp]
  0016f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR last_slash$[rsp]
  00174	48 2b c8	 sub	 rcx, rax
  00177	48 8b c1	 mov	 rax, rcx
  0017a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR info$[rsp]
  0017f	c6 44 01 01 00	 mov	 BYTE PTR [rcx+rax+1], 0

; 323  :     
; 324  :     if(obj_data)

  00184	48 83 7c 24 38
	00		 cmp	 QWORD PTR obj_data$[rsp], 0
  0018a	74 14		 je	 SHORT $LN6@load_obj

; 325  :         parse_obj(&info, obj_data, &mtl_name);

  0018c	4c 8d 44 24 28	 lea	 r8, QWORD PTR mtl_name$[rsp]
  00191	48 8b 54 24 38	 mov	 rdx, QWORD PTR obj_data$[rsp]
  00196	48 8d 4c 24 48	 lea	 rcx, QWORD PTR info$[rsp]
  0019b	e8 00 00 00 00	 call	 ?parse_obj@@YAXPEAUobj_info_t@@PEAEPEAPEAD@Z ; parse_obj
$LN6@load_obj:

; 326  :     
; 327  :     u8 *mtl_data = NULL;

  001a0	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR mtl_data$[rsp], 0

; 328  :     if(mtl_name) {

  001a9	48 83 7c 24 28
	00		 cmp	 QWORD PTR mtl_name$[rsp], 0
  001af	74 2a		 je	 SHORT $LN7@load_obj

; 329  :         strcpy(last_slash+1, mtl_name);

  001b1	48 8b 44 24 20	 mov	 rax, QWORD PTR last_slash$[rsp]
  001b6	48 ff c0	 inc	 rax
  001b9	48 8b 54 24 28	 mov	 rdx, QWORD PTR mtl_name$[rsp]
  001be	48 8b c8	 mov	 rcx, rax
  001c1	e8 00 00 00 00	 call	 strcpy

; 330  :         read_file(path, &mtl_data);

  001c6	45 33 c0	 xor	 r8d, r8d
  001c9	48 8d 54 24 30	 lea	 rdx, QWORD PTR mtl_data$[rsp]
  001ce	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR path$[rsp]
  001d6	e8 00 00 00 00	 call	 ?read_file@@YAXPEADPEAPEAEPEA_K@Z ; read_file
$LN7@load_obj:

; 331  :     }
; 332  :     
; 333  :     if(mtl_data)

  001db	48 83 7c 24 30
	00		 cmp	 QWORD PTR mtl_data$[rsp], 0
  001e1	74 0f		 je	 SHORT $LN8@load_obj

; 334  :         parse_mtl(&info, mtl_data);

  001e3	48 8b 54 24 30	 mov	 rdx, QWORD PTR mtl_data$[rsp]
  001e8	48 8d 4c 24 48	 lea	 rcx, QWORD PTR info$[rsp]
  001ed	e8 00 00 00 00	 call	 ?parse_mtl@@YAXPEAUobj_info_t@@PEAE@Z ; parse_mtl
$LN8@load_obj:

; 335  :     
; 336  :     return info;

  001f2	48 8d 44 24 48	 lea	 rax, QWORD PTR info$[rsp]
  001f7	48 8b bc 24 c0
	01 00 00	 mov	 rdi, QWORD PTR $T1[rsp]
  001ff	48 8b f0	 mov	 rsi, rax
  00202	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00207	f3 a4		 rep movsb
  00209	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR $T1[rsp]
$LN9@load_obj:

; 337  : }

  00211	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00219	48 33 cc	 xor	 rcx, rsp
  0021c	e8 00 00 00 00	 call	 __security_check_cookie
  00221	48 81 c4 a8 01
	00 00		 add	 rsp, 424		; 000001a8H
  00228	5f		 pop	 rdi
  00229	5e		 pop	 rsi
  0022a	c3		 ret	 0
?load_obj@@YA?AUobj_info_t@@PEAD@Z ENDP			; load_obj
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\obj_loader.cpp
_TEXT	SEGMENT
i$1 = 32
tv83 = 36
tv129 = 40
obj_count$2 = 44
mat_id$3 = 48
mat$ = 56
objs$4 = 64
info$ = 96
token$ = 104
?parse_mtl@@YAXPEAUobj_info_t@@PEAE@Z PROC		; parse_mtl

; 193  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 194  :     obj_mat_t *mat = NULL;

  0000e	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR mat$[rsp], 0
$LN2@parse_mtl:

; 195  :     
; 196  :     while(*token) {

  00017	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  0001c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0001f	85 c0		 test	 eax, eax
  00021	0f 84 fb 08 00
	00		 je	 $LN3@parse_mtl

; 197  :         if((strncmp((char *)token, "newmtl", 6) == 0) &&

  00027	41 b8 06 00 00
	00		 mov	 r8d, 6
  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG83119
  00034	48 8b 4c 24 68	 mov	 rcx, QWORD PTR token$[rsp]
  00039	e8 00 00 00 00	 call	 strncmp
  0003e	85 c0		 test	 eax, eax
  00040	0f 85 2a 01 00
	00		 jne	 $LN19@parse_mtl
  00046	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  0004b	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  0004f	83 f8 20	 cmp	 eax, 32			; 00000020H
  00052	74 12		 je	 SHORT $LN21@parse_mtl
  00054	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00059	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  0005d	83 f8 09	 cmp	 eax, 9
  00060	0f 85 0a 01 00
	00		 jne	 $LN19@parse_mtl
$LN21@parse_mtl:

; 198  :            IS_SPACE(*(token+6))) {
; 199  :             token += 7;

  00066	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  0006b	48 83 c0 07	 add	 rax, 7
  0006f	48 89 44 24 68	 mov	 QWORD PTR token$[rsp], rax

; 200  :             
; 201  :             u32 mat_id = get_stack_count(info->materials);

  00074	48 8b 44 24 60	 mov	 rax, QWORD PTR info$[rsp]
  00079	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0007e	74 12		 je	 SHORT $LN85@parse_mtl
  00080	48 8b 44 24 60	 mov	 rax, QWORD PTR info$[rsp]
  00085	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00089	8b 40 fc	 mov	 eax, DWORD PTR [rax-4]
  0008c	89 44 24 24	 mov	 DWORD PTR tv83[rsp], eax
  00090	eb 08		 jmp	 SHORT $LN86@parse_mtl
$LN85@parse_mtl:
  00092	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
$LN86@parse_mtl:
  0009a	8b 44 24 24	 mov	 eax, DWORD PTR tv83[rsp]
  0009e	89 44 24 30	 mov	 DWORD PTR mat_id$3[rsp], eax

; 202  :             mat = (obj_mat_t *)stack_push(&info->materials);

  000a2	48 8b 44 24 60	 mov	 rax, QWORD PTR info$[rsp]
  000a7	48 83 c0 10	 add	 rax, 16
  000ab	41 b8 90 00 00
	00		 mov	 r8d, 144		; 00000090H
  000b1	ba 01 00 00 00	 mov	 edx, 1
  000b6	48 8b c8	 mov	 rcx, rax
  000b9	e8 00 00 00 00	 call	 ?_stack_push@@YAPEAXPEAPEAXII@Z ; _stack_push
  000be	48 89 44 24 38	 mov	 QWORD PTR mat$[rsp], rax

; 203  :             init_obj_material(mat);

  000c3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mat$[rsp]
  000c8	e8 00 00 00 00	 call	 ?init_obj_material@@YAXPEAUobj_mat_t@@@Z ; init_obj_material

; 204  :             
; 205  :             parse_name(&token, &mat->name);

  000cd	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  000d2	48 8b d0	 mov	 rdx, rax
  000d5	48 8d 4c 24 68	 lea	 rcx, QWORD PTR token$[rsp]
  000da	e8 00 00 00 00	 call	 ?parse_name@@YAIPEAPEAEPEAPEAD@Z ; parse_name

; 206  :             
; 207  :             obj_t *objs = info->objs;

  000df	48 8b 44 24 60	 mov	 rax, QWORD PTR info$[rsp]
  000e4	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000e8	48 89 44 24 40	 mov	 QWORD PTR objs$4[rsp], rax

; 208  :             u32 obj_count = get_stack_count(objs);

  000ed	48 83 7c 24 40
	00		 cmp	 QWORD PTR objs$4[rsp], 0
  000f3	74 0e		 je	 SHORT $LN87@parse_mtl
  000f5	48 8b 44 24 40	 mov	 rax, QWORD PTR objs$4[rsp]
  000fa	8b 40 fc	 mov	 eax, DWORD PTR [rax-4]
  000fd	89 44 24 28	 mov	 DWORD PTR tv129[rsp], eax
  00101	eb 08		 jmp	 SHORT $LN88@parse_mtl
$LN87@parse_mtl:
  00103	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv129[rsp], 0
$LN88@parse_mtl:
  0010b	8b 44 24 28	 mov	 eax, DWORD PTR tv129[rsp]
  0010f	89 44 24 2c	 mov	 DWORD PTR obj_count$2[rsp], eax

; 209  :             for(u32 i = 0; i < obj_count; i++) {

  00113	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  0011b	eb 0a		 jmp	 SHORT $LN6@parse_mtl
$LN4@parse_mtl:
  0011d	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00121	ff c0		 inc	 eax
  00123	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN6@parse_mtl:
  00127	8b 44 24 2c	 mov	 eax, DWORD PTR obj_count$2[rsp]
  0012b	39 44 24 20	 cmp	 DWORD PTR i$1[rsp], eax
  0012f	73 3a		 jae	 SHORT $LN5@parse_mtl

; 210  :                 if (strcmp(mat->name, objs[i].mat_name) == 0) {

  00131	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00135	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00139	48 8b 4c 24 40	 mov	 rcx, QWORD PTR objs$4[rsp]
  0013e	48 8b 54 01 08	 mov	 rdx, QWORD PTR [rcx+rax+8]
  00143	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  00148	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0014b	e8 00 00 00 00	 call	 strcmp
  00150	85 c0		 test	 eax, eax
  00152	75 15		 jne	 SHORT $LN22@parse_mtl

; 211  :                     objs[i].mat_id = mat_id;

  00154	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00158	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0015c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR objs$4[rsp]
  00161	8b 54 24 30	 mov	 edx, DWORD PTR mat_id$3[rsp]
  00165	89 54 01 18	 mov	 DWORD PTR [rcx+rax+24], edx
$LN22@parse_mtl:

; 212  :                 }
; 213  :             }

  00169	eb b2		 jmp	 SHORT $LN4@parse_mtl
$LN5@parse_mtl:

; 214  :         } else if (*token == 'K') {

  0016b	e9 96 07 00 00	 jmp	 $LN20@parse_mtl
$LN19@parse_mtl:
  00170	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00175	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00178	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  0017b	0f 85 e1 01 00
	00		 jne	 $LN23@parse_mtl

; 215  :             token++;

  00181	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00186	48 ff c0	 inc	 rax
  00189	48 89 44 24 68	 mov	 QWORD PTR token$[rsp], rax

; 216  :             
; 217  :             if (*token == 'a' && IS_SPACE(*(token+1))) {

  0018e	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00193	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00196	83 f8 61	 cmp	 eax, 97			; 00000061H
  00199	75 45		 jne	 SHORT $LN25@parse_mtl
  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  001a0	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001a4	83 f8 20	 cmp	 eax, 32			; 00000020H
  001a7	74 0e		 je	 SHORT $LN27@parse_mtl
  001a9	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  001ae	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001b2	83 f8 09	 cmp	 eax, 9
  001b5	75 29		 jne	 SHORT $LN25@parse_mtl
$LN27@parse_mtl:

; 218  :                 token += 2;

  001b7	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  001bc	48 83 c0 02	 add	 rax, 2
  001c0	48 89 44 24 68	 mov	 QWORD PTR token$[rsp], rax

; 219  :                 parse_v3(mat->ambient, &token);

  001c5	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  001ca	48 83 c0 08	 add	 rax, 8
  001ce	48 8d 54 24 68	 lea	 rdx, QWORD PTR token$[rsp]
  001d3	48 8b c8	 mov	 rcx, rax
  001d6	e8 00 00 00 00	 call	 ?parse_v3@@YAXPEAMPEAPEAE@Z ; parse_v3
  001db	e9 7d 01 00 00	 jmp	 $LN26@parse_mtl
$LN25@parse_mtl:

; 220  :             } else if (*token == 'd' && IS_SPACE(*(token+1))) {

  001e0	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  001e5	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001e8	83 f8 64	 cmp	 eax, 100		; 00000064H
  001eb	75 45		 jne	 SHORT $LN28@parse_mtl
  001ed	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  001f2	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001f6	83 f8 20	 cmp	 eax, 32			; 00000020H
  001f9	74 0e		 je	 SHORT $LN30@parse_mtl
  001fb	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00200	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00204	83 f8 09	 cmp	 eax, 9
  00207	75 29		 jne	 SHORT $LN28@parse_mtl
$LN30@parse_mtl:

; 221  :                 token += 2;

  00209	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  0020e	48 83 c0 02	 add	 rax, 2
  00212	48 89 44 24 68	 mov	 QWORD PTR token$[rsp], rax

; 222  :                 parse_v3(mat->diffuse, &token);

  00217	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  0021c	48 83 c0 14	 add	 rax, 20
  00220	48 8d 54 24 68	 lea	 rdx, QWORD PTR token$[rsp]
  00225	48 8b c8	 mov	 rcx, rax
  00228	e8 00 00 00 00	 call	 ?parse_v3@@YAXPEAMPEAPEAE@Z ; parse_v3
  0022d	e9 2b 01 00 00	 jmp	 $LN29@parse_mtl
$LN28@parse_mtl:

; 223  :             } else if (*token == 's' && IS_SPACE(*(token+1))) {

  00232	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00237	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0023a	83 f8 73	 cmp	 eax, 115		; 00000073H
  0023d	75 45		 jne	 SHORT $LN31@parse_mtl
  0023f	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00244	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00248	83 f8 20	 cmp	 eax, 32			; 00000020H
  0024b	74 0e		 je	 SHORT $LN33@parse_mtl
  0024d	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00252	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00256	83 f8 09	 cmp	 eax, 9
  00259	75 29		 jne	 SHORT $LN31@parse_mtl
$LN33@parse_mtl:

; 224  :                 token += 2;

  0025b	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00260	48 83 c0 02	 add	 rax, 2
  00264	48 89 44 24 68	 mov	 QWORD PTR token$[rsp], rax

; 225  :                 parse_v3(mat->specular, &token);

  00269	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  0026e	48 83 c0 20	 add	 rax, 32			; 00000020H
  00272	48 8d 54 24 68	 lea	 rdx, QWORD PTR token$[rsp]
  00277	48 8b c8	 mov	 rcx, rax
  0027a	e8 00 00 00 00	 call	 ?parse_v3@@YAXPEAMPEAPEAE@Z ; parse_v3
  0027f	e9 d9 00 00 00	 jmp	 $LN32@parse_mtl
$LN31@parse_mtl:

; 226  :             } else if (*token == 't' && IS_SPACE(*(token+1))) {

  00284	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00289	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0028c	83 f8 74	 cmp	 eax, 116		; 00000074H
  0028f	75 45		 jne	 SHORT $LN34@parse_mtl
  00291	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00296	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0029a	83 f8 20	 cmp	 eax, 32			; 00000020H
  0029d	74 0e		 je	 SHORT $LN36@parse_mtl
  0029f	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  002a4	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  002a8	83 f8 09	 cmp	 eax, 9
  002ab	75 29		 jne	 SHORT $LN34@parse_mtl
$LN36@parse_mtl:

; 227  :                 token += 2;

  002ad	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  002b2	48 83 c0 02	 add	 rax, 2
  002b6	48 89 44 24 68	 mov	 QWORD PTR token$[rsp], rax

; 228  :                 parse_v3(mat->transmittance, &token);

  002bb	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  002c0	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  002c4	48 8d 54 24 68	 lea	 rdx, QWORD PTR token$[rsp]
  002c9	48 8b c8	 mov	 rcx, rax
  002cc	e8 00 00 00 00	 call	 ?parse_v3@@YAXPEAMPEAPEAE@Z ; parse_v3
  002d1	e9 87 00 00 00	 jmp	 $LN35@parse_mtl
$LN34@parse_mtl:

; 229  :             } else if (*token == 'e' && IS_SPACE(*(token+1))) {

  002d6	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  002db	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002de	83 f8 65	 cmp	 eax, 101		; 00000065H
  002e1	75 42		 jne	 SHORT $LN37@parse_mtl
  002e3	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  002e8	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  002ec	83 f8 20	 cmp	 eax, 32			; 00000020H
  002ef	74 0e		 je	 SHORT $LN39@parse_mtl
  002f1	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  002f6	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  002fa	83 f8 09	 cmp	 eax, 9
  002fd	75 26		 jne	 SHORT $LN37@parse_mtl
$LN39@parse_mtl:

; 230  :                 token += 2;

  002ff	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00304	48 83 c0 02	 add	 rax, 2
  00308	48 89 44 24 68	 mov	 QWORD PTR token$[rsp], rax

; 231  :                 parse_v3(mat->emission, &token);

  0030d	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  00312	48 83 c0 38	 add	 rax, 56			; 00000038H
  00316	48 8d 54 24 68	 lea	 rdx, QWORD PTR token$[rsp]
  0031b	48 8b c8	 mov	 rcx, rax
  0031e	e8 00 00 00 00	 call	 ?parse_v3@@YAXPEAMPEAPEAE@Z ; parse_v3

; 232  :             } else

  00323	eb 38		 jmp	 SHORT $LN38@parse_mtl
$LN37@parse_mtl:
$LN9@parse_mtl:

; 233  :                 LOG("Unsupported Mtl Command.");

  00325	b9 02 00 00 00	 mov	 ecx, 2
  0032a	e8 00 00 00 00	 call	 __acrt_iob_func
  0032f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG83139
  00336	48 8b c8	 mov	 rcx, rax
  00339	e8 00 00 00 00	 call	 fprintf
  0033e	b9 02 00 00 00	 mov	 ecx, 2
  00343	e8 00 00 00 00	 call	 __acrt_iob_func
  00348	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG83140
  0034f	48 8b c8	 mov	 rcx, rax
  00352	e8 00 00 00 00	 call	 fprintf
  00357	33 c0		 xor	 eax, eax
  00359	85 c0		 test	 eax, eax
  0035b	75 c8		 jne	 SHORT $LN9@parse_mtl
$LN38@parse_mtl:
$LN35@parse_mtl:
$LN32@parse_mtl:
$LN29@parse_mtl:
$LN26@parse_mtl:
  0035d	e9 a4 05 00 00	 jmp	 $LN24@parse_mtl
$LN23@parse_mtl:

; 234  :         } else if (*token == 'N') {

  00362	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00367	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0036a	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  0036d	0f 85 ef 00 00
	00		 jne	 $LN40@parse_mtl

; 235  :             token++;

  00373	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00378	48 ff c0	 inc	 rax
  0037b	48 89 44 24 68	 mov	 QWORD PTR token$[rsp], rax

; 236  :             
; 237  :             if (*token == 'i' && IS_SPACE(*(token+1))) {

  00380	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00385	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00388	83 f8 69	 cmp	 eax, 105		; 00000069H
  0038b	75 47		 jne	 SHORT $LN42@parse_mtl
  0038d	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00392	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00396	83 f8 20	 cmp	 eax, 32			; 00000020H
  00399	74 0e		 je	 SHORT $LN44@parse_mtl
  0039b	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  003a0	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  003a4	83 f8 09	 cmp	 eax, 9
  003a7	75 2b		 jne	 SHORT $LN42@parse_mtl
$LN44@parse_mtl:

; 238  :                 token += 2;

  003a9	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  003ae	48 83 c0 02	 add	 rax, 2
  003b2	48 89 44 24 68	 mov	 QWORD PTR token$[rsp], rax

; 239  :                 mat->index_of_refraction = parse_double(&token);

  003b7	48 8d 4c 24 68	 lea	 rcx, QWORD PTR token$[rsp]
  003bc	e8 00 00 00 00	 call	 ?parse_double@@YANPEAPEAE@Z ; parse_double
  003c1	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  003c5	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  003ca	f3 0f 11 40 48	 movss	 DWORD PTR [rax+72], xmm0
  003cf	e9 89 00 00 00	 jmp	 $LN43@parse_mtl
$LN42@parse_mtl:

; 240  :             } else if (*token == 's' && IS_SPACE(*(token+1))) {

  003d4	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  003d9	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003dc	83 f8 73	 cmp	 eax, 115		; 00000073H
  003df	75 44		 jne	 SHORT $LN45@parse_mtl
  003e1	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  003e6	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  003ea	83 f8 20	 cmp	 eax, 32			; 00000020H
  003ed	74 0e		 je	 SHORT $LN47@parse_mtl
  003ef	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  003f4	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  003f8	83 f8 09	 cmp	 eax, 9
  003fb	75 28		 jne	 SHORT $LN45@parse_mtl
$LN47@parse_mtl:

; 241  :                 token += 2;

  003fd	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00402	48 83 c0 02	 add	 rax, 2
  00406	48 89 44 24 68	 mov	 QWORD PTR token$[rsp], rax

; 242  :                 mat->shininess = parse_double(&token);

  0040b	48 8d 4c 24 68	 lea	 rcx, QWORD PTR token$[rsp]
  00410	e8 00 00 00 00	 call	 ?parse_double@@YANPEAPEAE@Z ; parse_double
  00415	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00419	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  0041e	f3 0f 11 40 44	 movss	 DWORD PTR [rax+68], xmm0

; 243  :             }

  00423	eb 38		 jmp	 SHORT $LN46@parse_mtl
$LN45@parse_mtl:
$LN12@parse_mtl:

; 244  :             else
; 245  :                 LOG("Unsupported Mtl Command.");

  00425	b9 02 00 00 00	 mov	 ecx, 2
  0042a	e8 00 00 00 00	 call	 __acrt_iob_func
  0042f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG83149
  00436	48 8b c8	 mov	 rcx, rax
  00439	e8 00 00 00 00	 call	 fprintf
  0043e	b9 02 00 00 00	 mov	 ecx, 2
  00443	e8 00 00 00 00	 call	 __acrt_iob_func
  00448	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG83150
  0044f	48 8b c8	 mov	 rcx, rax
  00452	e8 00 00 00 00	 call	 fprintf
  00457	33 c0		 xor	 eax, eax
  00459	85 c0		 test	 eax, eax
  0045b	75 c8		 jne	 SHORT $LN12@parse_mtl
$LN46@parse_mtl:
$LN43@parse_mtl:
  0045d	e9 a4 04 00 00	 jmp	 $LN41@parse_mtl
$LN40@parse_mtl:

; 246  :         } else if (*token == 'd' && IS_SPACE(*(token+1))) {

  00462	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00467	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0046a	83 f8 64	 cmp	 eax, 100		; 00000064H
  0046d	75 47		 jne	 SHORT $LN48@parse_mtl
  0046f	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00474	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00478	83 f8 20	 cmp	 eax, 32			; 00000020H
  0047b	74 0e		 je	 SHORT $LN50@parse_mtl
  0047d	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00482	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00486	83 f8 09	 cmp	 eax, 9
  00489	75 2b		 jne	 SHORT $LN48@parse_mtl
$LN50@parse_mtl:

; 247  :             token += 2;

  0048b	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00490	48 83 c0 02	 add	 rax, 2
  00494	48 89 44 24 68	 mov	 QWORD PTR token$[rsp], rax

; 248  :             mat->dissolve = parse_double(&token);

  00499	48 8d 4c 24 68	 lea	 rcx, QWORD PTR token$[rsp]
  0049e	e8 00 00 00 00	 call	 ?parse_double@@YANPEAPEAE@Z ; parse_double
  004a3	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  004a7	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  004ac	f3 0f 11 40 4c	 movss	 DWORD PTR [rax+76], xmm0
  004b1	e9 50 04 00 00	 jmp	 $LN49@parse_mtl
$LN48@parse_mtl:

; 249  :         } else if (*token == 'T' && *(token+1) == 'r' &&

  004b6	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  004bb	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  004be	83 f8 54	 cmp	 eax, 84			; 00000054H
  004c1	75 64		 jne	 SHORT $LN51@parse_mtl
  004c3	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  004c8	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  004cc	83 f8 72	 cmp	 eax, 114		; 00000072H
  004cf	75 56		 jne	 SHORT $LN51@parse_mtl
  004d1	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  004d6	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  004da	83 f8 20	 cmp	 eax, 32			; 00000020H
  004dd	74 0e		 je	 SHORT $LN53@parse_mtl
  004df	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  004e4	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  004e8	83 f8 09	 cmp	 eax, 9
  004eb	75 3a		 jne	 SHORT $LN51@parse_mtl
$LN53@parse_mtl:

; 250  :                    IS_SPACE(*(token+2))) {
; 251  :             token += 3;

  004ed	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  004f2	48 83 c0 03	 add	 rax, 3
  004f6	48 89 44 24 68	 mov	 QWORD PTR token$[rsp], rax

; 252  :             mat->dissolve = 1.0f - parse_double(&token);

  004fb	48 8d 4c 24 68	 lea	 rcx, QWORD PTR token$[rsp]
  00500	e8 00 00 00 00	 call	 ?parse_double@@YANPEAPEAE@Z ; parse_double
  00505	f2 0f 10 0d 00
	00 00 00	 movsd	 xmm1, QWORD PTR __real@3ff0000000000000
  0050d	f2 0f 5c c8	 subsd	 xmm1, xmm0
  00511	0f 28 c1	 movaps	 xmm0, xmm1
  00514	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00518	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  0051d	f3 0f 11 40 4c	 movss	 DWORD PTR [rax+76], xmm0
  00522	e9 df 03 00 00	 jmp	 $LN52@parse_mtl
$LN51@parse_mtl:

; 253  :         } else if ((strncmp((char *)token, "illum", 5) == 0) &&

  00527	41 b8 05 00 00
	00		 mov	 r8d, 5
  0052d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG83159
  00534	48 8b 4c 24 68	 mov	 rcx, QWORD PTR token$[rsp]
  00539	e8 00 00 00 00	 call	 strncmp
  0053e	85 c0		 test	 eax, eax
  00540	75 41		 jne	 SHORT $LN54@parse_mtl
  00542	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00547	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  0054b	83 f8 20	 cmp	 eax, 32			; 00000020H
  0054e	74 0e		 je	 SHORT $LN56@parse_mtl
  00550	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00555	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00559	83 f8 09	 cmp	 eax, 9
  0055c	75 25		 jne	 SHORT $LN54@parse_mtl
$LN56@parse_mtl:

; 254  :                    IS_SPACE(*(token+5))) {
; 255  :             token += 6;

  0055e	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00563	48 83 c0 06	 add	 rax, 6
  00567	48 89 44 24 68	 mov	 QWORD PTR token$[rsp], rax

; 256  :             mat->illum = parse_int(&token);

  0056c	48 8d 4c 24 68	 lea	 rcx, QWORD PTR token$[rsp]
  00571	e8 00 00 00 00	 call	 ?parse_int@@YAHPEAPEAE@Z ; parse_int
  00576	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mat$[rsp]
  0057b	89 41 50	 mov	 DWORD PTR [rcx+80], eax
  0057e	e9 83 03 00 00	 jmp	 $LN55@parse_mtl
$LN54@parse_mtl:

; 257  :         } else if (strncmp((char *)token, "map_", 4) == 0) {

  00583	41 b8 04 00 00
	00		 mov	 r8d, 4
  00589	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG83163
  00590	48 8b 4c 24 68	 mov	 rcx, QWORD PTR token$[rsp]
  00595	e8 00 00 00 00	 call	 strncmp
  0059a	85 c0		 test	 eax, eax
  0059c	0f 85 aa 02 00
	00		 jne	 $LN57@parse_mtl

; 258  :             token += 4;

  005a2	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  005a7	48 83 c0 04	 add	 rax, 4
  005ab	48 89 44 24 68	 mov	 QWORD PTR token$[rsp], rax

; 259  :             
; 260  :             if(*token == 'K') {

  005b0	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  005b5	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  005b8	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  005bb	0f 85 3d 01 00
	00		 jne	 $LN59@parse_mtl

; 261  :                 token++;

  005c1	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  005c6	48 ff c0	 inc	 rax
  005c9	48 89 44 24 68	 mov	 QWORD PTR token$[rsp], rax

; 262  :                 
; 263  :                 if(*token == 'a' && IS_SPACE(*(token+1))) {

  005ce	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  005d3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  005d6	83 f8 61	 cmp	 eax, 97			; 00000061H
  005d9	75 45		 jne	 SHORT $LN61@parse_mtl
  005db	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  005e0	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  005e4	83 f8 20	 cmp	 eax, 32			; 00000020H
  005e7	74 0e		 je	 SHORT $LN63@parse_mtl
  005e9	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  005ee	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  005f2	83 f8 09	 cmp	 eax, 9
  005f5	75 29		 jne	 SHORT $LN61@parse_mtl
$LN63@parse_mtl:

; 264  :                     token += 2;

  005f7	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  005fc	48 83 c0 02	 add	 rax, 2
  00600	48 89 44 24 68	 mov	 QWORD PTR token$[rsp], rax

; 265  :                     parse_name(&token, &mat->ambient_texture_name);

  00605	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  0060a	48 83 c0 58	 add	 rax, 88			; 00000058H
  0060e	48 8b d0	 mov	 rdx, rax
  00611	48 8d 4c 24 68	 lea	 rcx, QWORD PTR token$[rsp]
  00616	e8 00 00 00 00	 call	 ?parse_name@@YAIPEAPEAEPEAPEAD@Z ; parse_name
  0061b	e9 d9 00 00 00	 jmp	 $LN62@parse_mtl
$LN61@parse_mtl:

; 266  :                 } else if (*token == 'd' && IS_SPACE(*(token+1))) {

  00620	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00625	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00628	83 f8 64	 cmp	 eax, 100		; 00000064H
  0062b	75 45		 jne	 SHORT $LN64@parse_mtl
  0062d	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00632	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00636	83 f8 20	 cmp	 eax, 32			; 00000020H
  00639	74 0e		 je	 SHORT $LN66@parse_mtl
  0063b	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00640	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00644	83 f8 09	 cmp	 eax, 9
  00647	75 29		 jne	 SHORT $LN64@parse_mtl
$LN66@parse_mtl:

; 267  :                     token += 2;

  00649	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  0064e	48 83 c0 02	 add	 rax, 2
  00652	48 89 44 24 68	 mov	 QWORD PTR token$[rsp], rax

; 268  :                     parse_name(&token, &mat->diffuse_texture_name);

  00657	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  0065c	48 83 c0 60	 add	 rax, 96			; 00000060H
  00660	48 8b d0	 mov	 rdx, rax
  00663	48 8d 4c 24 68	 lea	 rcx, QWORD PTR token$[rsp]
  00668	e8 00 00 00 00	 call	 ?parse_name@@YAIPEAPEAEPEAPEAD@Z ; parse_name
  0066d	e9 87 00 00 00	 jmp	 $LN65@parse_mtl
$LN64@parse_mtl:

; 269  :                 } else if (*token == 's' && IS_SPACE(*(token+1))) {

  00672	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00677	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0067a	83 f8 73	 cmp	 eax, 115		; 00000073H
  0067d	75 42		 jne	 SHORT $LN67@parse_mtl
  0067f	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00684	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00688	83 f8 20	 cmp	 eax, 32			; 00000020H
  0068b	74 0e		 je	 SHORT $LN69@parse_mtl
  0068d	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00692	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00696	83 f8 09	 cmp	 eax, 9
  00699	75 26		 jne	 SHORT $LN67@parse_mtl
$LN69@parse_mtl:

; 270  :                     token += 2;

  0069b	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  006a0	48 83 c0 02	 add	 rax, 2
  006a4	48 89 44 24 68	 mov	 QWORD PTR token$[rsp], rax

; 271  :                     parse_name(&token, &mat->specular_texture_name);

  006a9	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  006ae	48 83 c0 68	 add	 rax, 104		; 00000068H
  006b2	48 8b d0	 mov	 rdx, rax
  006b5	48 8d 4c 24 68	 lea	 rcx, QWORD PTR token$[rsp]
  006ba	e8 00 00 00 00	 call	 ?parse_name@@YAIPEAPEAEPEAPEAD@Z ; parse_name

; 272  :                 }

  006bf	eb 38		 jmp	 SHORT $LN68@parse_mtl
$LN67@parse_mtl:
$LN15@parse_mtl:

; 273  :                 else
; 274  :                     LOG("Unsupported Mtl Command.");

  006c1	b9 02 00 00 00	 mov	 ecx, 2
  006c6	e8 00 00 00 00	 call	 __acrt_iob_func
  006cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG83175
  006d2	48 8b c8	 mov	 rcx, rax
  006d5	e8 00 00 00 00	 call	 fprintf
  006da	b9 02 00 00 00	 mov	 ecx, 2
  006df	e8 00 00 00 00	 call	 __acrt_iob_func
  006e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG83176
  006eb	48 8b c8	 mov	 rcx, rax
  006ee	e8 00 00 00 00	 call	 fprintf
  006f3	33 c0		 xor	 eax, eax
  006f5	85 c0		 test	 eax, eax
  006f7	75 c8		 jne	 SHORT $LN15@parse_mtl
$LN68@parse_mtl:
$LN65@parse_mtl:
$LN62@parse_mtl:
  006f9	e9 49 01 00 00	 jmp	 $LN60@parse_mtl
$LN59@parse_mtl:

; 275  :             } else if (*token == 'N' && *(token+1) == 's' &&

  006fe	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00703	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00706	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  00709	75 53		 jne	 SHORT $LN70@parse_mtl
  0070b	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00710	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00714	83 f8 73	 cmp	 eax, 115		; 00000073H
  00717	75 45		 jne	 SHORT $LN70@parse_mtl
  00719	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  0071e	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00722	83 f8 20	 cmp	 eax, 32			; 00000020H
  00725	74 0e		 je	 SHORT $LN72@parse_mtl
  00727	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  0072c	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00730	83 f8 09	 cmp	 eax, 9
  00733	75 29		 jne	 SHORT $LN70@parse_mtl
$LN72@parse_mtl:

; 276  :                        IS_SPACE(*(token+2))) {
; 277  :                 token += 3;

  00735	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  0073a	48 83 c0 03	 add	 rax, 3
  0073e	48 89 44 24 68	 mov	 QWORD PTR token$[rsp], rax

; 278  :                 parse_name(&token, &mat->specular_highlight_texture_name);

  00743	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  00748	48 83 c0 70	 add	 rax, 112		; 00000070H
  0074c	48 8b d0	 mov	 rdx, rax
  0074f	48 8d 4c 24 68	 lea	 rcx, QWORD PTR token$[rsp]
  00754	e8 00 00 00 00	 call	 ?parse_name@@YAIPEAPEAEPEAPEAD@Z ; parse_name
  00759	e9 e9 00 00 00	 jmp	 $LN71@parse_mtl
$LN70@parse_mtl:

; 279  :             } else if ((strncmp((char *)token, "Bump", 4) == 0) && 

  0075e	41 b8 04 00 00
	00		 mov	 r8d, 4
  00764	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG83182
  0076b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR token$[rsp]
  00770	e8 00 00 00 00	 call	 strncmp
  00775	85 c0		 test	 eax, eax
  00777	75 45		 jne	 SHORT $LN73@parse_mtl
  00779	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  0077e	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00782	83 f8 20	 cmp	 eax, 32			; 00000020H
  00785	74 0e		 je	 SHORT $LN75@parse_mtl
  00787	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  0078c	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00790	83 f8 09	 cmp	 eax, 9
  00793	75 29		 jne	 SHORT $LN73@parse_mtl
$LN75@parse_mtl:

; 280  :                        IS_SPACE(*(token+4))) {
; 281  :                 token += 5;

  00795	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  0079a	48 83 c0 05	 add	 rax, 5
  0079e	48 89 44 24 68	 mov	 QWORD PTR token$[rsp], rax

; 282  :                 parse_name(&token, &mat->bump_texture_name);

  007a3	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  007a8	48 83 c0 78	 add	 rax, 120		; 00000078H
  007ac	48 8b d0	 mov	 rdx, rax
  007af	48 8d 4c 24 68	 lea	 rcx, QWORD PTR token$[rsp]
  007b4	e8 00 00 00 00	 call	 ?parse_name@@YAIPEAPEAEPEAPEAD@Z ; parse_name
  007b9	e9 89 00 00 00	 jmp	 $LN74@parse_mtl
$LN73@parse_mtl:

; 283  :             } else if (*token == 'd' && IS_SPACE(*(token+1))) {

  007be	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  007c3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  007c6	83 f8 64	 cmp	 eax, 100		; 00000064H
  007c9	75 44		 jne	 SHORT $LN76@parse_mtl
  007cb	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  007d0	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  007d4	83 f8 20	 cmp	 eax, 32			; 00000020H
  007d7	74 0e		 je	 SHORT $LN78@parse_mtl
  007d9	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  007de	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  007e2	83 f8 09	 cmp	 eax, 9
  007e5	75 28		 jne	 SHORT $LN76@parse_mtl
$LN78@parse_mtl:

; 284  :                 token += 2;

  007e7	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  007ec	48 83 c0 02	 add	 rax, 2
  007f0	48 89 44 24 68	 mov	 QWORD PTR token$[rsp], rax

; 285  :                 parse_name(&token, &mat->alpha_texture_name);

  007f5	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  007fa	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  00800	48 8b d0	 mov	 rdx, rax
  00803	48 8d 4c 24 68	 lea	 rcx, QWORD PTR token$[rsp]
  00808	e8 00 00 00 00	 call	 ?parse_name@@YAIPEAPEAEPEAPEAD@Z ; parse_name

; 286  :             }

  0080d	eb 38		 jmp	 SHORT $LN77@parse_mtl
$LN76@parse_mtl:
$LN18@parse_mtl:

; 287  :             else
; 288  :                 LOG("Unsupported Mtl Command.");

  0080f	b9 02 00 00 00	 mov	 ecx, 2
  00814	e8 00 00 00 00	 call	 __acrt_iob_func
  00819	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG83187
  00820	48 8b c8	 mov	 rcx, rax
  00823	e8 00 00 00 00	 call	 fprintf
  00828	b9 02 00 00 00	 mov	 ecx, 2
  0082d	e8 00 00 00 00	 call	 __acrt_iob_func
  00832	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG83188
  00839	48 8b c8	 mov	 rcx, rax
  0083c	e8 00 00 00 00	 call	 fprintf
  00841	33 c0		 xor	 eax, eax
  00843	85 c0		 test	 eax, eax
  00845	75 c8		 jne	 SHORT $LN18@parse_mtl
$LN77@parse_mtl:
$LN74@parse_mtl:
$LN71@parse_mtl:
$LN60@parse_mtl:
  00847	e9 ba 00 00 00	 jmp	 $LN58@parse_mtl
$LN57@parse_mtl:

; 289  :         } else if ((strncmp((char *)token, "bump", 4) == 0) &&

  0084c	41 b8 04 00 00
	00		 mov	 r8d, 4
  00852	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG83191
  00859	48 8b 4c 24 68	 mov	 rcx, QWORD PTR token$[rsp]
  0085e	e8 00 00 00 00	 call	 strncmp
  00863	85 c0		 test	 eax, eax
  00865	75 42		 jne	 SHORT $LN79@parse_mtl
  00867	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  0086c	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00870	83 f8 20	 cmp	 eax, 32			; 00000020H
  00873	74 0e		 je	 SHORT $LN81@parse_mtl
  00875	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  0087a	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  0087e	83 f8 09	 cmp	 eax, 9
  00881	75 26		 jne	 SHORT $LN79@parse_mtl
$LN81@parse_mtl:

; 290  :                    IS_SPACE(*(token+4))) {
; 291  :             token += 5;

  00883	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00888	48 83 c0 05	 add	 rax, 5
  0088c	48 89 44 24 68	 mov	 QWORD PTR token$[rsp], rax

; 292  :             parse_name(&token, &mat->bump_texture_name);

  00891	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  00896	48 83 c0 78	 add	 rax, 120		; 00000078H
  0089a	48 8b d0	 mov	 rdx, rax
  0089d	48 8d 4c 24 68	 lea	 rcx, QWORD PTR token$[rsp]
  008a2	e8 00 00 00 00	 call	 ?parse_name@@YAIPEAPEAEPEAPEAD@Z ; parse_name
  008a7	eb 5d		 jmp	 SHORT $LN80@parse_mtl
$LN79@parse_mtl:

; 293  :         } else if ((strncmp((char *)token, "disp", 4) == 0) &&

  008a9	41 b8 04 00 00
	00		 mov	 r8d, 4
  008af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG83194
  008b6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR token$[rsp]
  008bb	e8 00 00 00 00	 call	 strncmp
  008c0	85 c0		 test	 eax, eax
  008c2	75 42		 jne	 SHORT $LN82@parse_mtl
  008c4	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  008c9	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  008cd	83 f8 20	 cmp	 eax, 32			; 00000020H
  008d0	74 0e		 je	 SHORT $LN83@parse_mtl
  008d2	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  008d7	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  008db	83 f8 09	 cmp	 eax, 9
  008de	75 26		 jne	 SHORT $LN82@parse_mtl
$LN83@parse_mtl:

; 294  :                    IS_SPACE(*(token+4))) {
; 295  :             token += 5;

  008e0	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  008e5	48 83 c0 05	 add	 rax, 5
  008e9	48 89 44 24 68	 mov	 QWORD PTR token$[rsp], rax

; 296  :             parse_name(&token, &mat->displacement_texture_name);

  008ee	48 8b 44 24 38	 mov	 rax, QWORD PTR mat$[rsp]
  008f3	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  008f9	48 8b d0	 mov	 rdx, rax
  008fc	48 8d 4c 24 68	 lea	 rcx, QWORD PTR token$[rsp]
  00901	e8 00 00 00 00	 call	 ?parse_name@@YAIPEAPEAEPEAPEAD@Z ; parse_name
$LN82@parse_mtl:
$LN80@parse_mtl:
$LN58@parse_mtl:
$LN55@parse_mtl:
$LN52@parse_mtl:
$LN49@parse_mtl:
$LN41@parse_mtl:
$LN24@parse_mtl:
$LN20@parse_mtl:

; 297  :         }
; 298  :         
; 299  :         skip_to_new_line(&token);

  00906	48 8d 4c 24 68	 lea	 rcx, QWORD PTR token$[rsp]
  0090b	e8 00 00 00 00	 call	 ?skip_to_new_line@@YAXPEAPEAE@Z ; skip_to_new_line

; 300  :         token++;

  00910	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  00915	48 ff c0	 inc	 rax
  00918	48 89 44 24 68	 mov	 QWORD PTR token$[rsp], rax

; 301  :     }

  0091d	e9 f5 f6 ff ff	 jmp	 $LN2@parse_mtl
$LN3@parse_mtl:

; 302  : }

  00922	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00926	c3		 ret	 0
?parse_mtl@@YAXPEAUobj_info_t@@PEAE@Z ENDP		; parse_mtl
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\obj_loader.cpp
_TEXT	SEGMENT
material$ = 48
?init_obj_material@@YAXPEAUobj_mat_t@@@Z PROC		; init_obj_material

; 183  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 184  :     memset(material, 0, sizeof(*material));

  00009	41 b8 90 00 00
	00		 mov	 r8d, 144		; 00000090H
  0000f	33 d2		 xor	 edx, edx
  00011	48 8b 4c 24 30	 mov	 rcx, QWORD PTR material$[rsp]
  00016	e8 00 00 00 00	 call	 memset

; 185  :     
; 186  :     material->dissolve = 1.0f;

  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR material$[rsp]
  00020	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00028	f3 0f 11 40 4c	 movss	 DWORD PTR [rax+76], xmm0

; 187  :     material->shininess = 1.0f;

  0002d	48 8b 44 24 30	 mov	 rax, QWORD PTR material$[rsp]
  00032	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0003a	f3 0f 11 40 44	 movss	 DWORD PTR [rax+68], xmm0

; 188  :     material->index_of_refraction = 1.0f;

  0003f	48 8b 44 24 30	 mov	 rax, QWORD PTR material$[rsp]
  00044	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0004c	f3 0f 11 40 48	 movss	 DWORD PTR [rax+72], xmm0

; 189  : }

  00051	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00055	c3		 ret	 0
?init_obj_material@@YAXPEAUobj_mat_t@@@Z ENDP		; init_obj_material
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\obj_loader.cpp
_TEXT	SEGMENT
idx_offset$ = 32
obj$ = 40
face_count$1 = 48
is_gen_norms$2 = 52
v$ = 56
vn$ = 64
vt$ = 72
idx$ = 80
$T3 = 88
$T4 = 104
$T5 = 120
$T6 = 136
$T7 = 152
$T8 = 168
i$9 = 184
__$ArrayPad$ = 224
info$ = 272
token$ = 280
out_mtl_name$ = 288
?parse_obj@@YAXPEAUobj_info_t@@PEAEPEAPEAD@Z PROC	; parse_obj

; 100  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 101  :     obj_t *obj = NULL;

  0002a	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR obj$[rsp], 0

; 102  :     f32 *v, *vn, *vt;
; 103  :     vert_idx_t *idx;
; 104  :     
; 105  :     u32 idx_offset = 0;

  00033	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR idx_offset$[rsp], 0

; 106  :     *out_mtl_name = NULL;

  0003b	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR out_mtl_name$[rsp]
  00043	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN2@parse_obj:

; 107  :     
; 108  :     while(*token) {

  0004a	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  00052	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00055	85 c0		 test	 eax, eax
  00057	0f 84 bf 05 00
	00		 je	 $LN3@parse_obj

; 109  :         if((*token == 'o' || *token == 'g') && IS_SPACE(*(token+1))) {

  0005d	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  00065	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00068	83 f8 6f	 cmp	 eax, 111		; 0000006fH
  0006b	74 14		 je	 SHORT $LN11@parse_obj
  0006d	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  00075	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00078	83 f8 67	 cmp	 eax, 103		; 00000067H
  0007b	0f 85 a0 00 00
	00		 jne	 $LN9@parse_obj
$LN11@parse_obj:
  00081	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  00089	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0008d	83 f8 20	 cmp	 eax, 32			; 00000020H
  00090	74 11		 je	 SHORT $LN12@parse_obj
  00092	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  0009a	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0009e	83 f8 09	 cmp	 eax, 9
  000a1	75 7e		 jne	 SHORT $LN9@parse_obj
$LN12@parse_obj:

; 110  :             token += 2;

  000a3	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  000ab	48 83 c0 02	 add	 rax, 2
  000af	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR token$[rsp], rax

; 111  :             
; 112  :             if(obj)

  000b7	48 83 7c 24 28
	00		 cmp	 QWORD PTR obj$[rsp], 0
  000bd	74 18		 je	 SHORT $LN13@parse_obj

; 113  :                 obj->idx_count = idx_offset - obj->idx_offset;

  000bf	48 8b 44 24 28	 mov	 rax, QWORD PTR obj$[rsp]
  000c4	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000c7	8b 4c 24 20	 mov	 ecx, DWORD PTR idx_offset$[rsp]
  000cb	2b c8		 sub	 ecx, eax
  000cd	8b c1		 mov	 eax, ecx
  000cf	48 8b 4c 24 28	 mov	 rcx, QWORD PTR obj$[rsp]
  000d4	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN13@parse_obj:

; 114  :             
; 115  :             obj = (obj_t *)stack_push(&info->objs);

  000d7	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR info$[rsp]
  000df	48 83 c0 08	 add	 rax, 8
  000e3	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  000e9	ba 01 00 00 00	 mov	 edx, 1
  000ee	48 8b c8	 mov	 rcx, rax
  000f1	e8 00 00 00 00	 call	 ?_stack_push@@YAPEAXPEAPEAXII@Z ; _stack_push
  000f6	48 89 44 24 28	 mov	 QWORD PTR obj$[rsp], rax

; 116  :             obj->idx_offset = idx_offset;

  000fb	48 8b 44 24 28	 mov	 rax, QWORD PTR obj$[rsp]
  00100	8b 4c 24 20	 mov	 ecx, DWORD PTR idx_offset$[rsp]
  00104	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 117  :             parse_name(&token, &obj->name);

  00107	48 8b 44 24 28	 mov	 rax, QWORD PTR obj$[rsp]
  0010c	48 8b d0	 mov	 rdx, rax
  0010f	48 8d 8c 24 18
	01 00 00	 lea	 rcx, QWORD PTR token$[rsp]
  00117	e8 00 00 00 00	 call	 ?parse_name@@YAIPEAPEAEPEAPEAD@Z ; parse_name
  0011c	e9 d6 04 00 00	 jmp	 $LN10@parse_obj
$LN9@parse_obj:

; 118  :         } else if(*token == 'v') {

  00121	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  00129	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0012c	83 f8 76	 cmp	 eax, 118		; 00000076H
  0012f	0f 85 c2 01 00
	00		 jne	 $LN14@parse_obj

; 119  :             token++;

  00135	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  0013d	48 ff c0	 inc	 rax
  00140	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR token$[rsp], rax

; 120  :             
; 121  :             if(IS_SPACE(*token)) {

  00148	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  00150	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00153	83 f8 20	 cmp	 eax, 32			; 00000020H
  00156	74 10		 je	 SHORT $LN18@parse_obj
  00158	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  00160	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00163	83 f8 09	 cmp	 eax, 9
  00166	75 4e		 jne	 SHORT $LN16@parse_obj
$LN18@parse_obj:

; 122  :                 token++;

  00168	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  00170	48 ff c0	 inc	 rax
  00173	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR token$[rsp], rax

; 123  :                 v = (f32 *)stack_push_array(&info->v, 3);

  0017b	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00183	48 83 c0 18	 add	 rax, 24
  00187	41 b8 04 00 00
	00		 mov	 r8d, 4
  0018d	ba 03 00 00 00	 mov	 edx, 3
  00192	48 8b c8	 mov	 rcx, rax
  00195	e8 00 00 00 00	 call	 ?_stack_push@@YAPEAXPEAPEAXII@Z ; _stack_push
  0019a	48 89 44 24 38	 mov	 QWORD PTR v$[rsp], rax

; 124  :                 parse_v3(v, &token);

  0019f	48 8d 94 24 18
	01 00 00	 lea	 rdx, QWORD PTR token$[rsp]
  001a7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR v$[rsp]
  001ac	e8 00 00 00 00	 call	 ?parse_v3@@YAXPEAMPEAPEAE@Z ; parse_v3

; 125  :             }

  001b1	e9 3c 01 00 00	 jmp	 $LN17@parse_obj
$LN16@parse_obj:

; 126  :             else if(*token == 'n' && IS_SPACE(*(token+1))) {

  001b6	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  001be	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001c1	83 f8 6e	 cmp	 eax, 110		; 0000006eH
  001c4	75 71		 jne	 SHORT $LN19@parse_obj
  001c6	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  001ce	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001d2	83 f8 20	 cmp	 eax, 32			; 00000020H
  001d5	74 11		 je	 SHORT $LN21@parse_obj
  001d7	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  001df	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001e3	83 f8 09	 cmp	 eax, 9
  001e6	75 4f		 jne	 SHORT $LN19@parse_obj
$LN21@parse_obj:

; 127  :                 token += 2;

  001e8	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  001f0	48 83 c0 02	 add	 rax, 2
  001f4	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR token$[rsp], rax

; 128  :                 vn = (f32 *)stack_push_array(&info->vn, 3);

  001fc	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00204	48 83 c0 20	 add	 rax, 32			; 00000020H
  00208	41 b8 04 00 00
	00		 mov	 r8d, 4
  0020e	ba 03 00 00 00	 mov	 edx, 3
  00213	48 8b c8	 mov	 rcx, rax
  00216	e8 00 00 00 00	 call	 ?_stack_push@@YAPEAXPEAPEAXII@Z ; _stack_push
  0021b	48 89 44 24 40	 mov	 QWORD PTR vn$[rsp], rax

; 129  :                 parse_v3(vn, &token);

  00220	48 8d 94 24 18
	01 00 00	 lea	 rdx, QWORD PTR token$[rsp]
  00228	48 8b 4c 24 40	 mov	 rcx, QWORD PTR vn$[rsp]
  0022d	e8 00 00 00 00	 call	 ?parse_v3@@YAXPEAMPEAPEAE@Z ; parse_v3

; 130  :             }

  00232	e9 bb 00 00 00	 jmp	 $LN20@parse_obj
$LN19@parse_obj:

; 131  :             else if(*token == 't' && IS_SPACE(*(token+1))) {

  00237	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  0023f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00242	83 f8 74	 cmp	 eax, 116		; 00000074H
  00245	75 6e		 jne	 SHORT $LN22@parse_obj
  00247	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  0024f	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00253	83 f8 20	 cmp	 eax, 32			; 00000020H
  00256	74 11		 je	 SHORT $LN24@parse_obj
  00258	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  00260	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00264	83 f8 09	 cmp	 eax, 9
  00267	75 4c		 jne	 SHORT $LN22@parse_obj
$LN24@parse_obj:

; 132  :                 token += 2;

  00269	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  00271	48 83 c0 02	 add	 rax, 2
  00275	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR token$[rsp], rax

; 133  :                 vt = (f32 *)stack_push_array(&info->vt, 2);

  0027d	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR info$[rsp]
  00285	48 83 c0 28	 add	 rax, 40			; 00000028H
  00289	41 b8 04 00 00
	00		 mov	 r8d, 4
  0028f	ba 02 00 00 00	 mov	 edx, 2
  00294	48 8b c8	 mov	 rcx, rax
  00297	e8 00 00 00 00	 call	 ?_stack_push@@YAPEAXPEAPEAXII@Z ; _stack_push
  0029c	48 89 44 24 48	 mov	 QWORD PTR vt$[rsp], rax

; 134  :                 parse_v2(vt, &token);

  002a1	48 8d 94 24 18
	01 00 00	 lea	 rdx, QWORD PTR token$[rsp]
  002a9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR vt$[rsp]
  002ae	e8 00 00 00 00	 call	 ?parse_v2@@YAXPEAMPEAPEAE@Z ; parse_v2

; 135  :             }

  002b3	eb 3d		 jmp	 SHORT $LN23@parse_obj
$LN22@parse_obj:
$LN6@parse_obj:

; 136  :             else
; 137  :                 ASSERT(0, "Unsupported Obj Command.");

  002b5	33 c0		 xor	 eax, eax
  002b7	83 f8 01	 cmp	 eax, 1
  002ba	74 30		 je	 SHORT $LN25@parse_obj
  002bc	b9 02 00 00 00	 mov	 ecx, 2
  002c1	e8 00 00 00 00	 call	 __acrt_iob_func
  002c6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG83062
  002cd	41 b8 89 00 00
	00		 mov	 r8d, 137		; 00000089H
  002d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG83063
  002da	48 8b c8	 mov	 rcx, rax
  002dd	e8 00 00 00 00	 call	 fprintf
  002e2	b9 01 00 00 00	 mov	 ecx, 1
  002e7	e8 00 00 00 00	 call	 exit
$LN25@parse_obj:
  002ec	33 c0		 xor	 eax, eax
  002ee	85 c0		 test	 eax, eax
  002f0	75 c3		 jne	 SHORT $LN6@parse_obj
$LN23@parse_obj:
$LN20@parse_obj:
$LN17@parse_obj:
  002f2	e9 00 03 00 00	 jmp	 $LN15@parse_obj
$LN14@parse_obj:

; 138  :         } else if (*token == 'f' && IS_SPACE(*(token+1))) {

  002f7	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  002ff	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00302	83 f8 66	 cmp	 eax, 102		; 00000066H
  00305	0f 85 14 02 00
	00		 jne	 $LN26@parse_obj
  0030b	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  00313	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00317	83 f8 20	 cmp	 eax, 32			; 00000020H
  0031a	74 15		 je	 SHORT $LN28@parse_obj
  0031c	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  00324	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00328	83 f8 09	 cmp	 eax, 9
  0032b	0f 85 ee 01 00
	00		 jne	 $LN26@parse_obj
$LN28@parse_obj:

; 139  :             token += 2;

  00331	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  00339	48 83 c0 02	 add	 rax, 2
  0033d	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR token$[rsp], rax

; 140  :             
; 141  :             u32 face_count = 0;

  00345	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR face_count$1[rsp], 0

; 142  :             vert_idx_t i[3];
; 143  :             i[0] = parse_indices(&token);

  0034d	48 8d 94 24 18
	01 00 00	 lea	 rdx, QWORD PTR token$[rsp]
  00355	48 8d 4c 24 58	 lea	 rcx, QWORD PTR $T3[rsp]
  0035a	e8 00 00 00 00	 call	 ?parse_indices@@YA?ATvert_idx_t@@PEAPEAE@Z ; parse_indices
  0035f	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR $T6[rsp]
  00367	48 8b f9	 mov	 rdi, rcx
  0036a	48 8b f0	 mov	 rsi, rax
  0036d	b9 0c 00 00 00	 mov	 ecx, 12
  00372	f3 a4		 rep movsb
  00374	b8 0c 00 00 00	 mov	 eax, 12
  00379	48 6b c0 00	 imul	 rax, rax, 0
  0037d	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR $T6[rsp]
  00385	48 8d bc 04 b8
	00 00 00	 lea	 rdi, QWORD PTR i$9[rsp+rax]
  0038d	48 8b f1	 mov	 rsi, rcx
  00390	b9 0c 00 00 00	 mov	 ecx, 12
  00395	f3 a4		 rep movsb

; 144  :             skip_space_and_cr(&token);

  00397	48 8d 8c 24 18
	01 00 00	 lea	 rcx, QWORD PTR token$[rsp]
  0039f	e8 00 00 00 00	 call	 ?skip_space_and_cr@@YAXPEAPEAE@Z ; skip_space_and_cr

; 145  :             i[2] = parse_indices(&token);

  003a4	48 8d 94 24 18
	01 00 00	 lea	 rdx, QWORD PTR token$[rsp]
  003ac	48 8d 4c 24 68	 lea	 rcx, QWORD PTR $T4[rsp]
  003b1	e8 00 00 00 00	 call	 ?parse_indices@@YA?ATvert_idx_t@@PEAPEAE@Z ; parse_indices
  003b6	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR $T7[rsp]
  003be	48 8b f9	 mov	 rdi, rcx
  003c1	48 8b f0	 mov	 rsi, rax
  003c4	b9 0c 00 00 00	 mov	 ecx, 12
  003c9	f3 a4		 rep movsb
  003cb	b8 0c 00 00 00	 mov	 eax, 12
  003d0	48 6b c0 02	 imul	 rax, rax, 2
  003d4	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR $T7[rsp]
  003dc	48 8d bc 04 b8
	00 00 00	 lea	 rdi, QWORD PTR i$9[rsp+rax]
  003e4	48 8b f1	 mov	 rsi, rcx
  003e7	b9 0c 00 00 00	 mov	 ecx, 12
  003ec	f3 a4		 rep movsb

; 146  :             skip_space_and_cr(&token);

  003ee	48 8d 8c 24 18
	01 00 00	 lea	 rcx, QWORD PTR token$[rsp]
  003f6	e8 00 00 00 00	 call	 ?skip_space_and_cr@@YAXPEAPEAE@Z ; skip_space_and_cr

; 147  :             
; 148  :             // NOTE(ajeej): generate normals
; 149  :             v3 n;
; 150  :             u32 is_gen_norms = 0;

  003fb	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR is_gen_norms$2[rsp], 0
$LN7@parse_obj:

; 151  :             
; 152  :             while(!IS_NEW_LINE(*token)) {

  00403	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  0040b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0040e	83 f8 0d	 cmp	 eax, 13
  00411	0f 84 f2 00 00
	00		 je	 $LN8@parse_obj
  00417	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  0041f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00422	83 f8 0a	 cmp	 eax, 10
  00425	0f 84 de 00 00
	00		 je	 $LN8@parse_obj
  0042b	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  00433	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00436	85 c0		 test	 eax, eax
  00438	0f 84 cb 00 00
	00		 je	 $LN8@parse_obj

; 153  :                 i[1] = i[2];

  0043e	b8 0c 00 00 00	 mov	 eax, 12
  00443	48 6b c0 02	 imul	 rax, rax, 2
  00447	b9 0c 00 00 00	 mov	 ecx, 12
  0044c	48 6b c9 01	 imul	 rcx, rcx, 1
  00450	48 8d bc 0c b8
	00 00 00	 lea	 rdi, QWORD PTR i$9[rsp+rcx]
  00458	48 8d b4 04 b8
	00 00 00	 lea	 rsi, QWORD PTR i$9[rsp+rax]
  00460	b9 0c 00 00 00	 mov	 ecx, 12
  00465	f3 a4		 rep movsb

; 154  :                 i[2] = parse_indices(&token);

  00467	48 8d 94 24 18
	01 00 00	 lea	 rdx, QWORD PTR token$[rsp]
  0046f	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T5[rsp]
  00474	e8 00 00 00 00	 call	 ?parse_indices@@YA?ATvert_idx_t@@PEAPEAE@Z ; parse_indices
  00479	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR $T8[rsp]
  00481	48 8b f9	 mov	 rdi, rcx
  00484	48 8b f0	 mov	 rsi, rax
  00487	b9 0c 00 00 00	 mov	 ecx, 12
  0048c	f3 a4		 rep movsb
  0048e	b8 0c 00 00 00	 mov	 eax, 12
  00493	48 6b c0 02	 imul	 rax, rax, 2
  00497	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR $T8[rsp]
  0049f	48 8d bc 04 b8
	00 00 00	 lea	 rdi, QWORD PTR i$9[rsp+rax]
  004a7	48 8b f1	 mov	 rsi, rcx
  004aa	b9 0c 00 00 00	 mov	 ecx, 12
  004af	f3 a4		 rep movsb

; 155  :                 skip_space_and_cr(&token);

  004b1	48 8d 8c 24 18
	01 00 00	 lea	 rcx, QWORD PTR token$[rsp]
  004b9	e8 00 00 00 00	 call	 ?skip_space_and_cr@@YAXPEAPEAE@Z ; skip_space_and_cr

; 156  :                 
; 157  :                 idx = (vert_idx_t *)stack_push_array(&info->v_idx, 3);

  004be	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR info$[rsp]
  004c6	48 83 c0 30	 add	 rax, 48			; 00000030H
  004ca	41 b8 0c 00 00
	00		 mov	 r8d, 12
  004d0	ba 03 00 00 00	 mov	 edx, 3
  004d5	48 8b c8	 mov	 rcx, rax
  004d8	e8 00 00 00 00	 call	 ?_stack_push@@YAPEAXPEAPEAXII@Z ; _stack_push
  004dd	48 89 44 24 50	 mov	 QWORD PTR idx$[rsp], rax

; 158  :                 memcpy(idx, i, sizeof(*i)*3);

  004e2	41 b8 24 00 00
	00		 mov	 r8d, 36			; 00000024H
  004e8	48 8d 94 24 b8
	00 00 00	 lea	 rdx, QWORD PTR i$9[rsp]
  004f0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR idx$[rsp]
  004f5	e8 00 00 00 00	 call	 memcpy

; 159  :                 face_count++;

  004fa	8b 44 24 30	 mov	 eax, DWORD PTR face_count$1[rsp]
  004fe	ff c0		 inc	 eax
  00500	89 44 24 30	 mov	 DWORD PTR face_count$1[rsp], eax

; 160  :             }

  00504	e9 fa fe ff ff	 jmp	 $LN7@parse_obj
$LN8@parse_obj:

; 161  :             
; 162  :             idx_offset += face_count*3;

  00509	6b 44 24 30 03	 imul	 eax, DWORD PTR face_count$1[rsp], 3
  0050e	8b 4c 24 20	 mov	 ecx, DWORD PTR idx_offset$[rsp]
  00512	03 c8		 add	 ecx, eax
  00514	8b c1		 mov	 eax, ecx
  00516	89 44 24 20	 mov	 DWORD PTR idx_offset$[rsp], eax
  0051a	e9 d8 00 00 00	 jmp	 $LN27@parse_obj
$LN26@parse_obj:

; 163  :         } else if ((strncmp((char *)token, "usemtl", 6) == 0) &&

  0051f	41 b8 06 00 00
	00		 mov	 r8d, 6
  00525	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG83069
  0052c	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR token$[rsp]
  00534	e8 00 00 00 00	 call	 strncmp
  00539	85 c0		 test	 eax, eax
  0053b	75 51		 jne	 SHORT $LN29@parse_obj
  0053d	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  00545	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  00549	83 f8 20	 cmp	 eax, 32			; 00000020H
  0054c	74 11		 je	 SHORT $LN31@parse_obj
  0054e	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  00556	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  0055a	83 f8 09	 cmp	 eax, 9
  0055d	75 2f		 jne	 SHORT $LN29@parse_obj
$LN31@parse_obj:

; 164  :                    IS_SPACE(*(token+6))) {
; 165  :             token += 7;

  0055f	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  00567	48 83 c0 07	 add	 rax, 7
  0056b	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR token$[rsp], rax

; 166  :             
; 167  :             parse_name(&token, &obj->mat_name);

  00573	48 8b 44 24 28	 mov	 rax, QWORD PTR obj$[rsp]
  00578	48 83 c0 08	 add	 rax, 8
  0057c	48 8b d0	 mov	 rdx, rax
  0057f	48 8d 8c 24 18
	01 00 00	 lea	 rcx, QWORD PTR token$[rsp]
  00587	e8 00 00 00 00	 call	 ?parse_name@@YAIPEAPEAEPEAPEAD@Z ; parse_name
  0058c	eb 69		 jmp	 SHORT $LN30@parse_obj
$LN29@parse_obj:

; 168  :         } else if ((strncmp((char *)token, "mtllib", 6) == 0) &&

  0058e	41 b8 06 00 00
	00		 mov	 r8d, 6
  00594	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG83072
  0059b	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR token$[rsp]
  005a3	e8 00 00 00 00	 call	 strncmp
  005a8	85 c0		 test	 eax, eax
  005aa	75 4b		 jne	 SHORT $LN32@parse_obj
  005ac	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  005b4	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  005b8	83 f8 20	 cmp	 eax, 32			; 00000020H
  005bb	74 11		 je	 SHORT $LN33@parse_obj
  005bd	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  005c5	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  005c9	83 f8 09	 cmp	 eax, 9
  005cc	75 29		 jne	 SHORT $LN32@parse_obj
$LN33@parse_obj:

; 169  :                    IS_SPACE(*(token+6))) {
; 170  :             token += 7;

  005ce	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  005d6	48 83 c0 07	 add	 rax, 7
  005da	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR token$[rsp], rax

; 171  :             parse_name(&token, out_mtl_name);

  005e2	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR out_mtl_name$[rsp]
  005ea	48 8d 8c 24 18
	01 00 00	 lea	 rcx, QWORD PTR token$[rsp]
  005f2	e8 00 00 00 00	 call	 ?parse_name@@YAIPEAPEAEPEAPEAD@Z ; parse_name
$LN32@parse_obj:
$LN30@parse_obj:
$LN27@parse_obj:
$LN15@parse_obj:
$LN10@parse_obj:

; 172  :         }
; 173  :         
; 174  :         skip_to_new_line(&token);

  005f7	48 8d 8c 24 18
	01 00 00	 lea	 rcx, QWORD PTR token$[rsp]
  005ff	e8 00 00 00 00	 call	 ?skip_to_new_line@@YAXPEAPEAE@Z ; skip_to_new_line

; 175  :         token++;

  00604	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR token$[rsp]
  0060c	48 ff c0	 inc	 rax
  0060f	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR token$[rsp], rax

; 176  :     }

  00617	e9 2e fa ff ff	 jmp	 $LN2@parse_obj
$LN3@parse_obj:

; 177  :     
; 178  :     obj->idx_count = idx_offset - obj->idx_offset;

  0061c	48 8b 44 24 28	 mov	 rax, QWORD PTR obj$[rsp]
  00621	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00624	8b 4c 24 20	 mov	 ecx, DWORD PTR idx_offset$[rsp]
  00628	2b c8		 sub	 ecx, eax
  0062a	8b c1		 mov	 eax, ecx
  0062c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR obj$[rsp]
  00631	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN34@parse_obj:

; 179  : }

  00634	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0063c	48 33 cc	 xor	 rcx, rsp
  0063f	e8 00 00 00 00	 call	 __security_check_cookie
  00644	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  0064b	5f		 pop	 rdi
  0064c	5e		 pop	 rsi
  0064d	c3		 ret	 0
?parse_obj@@YAXPEAUobj_info_t@@PEAEPEAPEAD@Z ENDP	; parse_obj
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\obj_loader.cpp
_TEXT	SEGMENT
length$ = 32
name$ = 40
start$ = 48
token$ = 80
out_name$ = 88
?parse_name@@YAIPEAPEAEPEAPEAD@Z PROC			; parse_name

; 80   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 81   :     char *name;
; 82   :     u32 length = 0; u8 *start = *token;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR length$[rsp], 0
  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  0001b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001e	48 89 44 24 30	 mov	 QWORD PTR start$[rsp], rax
$LN2@parse_name:

; 83   :     while(!IS_NEW_LINE(**token))

  00023	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  00028	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002e	83 f8 0d	 cmp	 eax, 13
  00031	74 34		 je	 SHORT $LN3@parse_name
  00033	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  00038	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003e	83 f8 0a	 cmp	 eax, 10
  00041	74 24		 je	 SHORT $LN3@parse_name
  00043	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  00048	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0004e	85 c0		 test	 eax, eax
  00050	74 15		 je	 SHORT $LN3@parse_name

; 84   :         (*token)++;

  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  00057	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005a	48 ff c0	 inc	 rax
  0005d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR token$[rsp]
  00062	48 89 01	 mov	 QWORD PTR [rcx], rax
  00065	eb bc		 jmp	 SHORT $LN2@parse_name
$LN3@parse_name:

; 85   :     
; 86   :     length = (*token - start);

  00067	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  0006c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR start$[rsp]
  00071	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00074	48 2b c1	 sub	 rax, rcx
  00077	89 44 24 20	 mov	 DWORD PTR length$[rsp], eax

; 87   :     
; 88   :     name = (char *)malloc(length+1);

  0007b	8b 44 24 20	 mov	 eax, DWORD PTR length$[rsp]
  0007f	ff c0		 inc	 eax
  00081	8b c0		 mov	 eax, eax
  00083	8b c8		 mov	 ecx, eax
  00085	e8 00 00 00 00	 call	 malloc
  0008a	48 89 44 24 28	 mov	 QWORD PTR name$[rsp], rax

; 89   :     memcpy(name, start, length);

  0008f	8b 44 24 20	 mov	 eax, DWORD PTR length$[rsp]
  00093	44 8b c0	 mov	 r8d, eax
  00096	48 8b 54 24 30	 mov	 rdx, QWORD PTR start$[rsp]
  0009b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR name$[rsp]
  000a0	e8 00 00 00 00	 call	 memcpy

; 90   :     name[length] = '\0';

  000a5	8b 44 24 20	 mov	 eax, DWORD PTR length$[rsp]
  000a9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR name$[rsp]
  000ae	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 91   :     
; 92   :     *out_name = name;

  000b2	48 8b 44 24 58	 mov	 rax, QWORD PTR out_name$[rsp]
  000b7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR name$[rsp]
  000bc	48 89 08	 mov	 QWORD PTR [rax], rcx

; 93   :     
; 94   :     return length;

  000bf	8b 44 24 20	 mov	 eax, DWORD PTR length$[rsp]

; 95   : }

  000c3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c7	c3		 ret	 0
?parse_name@@YAIPEAPEAEPEAPEAD@Z ENDP			; parse_name
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\obj_loader.cpp
_TEXT	SEGMENT
res$ = 32
__$ArrayPad$ = 48
$T1 = 96
token$ = 104
?parse_indices@@YA?ATvert_idx_t@@PEAPEAE@Z PROC		; parse_indices

; 58   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 59   :     vert_idx_t res;
; 60   :     res.v = -1; res.vn = -1; res.vt = -1;

  0001f	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR res$[rsp], -1
  00027	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR res$[rsp+4], -1
  0002f	c7 44 24 28 ff
	ff ff ff	 mov	 DWORD PTR res$[rsp+8], -1

; 61   :     
; 62   :     res.v = parse_int(token)-1;

  00037	48 8b 4c 24 68	 mov	 rcx, QWORD PTR token$[rsp]
  0003c	e8 00 00 00 00	 call	 ?parse_int@@YAHPEAPEAE@Z ; parse_int
  00041	ff c8		 dec	 eax
  00043	89 44 24 20	 mov	 DWORD PTR res$[rsp], eax

; 63   :     if(**token != '/')

  00047	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  0004c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00052	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00055	74 1e		 je	 SHORT $LN2@parse_indi

; 64   :         return res;

  00057	48 8d 44 24 20	 lea	 rax, QWORD PTR res$[rsp]
  0005c	48 8b 7c 24 60	 mov	 rdi, QWORD PTR $T1[rsp]
  00061	48 8b f0	 mov	 rsi, rax
  00064	b9 0c 00 00 00	 mov	 ecx, 12
  00069	f3 a4		 rep movsb
  0006b	48 8b 44 24 60	 mov	 rax, QWORD PTR $T1[rsp]
  00070	e9 9a 00 00 00	 jmp	 $LN1@parse_indi
$LN2@parse_indi:

; 65   :     (*token)++;

  00075	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  0007a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007d	48 ff c0	 inc	 rax
  00080	48 8b 4c 24 68	 mov	 rcx, QWORD PTR token$[rsp]
  00085	48 89 01	 mov	 QWORD PTR [rcx], rax

; 66   :     
; 67   :     if(**token != '/') {

  00088	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  0008d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00090	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00093	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00096	74 3b		 je	 SHORT $LN3@parse_indi

; 68   :         res.vt = parse_int(token)-1;

  00098	48 8b 4c 24 68	 mov	 rcx, QWORD PTR token$[rsp]
  0009d	e8 00 00 00 00	 call	 ?parse_int@@YAHPEAPEAE@Z ; parse_int
  000a2	ff c8		 dec	 eax
  000a4	89 44 24 28	 mov	 DWORD PTR res$[rsp+8], eax

; 69   :         if(**token != '/')

  000a8	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  000ad	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b0	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000b3	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  000b6	74 1b		 je	 SHORT $LN4@parse_indi

; 70   :             return res;

  000b8	48 8d 44 24 20	 lea	 rax, QWORD PTR res$[rsp]
  000bd	48 8b 7c 24 60	 mov	 rdi, QWORD PTR $T1[rsp]
  000c2	48 8b f0	 mov	 rsi, rax
  000c5	b9 0c 00 00 00	 mov	 ecx, 12
  000ca	f3 a4		 rep movsb
  000cc	48 8b 44 24 60	 mov	 rax, QWORD PTR $T1[rsp]
  000d1	eb 3c		 jmp	 SHORT $LN1@parse_indi
$LN4@parse_indi:
$LN3@parse_indi:

; 71   :     }
; 72   :     (*token)++;

  000d3	48 8b 44 24 68	 mov	 rax, QWORD PTR token$[rsp]
  000d8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000db	48 ff c0	 inc	 rax
  000de	48 8b 4c 24 68	 mov	 rcx, QWORD PTR token$[rsp]
  000e3	48 89 01	 mov	 QWORD PTR [rcx], rax

; 73   :     res.vn = parse_int(token)-1;

  000e6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR token$[rsp]
  000eb	e8 00 00 00 00	 call	 ?parse_int@@YAHPEAPEAE@Z ; parse_int
  000f0	ff c8		 dec	 eax
  000f2	89 44 24 24	 mov	 DWORD PTR res$[rsp+4], eax

; 74   :     
; 75   :     return res;

  000f6	48 8d 44 24 20	 lea	 rax, QWORD PTR res$[rsp]
  000fb	48 8b 7c 24 60	 mov	 rdi, QWORD PTR $T1[rsp]
  00100	48 8b f0	 mov	 rsi, rax
  00103	b9 0c 00 00 00	 mov	 ecx, 12
  00108	f3 a4		 rep movsb
  0010a	48 8b 44 24 60	 mov	 rax, QWORD PTR $T1[rsp]
$LN1@parse_indi:

; 76   : }

  0010f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00114	48 33 cc	 xor	 rcx, rsp
  00117	e8 00 00 00 00	 call	 __security_check_cookie
  0011c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00120	5f		 pop	 rdi
  00121	5e		 pop	 rsi
  00122	c3		 ret	 0
?parse_indices@@YA?ATvert_idx_t@@PEAPEAE@Z ENDP		; parse_indices
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\obj_loader.cpp
_TEXT	SEGMENT
v$ = 48
token$ = 56
?parse_v3@@YAXPEAMPEAPEAE@Z PROC			; parse_v3

; 50   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 51   :     v[0] = parse_double(token);

  0000e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR token$[rsp]
  00013	e8 00 00 00 00	 call	 ?parse_double@@YANPEAPEAE@Z ; parse_double
  00018	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0001c	b8 04 00 00 00	 mov	 eax, 4
  00021	48 6b c0 00	 imul	 rax, rax, 0
  00025	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  0002a	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0

; 52   :     v[1] = parse_double(token);

  0002f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR token$[rsp]
  00034	e8 00 00 00 00	 call	 ?parse_double@@YANPEAPEAE@Z ; parse_double
  00039	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0003d	b8 04 00 00 00	 mov	 eax, 4
  00042	48 6b c0 01	 imul	 rax, rax, 1
  00046	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  0004b	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0

; 53   :     v[2] = parse_double(token);

  00050	48 8b 4c 24 38	 mov	 rcx, QWORD PTR token$[rsp]
  00055	e8 00 00 00 00	 call	 ?parse_double@@YANPEAPEAE@Z ; parse_double
  0005a	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0005e	b8 04 00 00 00	 mov	 eax, 4
  00063	48 6b c0 02	 imul	 rax, rax, 2
  00067	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  0006c	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0

; 54   : }

  00071	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00075	c3		 ret	 0
?parse_v3@@YAXPEAMPEAPEAE@Z ENDP			; parse_v3
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\obj_loader.cpp
_TEXT	SEGMENT
v$ = 48
token$ = 56
?parse_v2@@YAXPEAMPEAPEAE@Z PROC			; parse_v2

; 43   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 44   :     v[0] = parse_double(token);

  0000e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR token$[rsp]
  00013	e8 00 00 00 00	 call	 ?parse_double@@YANPEAPEAE@Z ; parse_double
  00018	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0001c	b8 04 00 00 00	 mov	 eax, 4
  00021	48 6b c0 00	 imul	 rax, rax, 0
  00025	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  0002a	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0

; 45   :     v[1] = parse_double(token);

  0002f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR token$[rsp]
  00034	e8 00 00 00 00	 call	 ?parse_double@@YANPEAPEAE@Z ; parse_double
  00039	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0003d	b8 04 00 00 00	 mov	 eax, 4
  00042	48 6b c0 01	 imul	 rax, rax, 1
  00046	48 8b 4c 24 30	 mov	 rcx, QWORD PTR v$[rsp]
  0004b	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0

; 46   : }

  00050	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00054	c3		 ret	 0
?parse_v2@@YAXPEAMPEAPEAE@Z ENDP			; parse_v2
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\obj_loader.cpp
_TEXT	SEGMENT
end$ = 32
result$ = 40
token$ = 64
?parse_double@@YANPEAPEAE@Z PROC			; parse_double

; 33   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 34   :     u8 *end;
; 35   :     skip_space(token);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR token$[rsp]
  0000e	e8 00 00 00 00	 call	 ?skip_space@@YAXPEAPEAE@Z ; skip_space

; 36   :     f64 result = strtod((char *)*token, (char **)&end);

  00013	48 8d 54 24 20	 lea	 rdx, QWORD PTR end$[rsp]
  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR token$[rsp]
  0001d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00020	e8 00 00 00 00	 call	 strtod
  00025	f2 0f 11 44 24
	28		 movsd	 QWORD PTR result$[rsp], xmm0

; 37   :     *token = end;

  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR token$[rsp]
  00030	48 8b 4c 24 20	 mov	 rcx, QWORD PTR end$[rsp]
  00035	48 89 08	 mov	 QWORD PTR [rax], rcx

; 38   :     return result;

  00038	f2 0f 10 44 24
	28		 movsd	 xmm0, QWORD PTR result$[rsp]

; 39   : }

  0003e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00042	c3		 ret	 0
?parse_double@@YANPEAPEAE@Z ENDP			; parse_double
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\obj_loader.cpp
_TEXT	SEGMENT
result$ = 32
token$ = 64
?parse_int@@YAHPEAPEAE@Z PROC				; parse_int

; 23   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 24   :     i32 result = 0;

  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR result$[rsp], 0

; 25   :     // TODO(ajeej): check to move this out of here
; 26   :     skip_space(token);

  00011	48 8b 4c 24 40	 mov	 rcx, QWORD PTR token$[rsp]
  00016	e8 00 00 00 00	 call	 ?skip_space@@YAXPEAPEAE@Z ; skip_space

; 27   :     result = strtol((char *)*token, (char **)token, 10);

  0001b	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00021	48 8b 54 24 40	 mov	 rdx, QWORD PTR token$[rsp]
  00026	48 8b 44 24 40	 mov	 rax, QWORD PTR token$[rsp]
  0002b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0002e	e8 00 00 00 00	 call	 strtol
  00033	89 44 24 20	 mov	 DWORD PTR result$[rsp], eax

; 28   :     return result;

  00037	8b 44 24 20	 mov	 eax, DWORD PTR result$[rsp]

; 29   : }

  0003b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003f	c3		 ret	 0
?parse_int@@YAHPEAPEAE@Z ENDP				; parse_int
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\obj_loader.cpp
_TEXT	SEGMENT
token$ = 8
?skip_to_new_line@@YAXPEAPEAE@Z PROC			; skip_to_new_line

; 17   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN2@skip_to_ne:

; 18   :     while(!IS_NEW_LINE(**token)) (*token)++;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR token$[rsp]
  0000a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0000d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00010	83 f8 0d	 cmp	 eax, 13
  00013	74 34		 je	 SHORT $LN3@skip_to_ne
  00015	48 8b 44 24 08	 mov	 rax, QWORD PTR token$[rsp]
  0001a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00020	83 f8 0a	 cmp	 eax, 10
  00023	74 24		 je	 SHORT $LN3@skip_to_ne
  00025	48 8b 44 24 08	 mov	 rax, QWORD PTR token$[rsp]
  0002a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00030	85 c0		 test	 eax, eax
  00032	74 15		 je	 SHORT $LN3@skip_to_ne
  00034	48 8b 44 24 08	 mov	 rax, QWORD PTR token$[rsp]
  00039	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003c	48 ff c0	 inc	 rax
  0003f	48 8b 4c 24 08	 mov	 rcx, QWORD PTR token$[rsp]
  00044	48 89 01	 mov	 QWORD PTR [rcx], rax
  00047	eb bc		 jmp	 SHORT $LN2@skip_to_ne
$LN3@skip_to_ne:

; 19   : }

  00049	c3		 ret	 0
?skip_to_new_line@@YAXPEAPEAE@Z ENDP			; skip_to_new_line
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\obj_loader.cpp
_TEXT	SEGMENT
token$ = 8
?skip_space_and_cr@@YAXPEAPEAE@Z PROC			; skip_space_and_cr

; 11   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN2@skip_space:

; 12   :     while(IS_SPACE(**token) || **token == '\r') (*token)++;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR token$[rsp]
  0000a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0000d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00010	83 f8 20	 cmp	 eax, 32			; 00000020H
  00013	74 20		 je	 SHORT $LN4@skip_space
  00015	48 8b 44 24 08	 mov	 rax, QWORD PTR token$[rsp]
  0001a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00020	83 f8 09	 cmp	 eax, 9
  00023	74 10		 je	 SHORT $LN4@skip_space
  00025	48 8b 44 24 08	 mov	 rax, QWORD PTR token$[rsp]
  0002a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00030	83 f8 0d	 cmp	 eax, 13
  00033	75 15		 jne	 SHORT $LN3@skip_space
$LN4@skip_space:
  00035	48 8b 44 24 08	 mov	 rax, QWORD PTR token$[rsp]
  0003a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003d	48 ff c0	 inc	 rax
  00040	48 8b 4c 24 08	 mov	 rcx, QWORD PTR token$[rsp]
  00045	48 89 01	 mov	 QWORD PTR [rcx], rax
  00048	eb bb		 jmp	 SHORT $LN2@skip_space
$LN3@skip_space:

; 13   : }

  0004a	c3		 ret	 0
?skip_space_and_cr@@YAXPEAPEAE@Z ENDP			; skip_space_and_cr
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\obj_loader.cpp
_TEXT	SEGMENT
token$ = 8
?skip_space@@YAXPEAPEAE@Z PROC				; skip_space

; 5    : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN2@skip_space:

; 6    :     while(IS_SPACE(**token)) (*token)++;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR token$[rsp]
  0000a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0000d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00010	83 f8 20	 cmp	 eax, 32			; 00000020H
  00013	74 10		 je	 SHORT $LN4@skip_space
  00015	48 8b 44 24 08	 mov	 rax, QWORD PTR token$[rsp]
  0001a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00020	83 f8 09	 cmp	 eax, 9
  00023	75 15		 jne	 SHORT $LN3@skip_space
$LN4@skip_space:
  00025	48 8b 44 24 08	 mov	 rax, QWORD PTR token$[rsp]
  0002a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002d	48 ff c0	 inc	 rax
  00030	48 8b 4c 24 08	 mov	 rcx, QWORD PTR token$[rsp]
  00035	48 89 01	 mov	 QWORD PTR [rcx], rax
  00038	eb cb		 jmp	 SHORT $LN2@skip_space
$LN3@skip_space:

; 7    : }

  0003a	c3		 ret	 0
?skip_space@@YAXPEAPEAE@Z ENDP				; skip_space
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\renderer.h
_TEXT	SEGMENT
gl$ = 8
id$ = 16
?get_shader@@YAIPEAUgl_renderer@@I@Z PROC		; get_shader

; 120  : get_shader(gl_renderer *gl, u32 id) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 121  :     return gl->shaders[id];

  00009	8b 44 24 10	 mov	 eax, DWORD PTR id$[rsp]
  0000d	48 8b 4c 24 08	 mov	 rcx, QWORD PTR gl$[rsp]
  00012	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00016	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]

; 122  : }

  00019	c3		 ret	 0
?get_shader@@YAIPEAUgl_renderer@@I@Z ENDP		; get_shader
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\utils.h
_TEXT	SEGMENT
file$ = 32
size$ = 40
data$ = 48
filename$ = 80
out_data$ = 88
out_size$ = 96
?read_file@@YAXPEADPEAPEAEPEA_K@Z PROC			; read_file

; 67   : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 68   :     FILE *file = fopen(filename, "r");

  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG82511
  0001a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR filename$[rsp]
  0001f	e8 00 00 00 00	 call	 fopen
  00024	48 89 44 24 20	 mov	 QWORD PTR file$[rsp], rax

; 69   :     if (file == NULL) {

  00029	48 83 7c 24 20
	00		 cmp	 QWORD PTR file$[rsp], 0
  0002f	75 49		 jne	 SHORT $LN5@read_file
$LN4@read_file:

; 70   :         LOG("Could not open shader source file.");

  00031	b9 02 00 00 00	 mov	 ecx, 2
  00036	e8 00 00 00 00	 call	 __acrt_iob_func
  0003b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG82513
  00042	48 8b c8	 mov	 rcx, rax
  00045	e8 00 00 00 00	 call	 fprintf
  0004a	b9 02 00 00 00	 mov	 ecx, 2
  0004f	e8 00 00 00 00	 call	 __acrt_iob_func
  00054	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG82514
  0005b	48 8b c8	 mov	 rcx, rax
  0005e	e8 00 00 00 00	 call	 fprintf
  00063	33 c0		 xor	 eax, eax
  00065	85 c0		 test	 eax, eax
  00067	75 c8		 jne	 SHORT $LN4@read_file

; 71   :         *out_data = NULL;

  00069	48 8b 44 24 58	 mov	 rax, QWORD PTR out_data$[rsp]
  0006e	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 72   :         return;

  00075	e9 9f 00 00 00	 jmp	 $LN1@read_file
$LN5@read_file:

; 73   :     }
; 74   :     
; 75   :     u64 size;
; 76   :     fseek(file, 0, SEEK_END);

  0007a	41 b8 02 00 00
	00		 mov	 r8d, 2
  00080	33 d2		 xor	 edx, edx
  00082	48 8b 4c 24 20	 mov	 rcx, QWORD PTR file$[rsp]
  00087	e8 00 00 00 00	 call	 fseek

; 77   :     size = ftell(file);

  0008c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR file$[rsp]
  00091	e8 00 00 00 00	 call	 ftell
  00096	48 98		 cdqe
  00098	48 89 44 24 28	 mov	 QWORD PTR size$[rsp], rax

; 78   :     fseek(file, 0, SEEK_SET);

  0009d	45 33 c0	 xor	 r8d, r8d
  000a0	33 d2		 xor	 edx, edx
  000a2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR file$[rsp]
  000a7	e8 00 00 00 00	 call	 fseek

; 79   :     
; 80   :     u8 *data = (u8 *)malloc(size+1);

  000ac	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  000b1	48 ff c0	 inc	 rax
  000b4	48 8b c8	 mov	 rcx, rax
  000b7	e8 00 00 00 00	 call	 malloc
  000bc	48 89 44 24 30	 mov	 QWORD PTR data$[rsp], rax

; 81   :     fread(data, 1, size, file);

  000c1	4c 8b 4c 24 20	 mov	 r9, QWORD PTR file$[rsp]
  000c6	4c 8b 44 24 28	 mov	 r8, QWORD PTR size$[rsp]
  000cb	ba 01 00 00 00	 mov	 edx, 1
  000d0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  000d5	e8 00 00 00 00	 call	 fread

; 82   :     data[size] = '\0';

  000da	48 8b 44 24 28	 mov	 rax, QWORD PTR size$[rsp]
  000df	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  000e4	48 03 c8	 add	 rcx, rax
  000e7	48 8b c1	 mov	 rax, rcx
  000ea	c6 00 00	 mov	 BYTE PTR [rax], 0

; 83   :     
; 84   :     fclose(file);

  000ed	48 8b 4c 24 20	 mov	 rcx, QWORD PTR file$[rsp]
  000f2	e8 00 00 00 00	 call	 fclose

; 85   :     
; 86   :     *out_data = data;

  000f7	48 8b 44 24 58	 mov	 rax, QWORD PTR out_data$[rsp]
  000fc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  00101	48 89 08	 mov	 QWORD PTR [rax], rcx

; 87   :     
; 88   :     if(out_size)

  00104	48 83 7c 24 60
	00		 cmp	 QWORD PTR out_size$[rsp], 0
  0010a	74 0d		 je	 SHORT $LN6@read_file

; 89   :         *out_size = size;

  0010c	48 8b 44 24 60	 mov	 rax, QWORD PTR out_size$[rsp]
  00111	48 8b 4c 24 28	 mov	 rcx, QWORD PTR size$[rsp]
  00116	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN6@read_file:
$LN1@read_file:

; 90   : }

  00119	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0011d	c3		 ret	 0
?read_file@@YAXPEADPEAPEAEPEA_K@Z ENDP			; read_file
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
s$ = 48
?stbi__is_16_main@@YAHPEAUstbi__context@@@Z PROC	; stbi__is_16_main

; 7672 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 7673 : #ifndef STBI_NO_PNG
; 7674 :     if (stbi__png_is16(s))  return 1;

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__png_is16@@YAHPEAUstbi__context@@@Z ; stbi__png_is16
  00013	85 c0		 test	 eax, eax
  00015	74 07		 je	 SHORT $LN2@stbi__is_1
  00017	b8 01 00 00 00	 mov	 eax, 1
  0001c	eb 2c		 jmp	 SHORT $LN1@stbi__is_1
$LN2@stbi__is_1:

; 7675 : #endif
; 7676 :     
; 7677 : #ifndef STBI_NO_PSD
; 7678 :     if (stbi__psd_is16(s))  return 1;

  0001e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00023	e8 00 00 00 00	 call	 ?stbi__psd_is16@@YAHPEAUstbi__context@@@Z ; stbi__psd_is16
  00028	85 c0		 test	 eax, eax
  0002a	74 07		 je	 SHORT $LN3@stbi__is_1
  0002c	b8 01 00 00 00	 mov	 eax, 1
  00031	eb 17		 jmp	 SHORT $LN1@stbi__is_1
$LN3@stbi__is_1:

; 7679 : #endif
; 7680 :     
; 7681 : #ifndef STBI_NO_PNM
; 7682 :     if (stbi__pnm_is16(s))  return 1;

  00033	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00038	e8 00 00 00 00	 call	 ?stbi__pnm_is16@@YAHPEAUstbi__context@@@Z ; stbi__pnm_is16
  0003d	85 c0		 test	 eax, eax
  0003f	74 07		 je	 SHORT $LN4@stbi__is_1
  00041	b8 01 00 00 00	 mov	 eax, 1
  00046	eb 02		 jmp	 SHORT $LN1@stbi__is_1
$LN4@stbi__is_1:

; 7683 : #endif
; 7684 :     return 0;

  00048	33 c0		 xor	 eax, eax
$LN1@stbi__is_1:

; 7685 : }

  0004a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004e	c3		 ret	 0
?stbi__is_16_main@@YAHPEAUstbi__context@@@Z ENDP	; stbi__is_16_main
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
s$ = 48
x$ = 56
y$ = 64
comp$ = 72
?stbi__info_main@@YAHPEAUstbi__context@@PEAH11@Z PROC	; stbi__info_main

; 7630 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 7631 : #ifndef STBI_NO_JPEG
; 7632 :     if (stbi__jpeg_info(s, x, y, comp)) return 1;

  00018	4c 8b 4c 24 48	 mov	 r9, QWORD PTR comp$[rsp]
  0001d	4c 8b 44 24 40	 mov	 r8, QWORD PTR y$[rsp]
  00022	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$[rsp]
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0002c	e8 00 00 00 00	 call	 ?stbi__jpeg_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__jpeg_info
  00031	85 c0		 test	 eax, eax
  00033	74 0a		 je	 SHORT $LN2@stbi__info
  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	e9 38 01 00 00	 jmp	 $LN1@stbi__info
$LN2@stbi__info:

; 7633 : #endif
; 7634 :     
; 7635 : #ifndef STBI_NO_PNG
; 7636 :     if (stbi__png_info(s, x, y, comp))  return 1;

  0003f	4c 8b 4c 24 48	 mov	 r9, QWORD PTR comp$[rsp]
  00044	4c 8b 44 24 40	 mov	 r8, QWORD PTR y$[rsp]
  00049	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$[rsp]
  0004e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00053	e8 00 00 00 00	 call	 ?stbi__png_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__png_info
  00058	85 c0		 test	 eax, eax
  0005a	74 0a		 je	 SHORT $LN3@stbi__info
  0005c	b8 01 00 00 00	 mov	 eax, 1
  00061	e9 11 01 00 00	 jmp	 $LN1@stbi__info
$LN3@stbi__info:

; 7637 : #endif
; 7638 :     
; 7639 : #ifndef STBI_NO_GIF
; 7640 :     if (stbi__gif_info(s, x, y, comp))  return 1;

  00066	4c 8b 4c 24 48	 mov	 r9, QWORD PTR comp$[rsp]
  0006b	4c 8b 44 24 40	 mov	 r8, QWORD PTR y$[rsp]
  00070	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$[rsp]
  00075	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0007a	e8 00 00 00 00	 call	 ?stbi__gif_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__gif_info
  0007f	85 c0		 test	 eax, eax
  00081	74 0a		 je	 SHORT $LN4@stbi__info
  00083	b8 01 00 00 00	 mov	 eax, 1
  00088	e9 ea 00 00 00	 jmp	 $LN1@stbi__info
$LN4@stbi__info:

; 7641 : #endif
; 7642 :     
; 7643 : #ifndef STBI_NO_BMP
; 7644 :     if (stbi__bmp_info(s, x, y, comp))  return 1;

  0008d	4c 8b 4c 24 48	 mov	 r9, QWORD PTR comp$[rsp]
  00092	4c 8b 44 24 40	 mov	 r8, QWORD PTR y$[rsp]
  00097	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$[rsp]
  0009c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  000a1	e8 00 00 00 00	 call	 ?stbi__bmp_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__bmp_info
  000a6	85 c0		 test	 eax, eax
  000a8	74 0a		 je	 SHORT $LN5@stbi__info
  000aa	b8 01 00 00 00	 mov	 eax, 1
  000af	e9 c3 00 00 00	 jmp	 $LN1@stbi__info
$LN5@stbi__info:

; 7645 : #endif
; 7646 :     
; 7647 : #ifndef STBI_NO_PSD
; 7648 :     if (stbi__psd_info(s, x, y, comp))  return 1;

  000b4	4c 8b 4c 24 48	 mov	 r9, QWORD PTR comp$[rsp]
  000b9	4c 8b 44 24 40	 mov	 r8, QWORD PTR y$[rsp]
  000be	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$[rsp]
  000c3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  000c8	e8 00 00 00 00	 call	 ?stbi__psd_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__psd_info
  000cd	85 c0		 test	 eax, eax
  000cf	74 0a		 je	 SHORT $LN6@stbi__info
  000d1	b8 01 00 00 00	 mov	 eax, 1
  000d6	e9 9c 00 00 00	 jmp	 $LN1@stbi__info
$LN6@stbi__info:

; 7649 : #endif
; 7650 :     
; 7651 : #ifndef STBI_NO_PIC
; 7652 :     if (stbi__pic_info(s, x, y, comp))  return 1;

  000db	4c 8b 4c 24 48	 mov	 r9, QWORD PTR comp$[rsp]
  000e0	4c 8b 44 24 40	 mov	 r8, QWORD PTR y$[rsp]
  000e5	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$[rsp]
  000ea	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  000ef	e8 00 00 00 00	 call	 ?stbi__pic_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__pic_info
  000f4	85 c0		 test	 eax, eax
  000f6	74 07		 je	 SHORT $LN7@stbi__info
  000f8	b8 01 00 00 00	 mov	 eax, 1
  000fd	eb 78		 jmp	 SHORT $LN1@stbi__info
$LN7@stbi__info:

; 7653 : #endif
; 7654 :     
; 7655 : #ifndef STBI_NO_PNM
; 7656 :     if (stbi__pnm_info(s, x, y, comp))  return 1;

  000ff	4c 8b 4c 24 48	 mov	 r9, QWORD PTR comp$[rsp]
  00104	4c 8b 44 24 40	 mov	 r8, QWORD PTR y$[rsp]
  00109	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$[rsp]
  0010e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00113	e8 00 00 00 00	 call	 ?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__pnm_info
  00118	85 c0		 test	 eax, eax
  0011a	74 07		 je	 SHORT $LN8@stbi__info
  0011c	b8 01 00 00 00	 mov	 eax, 1
  00121	eb 54		 jmp	 SHORT $LN1@stbi__info
$LN8@stbi__info:

; 7657 : #endif
; 7658 :     
; 7659 : #ifndef STBI_NO_HDR
; 7660 :     if (stbi__hdr_info(s, x, y, comp))  return 1;

  00123	4c 8b 4c 24 48	 mov	 r9, QWORD PTR comp$[rsp]
  00128	4c 8b 44 24 40	 mov	 r8, QWORD PTR y$[rsp]
  0012d	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$[rsp]
  00132	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00137	e8 00 00 00 00	 call	 ?stbi__hdr_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__hdr_info
  0013c	85 c0		 test	 eax, eax
  0013e	74 07		 je	 SHORT $LN9@stbi__info
  00140	b8 01 00 00 00	 mov	 eax, 1
  00145	eb 30		 jmp	 SHORT $LN1@stbi__info
$LN9@stbi__info:

; 7661 : #endif
; 7662 :     
; 7663 :     // test tga last because it's a crappy test!
; 7664 : #ifndef STBI_NO_TGA
; 7665 :     if (stbi__tga_info(s, x, y, comp))

  00147	4c 8b 4c 24 48	 mov	 r9, QWORD PTR comp$[rsp]
  0014c	4c 8b 44 24 40	 mov	 r8, QWORD PTR y$[rsp]
  00151	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$[rsp]
  00156	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0015b	e8 00 00 00 00	 call	 ?stbi__tga_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__tga_info
  00160	85 c0		 test	 eax, eax
  00162	74 07		 je	 SHORT $LN10@stbi__info

; 7666 :         return 1;

  00164	b8 01 00 00 00	 mov	 eax, 1
  00169	eb 0c		 jmp	 SHORT $LN1@stbi__info
$LN10@stbi__info:

; 7667 : #endif
; 7668 :     return stbi__err("unknown image type", "Image not of any known type, or corrupt");

  0016b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG82430
  00172	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
$LN1@stbi__info:

; 7669 : }

  00177	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0017b	c3		 ret	 0
?stbi__info_main@@YAHPEAUstbi__context@@PEAH11@Z ENDP	; stbi__info_main
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
value$ = 32
s$ = 64
c$ = 72
?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z PROC ; stbi__pnm_getinteger

; 7565 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7566 :     int value = 0;

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR value$[rsp], 0
$LN2@stbi__pnm_:

; 7567 :     
; 7568 :     while (!stbi__at_eof(s) && stbi__pnm_isdigit(*c)) {

  00016	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001b	e8 00 00 00 00	 call	 ?stbi__at_eof@@YAHPEAUstbi__context@@@Z ; stbi__at_eof
  00020	85 c0		 test	 eax, eax
  00022	75 68		 jne	 SHORT $LN3@stbi__pnm_
  00024	48 8b 44 24 48	 mov	 rax, QWORD PTR c$[rsp]
  00029	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0002c	e8 00 00 00 00	 call	 ?stbi__pnm_isdigit@@YAHD@Z ; stbi__pnm_isdigit
  00031	85 c0		 test	 eax, eax
  00033	74 57		 je	 SHORT $LN3@stbi__pnm_

; 7569 :         value = value*10 + (*c - '0');

  00035	6b 44 24 20 0a	 imul	 eax, DWORD PTR value$[rsp], 10
  0003a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR c$[rsp]
  0003f	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  00042	8d 44 08 d0	 lea	 eax, DWORD PTR [rax+rcx-48]
  00046	89 44 24 20	 mov	 DWORD PTR value$[rsp], eax

; 7570 :         *c = (char) stbi__get8(s);

  0004a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0004f	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00054	48 8b 4c 24 48	 mov	 rcx, QWORD PTR c$[rsp]
  00059	88 01		 mov	 BYTE PTR [rcx], al

; 7571 :         if((value > 214748364) || (value == 214748364 && *c > '7'))

  0005b	81 7c 24 20 cc
	cc cc 0c	 cmp	 DWORD PTR value$[rsp], 214748364 ; 0cccccccH
  00063	7f 17		 jg	 SHORT $LN5@stbi__pnm_
  00065	81 7c 24 20 cc
	cc cc 0c	 cmp	 DWORD PTR value$[rsp], 214748364 ; 0cccccccH
  0006d	75 1b		 jne	 SHORT $LN4@stbi__pnm_
  0006f	48 8b 44 24 48	 mov	 rax, QWORD PTR c$[rsp]
  00074	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00077	83 f8 37	 cmp	 eax, 55			; 00000037H
  0007a	7e 0e		 jle	 SHORT $LN4@stbi__pnm_
$LN5@stbi__pnm_:

; 7572 :             return stbi__err("integer parse overflow", "Parsing an integer in the PPM header overflowed a 32-bit int");

  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG82382
  00083	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00088	eb 06		 jmp	 SHORT $LN1@stbi__pnm_
$LN4@stbi__pnm_:

; 7573 :     }

  0008a	eb 8a		 jmp	 SHORT $LN2@stbi__pnm_
$LN3@stbi__pnm_:

; 7574 :     
; 7575 :     return value;

  0008c	8b 44 24 20	 mov	 eax, DWORD PTR value$[rsp]
$LN1@stbi__pnm_:

; 7576 : }

  00090	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00094	c3		 ret	 0
?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z ENDP ; stbi__pnm_getinteger
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv68 = 0
c$ = 32
?stbi__pnm_isdigit@@YAHD@Z PROC				; stbi__pnm_isdigit

; 7560 : {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	48 83 ec 18	 sub	 rsp, 24

; 7561 :     return c >= '0' && c <= '9';

  00008	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  0000d	83 f8 30	 cmp	 eax, 48			; 00000030H
  00010	7c 13		 jl	 SHORT $LN3@stbi__pnm_
  00012	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  00017	83 f8 39	 cmp	 eax, 57			; 00000039H
  0001a	7f 09		 jg	 SHORT $LN3@stbi__pnm_
  0001c	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv68[rsp], 1
  00023	eb 07		 jmp	 SHORT $LN4@stbi__pnm_
$LN3@stbi__pnm_:
  00025	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv68[rsp], 0
$LN4@stbi__pnm_:
  0002c	8b 04 24	 mov	 eax, DWORD PTR tv68[rsp]

; 7562 : }

  0002f	48 83 c4 18	 add	 rsp, 24
  00033	c3		 ret	 0
?stbi__pnm_isdigit@@YAHD@Z ENDP				; stbi__pnm_isdigit
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
s$ = 48
c$ = 56
?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z PROC ; stbi__pnm_skip_whitespace

; 7546 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN2@stbi__pnm_:
$LN5@stbi__pnm_:

; 7547 :     for (;;) {
; 7548 :         while (!stbi__at_eof(s) && stbi__pnm_isspace(*c))

  0000e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00013	e8 00 00 00 00	 call	 ?stbi__at_eof@@YAHPEAUstbi__context@@@Z ; stbi__at_eof
  00018	85 c0		 test	 eax, eax
  0001a	75 24		 jne	 SHORT $LN6@stbi__pnm_
  0001c	48 8b 44 24 38	 mov	 rax, QWORD PTR c$[rsp]
  00021	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00024	e8 00 00 00 00	 call	 ?stbi__pnm_isspace@@YAHD@Z ; stbi__pnm_isspace
  00029	85 c0		 test	 eax, eax
  0002b	74 13		 je	 SHORT $LN6@stbi__pnm_

; 7549 :             *c = (char) stbi__get8(s);

  0002d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00032	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00037	48 8b 4c 24 38	 mov	 rcx, QWORD PTR c$[rsp]
  0003c	88 01		 mov	 BYTE PTR [rcx], al
  0003e	eb ce		 jmp	 SHORT $LN5@stbi__pnm_
$LN6@stbi__pnm_:

; 7550 :         
; 7551 :         if (stbi__at_eof(s) || *c != '#')

  00040	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00045	e8 00 00 00 00	 call	 ?stbi__at_eof@@YAHPEAUstbi__context@@@Z ; stbi__at_eof
  0004a	85 c0		 test	 eax, eax
  0004c	75 0d		 jne	 SHORT $LN10@stbi__pnm_
  0004e	48 8b 44 24 38	 mov	 rax, QWORD PTR c$[rsp]
  00053	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00056	83 f8 23	 cmp	 eax, 35			; 00000023H
  00059	74 02		 je	 SHORT $LN9@stbi__pnm_
$LN10@stbi__pnm_:

; 7552 :             break;

  0005b	eb 40		 jmp	 SHORT $LN3@stbi__pnm_
$LN9@stbi__pnm_:
$LN7@stbi__pnm_:

; 7553 :         
; 7554 :         while (!stbi__at_eof(s) && *c != '\n' && *c != '\r' )

  0005d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00062	e8 00 00 00 00	 call	 ?stbi__at_eof@@YAHPEAUstbi__context@@@Z ; stbi__at_eof
  00067	85 c0		 test	 eax, eax
  00069	75 2d		 jne	 SHORT $LN8@stbi__pnm_
  0006b	48 8b 44 24 38	 mov	 rax, QWORD PTR c$[rsp]
  00070	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00073	83 f8 0a	 cmp	 eax, 10
  00076	74 20		 je	 SHORT $LN8@stbi__pnm_
  00078	48 8b 44 24 38	 mov	 rax, QWORD PTR c$[rsp]
  0007d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00080	83 f8 0d	 cmp	 eax, 13
  00083	74 13		 je	 SHORT $LN8@stbi__pnm_

; 7555 :             *c = (char) stbi__get8(s);

  00085	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0008a	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0008f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR c$[rsp]
  00094	88 01		 mov	 BYTE PTR [rcx], al
  00096	eb c5		 jmp	 SHORT $LN7@stbi__pnm_
$LN8@stbi__pnm_:

; 7556 :     }

  00098	e9 71 ff ff ff	 jmp	 $LN2@stbi__pnm_
$LN3@stbi__pnm_:

; 7557 : }

  0009d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a1	c3		 ret	 0
?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z ENDP ; stbi__pnm_skip_whitespace
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv76 = 0
c$ = 32
?stbi__pnm_isspace@@YAHD@Z PROC				; stbi__pnm_isspace

; 7541 : {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	48 83 ec 18	 sub	 rsp, 24

; 7542 :     return c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f' || c == '\r';

  00008	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  0000d	83 f8 20	 cmp	 eax, 32			; 00000020H
  00010	74 3b		 je	 SHORT $LN3@stbi__pnm_
  00012	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  00017	83 f8 09	 cmp	 eax, 9
  0001a	74 31		 je	 SHORT $LN3@stbi__pnm_
  0001c	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  00021	83 f8 0a	 cmp	 eax, 10
  00024	74 27		 je	 SHORT $LN3@stbi__pnm_
  00026	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  0002b	83 f8 0b	 cmp	 eax, 11
  0002e	74 1d		 je	 SHORT $LN3@stbi__pnm_
  00030	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  00035	83 f8 0c	 cmp	 eax, 12
  00038	74 13		 je	 SHORT $LN3@stbi__pnm_
  0003a	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  0003f	83 f8 0d	 cmp	 eax, 13
  00042	74 09		 je	 SHORT $LN3@stbi__pnm_
  00044	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv76[rsp], 0
  0004b	eb 07		 jmp	 SHORT $LN4@stbi__pnm_
$LN3@stbi__pnm_:
  0004d	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv76[rsp], 1
$LN4@stbi__pnm_:
  00054	8b 04 24	 mov	 eax, DWORD PTR tv76[rsp]

; 7543 : }

  00057	48 83 c4 18	 add	 rsp, 24
  0005b	c3		 ret	 0
?stbi__pnm_isspace@@YAHD@Z ENDP				; stbi__pnm_isspace
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
f1$1 = 32
tv151 = 36
output$ = 64
input$ = 72
req_comp$ = 80
?stbi__hdr_convert@@YAXPEAMPEAEH@Z PROC			; stbi__hdr_convert

; 7129 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7130 :     if ( input[3] != 0 ) {

  00013	b8 01 00 00 00	 mov	 eax, 1
  00018	48 6b c0 03	 imul	 rax, rax, 3
  0001c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR input$[rsp]
  00021	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00025	85 c0		 test	 eax, eax
  00027	0f 84 6d 01 00
	00		 je	 $LN4@stbi__hdr_

; 7131 :         float f1;
; 7132 :         // Exponent
; 7133 :         f1 = (float) ldexp(1.0f, input[3] - (int)(128 + 8));

  0002d	b8 01 00 00 00	 mov	 eax, 1
  00032	48 6b c0 03	 imul	 rax, rax, 3
  00036	48 8b 4c 24 48	 mov	 rcx, QWORD PTR input$[rsp]
  0003b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0003f	2d 88 00 00 00	 sub	 eax, 136		; 00000088H
  00044	8b d0		 mov	 edx, eax
  00046	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0004e	e8 00 00 00 00	 call	 ?ldexp@@YAMMH@Z		; ldexp
  00053	f3 0f 11 44 24
	20		 movss	 DWORD PTR f1$1[rsp], xmm0

; 7134 :         if (req_comp <= 2)

  00059	83 7c 24 50 02	 cmp	 DWORD PTR req_comp$[rsp], 2
  0005e	7f 64		 jg	 SHORT $LN6@stbi__hdr_

; 7135 :             output[0] = (input[0] + input[1] + input[2]) * f1 / 3;

  00060	b8 01 00 00 00	 mov	 eax, 1
  00065	48 6b c0 00	 imul	 rax, rax, 0
  00069	48 8b 4c 24 48	 mov	 rcx, QWORD PTR input$[rsp]
  0006e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00072	b9 01 00 00 00	 mov	 ecx, 1
  00077	48 6b c9 01	 imul	 rcx, rcx, 1
  0007b	48 8b 54 24 48	 mov	 rdx, QWORD PTR input$[rsp]
  00080	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00084	03 c1		 add	 eax, ecx
  00086	b9 01 00 00 00	 mov	 ecx, 1
  0008b	48 6b c9 02	 imul	 rcx, rcx, 2
  0008f	48 8b 54 24 48	 mov	 rdx, QWORD PTR input$[rsp]
  00094	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00098	03 c1		 add	 eax, ecx
  0009a	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0009e	f3 0f 59 44 24
	20		 mulss	 xmm0, DWORD PTR f1$1[rsp]
  000a4	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40400000
  000ac	b8 04 00 00 00	 mov	 eax, 4
  000b1	48 6b c0 00	 imul	 rax, rax, 0
  000b5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  000ba	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
  000bf	e9 8d 00 00 00	 jmp	 $LN7@stbi__hdr_
$LN6@stbi__hdr_:

; 7136 :         else {
; 7137 :             output[0] = input[0] * f1;

  000c4	b8 01 00 00 00	 mov	 eax, 1
  000c9	48 6b c0 00	 imul	 rax, rax, 0
  000cd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR input$[rsp]
  000d2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000d6	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000da	f3 0f 59 44 24
	20		 mulss	 xmm0, DWORD PTR f1$1[rsp]
  000e0	b8 04 00 00 00	 mov	 eax, 4
  000e5	48 6b c0 00	 imul	 rax, rax, 0
  000e9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  000ee	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0

; 7138 :             output[1] = input[1] * f1;

  000f3	b8 01 00 00 00	 mov	 eax, 1
  000f8	48 6b c0 01	 imul	 rax, rax, 1
  000fc	48 8b 4c 24 48	 mov	 rcx, QWORD PTR input$[rsp]
  00101	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00105	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00109	f3 0f 59 44 24
	20		 mulss	 xmm0, DWORD PTR f1$1[rsp]
  0010f	b8 04 00 00 00	 mov	 eax, 4
  00114	48 6b c0 01	 imul	 rax, rax, 1
  00118	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  0011d	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0

; 7139 :             output[2] = input[2] * f1;

  00122	b8 01 00 00 00	 mov	 eax, 1
  00127	48 6b c0 02	 imul	 rax, rax, 2
  0012b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR input$[rsp]
  00130	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00134	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00138	f3 0f 59 44 24
	20		 mulss	 xmm0, DWORD PTR f1$1[rsp]
  0013e	b8 04 00 00 00	 mov	 eax, 4
  00143	48 6b c0 02	 imul	 rax, rax, 2
  00147	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  0014c	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
$LN7@stbi__hdr_:

; 7140 :         }
; 7141 :         if (req_comp == 2) output[1] = 1;

  00151	83 7c 24 50 02	 cmp	 DWORD PTR req_comp$[rsp], 2
  00156	75 1b		 jne	 SHORT $LN8@stbi__hdr_
  00158	b8 04 00 00 00	 mov	 eax, 4
  0015d	48 6b c0 01	 imul	 rax, rax, 1
  00161	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  00166	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0016e	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
$LN8@stbi__hdr_:

; 7142 :         if (req_comp == 4) output[3] = 1;

  00173	83 7c 24 50 04	 cmp	 DWORD PTR req_comp$[rsp], 4
  00178	75 1b		 jne	 SHORT $LN9@stbi__hdr_
  0017a	b8 04 00 00 00	 mov	 eax, 4
  0017f	48 6b c0 03	 imul	 rax, rax, 3
  00183	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  00188	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00190	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
$LN9@stbi__hdr_:

; 7143 :     } else {

  00195	e9 bd 00 00 00	 jmp	 $LN5@stbi__hdr_
$LN4@stbi__hdr_:

; 7144 :         switch (req_comp) {

  0019a	8b 44 24 50	 mov	 eax, DWORD PTR req_comp$[rsp]
  0019e	89 44 24 24	 mov	 DWORD PTR tv151[rsp], eax
  001a2	83 7c 24 24 01	 cmp	 DWORD PTR tv151[rsp], 1
  001a7	0f 84 94 00 00
	00		 je	 $LN13@stbi__hdr_
  001ad	83 7c 24 24 02	 cmp	 DWORD PTR tv151[rsp], 2
  001b2	74 72		 je	 SHORT $LN12@stbi__hdr_
  001b4	83 7c 24 24 03	 cmp	 DWORD PTR tv151[rsp], 3
  001b9	74 27		 je	 SHORT $LN11@stbi__hdr_
  001bb	83 7c 24 24 04	 cmp	 DWORD PTR tv151[rsp], 4
  001c0	74 05		 je	 SHORT $LN10@stbi__hdr_
  001c2	e9 90 00 00 00	 jmp	 $LN2@stbi__hdr_
$LN10@stbi__hdr_:

; 7145 :             case 4: output[3] = 1; /* fallthrough */

  001c7	b8 04 00 00 00	 mov	 eax, 4
  001cc	48 6b c0 03	 imul	 rax, rax, 3
  001d0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  001d5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001dd	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
$LN11@stbi__hdr_:

; 7146 :             case 3: output[0] = output[1] = output[2] = 0;

  001e2	b8 04 00 00 00	 mov	 eax, 4
  001e7	48 6b c0 02	 imul	 rax, rax, 2
  001eb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  001f0	0f 57 c0	 xorps	 xmm0, xmm0
  001f3	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
  001f8	b8 04 00 00 00	 mov	 eax, 4
  001fd	48 6b c0 01	 imul	 rax, rax, 1
  00201	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  00206	0f 57 c0	 xorps	 xmm0, xmm0
  00209	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
  0020e	b8 04 00 00 00	 mov	 eax, 4
  00213	48 6b c0 00	 imul	 rax, rax, 0
  00217	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  0021c	0f 57 c0	 xorps	 xmm0, xmm0
  0021f	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0

; 7147 :             break;

  00224	eb 31		 jmp	 SHORT $LN2@stbi__hdr_
$LN12@stbi__hdr_:

; 7148 :             case 2: output[1] = 1; /* fallthrough */

  00226	b8 04 00 00 00	 mov	 eax, 4
  0022b	48 6b c0 01	 imul	 rax, rax, 1
  0022f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  00234	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0023c	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
$LN13@stbi__hdr_:

; 7149 :             case 1: output[0] = 0;

  00241	b8 04 00 00 00	 mov	 eax, 4
  00246	48 6b c0 00	 imul	 rax, rax, 0
  0024a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  0024f	0f 57 c0	 xorps	 xmm0, xmm0
  00252	f3 0f 11 04 01	 movss	 DWORD PTR [rcx+rax], xmm0
$LN2@stbi__hdr_:
$LN5@stbi__hdr_:

; 7150 :             break;
; 7151 :         }
; 7152 :     }
; 7153 : }

  00257	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0025b	c3		 ret	 0
?stbi__hdr_convert@@YAXPEAMPEAEH@Z ENDP			; stbi__hdr_convert
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
c$ = 32
len$ = 36
z$ = 64
buffer$ = 72
?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z PROC ; stbi__hdr_gettoken

; 7107 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7108 :     int len=0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0

; 7109 :     char c = '\0';

  00016	c6 44 24 20 00	 mov	 BYTE PTR c$[rsp], 0

; 7110 :     
; 7111 :     c = (char) stbi__get8(z);

  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00020	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00025	88 44 24 20	 mov	 BYTE PTR c$[rsp], al
$LN2@stbi__hdr_:

; 7112 :     
; 7113 :     while (!stbi__at_eof(z) && c != '\n') {

  00029	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  0002e	e8 00 00 00 00	 call	 ?stbi__at_eof@@YAHPEAUstbi__context@@@Z ; stbi__at_eof
  00033	85 c0		 test	 eax, eax
  00035	75 64		 jne	 SHORT $LN3@stbi__hdr_
  00037	0f be 44 24 20	 movsx	 eax, BYTE PTR c$[rsp]
  0003c	83 f8 0a	 cmp	 eax, 10
  0003f	74 5a		 je	 SHORT $LN3@stbi__hdr_

; 7114 :         buffer[len++] = c;

  00041	48 63 44 24 24	 movsxd	 rax, DWORD PTR len$[rsp]
  00046	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buffer$[rsp]
  0004b	0f b6 54 24 20	 movzx	 edx, BYTE PTR c$[rsp]
  00050	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00053	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  00057	ff c0		 inc	 eax
  00059	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax

; 7115 :         if (len == STBI__HDR_BUFLEN-1) {

  0005d	81 7c 24 24 ff
	03 00 00	 cmp	 DWORD PTR len$[rsp], 1023 ; 000003ffH
  00065	75 24		 jne	 SHORT $LN6@stbi__hdr_
$LN4@stbi__hdr_:

; 7116 :             // flush to end of line
; 7117 :             while (!stbi__at_eof(z) && stbi__get8(z) != '\n')

  00067	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  0006c	e8 00 00 00 00	 call	 ?stbi__at_eof@@YAHPEAUstbi__context@@@Z ; stbi__at_eof
  00071	85 c0		 test	 eax, eax
  00073	75 14		 jne	 SHORT $LN5@stbi__hdr_
  00075	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  0007a	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0007f	0f b6 c0	 movzx	 eax, al
  00082	83 f8 0a	 cmp	 eax, 10
  00085	74 02		 je	 SHORT $LN5@stbi__hdr_

; 7118 :                 ;

  00087	eb de		 jmp	 SHORT $LN4@stbi__hdr_
$LN5@stbi__hdr_:

; 7119 :             break;

  00089	eb 10		 jmp	 SHORT $LN3@stbi__hdr_
$LN6@stbi__hdr_:

; 7120 :         }
; 7121 :         c = (char) stbi__get8(z);

  0008b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00090	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00095	88 44 24 20	 mov	 BYTE PTR c$[rsp], al

; 7122 :     }

  00099	eb 8e		 jmp	 SHORT $LN2@stbi__hdr_
$LN3@stbi__hdr_:

; 7123 :     
; 7124 :     buffer[len] = 0;

  0009b	48 63 44 24 24	 movsxd	 rax, DWORD PTR len$[rsp]
  000a0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buffer$[rsp]
  000a5	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 7125 :     return buffer;

  000a9	48 8b 44 24 48	 mov	 rax, QWORD PTR buffer$[rsp]

; 7126 : }

  000ae	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b2	c3		 ret	 0
?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z ENDP ; stbi__hdr_gettoken
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
i$ = 32
s$ = 64
signature$ = 72
?stbi__hdr_test_core@@YAHPEAUstbi__context@@PEBD@Z PROC	; stbi__hdr_test_core

; 7085 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7086 :     int i;
; 7087 :     for (i=0; signature[i]; ++i)

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00016	eb 0a		 jmp	 SHORT $LN4@stbi__hdr_
$LN2@stbi__hdr_:
  00018	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0001c	ff c0		 inc	 eax
  0001e	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__hdr_:
  00022	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00027	48 8b 4c 24 48	 mov	 rcx, QWORD PTR signature$[rsp]
  0002c	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00030	85 c0		 test	 eax, eax
  00032	74 25		 je	 SHORT $LN3@stbi__hdr_

; 7088 :         if (stbi__get8(s) != signature[i])

  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00039	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0003e	0f b6 c0	 movzx	 eax, al
  00041	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00046	48 8b 54 24 48	 mov	 rdx, QWORD PTR signature$[rsp]
  0004b	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  0004f	3b c1		 cmp	 eax, ecx
  00051	74 04		 je	 SHORT $LN5@stbi__hdr_

; 7089 :         return 0;

  00053	33 c0		 xor	 eax, eax
  00055	eb 11		 jmp	 SHORT $LN1@stbi__hdr_
$LN5@stbi__hdr_:
  00057	eb bf		 jmp	 SHORT $LN2@stbi__hdr_
$LN3@stbi__hdr_:

; 7090 :     stbi__rewind(s);

  00059	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0005e	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7091 :     return 1;

  00063	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__hdr_:

; 7092 : }

  00068	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006c	c3		 ret	 0
?stbi__hdr_test_core@@YAHPEAUstbi__context@@PEBD@Z ENDP	; stbi__hdr_test_core
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv78 = 32
g$ = 64
out$ = 72
delays$ = 80
?stbi__load_gif_main_outofmem@@YAPEAXPEAUstbi__gif@@PEAEPEAPEAH@Z PROC ; stbi__load_gif_main_outofmem

; 6950 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6951 :     STBI_FREE(g->out);

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR g$[rsp]
  00018	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0001c	e8 00 00 00 00	 call	 free

; 6952 :     STBI_FREE(g->history);

  00021	48 8b 44 24 40	 mov	 rax, QWORD PTR g$[rsp]
  00026	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0002a	e8 00 00 00 00	 call	 free

; 6953 :     STBI_FREE(g->background);

  0002f	48 8b 44 24 40	 mov	 rax, QWORD PTR g$[rsp]
  00034	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00038	e8 00 00 00 00	 call	 free

; 6954 :     
; 6955 :     if (out) STBI_FREE(out);

  0003d	48 83 7c 24 48
	00		 cmp	 QWORD PTR out$[rsp], 0
  00043	74 0a		 je	 SHORT $LN2@stbi__load
  00045	48 8b 4c 24 48	 mov	 rcx, QWORD PTR out$[rsp]
  0004a	e8 00 00 00 00	 call	 free
$LN2@stbi__load:

; 6956 :     if (delays && *delays) STBI_FREE(*delays);

  0004f	48 83 7c 24 50
	00		 cmp	 QWORD PTR delays$[rsp], 0
  00055	74 18		 je	 SHORT $LN3@stbi__load
  00057	48 8b 44 24 50	 mov	 rax, QWORD PTR delays$[rsp]
  0005c	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00060	74 0d		 je	 SHORT $LN3@stbi__load
  00062	48 8b 44 24 50	 mov	 rax, QWORD PTR delays$[rsp]
  00067	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0006a	e8 00 00 00 00	 call	 free
$LN3@stbi__load:

; 6957 :     return stbi__errpuc("outofmem", "Out of memory");

  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81936
  00076	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0007b	85 c0		 test	 eax, eax
  0007d	74 0a		 je	 SHORT $LN5@stbi__load
  0007f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
  00087	eb 08		 jmp	 SHORT $LN6@stbi__load
$LN5@stbi__load:
  00089	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
$LN6@stbi__load:
  00091	48 63 44 24 20	 movsxd	 rax, DWORD PTR tv78[rsp]

; 6958 : }

  00096	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009a	c3		 ret	 0
?stbi__load_gif_main_outofmem@@YAPEAXPEAUstbi__gif@@PEAEPEAPEAH@Z ENDP ; stbi__load_gif_main_outofmem
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
pi$ = 32
pcount$ = 36
len$1 = 40
dispose$ = 44
tv234 = 48
w$2 = 52
tv83 = 56
tv143 = 60
tv252 = 64
x$3 = 68
y$4 = 72
h$5 = 76
tv299 = 80
tv318 = 84
first_frame$ = 88
tv413 = 92
tag$6 = 96
tv582 = 100
ext$7 = 104
o$8 = 112
s$ = 144
g$ = 152
comp$ = 160
req_comp$ = 168
two_back$ = 176
?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHHPEAE@Z PROC ; stbi__gif_load_next

; 6776 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 6777 :     int dispose;
; 6778 :     int first_frame;
; 6779 :     int pi;
; 6780 :     int pcount;
; 6781 :     STBI_NOTUSED(req_comp);
; 6782 :     
; 6783 :     // on first frame, any non-written pixels get the background colour (non-transparent)
; 6784 :     first_frame = 0;

  0001b	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR first_frame$[rsp], 0

; 6785 :     if (g->out == 0) {

  00023	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  0002b	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00030	0f 85 aa 01 00
	00		 jne	 $LN18@stbi__gif_

; 6786 :         if (!stbi__gif_header(s, g, comp,0)) return 0; // stbi__g_failure_reason set by stbi__gif_header

  00036	45 33 c9	 xor	 r9d, r9d
  00039	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR comp$[rsp]
  00041	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR g$[rsp]
  00049	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00051	e8 00 00 00 00	 call	 ?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z ; stbi__gif_header
  00056	85 c0		 test	 eax, eax
  00058	75 07		 jne	 SHORT $LN20@stbi__gif_
  0005a	33 c0		 xor	 eax, eax
  0005c	e9 7f 09 00 00	 jmp	 $LN1@stbi__gif_
$LN20@stbi__gif_:

; 6787 :         if (!stbi__mad3sizes_valid(4, g->w, g->h, 0))

  00061	45 33 c9	 xor	 r9d, r9d
  00064	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  0006c	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  00070	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00078	8b 10		 mov	 edx, DWORD PTR [rax]
  0007a	b9 04 00 00 00	 mov	 ecx, 4
  0007f	e8 00 00 00 00	 call	 ?stbi__mad3sizes_valid@@YAHHHHH@Z ; stbi__mad3sizes_valid
  00084	85 c0		 test	 eax, eax
  00086	75 2c		 jne	 SHORT $LN21@stbi__gif_

; 6788 :             return stbi__errpuc("too large", "GIF image is too large");

  00088	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81890
  0008f	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00094	85 c0		 test	 eax, eax
  00096	74 0a		 je	 SHORT $LN55@stbi__gif_
  00098	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
  000a0	eb 08		 jmp	 SHORT $LN56@stbi__gif_
$LN55@stbi__gif_:
  000a2	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
$LN56@stbi__gif_:
  000aa	48 63 44 24 38	 movsxd	 rax, DWORD PTR tv83[rsp]
  000af	e9 2c 09 00 00	 jmp	 $LN1@stbi__gif_
$LN21@stbi__gif_:

; 6789 :         pcount = g->w * g->h;

  000b4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  000bc	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  000c4	8b 00		 mov	 eax, DWORD PTR [rax]
  000c6	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  000ca	89 44 24 24	 mov	 DWORD PTR pcount$[rsp], eax

; 6790 :         g->out = (stbi_uc *) stbi__malloc(4 * pcount);

  000ce	8b 44 24 24	 mov	 eax, DWORD PTR pcount$[rsp]
  000d2	c1 e0 02	 shl	 eax, 2
  000d5	48 98		 cdqe
  000d7	48 8b c8	 mov	 rcx, rax
  000da	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  000df	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  000e7	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 6791 :         g->background = (stbi_uc *) stbi__malloc(4 * pcount);

  000eb	8b 44 24 24	 mov	 eax, DWORD PTR pcount$[rsp]
  000ef	c1 e0 02	 shl	 eax, 2
  000f2	48 98		 cdqe
  000f4	48 8b c8	 mov	 rcx, rax
  000f7	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  000fc	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00104	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 6792 :         g->history = (stbi_uc *) stbi__malloc(pcount);

  00108	48 63 44 24 24	 movsxd	 rax, DWORD PTR pcount$[rsp]
  0010d	48 8b c8	 mov	 rcx, rax
  00110	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  00115	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0011d	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 6793 :         if (!g->out || !g->background || !g->history)

  00121	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00129	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0012e	74 1e		 je	 SHORT $LN23@stbi__gif_
  00130	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00138	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0013d	74 0f		 je	 SHORT $LN23@stbi__gif_
  0013f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00147	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0014c	75 2c		 jne	 SHORT $LN22@stbi__gif_
$LN23@stbi__gif_:

; 6794 :             return stbi__errpuc("outofmem", "Out of memory");

  0014e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81893
  00155	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0015a	85 c0		 test	 eax, eax
  0015c	74 0a		 je	 SHORT $LN57@stbi__gif_
  0015e	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv143[rsp], 0
  00166	eb 08		 jmp	 SHORT $LN58@stbi__gif_
$LN57@stbi__gif_:
  00168	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv143[rsp], 0
$LN58@stbi__gif_:
  00170	48 63 44 24 3c	 movsxd	 rax, DWORD PTR tv143[rsp]
  00175	e9 66 08 00 00	 jmp	 $LN1@stbi__gif_
$LN22@stbi__gif_:

; 6795 :         
; 6796 :         // image is treated as "transparent" at the start - ie, nothing overwrites the current background;
; 6797 :         // background colour is only used for pixels that are not rendered first frame, after that "background"
; 6798 :         // color refers to the color that was there the previous frame.
; 6799 :         memset(g->out, 0x00, 4 * pcount);

  0017a	8b 44 24 24	 mov	 eax, DWORD PTR pcount$[rsp]
  0017e	c1 e0 02	 shl	 eax, 2
  00181	48 98		 cdqe
  00183	4c 8b c0	 mov	 r8, rax
  00186	33 d2		 xor	 edx, edx
  00188	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00190	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00194	e8 00 00 00 00	 call	 memset

; 6800 :         memset(g->background, 0x00, 4 * pcount); // state of the background (starts transparent)

  00199	8b 44 24 24	 mov	 eax, DWORD PTR pcount$[rsp]
  0019d	c1 e0 02	 shl	 eax, 2
  001a0	48 98		 cdqe
  001a2	4c 8b c0	 mov	 r8, rax
  001a5	33 d2		 xor	 edx, edx
  001a7	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  001af	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  001b3	e8 00 00 00 00	 call	 memset

; 6801 :         memset(g->history, 0x00, pcount);        // pixels that were affected previous frame

  001b8	48 63 44 24 24	 movsxd	 rax, DWORD PTR pcount$[rsp]
  001bd	4c 8b c0	 mov	 r8, rax
  001c0	33 d2		 xor	 edx, edx
  001c2	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  001ca	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  001ce	e8 00 00 00 00	 call	 memset

; 6802 :         first_frame = 1;

  001d3	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR first_frame$[rsp], 1

; 6803 :     } else {

  001db	e9 8f 01 00 00	 jmp	 $LN19@stbi__gif_
$LN18@stbi__gif_:

; 6804 :         // second frame - how do we dispose of the previous one?
; 6805 :         dispose = (g->eflags & 0x1C) >> 2;

  001e0	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  001e8	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  001eb	83 e0 1c	 and	 eax, 28
  001ee	c1 f8 02	 sar	 eax, 2
  001f1	89 44 24 2c	 mov	 DWORD PTR dispose$[rsp], eax

; 6806 :         pcount = g->w * g->h;

  001f5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  001fd	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00205	8b 00		 mov	 eax, DWORD PTR [rax]
  00207	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  0020b	89 44 24 24	 mov	 DWORD PTR pcount$[rsp], eax

; 6807 :         
; 6808 :         if ((dispose == 3) && (two_back == 0)) {

  0020f	83 7c 24 2c 03	 cmp	 DWORD PTR dispose$[rsp], 3
  00214	75 13		 jne	 SHORT $LN24@stbi__gif_
  00216	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR two_back$[rsp], 0
  0021f	75 08		 jne	 SHORT $LN24@stbi__gif_

; 6809 :             dispose = 2; // if I don't have an image to revert back to, default to the old background

  00221	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR dispose$[rsp], 2
$LN24@stbi__gif_:

; 6810 :         }
; 6811 :         
; 6812 :         if (dispose == 3) { // use previous graphic

  00229	83 7c 24 2c 03	 cmp	 DWORD PTR dispose$[rsp], 3
  0022e	75 7f		 jne	 SHORT $LN25@stbi__gif_

; 6813 :             for (pi = 0; pi < pcount; ++pi) {

  00230	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR pi$[rsp], 0
  00238	eb 0a		 jmp	 SHORT $LN4@stbi__gif_
$LN2@stbi__gif_:
  0023a	8b 44 24 20	 mov	 eax, DWORD PTR pi$[rsp]
  0023e	ff c0		 inc	 eax
  00240	89 44 24 20	 mov	 DWORD PTR pi$[rsp], eax
$LN4@stbi__gif_:
  00244	8b 44 24 24	 mov	 eax, DWORD PTR pcount$[rsp]
  00248	39 44 24 20	 cmp	 DWORD PTR pi$[rsp], eax
  0024c	7d 5c		 jge	 SHORT $LN3@stbi__gif_

; 6814 :                 if (g->history[pi]) {

  0024e	48 63 44 24 20	 movsxd	 rax, DWORD PTR pi$[rsp]
  00253	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0025b	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0025f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00263	85 c0		 test	 eax, eax
  00265	74 41		 je	 SHORT $LN27@stbi__gif_

; 6815 :                     memcpy( &g->out[pi * 4], &two_back[pi * 4], 4 );

  00267	8b 44 24 20	 mov	 eax, DWORD PTR pi$[rsp]
  0026b	c1 e0 02	 shl	 eax, 2
  0026e	48 98		 cdqe
  00270	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR two_back$[rsp]
  00278	48 03 c8	 add	 rcx, rax
  0027b	48 8b c1	 mov	 rax, rcx
  0027e	8b 4c 24 20	 mov	 ecx, DWORD PTR pi$[rsp]
  00282	c1 e1 02	 shl	 ecx, 2
  00285	48 63 c9	 movsxd	 rcx, ecx
  00288	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR g$[rsp]
  00290	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00294	48 03 d1	 add	 rdx, rcx
  00297	48 8b ca	 mov	 rcx, rdx
  0029a	41 b8 04 00 00
	00		 mov	 r8d, 4
  002a0	48 8b d0	 mov	 rdx, rax
  002a3	e8 00 00 00 00	 call	 memcpy
$LN27@stbi__gif_:

; 6816 :                 }
; 6817 :             }

  002a8	eb 90		 jmp	 SHORT $LN2@stbi__gif_
$LN3@stbi__gif_:

; 6818 :         } else if (dispose == 2) {

  002aa	e9 85 00 00 00	 jmp	 $LN26@stbi__gif_
$LN25@stbi__gif_:
  002af	83 7c 24 2c 02	 cmp	 DWORD PTR dispose$[rsp], 2
  002b4	75 7e		 jne	 SHORT $LN28@stbi__gif_

; 6819 :             // restore what was changed last frame to background before that frame;
; 6820 :             for (pi = 0; pi < pcount; ++pi) {

  002b6	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR pi$[rsp], 0
  002be	eb 0a		 jmp	 SHORT $LN7@stbi__gif_
$LN5@stbi__gif_:
  002c0	8b 44 24 20	 mov	 eax, DWORD PTR pi$[rsp]
  002c4	ff c0		 inc	 eax
  002c6	89 44 24 20	 mov	 DWORD PTR pi$[rsp], eax
$LN7@stbi__gif_:
  002ca	8b 44 24 24	 mov	 eax, DWORD PTR pcount$[rsp]
  002ce	39 44 24 20	 cmp	 DWORD PTR pi$[rsp], eax
  002d2	7d 60		 jge	 SHORT $LN6@stbi__gif_

; 6821 :                 if (g->history[pi]) {

  002d4	48 63 44 24 20	 movsxd	 rax, DWORD PTR pi$[rsp]
  002d9	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  002e1	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  002e5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002e9	85 c0		 test	 eax, eax
  002eb	74 45		 je	 SHORT $LN30@stbi__gif_

; 6822 :                     memcpy( &g->out[pi * 4], &g->background[pi * 4], 4 );

  002ed	8b 44 24 20	 mov	 eax, DWORD PTR pi$[rsp]
  002f1	c1 e0 02	 shl	 eax, 2
  002f4	48 98		 cdqe
  002f6	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  002fe	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00302	48 03 c8	 add	 rcx, rax
  00305	48 8b c1	 mov	 rax, rcx
  00308	8b 4c 24 20	 mov	 ecx, DWORD PTR pi$[rsp]
  0030c	c1 e1 02	 shl	 ecx, 2
  0030f	48 63 c9	 movsxd	 rcx, ecx
  00312	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR g$[rsp]
  0031a	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  0031e	48 03 d1	 add	 rdx, rcx
  00321	48 8b ca	 mov	 rcx, rdx
  00324	41 b8 04 00 00
	00		 mov	 r8d, 4
  0032a	48 8b d0	 mov	 rdx, rax
  0032d	e8 00 00 00 00	 call	 memcpy
$LN30@stbi__gif_:

; 6823 :                 }
; 6824 :             }

  00332	eb 8c		 jmp	 SHORT $LN5@stbi__gif_
$LN6@stbi__gif_:
$LN28@stbi__gif_:
$LN26@stbi__gif_:

; 6825 :         } else {
; 6826 :             // This is a non-disposal case eithe way, so just
; 6827 :             // leave the pixels as is, and they will become the new background
; 6828 :             // 1: do not dispose
; 6829 :             // 0:  not specified.
; 6830 :         }
; 6831 :         
; 6832 :         // background is what out is after the undoing of the previou frame;
; 6833 :         memcpy( g->background, g->out, 4 * g->w * g->h );

  00334	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  0033c	8b 00		 mov	 eax, DWORD PTR [rax]
  0033e	c1 e0 02	 shl	 eax, 2
  00341	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00349	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  0034d	48 98		 cdqe
  0034f	4c 8b c0	 mov	 r8, rax
  00352	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  0035a	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0035e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00366	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0036a	e8 00 00 00 00	 call	 memcpy
$LN19@stbi__gif_:

; 6834 :     }
; 6835 :     
; 6836 :     // clear my history;
; 6837 :     memset( g->history, 0x00, g->w * g->h );        // pixels that were affected previous frame

  0036f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00377	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0037f	8b 00		 mov	 eax, DWORD PTR [rax]
  00381	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  00385	48 98		 cdqe
  00387	4c 8b c0	 mov	 r8, rax
  0038a	33 d2		 xor	 edx, edx
  0038c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00394	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00398	e8 00 00 00 00	 call	 memset
$LN8@stbi__gif_:

; 6838 :     
; 6839 :     for (;;) {
; 6840 :         int tag = stbi__get8(s);

  0039d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003a5	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  003aa	0f b6 c0	 movzx	 eax, al
  003ad	89 44 24 60	 mov	 DWORD PTR tag$6[rsp], eax

; 6841 :         switch (tag) {

  003b1	8b 44 24 60	 mov	 eax, DWORD PTR tag$6[rsp]
  003b5	89 44 24 30	 mov	 DWORD PTR tv234[rsp], eax
  003b9	83 7c 24 30 21	 cmp	 DWORD PTR tv234[rsp], 33 ; 00000021H
  003be	0f 84 6d 04 00
	00		 je	 $LN44@stbi__gif_
  003c4	83 7c 24 30 2c	 cmp	 DWORD PTR tv234[rsp], 44 ; 0000002cH
  003c9	74 10		 je	 SHORT $LN31@stbi__gif_
  003cb	83 7c 24 30 3b	 cmp	 DWORD PTR tv234[rsp], 59 ; 0000003bH
  003d0	0f 84 d2 05 00
	00		 je	 $LN52@stbi__gif_
  003d6	e9 d7 05 00 00	 jmp	 $LN53@stbi__gif_
$LN31@stbi__gif_:

; 6842 :             case 0x2C: /* Image Descriptor */
; 6843 :             {
; 6844 :                 stbi__int32 x, y, w, h;
; 6845 :                 stbi_uc *o;
; 6846 :                 
; 6847 :                 x = stbi__get16le(s);

  003db	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003e3	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  003e8	89 44 24 44	 mov	 DWORD PTR x$3[rsp], eax

; 6848 :                 y = stbi__get16le(s);

  003ec	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003f4	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  003f9	89 44 24 48	 mov	 DWORD PTR y$4[rsp], eax

; 6849 :                 w = stbi__get16le(s);

  003fd	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00405	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  0040a	89 44 24 34	 mov	 DWORD PTR w$2[rsp], eax

; 6850 :                 h = stbi__get16le(s);

  0040e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00416	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  0041b	89 44 24 4c	 mov	 DWORD PTR h$5[rsp], eax

; 6851 :                 if (((x + w) > (g->w)) || ((y + h) > (g->h)))

  0041f	8b 44 24 34	 mov	 eax, DWORD PTR w$2[rsp]
  00423	8b 4c 24 44	 mov	 ecx, DWORD PTR x$3[rsp]
  00427	03 c8		 add	 ecx, eax
  00429	8b c1		 mov	 eax, ecx
  0042b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00433	3b 01		 cmp	 eax, DWORD PTR [rcx]
  00435	7f 19		 jg	 SHORT $LN33@stbi__gif_
  00437	8b 44 24 4c	 mov	 eax, DWORD PTR h$5[rsp]
  0043b	8b 4c 24 48	 mov	 ecx, DWORD PTR y$4[rsp]
  0043f	03 c8		 add	 ecx, eax
  00441	8b c1		 mov	 eax, ecx
  00443	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0044b	3b 41 04	 cmp	 eax, DWORD PTR [rcx+4]
  0044e	7e 2c		 jle	 SHORT $LN32@stbi__gif_
$LN33@stbi__gif_:

; 6852 :                     return stbi__errpuc("bad Image Descriptor", "Corrupt GIF");

  00450	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81904
  00457	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0045c	85 c0		 test	 eax, eax
  0045e	74 0a		 je	 SHORT $LN59@stbi__gif_
  00460	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv252[rsp], 0
  00468	eb 08		 jmp	 SHORT $LN60@stbi__gif_
$LN59@stbi__gif_:
  0046a	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv252[rsp], 0
$LN60@stbi__gif_:
  00472	48 63 44 24 40	 movsxd	 rax, DWORD PTR tv252[rsp]
  00477	e9 64 05 00 00	 jmp	 $LN1@stbi__gif_
$LN32@stbi__gif_:

; 6853 :                 
; 6854 :                 g->line_size = g->w * 4;

  0047c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00484	8b 00		 mov	 eax, DWORD PTR [rax]
  00486	c1 e0 02	 shl	 eax, 2
  00489	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00491	89 81 64 88 00
	00		 mov	 DWORD PTR [rcx+34916], eax

; 6855 :                 g->start_x = x * 4;

  00497	8b 44 24 44	 mov	 eax, DWORD PTR x$3[rsp]
  0049b	c1 e0 02	 shl	 eax, 2
  0049e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  004a6	89 81 4c 88 00
	00		 mov	 DWORD PTR [rcx+34892], eax

; 6856 :                 g->start_y = y * g->line_size;

  004ac	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  004b4	8b 4c 24 48	 mov	 ecx, DWORD PTR y$4[rsp]
  004b8	0f af 88 64 88
	00 00		 imul	 ecx, DWORD PTR [rax+34916]
  004bf	8b c1		 mov	 eax, ecx
  004c1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  004c9	89 81 50 88 00
	00		 mov	 DWORD PTR [rcx+34896], eax

; 6857 :                 g->max_x   = g->start_x + w * 4;

  004cf	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  004d7	8b 80 4c 88 00
	00		 mov	 eax, DWORD PTR [rax+34892]
  004dd	8b 4c 24 34	 mov	 ecx, DWORD PTR w$2[rsp]
  004e1	8d 04 88	 lea	 eax, DWORD PTR [rax+rcx*4]
  004e4	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  004ec	89 81 54 88 00
	00		 mov	 DWORD PTR [rcx+34900], eax

; 6858 :                 g->max_y   = g->start_y + h * g->line_size;

  004f2	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  004fa	8b 4c 24 4c	 mov	 ecx, DWORD PTR h$5[rsp]
  004fe	0f af 88 64 88
	00 00		 imul	 ecx, DWORD PTR [rax+34916]
  00505	8b c1		 mov	 eax, ecx
  00507	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0050f	03 81 50 88 00
	00		 add	 eax, DWORD PTR [rcx+34896]
  00515	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0051d	89 81 58 88 00
	00		 mov	 DWORD PTR [rcx+34904], eax

; 6859 :                 g->cur_x   = g->start_x;

  00523	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  0052b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00533	8b 89 4c 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34892]
  00539	89 88 5c 88 00
	00		 mov	 DWORD PTR [rax+34908], ecx

; 6860 :                 g->cur_y   = g->start_y;

  0053f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00547	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0054f	8b 89 50 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34896]
  00555	89 88 60 88 00
	00		 mov	 DWORD PTR [rax+34912], ecx

; 6861 :                 
; 6862 :                 // if the width of the specified rectangle is 0, that means
; 6863 :                 // we may not see *any* pixels or the image is malformed;
; 6864 :                 // to make sure this is caught, move the current y down to
; 6865 :                 // max_y (which is what out_gif_code checks).
; 6866 :                 if (w == 0)

  0055b	83 7c 24 34 00	 cmp	 DWORD PTR w$2[rsp], 0
  00560	75 1c		 jne	 SHORT $LN34@stbi__gif_

; 6867 :                     g->cur_y = g->max_y;

  00562	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  0056a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00572	8b 89 58 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34904]
  00578	89 88 60 88 00
	00		 mov	 DWORD PTR [rax+34912], ecx
$LN34@stbi__gif_:

; 6868 :                 
; 6869 :                 g->lflags = stbi__get8(s);

  0057e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00586	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0058b	0f b6 c0	 movzx	 eax, al
  0058e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00596	89 81 48 88 00
	00		 mov	 DWORD PTR [rcx+34888], eax

; 6870 :                 
; 6871 :                 if (g->lflags & 0x40) {

  0059c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  005a4	8b 80 48 88 00
	00		 mov	 eax, DWORD PTR [rax+34888]
  005aa	83 e0 40	 and	 eax, 64			; 00000040H
  005ad	85 c0		 test	 eax, eax
  005af	74 33		 je	 SHORT $LN35@stbi__gif_

; 6872 :                     g->step = 8 * g->line_size; // first interlaced spacing

  005b1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  005b9	8b 80 64 88 00
	00		 mov	 eax, DWORD PTR [rax+34916]
  005bf	c1 e0 03	 shl	 eax, 3
  005c2	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  005ca	89 81 44 88 00
	00		 mov	 DWORD PTR [rcx+34884], eax

; 6873 :                     g->parse = 3;

  005d0	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  005d8	c7 80 40 88 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+34880], 3

; 6874 :                 } else {

  005e2	eb 2e		 jmp	 SHORT $LN36@stbi__gif_
$LN35@stbi__gif_:

; 6875 :                     g->step = g->line_size;

  005e4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  005ec	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  005f4	8b 89 64 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34916]
  005fa	89 88 44 88 00
	00		 mov	 DWORD PTR [rax+34884], ecx

; 6876 :                     g->parse = 0;

  00600	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00608	c7 80 40 88 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+34880], 0
$LN36@stbi__gif_:

; 6877 :                 }
; 6878 :                 
; 6879 :                 if (g->lflags & 0x80) {

  00612	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  0061a	8b 80 48 88 00
	00		 mov	 eax, DWORD PTR [rax+34888]
  00620	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00625	85 c0		 test	 eax, eax
  00627	0f 84 94 00 00
	00		 je	 $LN37@stbi__gif_

; 6880 :                     stbi__gif_parse_colortable(s,g->lpal, 2 << (g->lflags & 7), g->eflags & 0x01 ? g->transparent : -1);

  0062d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00635	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00638	83 e0 01	 and	 eax, 1
  0063b	85 c0		 test	 eax, eax
  0063d	74 11		 je	 SHORT $LN61@stbi__gif_
  0063f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00647	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  0064a	89 44 24 50	 mov	 DWORD PTR tv299[rsp], eax
  0064e	eb 08		 jmp	 SHORT $LN62@stbi__gif_
$LN61@stbi__gif_:
  00650	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR tv299[rsp], -1
$LN62@stbi__gif_:
  00658	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00660	8b 80 48 88 00
	00		 mov	 eax, DWORD PTR [rax+34888]
  00666	83 e0 07	 and	 eax, 7
  00669	b9 02 00 00 00	 mov	 ecx, 2
  0066e	89 4c 24 64	 mov	 DWORD PTR tv582[rsp], ecx
  00672	0f b6 c8	 movzx	 ecx, al
  00675	8b 44 24 64	 mov	 eax, DWORD PTR tv582[rsp]
  00679	d3 e0		 shl	 eax, cl
  0067b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00683	48 81 c1 34 04
	00 00		 add	 rcx, 1076		; 00000434H
  0068a	44 8b 4c 24 50	 mov	 r9d, DWORD PTR tv299[rsp]
  0068f	44 8b c0	 mov	 r8d, eax
  00692	48 8b d1	 mov	 rdx, rcx
  00695	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0069d	e8 00 00 00 00	 call	 ?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z ; stbi__gif_parse_colortable

; 6881 :                     g->color_table = (stbi_uc *) g->lpal;

  006a2	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  006aa	48 05 34 04 00
	00		 add	 rax, 1076		; 00000434H
  006b0	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  006b8	48 89 81 38 88
	00 00		 mov	 QWORD PTR [rcx+34872], rax
  006bf	eb 5d		 jmp	 SHORT $LN38@stbi__gif_
$LN37@stbi__gif_:

; 6882 :                 } else if (g->flags & 0x80) {

  006c1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  006c9	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  006cc	25 80 00 00 00	 and	 eax, 128		; 00000080H
  006d1	85 c0		 test	 eax, eax
  006d3	74 1d		 je	 SHORT $LN39@stbi__gif_

; 6883 :                     g->color_table = (stbi_uc *) g->pal;

  006d5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  006dd	48 83 c0 34	 add	 rax, 52			; 00000034H
  006e1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  006e9	48 89 81 38 88
	00 00		 mov	 QWORD PTR [rcx+34872], rax

; 6884 :                 } else

  006f0	eb 2c		 jmp	 SHORT $LN40@stbi__gif_
$LN39@stbi__gif_:

; 6885 :                     return stbi__errpuc("missing color table", "Corrupt GIF");

  006f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81912
  006f9	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  006fe	85 c0		 test	 eax, eax
  00700	74 0a		 je	 SHORT $LN63@stbi__gif_
  00702	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv318[rsp], 0
  0070a	eb 08		 jmp	 SHORT $LN64@stbi__gif_
$LN63@stbi__gif_:
  0070c	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv318[rsp], 0
$LN64@stbi__gif_:
  00714	48 63 44 24 54	 movsxd	 rax, DWORD PTR tv318[rsp]
  00719	e9 c2 02 00 00	 jmp	 $LN1@stbi__gif_
$LN40@stbi__gif_:
$LN38@stbi__gif_:

; 6886 :                 
; 6887 :                 o = stbi__process_gif_raster(s, g);

  0071e	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR g$[rsp]
  00726	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0072e	e8 00 00 00 00	 call	 ?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z ; stbi__process_gif_raster
  00733	48 89 44 24 70	 mov	 QWORD PTR o$8[rsp], rax

; 6888 :                 if (!o) return NULL;

  00738	48 83 7c 24 70
	00		 cmp	 QWORD PTR o$8[rsp], 0
  0073e	75 07		 jne	 SHORT $LN41@stbi__gif_
  00740	33 c0		 xor	 eax, eax
  00742	e9 99 02 00 00	 jmp	 $LN1@stbi__gif_
$LN41@stbi__gif_:

; 6889 :                 
; 6890 :                 // if this was the first frame,
; 6891 :                 pcount = g->w * g->h;

  00747	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  0074f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00757	8b 00		 mov	 eax, DWORD PTR [rax]
  00759	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  0075d	89 44 24 24	 mov	 DWORD PTR pcount$[rsp], eax

; 6892 :                 if (first_frame && (g->bgindex > 0)) {

  00761	83 7c 24 58 00	 cmp	 DWORD PTR first_frame$[rsp], 0
  00766	0f 84 bb 00 00
	00		 je	 $LN42@stbi__gif_
  0076c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00774	83 78 24 00	 cmp	 DWORD PTR [rax+36], 0
  00778	0f 8e a9 00 00
	00		 jle	 $LN42@stbi__gif_

; 6893 :                     // if first frame, any pixel not drawn to gets the background color
; 6894 :                     for (pi = 0; pi < pcount; ++pi) {

  0077e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR pi$[rsp], 0
  00786	eb 0a		 jmp	 SHORT $LN15@stbi__gif_
$LN13@stbi__gif_:
  00788	8b 44 24 20	 mov	 eax, DWORD PTR pi$[rsp]
  0078c	ff c0		 inc	 eax
  0078e	89 44 24 20	 mov	 DWORD PTR pi$[rsp], eax
$LN15@stbi__gif_:
  00792	8b 44 24 24	 mov	 eax, DWORD PTR pcount$[rsp]
  00796	39 44 24 20	 cmp	 DWORD PTR pi$[rsp], eax
  0079a	0f 8d 87 00 00
	00		 jge	 $LN14@stbi__gif_

; 6895 :                         if (g->history[pi] == 0) {

  007a0	48 63 44 24 20	 movsxd	 rax, DWORD PTR pi$[rsp]
  007a5	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  007ad	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  007b1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  007b5	85 c0		 test	 eax, eax
  007b7	75 69		 jne	 SHORT $LN43@stbi__gif_

; 6896 :                             g->pal[g->bgindex][3] = 255; // just in case it was made transparent, undo that; It will be reset next frame if need be;

  007b9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  007c1	48 63 40 24	 movsxd	 rax, DWORD PTR [rax+36]
  007c5	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  007cd	48 8d 44 81 34	 lea	 rax, QWORD PTR [rcx+rax*4+52]
  007d2	b9 01 00 00 00	 mov	 ecx, 1
  007d7	48 6b c9 03	 imul	 rcx, rcx, 3
  007db	c6 04 08 ff	 mov	 BYTE PTR [rax+rcx], 255	; 000000ffH

; 6897 :                             memcpy( &g->out[pi * 4], &g->pal[g->bgindex], 4 );

  007df	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  007e7	48 63 40 24	 movsxd	 rax, DWORD PTR [rax+36]
  007eb	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  007f3	48 8d 44 81 34	 lea	 rax, QWORD PTR [rcx+rax*4+52]
  007f8	8b 4c 24 20	 mov	 ecx, DWORD PTR pi$[rsp]
  007fc	c1 e1 02	 shl	 ecx, 2
  007ff	48 63 c9	 movsxd	 rcx, ecx
  00802	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR g$[rsp]
  0080a	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  0080e	48 03 d1	 add	 rdx, rcx
  00811	48 8b ca	 mov	 rcx, rdx
  00814	41 b8 04 00 00
	00		 mov	 r8d, 4
  0081a	48 8b d0	 mov	 rdx, rax
  0081d	e8 00 00 00 00	 call	 memcpy
$LN43@stbi__gif_:

; 6898 :                         }
; 6899 :                     }

  00822	e9 61 ff ff ff	 jmp	 $LN13@stbi__gif_
$LN14@stbi__gif_:
$LN42@stbi__gif_:

; 6900 :                 }
; 6901 :                 
; 6902 :                 return o;

  00827	48 8b 44 24 70	 mov	 rax, QWORD PTR o$8[rsp]
  0082c	e9 af 01 00 00	 jmp	 $LN1@stbi__gif_
$LN44@stbi__gif_:

; 6903 :             }
; 6904 :             
; 6905 :             case 0x21: // Comment Extension.
; 6906 :             {
; 6907 :                 int len;
; 6908 :                 int ext = stbi__get8(s);

  00831	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00839	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0083e	0f b6 c0	 movzx	 eax, al
  00841	89 44 24 68	 mov	 DWORD PTR ext$7[rsp], eax

; 6909 :                 if (ext == 0xF9) { // Graphic Control Extension.

  00845	81 7c 24 68 f9
	00 00 00	 cmp	 DWORD PTR ext$7[rsp], 249 ; 000000f9H
  0084d	0f 85 25 01 00
	00		 jne	 $LN45@stbi__gif_

; 6910 :                     len = stbi__get8(s);

  00853	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0085b	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00860	0f b6 c0	 movzx	 eax, al
  00863	89 44 24 28	 mov	 DWORD PTR len$1[rsp], eax

; 6911 :                     if (len == 4) {

  00867	83 7c 24 28 04	 cmp	 DWORD PTR len$1[rsp], 4
  0086c	0f 85 f3 00 00
	00		 jne	 $LN46@stbi__gif_

; 6912 :                         g->eflags = stbi__get8(s);

  00872	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0087a	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0087f	0f b6 c0	 movzx	 eax, al
  00882	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0088a	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 6913 :                         g->delay = 10 * stbi__get16le(s); // delay - 1/100th of a second, saving as 1/1000ths.

  0088d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00895	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  0089a	6b c0 0a	 imul	 eax, eax, 10
  0089d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  008a5	89 81 68 88 00
	00		 mov	 DWORD PTR [rcx+34920], eax

; 6914 :                         
; 6915 :                         // unset old transparent
; 6916 :                         if (g->transparent >= 0) {

  008ab	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  008b3	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  008b7	7c 26		 jl	 SHORT $LN48@stbi__gif_

; 6917 :                             g->pal[g->transparent][3] = 255;

  008b9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  008c1	48 63 40 2c	 movsxd	 rax, DWORD PTR [rax+44]
  008c5	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  008cd	48 8d 44 81 34	 lea	 rax, QWORD PTR [rcx+rax*4+52]
  008d2	b9 01 00 00 00	 mov	 ecx, 1
  008d7	48 6b c9 03	 imul	 rcx, rcx, 3
  008db	c6 04 08 ff	 mov	 BYTE PTR [rax+rcx], 255	; 000000ffH
$LN48@stbi__gif_:

; 6918 :                         }
; 6919 :                         if (g->eflags & 0x01) {

  008df	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  008e7	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  008ea	83 e0 01	 and	 eax, 1
  008ed	85 c0		 test	 eax, eax
  008ef	74 51		 je	 SHORT $LN49@stbi__gif_

; 6920 :                             g->transparent = stbi__get8(s);

  008f1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  008f9	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  008fe	0f b6 c0	 movzx	 eax, al
  00901	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00909	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 6921 :                             if (g->transparent >= 0) {

  0090c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00914	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  00918	7c 26		 jl	 SHORT $LN51@stbi__gif_

; 6922 :                                 g->pal[g->transparent][3] = 0;

  0091a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00922	48 63 40 2c	 movsxd	 rax, DWORD PTR [rax+44]
  00926	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  0092e	48 8d 44 81 34	 lea	 rax, QWORD PTR [rcx+rax*4+52]
  00933	b9 01 00 00 00	 mov	 ecx, 1
  00938	48 6b c9 03	 imul	 rcx, rcx, 3
  0093c	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
$LN51@stbi__gif_:

; 6923 :                             }
; 6924 :                         } else {

  00940	eb 21		 jmp	 SHORT $LN50@stbi__gif_
$LN49@stbi__gif_:

; 6925 :                             // don't need transparent
; 6926 :                             stbi__skip(s, 1);

  00942	ba 01 00 00 00	 mov	 edx, 1
  00947	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0094f	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 6927 :                             g->transparent = -1;

  00954	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  0095c	c7 40 2c ff ff
	ff ff		 mov	 DWORD PTR [rax+44], -1
$LN50@stbi__gif_:

; 6928 :                         }
; 6929 :                     } else {

  00963	eb 13		 jmp	 SHORT $LN47@stbi__gif_
$LN46@stbi__gif_:

; 6930 :                         stbi__skip(s, len);

  00965	8b 54 24 28	 mov	 edx, DWORD PTR len$1[rsp]
  00969	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00971	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 6931 :                         break;

  00976	eb 63		 jmp	 SHORT $LN11@stbi__gif_
$LN47@stbi__gif_:
$LN45@stbi__gif_:
$LN16@stbi__gif_:

; 6932 :                     }
; 6933 :                 }
; 6934 :                 while ((len = stbi__get8(s)) != 0) {

  00978	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00980	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00985	0f b6 c0	 movzx	 eax, al
  00988	89 44 24 28	 mov	 DWORD PTR len$1[rsp], eax
  0098c	83 7c 24 28 00	 cmp	 DWORD PTR len$1[rsp], 0
  00991	74 13		 je	 SHORT $LN17@stbi__gif_

; 6935 :                     stbi__skip(s, len);

  00993	8b 54 24 28	 mov	 edx, DWORD PTR len$1[rsp]
  00997	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0099f	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 6936 :                 }

  009a4	eb d2		 jmp	 SHORT $LN16@stbi__gif_
$LN17@stbi__gif_:

; 6937 :                 break;

  009a6	eb 33		 jmp	 SHORT $LN11@stbi__gif_
$LN52@stbi__gif_:

; 6938 :             }
; 6939 :             
; 6940 :             case 0x3B: // gif stream termination code
; 6941 :             return (stbi_uc *) s; // using '1' causes warning on some compilers

  009a8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  009b0	eb 2e		 jmp	 SHORT $LN1@stbi__gif_
$LN53@stbi__gif_:

; 6942 :             
; 6943 :             default:
; 6944 :             return stbi__errpuc("unknown code", "Corrupt GIF");

  009b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81926
  009b9	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  009be	85 c0		 test	 eax, eax
  009c0	74 0a		 je	 SHORT $LN65@stbi__gif_
  009c2	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv413[rsp], 0
  009ca	eb 08		 jmp	 SHORT $LN66@stbi__gif_
$LN65@stbi__gif_:
  009cc	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv413[rsp], 0
$LN66@stbi__gif_:
  009d4	48 63 44 24 5c	 movsxd	 rax, DWORD PTR tv413[rsp]
  009d9	eb 05		 jmp	 SHORT $LN1@stbi__gif_
$LN11@stbi__gif_:

; 6945 :         }
; 6946 :     }

  009db	e9 bd f9 ff ff	 jmp	 $LN8@stbi__gif_
$LN1@stbi__gif_:

; 6947 : }

  009e0	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  009e7	c3		 ret	 0
?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHHPEAE@Z ENDP ; stbi__gif_load_next
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
lzw_cs$ = 32
tv192 = 33
avail$ = 36
len$ = 40
codesize$ = 44
init_code$ = 48
code$1 = 52
valid_bits$ = 56
bits$ = 60
clear$ = 64
oldcode$ = 68
codemask$ = 72
first$ = 76
tv163 = 80
tv175 = 84
tv197 = 88
tv210 = 92
p$ = 96
tv242 = 104
tv246 = 108
tv273 = 112
tv299 = 116
s$ = 144
g$ = 152
?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z PROC ; stbi__process_gif_raster

; 6689 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 6690 :     stbi_uc lzw_cs;
; 6691 :     stbi__int32 len, init_code;
; 6692 :     stbi__uint32 first;
; 6693 :     stbi__int32 codesize, codemask, avail, oldcode, bits, valid_bits, clear;
; 6694 :     stbi__gif_lzw *p;
; 6695 :     
; 6696 :     lzw_cs = stbi__get8(s);

  00011	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00019	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0001e	88 44 24 20	 mov	 BYTE PTR lzw_cs$[rsp], al

; 6697 :     if (lzw_cs > 12) return NULL;

  00022	0f b6 44 24 20	 movzx	 eax, BYTE PTR lzw_cs$[rsp]
  00027	83 f8 0c	 cmp	 eax, 12
  0002a	7e 07		 jle	 SHORT $LN10@stbi__proc
  0002c	33 c0		 xor	 eax, eax
  0002e	e9 0e 04 00 00	 jmp	 $LN1@stbi__proc
$LN10@stbi__proc:

; 6698 :     clear = 1 << lzw_cs;

  00033	0f b6 44 24 20	 movzx	 eax, BYTE PTR lzw_cs$[rsp]
  00038	b9 01 00 00 00	 mov	 ecx, 1
  0003d	89 4c 24 68	 mov	 DWORD PTR tv242[rsp], ecx
  00041	0f b6 c8	 movzx	 ecx, al
  00044	8b 44 24 68	 mov	 eax, DWORD PTR tv242[rsp]
  00048	d3 e0		 shl	 eax, cl
  0004a	89 44 24 40	 mov	 DWORD PTR clear$[rsp], eax

; 6699 :     first = 1;

  0004e	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR first$[rsp], 1

; 6700 :     codesize = lzw_cs + 1;

  00056	0f b6 44 24 20	 movzx	 eax, BYTE PTR lzw_cs$[rsp]
  0005b	ff c0		 inc	 eax
  0005d	89 44 24 2c	 mov	 DWORD PTR codesize$[rsp], eax

; 6701 :     codemask = (1 << codesize) - 1;

  00061	8b 44 24 2c	 mov	 eax, DWORD PTR codesize$[rsp]
  00065	b9 01 00 00 00	 mov	 ecx, 1
  0006a	89 4c 24 6c	 mov	 DWORD PTR tv246[rsp], ecx
  0006e	0f b6 c8	 movzx	 ecx, al
  00071	8b 44 24 6c	 mov	 eax, DWORD PTR tv246[rsp]
  00075	d3 e0		 shl	 eax, cl
  00077	ff c8		 dec	 eax
  00079	89 44 24 48	 mov	 DWORD PTR codemask$[rsp], eax

; 6702 :     bits = 0;

  0007d	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0

; 6703 :     valid_bits = 0;

  00085	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR valid_bits$[rsp], 0

; 6704 :     for (init_code = 0; init_code < clear; init_code++) {

  0008d	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR init_code$[rsp], 0
  00095	eb 0a		 jmp	 SHORT $LN4@stbi__proc
$LN2@stbi__proc:
  00097	8b 44 24 30	 mov	 eax, DWORD PTR init_code$[rsp]
  0009b	ff c0		 inc	 eax
  0009d	89 44 24 30	 mov	 DWORD PTR init_code$[rsp], eax
$LN4@stbi__proc:
  000a1	8b 44 24 40	 mov	 eax, DWORD PTR clear$[rsp]
  000a5	39 44 24 30	 cmp	 DWORD PTR init_code$[rsp], eax
  000a9	7d 4e		 jge	 SHORT $LN3@stbi__proc

; 6705 :         g->codes[init_code].prefix = -1;

  000ab	48 63 44 24 30	 movsxd	 rax, DWORD PTR init_code$[rsp]
  000b0	b9 ff ff ff ff	 mov	 ecx, -1
  000b5	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR g$[rsp]
  000bd	66 89 8c 82 34
	08 00 00	 mov	 WORD PTR [rdx+rax*4+2100], cx

; 6706 :         g->codes[init_code].first = (stbi_uc) init_code;

  000c5	48 63 44 24 30	 movsxd	 rax, DWORD PTR init_code$[rsp]
  000ca	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  000d2	0f b6 54 24 30	 movzx	 edx, BYTE PTR init_code$[rsp]
  000d7	88 94 81 36 08
	00 00		 mov	 BYTE PTR [rcx+rax*4+2102], dl

; 6707 :         g->codes[init_code].suffix = (stbi_uc) init_code;

  000de	48 63 44 24 30	 movsxd	 rax, DWORD PTR init_code$[rsp]
  000e3	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  000eb	0f b6 54 24 30	 movzx	 edx, BYTE PTR init_code$[rsp]
  000f0	88 94 81 37 08
	00 00		 mov	 BYTE PTR [rcx+rax*4+2103], dl

; 6708 :     }

  000f7	eb 9e		 jmp	 SHORT $LN2@stbi__proc
$LN3@stbi__proc:

; 6709 :     
; 6710 :     // support no starting clear code
; 6711 :     avail = clear+2;

  000f9	8b 44 24 40	 mov	 eax, DWORD PTR clear$[rsp]
  000fd	83 c0 02	 add	 eax, 2
  00100	89 44 24 24	 mov	 DWORD PTR avail$[rsp], eax

; 6712 :     oldcode = -1;

  00104	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR oldcode$[rsp], -1

; 6713 :     
; 6714 :     len = 0;

  0010c	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0
$LN5@stbi__proc:

; 6715 :     for(;;) {
; 6716 :         if (valid_bits < codesize) {

  00114	8b 44 24 2c	 mov	 eax, DWORD PTR codesize$[rsp]
  00118	39 44 24 38	 cmp	 DWORD PTR valid_bits$[rsp], eax
  0011c	7d 6f		 jge	 SHORT $LN11@stbi__proc

; 6717 :             if (len == 0) {

  0011e	83 7c 24 28 00	 cmp	 DWORD PTR len$[rsp], 0
  00123	75 2c		 jne	 SHORT $LN13@stbi__proc

; 6718 :                 len = stbi__get8(s); // start new block

  00125	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0012d	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00132	0f b6 c0	 movzx	 eax, al
  00135	89 44 24 28	 mov	 DWORD PTR len$[rsp], eax

; 6719 :                 if (len == 0)

  00139	83 7c 24 28 00	 cmp	 DWORD PTR len$[rsp], 0
  0013e	75 11		 jne	 SHORT $LN14@stbi__proc

; 6720 :                     return g->out;

  00140	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00148	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0014c	e9 f0 02 00 00	 jmp	 $LN1@stbi__proc
$LN14@stbi__proc:
$LN13@stbi__proc:

; 6721 :             }
; 6722 :             --len;

  00151	8b 44 24 28	 mov	 eax, DWORD PTR len$[rsp]
  00155	ff c8		 dec	 eax
  00157	89 44 24 28	 mov	 DWORD PTR len$[rsp], eax

; 6723 :             bits |= (stbi__int32) stbi__get8(s) << valid_bits;

  0015b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00163	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00168	0f b6 c0	 movzx	 eax, al
  0016b	8b 4c 24 38	 mov	 ecx, DWORD PTR valid_bits$[rsp]
  0016f	d3 e0		 shl	 eax, cl
  00171	8b 4c 24 3c	 mov	 ecx, DWORD PTR bits$[rsp]
  00175	0b c8		 or	 ecx, eax
  00177	8b c1		 mov	 eax, ecx
  00179	89 44 24 3c	 mov	 DWORD PTR bits$[rsp], eax

; 6724 :             valid_bits += 8;

  0017d	8b 44 24 38	 mov	 eax, DWORD PTR valid_bits$[rsp]
  00181	83 c0 08	 add	 eax, 8
  00184	89 44 24 38	 mov	 DWORD PTR valid_bits$[rsp], eax

; 6725 :         } else {

  00188	e9 af 02 00 00	 jmp	 $LN12@stbi__proc
$LN11@stbi__proc:

; 6726 :             stbi__int32 code = bits & codemask;

  0018d	8b 44 24 48	 mov	 eax, DWORD PTR codemask$[rsp]
  00191	8b 4c 24 3c	 mov	 ecx, DWORD PTR bits$[rsp]
  00195	23 c8		 and	 ecx, eax
  00197	8b c1		 mov	 eax, ecx
  00199	89 44 24 34	 mov	 DWORD PTR code$1[rsp], eax

; 6727 :             bits >>= codesize;

  0019d	8b 44 24 2c	 mov	 eax, DWORD PTR codesize$[rsp]
  001a1	0f b6 c8	 movzx	 ecx, al
  001a4	8b 44 24 3c	 mov	 eax, DWORD PTR bits$[rsp]
  001a8	d3 f8		 sar	 eax, cl
  001aa	89 44 24 3c	 mov	 DWORD PTR bits$[rsp], eax

; 6728 :             valid_bits -= codesize;

  001ae	8b 44 24 2c	 mov	 eax, DWORD PTR codesize$[rsp]
  001b2	8b 4c 24 38	 mov	 ecx, DWORD PTR valid_bits$[rsp]
  001b6	2b c8		 sub	 ecx, eax
  001b8	8b c1		 mov	 eax, ecx
  001ba	89 44 24 38	 mov	 DWORD PTR valid_bits$[rsp], eax

; 6729 :             // @OPTIMIZE: is there some way we can accelerate the non-clear path?
; 6730 :             if (code == clear) {  // clear code

  001be	8b 44 24 40	 mov	 eax, DWORD PTR clear$[rsp]
  001c2	39 44 24 34	 cmp	 DWORD PTR code$1[rsp], eax
  001c6	75 47		 jne	 SHORT $LN15@stbi__proc

; 6731 :                 codesize = lzw_cs + 1;

  001c8	0f b6 44 24 20	 movzx	 eax, BYTE PTR lzw_cs$[rsp]
  001cd	ff c0		 inc	 eax
  001cf	89 44 24 2c	 mov	 DWORD PTR codesize$[rsp], eax

; 6732 :                 codemask = (1 << codesize) - 1;

  001d3	8b 44 24 2c	 mov	 eax, DWORD PTR codesize$[rsp]
  001d7	b9 01 00 00 00	 mov	 ecx, 1
  001dc	89 4c 24 70	 mov	 DWORD PTR tv273[rsp], ecx
  001e0	0f b6 c8	 movzx	 ecx, al
  001e3	8b 44 24 70	 mov	 eax, DWORD PTR tv273[rsp]
  001e7	d3 e0		 shl	 eax, cl
  001e9	ff c8		 dec	 eax
  001eb	89 44 24 48	 mov	 DWORD PTR codemask$[rsp], eax

; 6733 :                 avail = clear + 2;

  001ef	8b 44 24 40	 mov	 eax, DWORD PTR clear$[rsp]
  001f3	83 c0 02	 add	 eax, 2
  001f6	89 44 24 24	 mov	 DWORD PTR avail$[rsp], eax

; 6734 :                 oldcode = -1;

  001fa	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR oldcode$[rsp], -1

; 6735 :                 first = 0;

  00202	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR first$[rsp], 0
  0020a	e9 2d 02 00 00	 jmp	 $LN16@stbi__proc
$LN15@stbi__proc:

; 6736 :             } else if (code == clear + 1) { // end of stream code

  0020f	8b 44 24 40	 mov	 eax, DWORD PTR clear$[rsp]
  00213	ff c0		 inc	 eax
  00215	39 44 24 34	 cmp	 DWORD PTR code$1[rsp], eax
  00219	75 55		 jne	 SHORT $LN17@stbi__proc

; 6737 :                 stbi__skip(s, len);

  0021b	8b 54 24 28	 mov	 edx, DWORD PTR len$[rsp]
  0021f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00227	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip
$LN8@stbi__proc:

; 6738 :                 while ((len = stbi__get8(s)) > 0)

  0022c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00234	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00239	0f b6 c0	 movzx	 eax, al
  0023c	89 44 24 28	 mov	 DWORD PTR len$[rsp], eax
  00240	83 7c 24 28 00	 cmp	 DWORD PTR len$[rsp], 0
  00245	7e 13		 jle	 SHORT $LN9@stbi__proc

; 6739 :                     stbi__skip(s,len);

  00247	8b 54 24 28	 mov	 edx, DWORD PTR len$[rsp]
  0024b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00253	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip
  00258	eb d2		 jmp	 SHORT $LN8@stbi__proc
$LN9@stbi__proc:

; 6740 :                 return g->out;

  0025a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR g$[rsp]
  00262	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00266	e9 d6 01 00 00	 jmp	 $LN1@stbi__proc
  0026b	e9 cc 01 00 00	 jmp	 $LN18@stbi__proc
$LN17@stbi__proc:

; 6741 :             } else if (code <= avail) {

  00270	8b 44 24 24	 mov	 eax, DWORD PTR avail$[rsp]
  00274	39 44 24 34	 cmp	 DWORD PTR code$1[rsp], eax
  00278	0f 8f 95 01 00
	00		 jg	 $LN19@stbi__proc

; 6742 :                 if (first) {

  0027e	83 7c 24 4c 00	 cmp	 DWORD PTR first$[rsp], 0
  00283	74 2c		 je	 SHORT $LN21@stbi__proc

; 6743 :                     return stbi__errpuc("no clear code", "Corrupt GIF");

  00285	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81825
  0028c	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00291	85 c0		 test	 eax, eax
  00293	74 0a		 je	 SHORT $LN28@stbi__proc
  00295	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv163[rsp], 0
  0029d	eb 08		 jmp	 SHORT $LN29@stbi__proc
$LN28@stbi__proc:
  0029f	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv163[rsp], 0
$LN29@stbi__proc:
  002a7	48 63 44 24 50	 movsxd	 rax, DWORD PTR tv163[rsp]
  002ac	e9 90 01 00 00	 jmp	 $LN1@stbi__proc
$LN21@stbi__proc:

; 6744 :                 }
; 6745 :                 
; 6746 :                 if (oldcode >= 0) {

  002b1	83 7c 24 44 00	 cmp	 DWORD PTR oldcode$[rsp], 0
  002b6	0f 8c c5 00 00
	00		 jl	 $LN22@stbi__proc

; 6747 :                     p = &g->codes[avail++];

  002bc	48 63 44 24 24	 movsxd	 rax, DWORD PTR avail$[rsp]
  002c1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  002c9	48 8d 84 81 34
	08 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+2100]
  002d1	48 89 44 24 60	 mov	 QWORD PTR p$[rsp], rax
  002d6	8b 44 24 24	 mov	 eax, DWORD PTR avail$[rsp]
  002da	ff c0		 inc	 eax
  002dc	89 44 24 24	 mov	 DWORD PTR avail$[rsp], eax

; 6748 :                     if (avail > 8192) {

  002e0	81 7c 24 24 00
	20 00 00	 cmp	 DWORD PTR avail$[rsp], 8192 ; 00002000H
  002e8	7e 2c		 jle	 SHORT $LN24@stbi__proc

; 6749 :                         return stbi__errpuc("too many codes", "Corrupt GIF");

  002ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81829
  002f1	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  002f6	85 c0		 test	 eax, eax
  002f8	74 0a		 je	 SHORT $LN30@stbi__proc
  002fa	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv175[rsp], 0
  00302	eb 08		 jmp	 SHORT $LN31@stbi__proc
$LN30@stbi__proc:
  00304	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv175[rsp], 0
$LN31@stbi__proc:
  0030c	48 63 44 24 54	 movsxd	 rax, DWORD PTR tv175[rsp]
  00311	e9 2b 01 00 00	 jmp	 $LN1@stbi__proc
$LN24@stbi__proc:

; 6750 :                     }
; 6751 :                     
; 6752 :                     p->prefix = (stbi__int16) oldcode;

  00316	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  0031b	0f b7 4c 24 44	 movzx	 ecx, WORD PTR oldcode$[rsp]
  00320	66 89 08	 mov	 WORD PTR [rax], cx

; 6753 :                     p->first = g->codes[oldcode].first;

  00323	48 63 44 24 44	 movsxd	 rax, DWORD PTR oldcode$[rsp]
  00328	48 8b 4c 24 60	 mov	 rcx, QWORD PTR p$[rsp]
  0032d	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR g$[rsp]
  00335	0f b6 84 82 36
	08 00 00	 movzx	 eax, BYTE PTR [rdx+rax*4+2102]
  0033d	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 6754 :                     p->suffix = (code == avail) ? p->first : g->codes[code].first;

  00340	8b 44 24 24	 mov	 eax, DWORD PTR avail$[rsp]
  00344	39 44 24 34	 cmp	 DWORD PTR code$1[rsp], eax
  00348	75 0f		 jne	 SHORT $LN32@stbi__proc
  0034a	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  0034f	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00353	88 44 24 21	 mov	 BYTE PTR tv192[rsp], al
  00357	eb 19		 jmp	 SHORT $LN33@stbi__proc
$LN32@stbi__proc:
  00359	48 63 44 24 34	 movsxd	 rax, DWORD PTR code$1[rsp]
  0035e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  00366	0f b6 84 81 36
	08 00 00	 movzx	 eax, BYTE PTR [rcx+rax*4+2102]
  0036e	88 44 24 21	 mov	 BYTE PTR tv192[rsp], al
$LN33@stbi__proc:
  00372	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  00377	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR tv192[rsp]
  0037c	88 48 03	 mov	 BYTE PTR [rax+3], cl
  0037f	eb 36		 jmp	 SHORT $LN23@stbi__proc
$LN22@stbi__proc:

; 6755 :                 } else if (code == avail)

  00381	8b 44 24 24	 mov	 eax, DWORD PTR avail$[rsp]
  00385	39 44 24 34	 cmp	 DWORD PTR code$1[rsp], eax
  00389	75 2c		 jne	 SHORT $LN25@stbi__proc

; 6756 :                     return stbi__errpuc("illegal code in raster", "Corrupt GIF");

  0038b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81831
  00392	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00397	85 c0		 test	 eax, eax
  00399	74 0a		 je	 SHORT $LN34@stbi__proc
  0039b	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv197[rsp], 0
  003a3	eb 08		 jmp	 SHORT $LN35@stbi__proc
$LN34@stbi__proc:
  003a5	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv197[rsp], 0
$LN35@stbi__proc:
  003ad	48 63 44 24 58	 movsxd	 rax, DWORD PTR tv197[rsp]
  003b2	e9 8a 00 00 00	 jmp	 $LN1@stbi__proc
$LN25@stbi__proc:
$LN23@stbi__proc:

; 6757 :                 
; 6758 :                 stbi__out_gif_code(g, (stbi__uint16) code);

  003b7	0f b7 54 24 34	 movzx	 edx, WORD PTR code$1[rsp]
  003bc	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR g$[rsp]
  003c4	e8 00 00 00 00	 call	 ?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z ; stbi__out_gif_code

; 6759 :                 
; 6760 :                 if ((avail & codemask) == 0 && avail <= 0x0FFF) {

  003c9	8b 44 24 48	 mov	 eax, DWORD PTR codemask$[rsp]
  003cd	8b 4c 24 24	 mov	 ecx, DWORD PTR avail$[rsp]
  003d1	23 c8		 and	 ecx, eax
  003d3	8b c1		 mov	 eax, ecx
  003d5	85 c0		 test	 eax, eax
  003d7	75 30		 jne	 SHORT $LN26@stbi__proc
  003d9	81 7c 24 24 ff
	0f 00 00	 cmp	 DWORD PTR avail$[rsp], 4095 ; 00000fffH
  003e1	7f 26		 jg	 SHORT $LN26@stbi__proc

; 6761 :                     codesize++;

  003e3	8b 44 24 2c	 mov	 eax, DWORD PTR codesize$[rsp]
  003e7	ff c0		 inc	 eax
  003e9	89 44 24 2c	 mov	 DWORD PTR codesize$[rsp], eax

; 6762 :                     codemask = (1 << codesize) - 1;

  003ed	8b 44 24 2c	 mov	 eax, DWORD PTR codesize$[rsp]
  003f1	b9 01 00 00 00	 mov	 ecx, 1
  003f6	89 4c 24 74	 mov	 DWORD PTR tv299[rsp], ecx
  003fa	0f b6 c8	 movzx	 ecx, al
  003fd	8b 44 24 74	 mov	 eax, DWORD PTR tv299[rsp]
  00401	d3 e0		 shl	 eax, cl
  00403	ff c8		 dec	 eax
  00405	89 44 24 48	 mov	 DWORD PTR codemask$[rsp], eax
$LN26@stbi__proc:

; 6763 :                 }
; 6764 :                 
; 6765 :                 oldcode = code;

  00409	8b 44 24 34	 mov	 eax, DWORD PTR code$1[rsp]
  0040d	89 44 24 44	 mov	 DWORD PTR oldcode$[rsp], eax

; 6766 :             } else {

  00411	eb 29		 jmp	 SHORT $LN20@stbi__proc
$LN19@stbi__proc:

; 6767 :                 return stbi__errpuc("illegal code in raster", "Corrupt GIF");

  00413	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81833
  0041a	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0041f	85 c0		 test	 eax, eax
  00421	74 0a		 je	 SHORT $LN36@stbi__proc
  00423	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv210[rsp], 0
  0042b	eb 08		 jmp	 SHORT $LN37@stbi__proc
$LN36@stbi__proc:
  0042d	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv210[rsp], 0
$LN37@stbi__proc:
  00435	48 63 44 24 5c	 movsxd	 rax, DWORD PTR tv210[rsp]
  0043a	eb 05		 jmp	 SHORT $LN1@stbi__proc
$LN20@stbi__proc:
$LN18@stbi__proc:
$LN16@stbi__proc:
$LN12@stbi__proc:

; 6768 :             }
; 6769 :         }
; 6770 :     }

  0043c	e9 d3 fc ff ff	 jmp	 $LN5@stbi__proc
$LN1@stbi__proc:

; 6771 : }

  00441	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00448	c3		 ret	 0
?stbi__process_gif_raster@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@@Z ENDP ; stbi__process_gif_raster
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
idx$ = 32
tv256 = 36
c$ = 40
p$ = 48
g$ = 80
code$ = 88
?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z PROC		; stbi__out_gif_code

; 6652 : {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 6653 :     stbi_uc *p, *c;
; 6654 :     int idx;
; 6655 :     
; 6656 :     // recurse to decode the prefixes, since the linked-list is backwards,
; 6657 :     // and working backwards through an interleaved image would be nasty
; 6658 :     if (g->codes[code].prefix >= 0)

  0000e	0f b7 44 24 58	 movzx	 eax, WORD PTR code$[rsp]
  00013	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  00018	0f bf 84 81 34
	08 00 00	 movsx	 eax, WORD PTR [rcx+rax*4+2100]
  00020	85 c0		 test	 eax, eax
  00022	7c 1c		 jl	 SHORT $LN4@stbi__out_

; 6659 :         stbi__out_gif_code(g, g->codes[code].prefix);

  00024	0f b7 44 24 58	 movzx	 eax, WORD PTR code$[rsp]
  00029	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  0002e	0f b7 94 81 34
	08 00 00	 movzx	 edx, WORD PTR [rcx+rax*4+2100]
  00036	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  0003b	e8 00 00 00 00	 call	 ?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z ; stbi__out_gif_code
$LN4@stbi__out_:

; 6660 :     
; 6661 :     if (g->cur_y >= g->max_y) return;

  00040	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  00045	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  0004a	8b 89 58 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34904]
  00050	39 88 60 88 00
	00		 cmp	 DWORD PTR [rax+34912], ecx
  00056	7c 05		 jl	 SHORT $LN5@stbi__out_
  00058	e9 34 02 00 00	 jmp	 $LN1@stbi__out_
$LN5@stbi__out_:

; 6662 :     
; 6663 :     idx = g->cur_x + g->cur_y;

  0005d	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  00062	8b 80 5c 88 00
	00		 mov	 eax, DWORD PTR [rax+34908]
  00068	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  0006d	03 81 60 88 00
	00		 add	 eax, DWORD PTR [rcx+34912]
  00073	89 44 24 20	 mov	 DWORD PTR idx$[rsp], eax

; 6664 :     p = &g->out[idx];

  00077	48 63 44 24 20	 movsxd	 rax, DWORD PTR idx$[rsp]
  0007c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  00081	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00085	48 03 c8	 add	 rcx, rax
  00088	48 8b c1	 mov	 rax, rcx
  0008b	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 6665 :     g->history[idx / 4] = 1;

  00090	8b 44 24 20	 mov	 eax, DWORD PTR idx$[rsp]
  00094	99		 cdq
  00095	83 e2 03	 and	 edx, 3
  00098	03 c2		 add	 eax, edx
  0009a	c1 f8 02	 sar	 eax, 2
  0009d	48 98		 cdqe
  0009f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  000a4	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  000a8	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1

; 6666 :     
; 6667 :     c = &g->color_table[g->codes[code].suffix * 4];

  000ac	0f b7 44 24 58	 movzx	 eax, WORD PTR code$[rsp]
  000b1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  000b6	0f b6 84 81 37
	08 00 00	 movzx	 eax, BYTE PTR [rcx+rax*4+2103]
  000be	c1 e0 02	 shl	 eax, 2
  000c1	48 98		 cdqe
  000c3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  000c8	48 8b 89 38 88
	00 00		 mov	 rcx, QWORD PTR [rcx+34872]
  000cf	48 03 c8	 add	 rcx, rax
  000d2	48 8b c1	 mov	 rax, rcx
  000d5	48 89 44 24 28	 mov	 QWORD PTR c$[rsp], rax

; 6668 :     if (c[3] > 128) { // don't render transparent pixels;

  000da	b8 01 00 00 00	 mov	 eax, 1
  000df	48 6b c0 03	 imul	 rax, rax, 3
  000e3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR c$[rsp]
  000e8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ec	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  000f1	0f 8e 90 00 00
	00		 jle	 $LN6@stbi__out_

; 6669 :         p[0] = c[2];

  000f7	b8 01 00 00 00	 mov	 eax, 1
  000fc	48 6b c0 02	 imul	 rax, rax, 2
  00100	b9 01 00 00 00	 mov	 ecx, 1
  00105	48 6b c9 00	 imul	 rcx, rcx, 0
  00109	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  0010e	4c 8b 44 24 28	 mov	 r8, QWORD PTR c$[rsp]
  00113	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00118	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 6670 :         p[1] = c[1];

  0011b	b8 01 00 00 00	 mov	 eax, 1
  00120	48 6b c0 01	 imul	 rax, rax, 1
  00124	b9 01 00 00 00	 mov	 ecx, 1
  00129	48 6b c9 01	 imul	 rcx, rcx, 1
  0012d	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  00132	4c 8b 44 24 28	 mov	 r8, QWORD PTR c$[rsp]
  00137	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0013c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 6671 :         p[2] = c[0];

  0013f	b8 01 00 00 00	 mov	 eax, 1
  00144	48 6b c0 00	 imul	 rax, rax, 0
  00148	b9 01 00 00 00	 mov	 ecx, 1
  0014d	48 6b c9 02	 imul	 rcx, rcx, 2
  00151	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  00156	4c 8b 44 24 28	 mov	 r8, QWORD PTR c$[rsp]
  0015b	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00160	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 6672 :         p[3] = c[3];

  00163	b8 01 00 00 00	 mov	 eax, 1
  00168	48 6b c0 03	 imul	 rax, rax, 3
  0016c	b9 01 00 00 00	 mov	 ecx, 1
  00171	48 6b c9 03	 imul	 rcx, rcx, 3
  00175	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  0017a	4c 8b 44 24 28	 mov	 r8, QWORD PTR c$[rsp]
  0017f	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00184	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN6@stbi__out_:

; 6673 :     }
; 6674 :     g->cur_x += 4;

  00187	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  0018c	8b 80 5c 88 00
	00		 mov	 eax, DWORD PTR [rax+34908]
  00192	83 c0 04	 add	 eax, 4
  00195	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  0019a	89 81 5c 88 00
	00		 mov	 DWORD PTR [rcx+34908], eax

; 6675 :     
; 6676 :     if (g->cur_x >= g->max_x) {

  001a0	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  001a5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  001aa	8b 89 54 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34900]
  001b0	39 88 5c 88 00
	00		 cmp	 DWORD PTR [rax+34908], ecx
  001b6	0f 8c d5 00 00
	00		 jl	 $LN7@stbi__out_

; 6677 :         g->cur_x = g->start_x;

  001bc	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  001c1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  001c6	8b 89 4c 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34892]
  001cc	89 88 5c 88 00
	00		 mov	 DWORD PTR [rax+34908], ecx

; 6678 :         g->cur_y += g->step;

  001d2	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  001d7	8b 80 60 88 00
	00		 mov	 eax, DWORD PTR [rax+34912]
  001dd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  001e2	03 81 44 88 00
	00		 add	 eax, DWORD PTR [rcx+34884]
  001e8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  001ed	89 81 60 88 00
	00		 mov	 DWORD PTR [rcx+34912], eax
$LN2@stbi__out_:

; 6679 :         
; 6680 :         while (g->cur_y >= g->max_y && g->parse > 0) {

  001f3	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  001f8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  001fd	8b 89 58 88 00
	00		 mov	 ecx, DWORD PTR [rcx+34904]
  00203	39 88 60 88 00
	00		 cmp	 DWORD PTR [rax+34912], ecx
  00209	0f 8c 82 00 00
	00		 jl	 $LN3@stbi__out_
  0020f	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  00214	83 b8 40 88 00
	00 00		 cmp	 DWORD PTR [rax+34880], 0
  0021b	7e 74		 jle	 SHORT $LN3@stbi__out_

; 6681 :             g->step = (1 << g->parse) * g->line_size;

  0021d	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  00222	8b 80 40 88 00
	00		 mov	 eax, DWORD PTR [rax+34880]
  00228	b9 01 00 00 00	 mov	 ecx, 1
  0022d	89 4c 24 24	 mov	 DWORD PTR tv256[rsp], ecx
  00231	0f b6 c8	 movzx	 ecx, al
  00234	8b 44 24 24	 mov	 eax, DWORD PTR tv256[rsp]
  00238	d3 e0		 shl	 eax, cl
  0023a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  0023f	0f af 81 64 88
	00 00		 imul	 eax, DWORD PTR [rcx+34916]
  00246	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  0024b	89 81 44 88 00
	00		 mov	 DWORD PTR [rcx+34884], eax

; 6682 :             g->cur_y = g->start_y + (g->step >> 1);

  00251	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  00256	8b 80 44 88 00
	00		 mov	 eax, DWORD PTR [rax+34884]
  0025c	d1 f8		 sar	 eax, 1
  0025e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  00263	03 81 50 88 00
	00		 add	 eax, DWORD PTR [rcx+34896]
  00269	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  0026e	89 81 60 88 00
	00		 mov	 DWORD PTR [rcx+34912], eax

; 6683 :             --g->parse;

  00274	48 8b 44 24 50	 mov	 rax, QWORD PTR g$[rsp]
  00279	8b 80 40 88 00
	00		 mov	 eax, DWORD PTR [rax+34880]
  0027f	ff c8		 dec	 eax
  00281	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp]
  00286	89 81 40 88 00
	00		 mov	 DWORD PTR [rcx+34880], eax

; 6684 :         }

  0028c	e9 62 ff ff ff	 jmp	 $LN2@stbi__out_
$LN3@stbi__out_:
$LN7@stbi__out_:
$LN1@stbi__out_:

; 6685 :     }
; 6686 : }

  00291	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00295	c3		 ret	 0
?stbi__out_gif_code@@YAXPEAUstbi__gif@@G@Z ENDP		; stbi__out_gif_code
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
g$ = 32
s$ = 64
x$ = 72
y$ = 80
comp$ = 88
?stbi__gif_info_raw@@YAHPEAUstbi__context@@PEAH11@Z PROC ; stbi__gif_info_raw

; 6637 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6638 :     stbi__gif* g = (stbi__gif*) stbi__malloc(sizeof(stbi__gif));

  00018	b9 70 88 00 00	 mov	 ecx, 34928		; 00008870H
  0001d	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  00022	48 89 44 24 20	 mov	 QWORD PTR g$[rsp], rax

; 6639 :     if (!g) return stbi__err("outofmem", "Out of memory");

  00027	48 83 7c 24 20
	00		 cmp	 QWORD PTR g$[rsp], 0
  0002d	75 0e		 jne	 SHORT $LN2@stbi__gif_
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81758
  00036	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0003b	eb 72		 jmp	 SHORT $LN1@stbi__gif_
$LN2@stbi__gif_:

; 6640 :     if (!stbi__gif_header(s, g, comp, 1)) {

  0003d	41 b9 01 00 00
	00		 mov	 r9d, 1
  00043	4c 8b 44 24 58	 mov	 r8, QWORD PTR comp$[rsp]
  00048	48 8b 54 24 20	 mov	 rdx, QWORD PTR g$[rsp]
  0004d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00052	e8 00 00 00 00	 call	 ?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z ; stbi__gif_header
  00057	85 c0		 test	 eax, eax
  00059	75 18		 jne	 SHORT $LN3@stbi__gif_

; 6641 :         STBI_FREE(g);

  0005b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR g$[rsp]
  00060	e8 00 00 00 00	 call	 free

; 6642 :         stbi__rewind( s );

  00065	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0006a	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 6643 :         return 0;

  0006f	33 c0		 xor	 eax, eax
  00071	eb 3c		 jmp	 SHORT $LN1@stbi__gif_
$LN3@stbi__gif_:

; 6644 :     }
; 6645 :     if (x) *x = g->w;

  00073	48 83 7c 24 48
	00		 cmp	 QWORD PTR x$[rsp], 0
  00079	74 0e		 je	 SHORT $LN4@stbi__gif_
  0007b	48 8b 44 24 48	 mov	 rax, QWORD PTR x$[rsp]
  00080	48 8b 4c 24 20	 mov	 rcx, QWORD PTR g$[rsp]
  00085	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00087	89 08		 mov	 DWORD PTR [rax], ecx
$LN4@stbi__gif_:

; 6646 :     if (y) *y = g->h;

  00089	48 83 7c 24 50
	00		 cmp	 QWORD PTR y$[rsp], 0
  0008f	74 0f		 je	 SHORT $LN5@stbi__gif_
  00091	48 8b 44 24 50	 mov	 rax, QWORD PTR y$[rsp]
  00096	48 8b 4c 24 20	 mov	 rcx, QWORD PTR g$[rsp]
  0009b	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  0009e	89 08		 mov	 DWORD PTR [rax], ecx
$LN5@stbi__gif_:

; 6647 :     STBI_FREE(g);

  000a0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR g$[rsp]
  000a5	e8 00 00 00 00	 call	 free

; 6648 :     return 1;

  000aa	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__gif_:

; 6649 : }

  000af	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b3	c3		 ret	 0
?stbi__gif_info_raw@@YAHPEAUstbi__context@@PEAH11@Z ENDP ; stbi__gif_info_raw
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
version$ = 32
tv224 = 36
s$ = 64
g$ = 72
comp$ = 80
is_info$ = 88
?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z PROC ; stbi__gif_header

; 6606 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6607 :     stbi_uc version;
; 6608 :     if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8')

  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001d	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00022	0f b6 c0	 movzx	 eax, al
  00025	83 f8 47	 cmp	 eax, 71			; 00000047H
  00028	75 36		 jne	 SHORT $LN3@stbi__gif_
  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0002f	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00034	0f b6 c0	 movzx	 eax, al
  00037	83 f8 49	 cmp	 eax, 73			; 00000049H
  0003a	75 24		 jne	 SHORT $LN3@stbi__gif_
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00041	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00046	0f b6 c0	 movzx	 eax, al
  00049	83 f8 46	 cmp	 eax, 70			; 00000046H
  0004c	75 12		 jne	 SHORT $LN3@stbi__gif_
  0004e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00053	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00058	0f b6 c0	 movzx	 eax, al
  0005b	83 f8 38	 cmp	 eax, 56			; 00000038H
  0005e	74 11		 je	 SHORT $LN2@stbi__gif_
$LN3@stbi__gif_:

; 6609 :         return stbi__err("not GIF", "Corrupt GIF");

  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81735
  00067	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0006c	e9 96 01 00 00	 jmp	 $LN1@stbi__gif_
$LN2@stbi__gif_:

; 6610 :     
; 6611 :     version = stbi__get8(s);

  00071	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00076	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0007b	88 44 24 20	 mov	 BYTE PTR version$[rsp], al

; 6612 :     if (version != '7' && version != '9')    return stbi__err("not GIF", "Corrupt GIF");

  0007f	0f b6 44 24 20	 movzx	 eax, BYTE PTR version$[rsp]
  00084	83 f8 37	 cmp	 eax, 55			; 00000037H
  00087	74 1b		 je	 SHORT $LN4@stbi__gif_
  00089	0f b6 44 24 20	 movzx	 eax, BYTE PTR version$[rsp]
  0008e	83 f8 39	 cmp	 eax, 57			; 00000039H
  00091	74 11		 je	 SHORT $LN4@stbi__gif_
  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81737
  0009a	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0009f	e9 63 01 00 00	 jmp	 $LN1@stbi__gif_
$LN4@stbi__gif_:

; 6613 :     if (stbi__get8(s) != 'a')                return stbi__err("not GIF", "Corrupt GIF");

  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000a9	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  000ae	0f b6 c0	 movzx	 eax, al
  000b1	83 f8 61	 cmp	 eax, 97			; 00000061H
  000b4	74 11		 je	 SHORT $LN5@stbi__gif_
  000b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81739
  000bd	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000c2	e9 40 01 00 00	 jmp	 $LN1@stbi__gif_
$LN5@stbi__gif_:

; 6614 :     
; 6615 :     stbi__g_failure_reason = "";

  000c7	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
  000cc	8b c0		 mov	 eax, eax
  000ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000d4	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000dd	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  000e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG81740
  000e8	48 89 14 08	 mov	 QWORD PTR [rax+rcx], rdx

; 6616 :     g->w = stbi__get16le(s);

  000ec	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000f1	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  000f6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR g$[rsp]
  000fb	89 01		 mov	 DWORD PTR [rcx], eax

; 6617 :     g->h = stbi__get16le(s);

  000fd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00102	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  00107	48 8b 4c 24 48	 mov	 rcx, QWORD PTR g$[rsp]
  0010c	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 6618 :     g->flags = stbi__get8(s);

  0010f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00114	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00119	0f b6 c0	 movzx	 eax, al
  0011c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR g$[rsp]
  00121	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 6619 :     g->bgindex = stbi__get8(s);

  00124	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00129	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0012e	0f b6 c0	 movzx	 eax, al
  00131	48 8b 4c 24 48	 mov	 rcx, QWORD PTR g$[rsp]
  00136	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 6620 :     g->ratio = stbi__get8(s);

  00139	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0013e	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00143	0f b6 c0	 movzx	 eax, al
  00146	48 8b 4c 24 48	 mov	 rcx, QWORD PTR g$[rsp]
  0014b	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 6621 :     g->transparent = -1;

  0014e	48 8b 44 24 48	 mov	 rax, QWORD PTR g$[rsp]
  00153	c7 40 2c ff ff
	ff ff		 mov	 DWORD PTR [rax+44], -1

; 6622 :     
; 6623 :     if (g->w > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");

  0015a	48 8b 44 24 48	 mov	 rax, QWORD PTR g$[rsp]
  0015f	81 38 00 00 00
	01		 cmp	 DWORD PTR [rax], 16777216 ; 01000000H
  00165	7e 11		 jle	 SHORT $LN6@stbi__gif_
  00167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81742
  0016e	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00173	e9 8f 00 00 00	 jmp	 $LN1@stbi__gif_
$LN6@stbi__gif_:

; 6624 :     if (g->h > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");

  00178	48 8b 44 24 48	 mov	 rax, QWORD PTR g$[rsp]
  0017d	81 78 04 00 00
	00 01		 cmp	 DWORD PTR [rax+4], 16777216 ; 01000000H
  00184	7e 0e		 jle	 SHORT $LN7@stbi__gif_
  00186	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81744
  0018d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00192	eb 73		 jmp	 SHORT $LN1@stbi__gif_
$LN7@stbi__gif_:

; 6625 :     
; 6626 :     if (comp != 0) *comp = 4;  // can't actually tell whether it's 3 or 4 until we parse the comments

  00194	48 83 7c 24 50
	00		 cmp	 QWORD PTR comp$[rsp], 0
  0019a	74 0b		 je	 SHORT $LN8@stbi__gif_
  0019c	48 8b 44 24 50	 mov	 rax, QWORD PTR comp$[rsp]
  001a1	c7 00 04 00 00
	00		 mov	 DWORD PTR [rax], 4
$LN8@stbi__gif_:

; 6627 :     
; 6628 :     if (is_info) return 1;

  001a7	83 7c 24 58 00	 cmp	 DWORD PTR is_info$[rsp], 0
  001ac	74 07		 je	 SHORT $LN9@stbi__gif_
  001ae	b8 01 00 00 00	 mov	 eax, 1
  001b3	eb 52		 jmp	 SHORT $LN1@stbi__gif_
$LN9@stbi__gif_:

; 6629 :     
; 6630 :     if (g->flags & 0x80)

  001b5	48 8b 44 24 48	 mov	 rax, QWORD PTR g$[rsp]
  001ba	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  001bd	25 80 00 00 00	 and	 eax, 128		; 00000080H
  001c2	85 c0		 test	 eax, eax
  001c4	74 3c		 je	 SHORT $LN10@stbi__gif_

; 6631 :         stbi__gif_parse_colortable(s,g->pal, 2 << (g->flags & 7), -1);

  001c6	48 8b 44 24 48	 mov	 rax, QWORD PTR g$[rsp]
  001cb	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  001ce	83 e0 07	 and	 eax, 7
  001d1	b9 02 00 00 00	 mov	 ecx, 2
  001d6	89 4c 24 24	 mov	 DWORD PTR tv224[rsp], ecx
  001da	0f b6 c8	 movzx	 ecx, al
  001dd	8b 44 24 24	 mov	 eax, DWORD PTR tv224[rsp]
  001e1	d3 e0		 shl	 eax, cl
  001e3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR g$[rsp]
  001e8	48 83 c1 34	 add	 rcx, 52			; 00000034H
  001ec	41 b9 ff ff ff
	ff		 mov	 r9d, -1
  001f2	44 8b c0	 mov	 r8d, eax
  001f5	48 8b d1	 mov	 rdx, rcx
  001f8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  001fd	e8 00 00 00 00	 call	 ?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z ; stbi__gif_parse_colortable
$LN10@stbi__gif_:

; 6632 :     
; 6633 :     return 1;

  00202	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__gif_:

; 6634 : }

  00207	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0020b	c3		 ret	 0
?stbi__gif_header@@YAHPEAUstbi__context@@PEAUstbi__gif@@PEAHH@Z ENDP ; stbi__gif_header
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
i$ = 32
tv93 = 36
s$ = 64
pal$ = 72
num_entries$ = 80
transp$ = 88
?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z PROC ; stbi__gif_parse_colortable

; 6595 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6596 :     int i;
; 6597 :     for (i=0; i < num_entries; ++i) {

  00018	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00020	eb 0a		 jmp	 SHORT $LN4@stbi__gif_
$LN2@stbi__gif_:
  00022	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00026	ff c0		 inc	 eax
  00028	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__gif_:
  0002c	8b 44 24 50	 mov	 eax, DWORD PTR num_entries$[rsp]
  00030	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00034	0f 8d ac 00 00
	00		 jge	 $LN3@stbi__gif_

; 6598 :         pal[i][2] = stbi__get8(s);

  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0003f	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00044	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00049	48 8b 54 24 48	 mov	 rdx, QWORD PTR pal$[rsp]
  0004e	48 8d 0c 8a	 lea	 rcx, QWORD PTR [rdx+rcx*4]
  00052	ba 01 00 00 00	 mov	 edx, 1
  00057	48 6b d2 02	 imul	 rdx, rdx, 2
  0005b	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 6599 :         pal[i][1] = stbi__get8(s);

  0005e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00063	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00068	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0006d	48 8b 54 24 48	 mov	 rdx, QWORD PTR pal$[rsp]
  00072	48 8d 0c 8a	 lea	 rcx, QWORD PTR [rdx+rcx*4]
  00076	ba 01 00 00 00	 mov	 edx, 1
  0007b	48 6b d2 01	 imul	 rdx, rdx, 1
  0007f	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 6600 :         pal[i][0] = stbi__get8(s);

  00082	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00087	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0008c	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00091	48 8b 54 24 48	 mov	 rdx, QWORD PTR pal$[rsp]
  00096	48 8d 0c 8a	 lea	 rcx, QWORD PTR [rdx+rcx*4]
  0009a	ba 01 00 00 00	 mov	 edx, 1
  0009f	48 6b d2 00	 imul	 rdx, rdx, 0
  000a3	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 6601 :         pal[i][3] = transp == i ? 0 : 255;

  000a6	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000aa	39 44 24 58	 cmp	 DWORD PTR transp$[rsp], eax
  000ae	75 0a		 jne	 SHORT $LN6@stbi__gif_
  000b0	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
  000b8	eb 08		 jmp	 SHORT $LN7@stbi__gif_
$LN6@stbi__gif_:
  000ba	c7 44 24 24 ff
	00 00 00	 mov	 DWORD PTR tv93[rsp], 255 ; 000000ffH
$LN7@stbi__gif_:
  000c2	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000c7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pal$[rsp]
  000cc	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  000d0	b9 01 00 00 00	 mov	 ecx, 1
  000d5	48 6b c9 03	 imul	 rcx, rcx, 3
  000d9	0f b6 54 24 24	 movzx	 edx, BYTE PTR tv93[rsp]
  000de	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 6602 :     }

  000e1	e9 3c ff ff ff	 jmp	 $LN2@stbi__gif_
$LN3@stbi__gif_:

; 6603 : }

  000e6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ea	c3		 ret	 0
?stbi__gif_parse_colortable@@YAXPEAUstbi__context@@QEAY03EHH@Z ENDP ; stbi__gif_parse_colortable
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
sz$ = 32
s$ = 64
?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z PROC	; stbi__gif_test_raw

; 6578 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6579 :     int sz;
; 6580 :     if (stbi__get8(s) != 'G' || stbi__get8(s) != 'I' || stbi__get8(s) != 'F' || stbi__get8(s) != '8') return 0;

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00013	0f b6 c0	 movzx	 eax, al
  00016	83 f8 47	 cmp	 eax, 71			; 00000047H
  00019	75 36		 jne	 SHORT $LN3@stbi__gif_
  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00020	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00025	0f b6 c0	 movzx	 eax, al
  00028	83 f8 49	 cmp	 eax, 73			; 00000049H
  0002b	75 24		 jne	 SHORT $LN3@stbi__gif_
  0002d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00032	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00037	0f b6 c0	 movzx	 eax, al
  0003a	83 f8 46	 cmp	 eax, 70			; 00000046H
  0003d	75 12		 jne	 SHORT $LN3@stbi__gif_
  0003f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00044	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00049	0f b6 c0	 movzx	 eax, al
  0004c	83 f8 38	 cmp	 eax, 56			; 00000038H
  0004f	74 04		 je	 SHORT $LN2@stbi__gif_
$LN3@stbi__gif_:
  00051	33 c0		 xor	 eax, eax
  00053	eb 3e		 jmp	 SHORT $LN1@stbi__gif_
$LN2@stbi__gif_:

; 6581 :     sz = stbi__get8(s);

  00055	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0005a	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0005f	0f b6 c0	 movzx	 eax, al
  00062	89 44 24 20	 mov	 DWORD PTR sz$[rsp], eax

; 6582 :     if (sz != '9' && sz != '7') return 0;

  00066	83 7c 24 20 39	 cmp	 DWORD PTR sz$[rsp], 57	; 00000039H
  0006b	74 0b		 je	 SHORT $LN4@stbi__gif_
  0006d	83 7c 24 20 37	 cmp	 DWORD PTR sz$[rsp], 55	; 00000037H
  00072	74 04		 je	 SHORT $LN4@stbi__gif_
  00074	33 c0		 xor	 eax, eax
  00076	eb 1b		 jmp	 SHORT $LN1@stbi__gif_
$LN4@stbi__gif_:

; 6583 :     if (stbi__get8(s) != 'a') return 0;

  00078	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0007d	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00082	0f b6 c0	 movzx	 eax, al
  00085	83 f8 61	 cmp	 eax, 97			; 00000061H
  00088	74 04		 je	 SHORT $LN5@stbi__gif_
  0008a	33 c0		 xor	 eax, eax
  0008c	eb 05		 jmp	 SHORT $LN1@stbi__gif_
$LN5@stbi__gif_:

; 6584 :     return 1;

  0008e	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__gif_:

; 6585 : }

  00093	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00097	c3		 ret	 0
?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z ENDP	; stbi__gif_test_raw
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
count$1 = 32
count$2 = 36
i$3 = 40
dest$4 = 48
num_packets$ = 56
left$5 = 60
left$6 = 64
packet_idx$7 = 68
y$ = 72
act_comp$ = 76
tv155 = 80
x$8 = 84
i$9 = 88
packet$10 = 96
tv69 = 104
tv128 = 108
tv136 = 112
tv141 = 116
tv159 = 120
tv180 = 124
tv212 = 128
tv223 = 132
tv245 = 136
packet$11 = 144
chained$ = 152
value$12 = 156
value$13 = 160
packets$ = 168
__$ArrayPad$ = 200
s$ = 224
width$ = 232
height$ = 240
comp$ = 248
result$ = 256
?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z PROC ; stbi__pic_load_core

; 6388 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 6389 :     int act_comp=0,num_packets=0,y,chained;

  0002c	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR act_comp$[rsp], 0
  00034	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR num_packets$[rsp], 0
$LN4@stbi__pic_:

; 6390 :     stbi__pic_packet packets[10];
; 6391 :     
; 6392 :     // this will (should...) cater for even some bizarre stuff like having data
; 6393 :     // for the same channel in multiple packets.
; 6394 :     do {
; 6395 :         stbi__pic_packet *packet;
; 6396 :         
; 6397 :         if (num_packets==sizeof(packets)/sizeof(packets[0]))

  0003c	48 63 44 24 38	 movsxd	 rax, DWORD PTR num_packets$[rsp]
  00041	48 83 f8 0a	 cmp	 rax, 10
  00045	75 2c		 jne	 SHORT $LN29@stbi__pic_

; 6398 :             return stbi__errpuc("bad format","too many packets");

  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81580
  0004e	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00053	85 c0		 test	 eax, eax
  00055	74 0a		 je	 SHORT $LN50@stbi__pic_
  00057	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
  0005f	eb 08		 jmp	 SHORT $LN51@stbi__pic_
$LN50@stbi__pic_:
  00061	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
$LN51@stbi__pic_:
  00069	48 63 44 24 68	 movsxd	 rax, DWORD PTR tv69[rsp]
  0006e	e9 ae 05 00 00	 jmp	 $LN1@stbi__pic_
$LN29@stbi__pic_:

; 6399 :         
; 6400 :         packet = &packets[num_packets++];

  00073	48 63 44 24 38	 movsxd	 rax, DWORD PTR num_packets$[rsp]
  00078	48 6b c0 03	 imul	 rax, rax, 3
  0007c	48 8d 84 04 a8
	00 00 00	 lea	 rax, QWORD PTR packets$[rsp+rax]
  00084	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR packet$11[rsp], rax
  0008c	8b 44 24 38	 mov	 eax, DWORD PTR num_packets$[rsp]
  00090	ff c0		 inc	 eax
  00092	89 44 24 38	 mov	 DWORD PTR num_packets$[rsp], eax

; 6401 :         
; 6402 :         chained = stbi__get8(s);

  00096	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0009e	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  000a3	0f b6 c0	 movzx	 eax, al
  000a6	89 84 24 98 00
	00 00		 mov	 DWORD PTR chained$[rsp], eax

; 6403 :         packet->size    = stbi__get8(s);

  000ad	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000b5	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  000ba	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR packet$11[rsp]
  000c2	88 01		 mov	 BYTE PTR [rcx], al

; 6404 :         packet->type    = stbi__get8(s);

  000c4	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000cc	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  000d1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR packet$11[rsp]
  000d9	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 6405 :         packet->channel = stbi__get8(s);

  000dc	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000e4	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  000e9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR packet$11[rsp]
  000f1	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 6406 :         
; 6407 :         act_comp |= packet->channel;

  000f4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR packet$11[rsp]
  000fc	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00100	8b 4c 24 4c	 mov	 ecx, DWORD PTR act_comp$[rsp]
  00104	0b c8		 or	 ecx, eax
  00106	8b c1		 mov	 eax, ecx
  00108	89 44 24 4c	 mov	 DWORD PTR act_comp$[rsp], eax

; 6408 :         
; 6409 :         if (stbi__at_eof(s))          return stbi__errpuc("bad file","file too short (reading packets)");

  0010c	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00114	e8 00 00 00 00	 call	 ?stbi__at_eof@@YAHPEAUstbi__context@@@Z ; stbi__at_eof
  00119	85 c0		 test	 eax, eax
  0011b	74 2c		 je	 SHORT $LN30@stbi__pic_
  0011d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81582
  00124	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00129	85 c0		 test	 eax, eax
  0012b	74 0a		 je	 SHORT $LN52@stbi__pic_
  0012d	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
  00135	eb 08		 jmp	 SHORT $LN53@stbi__pic_
$LN52@stbi__pic_:
  00137	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
$LN53@stbi__pic_:
  0013f	48 63 44 24 6c	 movsxd	 rax, DWORD PTR tv128[rsp]
  00144	e9 d8 04 00 00	 jmp	 $LN1@stbi__pic_
$LN30@stbi__pic_:

; 6410 :         if (packet->size != 8)  return stbi__errpuc("bad format","packet isn't 8bpp");

  00149	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR packet$11[rsp]
  00151	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00154	83 f8 08	 cmp	 eax, 8
  00157	74 2c		 je	 SHORT $LN31@stbi__pic_
  00159	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81584
  00160	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00165	85 c0		 test	 eax, eax
  00167	74 0a		 je	 SHORT $LN54@stbi__pic_
  00169	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
  00171	eb 08		 jmp	 SHORT $LN55@stbi__pic_
$LN54@stbi__pic_:
  00173	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN55@stbi__pic_:
  0017b	48 63 44 24 70	 movsxd	 rax, DWORD PTR tv136[rsp]
  00180	e9 9c 04 00 00	 jmp	 $LN1@stbi__pic_
$LN31@stbi__pic_:

; 6411 :     } while (chained);

  00185	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR chained$[rsp], 0
  0018d	0f 85 a9 fe ff
	ff		 jne	 $LN4@stbi__pic_

; 6412 :     
; 6413 :     *comp = (act_comp & 0x10 ? 4 : 3); // has alpha channel?

  00193	8b 44 24 4c	 mov	 eax, DWORD PTR act_comp$[rsp]
  00197	83 e0 10	 and	 eax, 16
  0019a	85 c0		 test	 eax, eax
  0019c	74 0a		 je	 SHORT $LN56@stbi__pic_
  0019e	c7 44 24 74 04
	00 00 00	 mov	 DWORD PTR tv141[rsp], 4
  001a6	eb 08		 jmp	 SHORT $LN57@stbi__pic_
$LN56@stbi__pic_:
  001a8	c7 44 24 74 03
	00 00 00	 mov	 DWORD PTR tv141[rsp], 3
$LN57@stbi__pic_:
  001b0	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  001b8	8b 4c 24 74	 mov	 ecx, DWORD PTR tv141[rsp]
  001bc	89 08		 mov	 DWORD PTR [rax], ecx

; 6414 :     
; 6415 :     for(y=0; y<height; ++y) {

  001be	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR y$[rsp], 0
  001c6	eb 0a		 jmp	 SHORT $LN7@stbi__pic_
$LN5@stbi__pic_:
  001c8	8b 44 24 48	 mov	 eax, DWORD PTR y$[rsp]
  001cc	ff c0		 inc	 eax
  001ce	89 44 24 48	 mov	 DWORD PTR y$[rsp], eax
$LN7@stbi__pic_:
  001d2	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR height$[rsp]
  001d9	39 44 24 48	 cmp	 DWORD PTR y$[rsp], eax
  001dd	0f 8d 36 04 00
	00		 jge	 $LN6@stbi__pic_

; 6416 :         int packet_idx;
; 6417 :         
; 6418 :         for(packet_idx=0; packet_idx < num_packets; ++packet_idx) {

  001e3	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR packet_idx$7[rsp], 0
  001eb	eb 0a		 jmp	 SHORT $LN10@stbi__pic_
$LN8@stbi__pic_:
  001ed	8b 44 24 44	 mov	 eax, DWORD PTR packet_idx$7[rsp]
  001f1	ff c0		 inc	 eax
  001f3	89 44 24 44	 mov	 DWORD PTR packet_idx$7[rsp], eax
$LN10@stbi__pic_:
  001f7	8b 44 24 38	 mov	 eax, DWORD PTR num_packets$[rsp]
  001fb	39 44 24 44	 cmp	 DWORD PTR packet_idx$7[rsp], eax
  001ff	0f 8d 0f 04 00
	00		 jge	 $LN9@stbi__pic_

; 6419 :             stbi__pic_packet *packet = &packets[packet_idx];

  00205	48 63 44 24 44	 movsxd	 rax, DWORD PTR packet_idx$7[rsp]
  0020a	48 6b c0 03	 imul	 rax, rax, 3
  0020e	48 8d 84 04 a8
	00 00 00	 lea	 rax, QWORD PTR packets$[rsp+rax]
  00216	48 89 44 24 60	 mov	 QWORD PTR packet$10[rsp], rax

; 6420 :             stbi_uc *dest = result+y*width*4;

  0021b	8b 44 24 48	 mov	 eax, DWORD PTR y$[rsp]
  0021f	0f af 84 24 e8
	00 00 00	 imul	 eax, DWORD PTR width$[rsp]
  00227	c1 e0 02	 shl	 eax, 2
  0022a	48 98		 cdqe
  0022c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR result$[rsp]
  00234	48 03 c8	 add	 rcx, rax
  00237	48 8b c1	 mov	 rax, rcx
  0023a	48 89 44 24 30	 mov	 QWORD PTR dest$4[rsp], rax

; 6421 :             
; 6422 :             switch (packet->type) {

  0023f	48 8b 44 24 60	 mov	 rax, QWORD PTR packet$10[rsp]
  00244	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00248	88 44 24 50	 mov	 BYTE PTR tv155[rsp], al
  0024c	80 7c 24 50 00	 cmp	 BYTE PTR tv155[rsp], 0
  00251	74 42		 je	 SHORT $LN33@stbi__pic_
  00253	80 7c 24 50 01	 cmp	 BYTE PTR tv155[rsp], 1
  00258	0f 84 96 00 00
	00		 je	 $LN35@stbi__pic_
  0025e	80 7c 24 50 02	 cmp	 BYTE PTR tv155[rsp], 2
  00263	0f 84 96 01 00
	00		 je	 $LN39@stbi__pic_

; 6423 :                 default:
; 6424 :                 return stbi__errpuc("bad format","packet has bad compression type");

  00269	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81586
  00270	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00275	85 c0		 test	 eax, eax
  00277	74 0a		 je	 SHORT $LN58@stbi__pic_
  00279	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv159[rsp], 0
  00281	eb 08		 jmp	 SHORT $LN59@stbi__pic_
$LN58@stbi__pic_:
  00283	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv159[rsp], 0
$LN59@stbi__pic_:
  0028b	48 63 44 24 78	 movsxd	 rax, DWORD PTR tv159[rsp]
  00290	e9 8c 03 00 00	 jmp	 $LN1@stbi__pic_
$LN33@stbi__pic_:

; 6425 :                 
; 6426 :                 case 0: {//uncompressed
; 6427 :                     int x;
; 6428 :                     
; 6429 :                     for(x=0;x<width;++x, dest+=4)

  00295	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR x$8[rsp], 0
  0029d	eb 18		 jmp	 SHORT $LN15@stbi__pic_
$LN13@stbi__pic_:
  0029f	8b 44 24 54	 mov	 eax, DWORD PTR x$8[rsp]
  002a3	ff c0		 inc	 eax
  002a5	89 44 24 54	 mov	 DWORD PTR x$8[rsp], eax
  002a9	48 8b 44 24 30	 mov	 rax, QWORD PTR dest$4[rsp]
  002ae	48 83 c0 04	 add	 rax, 4
  002b2	48 89 44 24 30	 mov	 QWORD PTR dest$4[rsp], rax
$LN15@stbi__pic_:
  002b7	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR width$[rsp]
  002be	39 44 24 54	 cmp	 DWORD PTR x$8[rsp], eax
  002c2	7d 2b		 jge	 SHORT $LN14@stbi__pic_

; 6430 :                         if (!stbi__readval(s,packet->channel,dest))

  002c4	48 8b 44 24 60	 mov	 rax, QWORD PTR packet$10[rsp]
  002c9	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  002cd	4c 8b 44 24 30	 mov	 r8, QWORD PTR dest$4[rsp]
  002d2	8b d0		 mov	 edx, eax
  002d4	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002dc	e8 00 00 00 00	 call	 ?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z ; stbi__readval
  002e1	48 85 c0	 test	 rax, rax
  002e4	75 07		 jne	 SHORT $LN34@stbi__pic_

; 6431 :                         return 0;

  002e6	33 c0		 xor	 eax, eax
  002e8	e9 34 03 00 00	 jmp	 $LN1@stbi__pic_
$LN34@stbi__pic_:
  002ed	eb b0		 jmp	 SHORT $LN13@stbi__pic_
$LN14@stbi__pic_:

; 6432 :                     break;

  002ef	e9 1b 03 00 00	 jmp	 $LN11@stbi__pic_
$LN35@stbi__pic_:

; 6433 :                 }
; 6434 :                 
; 6435 :                 case 1://Pure RLE
; 6436 :                 {
; 6437 :                     int left=width, i;

  002f4	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR width$[rsp]
  002fb	89 44 24 3c	 mov	 DWORD PTR left$5[rsp], eax
$LN16@stbi__pic_:

; 6438 :                     
; 6439 :                     while (left>0) {

  002ff	83 7c 24 3c 00	 cmp	 DWORD PTR left$5[rsp], 0
  00304	0f 8e f0 00 00
	00		 jle	 $LN17@stbi__pic_

; 6440 :                         stbi_uc count,value[4];
; 6441 :                         
; 6442 :                         count=stbi__get8(s);

  0030a	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00312	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00317	88 44 24 20	 mov	 BYTE PTR count$1[rsp], al

; 6443 :                         if (stbi__at_eof(s))   return stbi__errpuc("bad file","file too short (pure read count)");

  0031b	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00323	e8 00 00 00 00	 call	 ?stbi__at_eof@@YAHPEAUstbi__context@@@Z ; stbi__at_eof
  00328	85 c0		 test	 eax, eax
  0032a	74 2c		 je	 SHORT $LN36@stbi__pic_
  0032c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81591
  00333	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00338	85 c0		 test	 eax, eax
  0033a	74 0a		 je	 SHORT $LN60@stbi__pic_
  0033c	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv180[rsp], 0
  00344	eb 08		 jmp	 SHORT $LN61@stbi__pic_
$LN60@stbi__pic_:
  00346	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv180[rsp], 0
$LN61@stbi__pic_:
  0034e	48 63 44 24 7c	 movsxd	 rax, DWORD PTR tv180[rsp]
  00353	e9 c9 02 00 00	 jmp	 $LN1@stbi__pic_
$LN36@stbi__pic_:

; 6444 :                         
; 6445 :                         if (count > left)

  00358	0f b6 44 24 20	 movzx	 eax, BYTE PTR count$1[rsp]
  0035d	3b 44 24 3c	 cmp	 eax, DWORD PTR left$5[rsp]
  00361	7e 09		 jle	 SHORT $LN37@stbi__pic_

; 6446 :                             count = (stbi_uc) left;

  00363	0f b6 44 24 3c	 movzx	 eax, BYTE PTR left$5[rsp]
  00368	88 44 24 20	 mov	 BYTE PTR count$1[rsp], al
$LN37@stbi__pic_:

; 6447 :                         
; 6448 :                         if (!stbi__readval(s,packet->channel,value))  return 0;

  0036c	48 8b 44 24 60	 mov	 rax, QWORD PTR packet$10[rsp]
  00371	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00375	4c 8d 84 24 9c
	00 00 00	 lea	 r8, QWORD PTR value$12[rsp]
  0037d	8b d0		 mov	 edx, eax
  0037f	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00387	e8 00 00 00 00	 call	 ?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z ; stbi__readval
  0038c	48 85 c0	 test	 rax, rax
  0038f	75 07		 jne	 SHORT $LN38@stbi__pic_
  00391	33 c0		 xor	 eax, eax
  00393	e9 89 02 00 00	 jmp	 $LN1@stbi__pic_
$LN38@stbi__pic_:

; 6449 :                         
; 6450 :                         for(i=0; i<count; ++i,dest+=4)

  00398	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR i$9[rsp], 0
  003a0	eb 18		 jmp	 SHORT $LN20@stbi__pic_
$LN18@stbi__pic_:
  003a2	8b 44 24 58	 mov	 eax, DWORD PTR i$9[rsp]
  003a6	ff c0		 inc	 eax
  003a8	89 44 24 58	 mov	 DWORD PTR i$9[rsp], eax
  003ac	48 8b 44 24 30	 mov	 rax, QWORD PTR dest$4[rsp]
  003b1	48 83 c0 04	 add	 rax, 4
  003b5	48 89 44 24 30	 mov	 QWORD PTR dest$4[rsp], rax
$LN20@stbi__pic_:
  003ba	0f b6 44 24 20	 movzx	 eax, BYTE PTR count$1[rsp]
  003bf	39 44 24 58	 cmp	 DWORD PTR i$9[rsp], eax
  003c3	7d 1f		 jge	 SHORT $LN19@stbi__pic_

; 6451 :                             stbi__copyval(packet->channel,dest,value);

  003c5	48 8b 44 24 60	 mov	 rax, QWORD PTR packet$10[rsp]
  003ca	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  003ce	4c 8d 84 24 9c
	00 00 00	 lea	 r8, QWORD PTR value$12[rsp]
  003d6	48 8b 54 24 30	 mov	 rdx, QWORD PTR dest$4[rsp]
  003db	8b c8		 mov	 ecx, eax
  003dd	e8 00 00 00 00	 call	 ?stbi__copyval@@YAXHPEAEPEBE@Z ; stbi__copyval
  003e2	eb be		 jmp	 SHORT $LN18@stbi__pic_
$LN19@stbi__pic_:

; 6452 :                         left -= count;

  003e4	0f b6 44 24 20	 movzx	 eax, BYTE PTR count$1[rsp]
  003e9	8b 4c 24 3c	 mov	 ecx, DWORD PTR left$5[rsp]
  003ed	2b c8		 sub	 ecx, eax
  003ef	8b c1		 mov	 eax, ecx
  003f1	89 44 24 3c	 mov	 DWORD PTR left$5[rsp], eax

; 6453 :                     }

  003f5	e9 05 ff ff ff	 jmp	 $LN16@stbi__pic_
$LN17@stbi__pic_:

; 6454 :                 }
; 6455 :                 break;

  003fa	e9 10 02 00 00	 jmp	 $LN11@stbi__pic_
$LN39@stbi__pic_:

; 6456 :                 
; 6457 :                 case 2: {//Mixed RLE
; 6458 :                     int left=width;

  003ff	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR width$[rsp]
  00406	89 44 24 40	 mov	 DWORD PTR left$6[rsp], eax
$LN21@stbi__pic_:

; 6459 :                     while (left>0) {

  0040a	83 7c 24 40 00	 cmp	 DWORD PTR left$6[rsp], 0
  0040f	0f 8e fa 01 00
	00		 jle	 $LN22@stbi__pic_

; 6460 :                         int count = stbi__get8(s), i;

  00415	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0041d	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00422	0f b6 c0	 movzx	 eax, al
  00425	89 44 24 24	 mov	 DWORD PTR count$2[rsp], eax

; 6461 :                         if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (mixed read count)");

  00429	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00431	e8 00 00 00 00	 call	 ?stbi__at_eof@@YAHPEAUstbi__context@@@Z ; stbi__at_eof
  00436	85 c0		 test	 eax, eax
  00438	74 35		 je	 SHORT $LN40@stbi__pic_
  0043a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81596
  00441	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00446	85 c0		 test	 eax, eax
  00448	74 0d		 je	 SHORT $LN62@stbi__pic_
  0044a	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv212[rsp], 0
  00455	eb 0b		 jmp	 SHORT $LN63@stbi__pic_
$LN62@stbi__pic_:
  00457	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv212[rsp], 0
$LN63@stbi__pic_:
  00462	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR tv212[rsp]
  0046a	e9 b2 01 00 00	 jmp	 $LN1@stbi__pic_
$LN40@stbi__pic_:

; 6462 :                         
; 6463 :                         if (count >= 128) { // Repeated

  0046f	81 7c 24 24 80
	00 00 00	 cmp	 DWORD PTR count$2[rsp], 128 ; 00000080H
  00477	0f 8c e3 00 00
	00		 jl	 $LN41@stbi__pic_

; 6464 :                             stbi_uc value[4];
; 6465 :                             
; 6466 :                             if (count==128)

  0047d	81 7c 24 24 80
	00 00 00	 cmp	 DWORD PTR count$2[rsp], 128 ; 00000080H
  00485	75 13		 jne	 SHORT $LN43@stbi__pic_

; 6467 :                                 count = stbi__get16be(s);

  00487	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0048f	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  00494	89 44 24 24	 mov	 DWORD PTR count$2[rsp], eax
  00498	eb 0b		 jmp	 SHORT $LN44@stbi__pic_
$LN43@stbi__pic_:

; 6468 :                             else
; 6469 :                                 count -= 127;

  0049a	8b 44 24 24	 mov	 eax, DWORD PTR count$2[rsp]
  0049e	83 e8 7f	 sub	 eax, 127		; 0000007fH
  004a1	89 44 24 24	 mov	 DWORD PTR count$2[rsp], eax
$LN44@stbi__pic_:

; 6470 :                             if (count > left)

  004a5	8b 44 24 40	 mov	 eax, DWORD PTR left$6[rsp]
  004a9	39 44 24 24	 cmp	 DWORD PTR count$2[rsp], eax
  004ad	7e 35		 jle	 SHORT $LN45@stbi__pic_

; 6471 :                                 return stbi__errpuc("bad file","scanline overrun");

  004af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81602
  004b6	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  004bb	85 c0		 test	 eax, eax
  004bd	74 0d		 je	 SHORT $LN64@stbi__pic_
  004bf	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv223[rsp], 0
  004ca	eb 0b		 jmp	 SHORT $LN65@stbi__pic_
$LN64@stbi__pic_:
  004cc	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv223[rsp], 0
$LN65@stbi__pic_:
  004d7	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR tv223[rsp]
  004df	e9 3d 01 00 00	 jmp	 $LN1@stbi__pic_
$LN45@stbi__pic_:

; 6472 :                             
; 6473 :                             if (!stbi__readval(s,packet->channel,value))

  004e4	48 8b 44 24 60	 mov	 rax, QWORD PTR packet$10[rsp]
  004e9	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  004ed	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR value$13[rsp]
  004f5	8b d0		 mov	 edx, eax
  004f7	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004ff	e8 00 00 00 00	 call	 ?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z ; stbi__readval
  00504	48 85 c0	 test	 rax, rax
  00507	75 07		 jne	 SHORT $LN46@stbi__pic_

; 6474 :                                 return 0;

  00509	33 c0		 xor	 eax, eax
  0050b	e9 11 01 00 00	 jmp	 $LN1@stbi__pic_
$LN46@stbi__pic_:

; 6475 :                             
; 6476 :                             for(i=0;i<count;++i, dest += 4)

  00510	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$3[rsp], 0
  00518	eb 18		 jmp	 SHORT $LN25@stbi__pic_
$LN23@stbi__pic_:
  0051a	8b 44 24 28	 mov	 eax, DWORD PTR i$3[rsp]
  0051e	ff c0		 inc	 eax
  00520	89 44 24 28	 mov	 DWORD PTR i$3[rsp], eax
  00524	48 8b 44 24 30	 mov	 rax, QWORD PTR dest$4[rsp]
  00529	48 83 c0 04	 add	 rax, 4
  0052d	48 89 44 24 30	 mov	 QWORD PTR dest$4[rsp], rax
$LN25@stbi__pic_:
  00532	8b 44 24 24	 mov	 eax, DWORD PTR count$2[rsp]
  00536	39 44 24 28	 cmp	 DWORD PTR i$3[rsp], eax
  0053a	7d 1f		 jge	 SHORT $LN24@stbi__pic_

; 6477 :                                 stbi__copyval(packet->channel,dest,value);

  0053c	48 8b 44 24 60	 mov	 rax, QWORD PTR packet$10[rsp]
  00541	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00545	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR value$13[rsp]
  0054d	48 8b 54 24 30	 mov	 rdx, QWORD PTR dest$4[rsp]
  00552	8b c8		 mov	 ecx, eax
  00554	e8 00 00 00 00	 call	 ?stbi__copyval@@YAXHPEAEPEBE@Z ; stbi__copyval
  00559	eb bf		 jmp	 SHORT $LN23@stbi__pic_
$LN24@stbi__pic_:

; 6478 :                         } else { // Raw

  0055b	e9 9a 00 00 00	 jmp	 $LN42@stbi__pic_
$LN41@stbi__pic_:

; 6479 :                             ++count;

  00560	8b 44 24 24	 mov	 eax, DWORD PTR count$2[rsp]
  00564	ff c0		 inc	 eax
  00566	89 44 24 24	 mov	 DWORD PTR count$2[rsp], eax

; 6480 :                             if (count>left) return stbi__errpuc("bad file","scanline overrun");

  0056a	8b 44 24 40	 mov	 eax, DWORD PTR left$6[rsp]
  0056e	39 44 24 24	 cmp	 DWORD PTR count$2[rsp], eax
  00572	7e 32		 jle	 SHORT $LN47@stbi__pic_
  00574	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81605
  0057b	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00580	85 c0		 test	 eax, eax
  00582	74 0d		 je	 SHORT $LN66@stbi__pic_
  00584	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv245[rsp], 0
  0058f	eb 0b		 jmp	 SHORT $LN67@stbi__pic_
$LN66@stbi__pic_:
  00591	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv245[rsp], 0
$LN67@stbi__pic_:
  0059c	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR tv245[rsp]
  005a4	eb 7b		 jmp	 SHORT $LN1@stbi__pic_
$LN47@stbi__pic_:

; 6481 :                             
; 6482 :                             for(i=0;i<count;++i, dest+=4)

  005a6	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$3[rsp], 0
  005ae	eb 18		 jmp	 SHORT $LN28@stbi__pic_
$LN26@stbi__pic_:
  005b0	8b 44 24 28	 mov	 eax, DWORD PTR i$3[rsp]
  005b4	ff c0		 inc	 eax
  005b6	89 44 24 28	 mov	 DWORD PTR i$3[rsp], eax
  005ba	48 8b 44 24 30	 mov	 rax, QWORD PTR dest$4[rsp]
  005bf	48 83 c0 04	 add	 rax, 4
  005c3	48 89 44 24 30	 mov	 QWORD PTR dest$4[rsp], rax
$LN28@stbi__pic_:
  005c8	8b 44 24 24	 mov	 eax, DWORD PTR count$2[rsp]
  005cc	39 44 24 28	 cmp	 DWORD PTR i$3[rsp], eax
  005d0	7d 28		 jge	 SHORT $LN27@stbi__pic_

; 6483 :                                 if (!stbi__readval(s,packet->channel,dest))

  005d2	48 8b 44 24 60	 mov	 rax, QWORD PTR packet$10[rsp]
  005d7	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  005db	4c 8b 44 24 30	 mov	 r8, QWORD PTR dest$4[rsp]
  005e0	8b d0		 mov	 edx, eax
  005e2	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005ea	e8 00 00 00 00	 call	 ?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z ; stbi__readval
  005ef	48 85 c0	 test	 rax, rax
  005f2	75 04		 jne	 SHORT $LN48@stbi__pic_

; 6484 :                                 return 0;

  005f4	33 c0		 xor	 eax, eax
  005f6	eb 29		 jmp	 SHORT $LN1@stbi__pic_
$LN48@stbi__pic_:
  005f8	eb b6		 jmp	 SHORT $LN26@stbi__pic_
$LN27@stbi__pic_:
$LN42@stbi__pic_:

; 6485 :                         }
; 6486 :                         left-=count;

  005fa	8b 44 24 24	 mov	 eax, DWORD PTR count$2[rsp]
  005fe	8b 4c 24 40	 mov	 ecx, DWORD PTR left$6[rsp]
  00602	2b c8		 sub	 ecx, eax
  00604	8b c1		 mov	 eax, ecx
  00606	89 44 24 40	 mov	 DWORD PTR left$6[rsp], eax

; 6487 :                     }

  0060a	e9 fb fd ff ff	 jmp	 $LN21@stbi__pic_
$LN22@stbi__pic_:
$LN11@stbi__pic_:

; 6488 :                     break;
; 6489 :                 }
; 6490 :             }
; 6491 :         }

  0060f	e9 d9 fb ff ff	 jmp	 $LN8@stbi__pic_
$LN9@stbi__pic_:

; 6492 :     }

  00614	e9 af fb ff ff	 jmp	 $LN5@stbi__pic_
$LN6@stbi__pic_:

; 6493 :     
; 6494 :     return result;

  00619	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR result$[rsp]
$LN1@stbi__pic_:

; 6495 : }

  00621	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00629	48 33 cc	 xor	 rcx, rsp
  0062c	e8 00 00 00 00	 call	 __security_check_cookie
  00631	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  00638	c3		 ret	 0
?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z ENDP ; stbi__pic_load_core
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
i$ = 0
mask$ = 4
channel$ = 32
dest$ = 40
src$ = 48
?stbi__copyval@@YAXHPEAEPEBE@Z PROC			; stbi__copyval

; 6379 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 6380 :     int mask=0x80,i;

  00012	c7 44 24 04 80
	00 00 00	 mov	 DWORD PTR mask$[rsp], 128 ; 00000080H

; 6381 :     
; 6382 :     for (i=0;i<4; ++i, mask>>=1)

  0001a	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  00021	eb 12		 jmp	 SHORT $LN4@stbi__copy
$LN2@stbi__copy:
  00023	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00026	ff c0		 inc	 eax
  00028	89 04 24	 mov	 DWORD PTR i$[rsp], eax
  0002b	8b 44 24 04	 mov	 eax, DWORD PTR mask$[rsp]
  0002f	d1 f8		 sar	 eax, 1
  00031	89 44 24 04	 mov	 DWORD PTR mask$[rsp], eax
$LN4@stbi__copy:
  00035	83 3c 24 04	 cmp	 DWORD PTR i$[rsp], 4
  00039	7d 2c		 jge	 SHORT $LN3@stbi__copy

; 6383 :         if (channel&mask)

  0003b	8b 44 24 04	 mov	 eax, DWORD PTR mask$[rsp]
  0003f	8b 4c 24 20	 mov	 ecx, DWORD PTR channel$[rsp]
  00043	23 c8		 and	 ecx, eax
  00045	8b c1		 mov	 eax, ecx
  00047	85 c0		 test	 eax, eax
  00049	74 1a		 je	 SHORT $LN5@stbi__copy

; 6384 :         dest[i]=src[i];

  0004b	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  0004f	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  00053	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$[rsp]
  00058	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$[rsp]
  0005d	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00062	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN5@stbi__copy:
  00065	eb bc		 jmp	 SHORT $LN2@stbi__copy
$LN3@stbi__copy:

; 6385 : }

  00067	48 83 c4 18	 add	 rsp, 24
  0006b	c3		 ret	 0
?stbi__copyval@@YAXHPEAEPEBE@Z ENDP			; stbi__copyval
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
i$ = 32
mask$ = 36
tv75 = 40
s$ = 64
channel$ = 72
dest$ = 80
?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z PROC	; stbi__readval

; 6365 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6366 :     int mask=0x80, i;

  00012	c7 44 24 24 80
	00 00 00	 mov	 DWORD PTR mask$[rsp], 128 ; 00000080H

; 6367 :     
; 6368 :     for (i=0; i<4; ++i, mask>>=1) {

  0001a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00022	eb 14		 jmp	 SHORT $LN4@stbi__read
$LN2@stbi__read:
  00024	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00028	ff c0		 inc	 eax
  0002a	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0002e	8b 44 24 24	 mov	 eax, DWORD PTR mask$[rsp]
  00032	d1 f8		 sar	 eax, 1
  00034	89 44 24 24	 mov	 DWORD PTR mask$[rsp], eax
$LN4@stbi__read:
  00038	83 7c 24 20 04	 cmp	 DWORD PTR i$[rsp], 4
  0003d	7d 60		 jge	 SHORT $LN3@stbi__read

; 6369 :         if (channel & mask) {

  0003f	8b 44 24 24	 mov	 eax, DWORD PTR mask$[rsp]
  00043	8b 4c 24 48	 mov	 ecx, DWORD PTR channel$[rsp]
  00047	23 c8		 and	 ecx, eax
  00049	8b c1		 mov	 eax, ecx
  0004b	85 c0		 test	 eax, eax
  0004d	74 4e		 je	 SHORT $LN5@stbi__read

; 6370 :             if (stbi__at_eof(s)) return stbi__errpuc("bad file","PIC file too short");

  0004f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00054	e8 00 00 00 00	 call	 ?stbi__at_eof@@YAHPEAUstbi__context@@@Z ; stbi__at_eof
  00059	85 c0		 test	 eax, eax
  0005b	74 29		 je	 SHORT $LN6@stbi__read
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81498
  00064	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00069	85 c0		 test	 eax, eax
  0006b	74 0a		 je	 SHORT $LN8@stbi__read
  0006d	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
  00075	eb 08		 jmp	 SHORT $LN9@stbi__read
$LN8@stbi__read:
  00077	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN9@stbi__read:
  0007f	48 63 44 24 28	 movsxd	 rax, DWORD PTR tv75[rsp]
  00084	eb 1e		 jmp	 SHORT $LN1@stbi__read
$LN6@stbi__read:

; 6371 :             dest[i]=stbi__get8(s);

  00086	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0008b	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00090	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00095	48 8b 54 24 50	 mov	 rdx, QWORD PTR dest$[rsp]
  0009a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN5@stbi__read:

; 6372 :         }
; 6373 :     }

  0009d	eb 85		 jmp	 SHORT $LN2@stbi__read
$LN3@stbi__read:

; 6374 :     
; 6375 :     return dest;

  0009f	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
$LN1@stbi__read:

; 6376 : }

  000a4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a8	c3		 ret	 0
?stbi__readval@@YAPEAEPEAUstbi__context@@HPEAE@Z ENDP	; stbi__readval
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
i$ = 32
s$ = 64
?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z PROC	; stbi__pic_test_core

; 6344 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6345 :     int i;
; 6346 :     
; 6347 :     if (!stbi__pic_is4(s,"\x53\x80\xF6\x34"))

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG81466
  00010	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00015	e8 00 00 00 00	 call	 ?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z ; stbi__pic_is4
  0001a	85 c0		 test	 eax, eax
  0001c	75 04		 jne	 SHORT $LN5@stbi__pic_

; 6348 :         return 0;

  0001e	33 c0		 xor	 eax, eax
  00020	eb 45		 jmp	 SHORT $LN1@stbi__pic_
$LN5@stbi__pic_:

; 6349 :     
; 6350 :     for(i=0;i<84;++i)

  00022	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0002a	eb 0a		 jmp	 SHORT $LN4@stbi__pic_
$LN2@stbi__pic_:
  0002c	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00030	ff c0		 inc	 eax
  00032	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__pic_:
  00036	83 7c 24 20 54	 cmp	 DWORD PTR i$[rsp], 84	; 00000054H
  0003b	7d 0c		 jge	 SHORT $LN3@stbi__pic_

; 6351 :         stbi__get8(s);

  0003d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00042	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00047	eb e3		 jmp	 SHORT $LN2@stbi__pic_
$LN3@stbi__pic_:

; 6352 :     
; 6353 :     if (!stbi__pic_is4(s,"PICT"))

  00049	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG81468
  00050	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00055	e8 00 00 00 00	 call	 ?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z ; stbi__pic_is4
  0005a	85 c0		 test	 eax, eax
  0005c	75 04		 jne	 SHORT $LN6@stbi__pic_

; 6354 :         return 0;

  0005e	33 c0		 xor	 eax, eax
  00060	eb 05		 jmp	 SHORT $LN1@stbi__pic_
$LN6@stbi__pic_:

; 6355 :     
; 6356 :     return 1;

  00062	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__pic_:

; 6357 : }

  00067	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006b	c3		 ret	 0
?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z ENDP	; stbi__pic_test_core
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
i$ = 32
s$ = 64
str$ = 72
?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z PROC	; stbi__pic_is4

; 6334 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6335 :     int i;
; 6336 :     for (i=0; i<4; ++i)

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00016	eb 0a		 jmp	 SHORT $LN4@stbi__pic_
$LN2@stbi__pic_:
  00018	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0001c	ff c0		 inc	 eax
  0001e	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__pic_:
  00022	83 7c 24 20 04	 cmp	 DWORD PTR i$[rsp], 4
  00027	7d 25		 jge	 SHORT $LN3@stbi__pic_

; 6337 :         if (stbi__get8(s) != (stbi_uc)str[i])

  00029	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0002e	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00033	0f b6 c0	 movzx	 eax, al
  00036	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0003b	48 8b 54 24 48	 mov	 rdx, QWORD PTR str$[rsp]
  00040	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00044	3b c1		 cmp	 eax, ecx
  00046	74 04		 je	 SHORT $LN5@stbi__pic_

; 6338 :         return 0;

  00048	33 c0		 xor	 eax, eax
  0004a	eb 07		 jmp	 SHORT $LN1@stbi__pic_
$LN5@stbi__pic_:
  0004c	eb ca		 jmp	 SHORT $LN2@stbi__pic_
$LN3@stbi__pic_:

; 6339 :     
; 6340 :     return 1;

  0004e	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__pic_:

; 6341 : }

  00053	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00057	c3		 ret	 0
?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z ENDP	; stbi__pic_is4
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
val$1 = 32
len$ = 36
count$ = 40
nleft$ = 44
s$ = 64
p$ = 72
pixelCount$ = 80
?stbi__psd_decode_rle@@YAHPEAUstbi__context@@PEAEH@Z PROC ; stbi__psd_decode_rle

; 6086 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6087 :     int count, nleft, len;
; 6088 :     
; 6089 :     count = 0;

  00013	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR count$[rsp], 0
$LN2@stbi__psd_:

; 6090 :     while ((nleft = pixelCount - count) > 0) {

  0001b	8b 44 24 28	 mov	 eax, DWORD PTR count$[rsp]
  0001f	8b 4c 24 50	 mov	 ecx, DWORD PTR pixelCount$[rsp]
  00023	2b c8		 sub	 ecx, eax
  00025	8b c1		 mov	 eax, ecx
  00027	89 44 24 2c	 mov	 DWORD PTR nleft$[rsp], eax
  0002b	83 7c 24 2c 00	 cmp	 DWORD PTR nleft$[rsp], 0
  00030	0f 8e fe 00 00
	00		 jle	 $LN3@stbi__psd_

; 6091 :         len = stbi__get8(s);

  00036	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0003b	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00040	0f b6 c0	 movzx	 eax, al
  00043	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax

; 6092 :         if (len == 128) {

  00047	81 7c 24 24 80
	00 00 00	 cmp	 DWORD PTR len$[rsp], 128 ; 00000080H
  0004f	75 05		 jne	 SHORT $LN8@stbi__psd_
  00051	e9 d9 00 00 00	 jmp	 $LN9@stbi__psd_
$LN8@stbi__psd_:

; 6093 :             // No-op.
; 6094 :         } else if (len < 128) {

  00056	81 7c 24 24 80
	00 00 00	 cmp	 DWORD PTR len$[rsp], 128 ; 00000080H
  0005e	7d 5f		 jge	 SHORT $LN10@stbi__psd_

; 6095 :             // Copy next len+1 bytes literally.
; 6096 :             len++;

  00060	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  00064	ff c0		 inc	 eax
  00066	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax

; 6097 :             if (len > nleft) return 0; // corrupt data

  0006a	8b 44 24 2c	 mov	 eax, DWORD PTR nleft$[rsp]
  0006e	39 44 24 24	 cmp	 DWORD PTR len$[rsp], eax
  00072	7e 07		 jle	 SHORT $LN12@stbi__psd_
  00074	33 c0		 xor	 eax, eax
  00076	e9 be 00 00 00	 jmp	 $LN1@stbi__psd_
$LN12@stbi__psd_:

; 6098 :             count += len;

  0007b	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  0007f	8b 4c 24 28	 mov	 ecx, DWORD PTR count$[rsp]
  00083	03 c8		 add	 ecx, eax
  00085	8b c1		 mov	 eax, ecx
  00087	89 44 24 28	 mov	 DWORD PTR count$[rsp], eax
$LN4@stbi__psd_:

; 6099 :             while (len) {

  0008b	83 7c 24 24 00	 cmp	 DWORD PTR len$[rsp], 0
  00090	74 2b		 je	 SHORT $LN5@stbi__psd_

; 6100 :                 *p = stbi__get8(s);

  00092	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00097	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0009c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR p$[rsp]
  000a1	88 01		 mov	 BYTE PTR [rcx], al

; 6101 :                 p += 4;

  000a3	48 8b 44 24 48	 mov	 rax, QWORD PTR p$[rsp]
  000a8	48 83 c0 04	 add	 rax, 4
  000ac	48 89 44 24 48	 mov	 QWORD PTR p$[rsp], rax

; 6102 :                 len--;

  000b1	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  000b5	ff c8		 dec	 eax
  000b7	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax

; 6103 :             }

  000bb	eb ce		 jmp	 SHORT $LN4@stbi__psd_
$LN5@stbi__psd_:

; 6104 :         } else if (len > 128) {

  000bd	eb 70		 jmp	 SHORT $LN11@stbi__psd_
$LN10@stbi__psd_:
  000bf	81 7c 24 24 80
	00 00 00	 cmp	 DWORD PTR len$[rsp], 128 ; 00000080H
  000c7	7e 66		 jle	 SHORT $LN13@stbi__psd_

; 6105 :             stbi_uc   val;
; 6106 :             // Next -len+1 bytes in the dest are replicated from next source byte.
; 6107 :             // (Interpret len as a negative 8-bit int.)
; 6108 :             len = 257 - len;

  000c9	b8 01 01 00 00	 mov	 eax, 257		; 00000101H
  000ce	2b 44 24 24	 sub	 eax, DWORD PTR len$[rsp]
  000d2	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax

; 6109 :             if (len > nleft) return 0; // corrupt data

  000d6	8b 44 24 2c	 mov	 eax, DWORD PTR nleft$[rsp]
  000da	39 44 24 24	 cmp	 DWORD PTR len$[rsp], eax
  000de	7e 04		 jle	 SHORT $LN14@stbi__psd_
  000e0	33 c0		 xor	 eax, eax
  000e2	eb 55		 jmp	 SHORT $LN1@stbi__psd_
$LN14@stbi__psd_:

; 6110 :             val = stbi__get8(s);

  000e4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000e9	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  000ee	88 44 24 20	 mov	 BYTE PTR val$1[rsp], al

; 6111 :             count += len;

  000f2	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  000f6	8b 4c 24 28	 mov	 ecx, DWORD PTR count$[rsp]
  000fa	03 c8		 add	 ecx, eax
  000fc	8b c1		 mov	 eax, ecx
  000fe	89 44 24 28	 mov	 DWORD PTR count$[rsp], eax
$LN6@stbi__psd_:

; 6112 :             while (len) {

  00102	83 7c 24 24 00	 cmp	 DWORD PTR len$[rsp], 0
  00107	74 26		 je	 SHORT $LN7@stbi__psd_

; 6113 :                 *p = val;

  00109	48 8b 44 24 48	 mov	 rax, QWORD PTR p$[rsp]
  0010e	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR val$1[rsp]
  00113	88 08		 mov	 BYTE PTR [rax], cl

; 6114 :                 p += 4;

  00115	48 8b 44 24 48	 mov	 rax, QWORD PTR p$[rsp]
  0011a	48 83 c0 04	 add	 rax, 4
  0011e	48 89 44 24 48	 mov	 QWORD PTR p$[rsp], rax

; 6115 :                 len--;

  00123	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  00127	ff c8		 dec	 eax
  00129	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax

; 6116 :             }

  0012d	eb d3		 jmp	 SHORT $LN6@stbi__psd_
$LN7@stbi__psd_:
$LN13@stbi__psd_:
$LN11@stbi__psd_:
$LN9@stbi__psd_:

; 6117 :         }
; 6118 :     }

  0012f	e9 e7 fe ff ff	 jmp	 $LN2@stbi__psd_
$LN3@stbi__psd_:

; 6119 :     
; 6120 :     return 1;

  00134	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__psd_:

; 6121 : }

  00139	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0013d	c3		 ret	 0
?stbi__psd_decode_rle@@YAHPEAUstbi__context@@PEAEH@Z ENDP ; stbi__psd_decode_rle
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
px$ = 32
fiveBitMask$ = 36
r$ = 40
g$ = 44
b$ = 48
s$ = 80
out$ = 88
?stbi__tga_read_rgb16@@YAXPEAUstbi__context@@PEAE@Z PROC ; stbi__tga_read_rgb16

; 5850 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 5851 :     stbi__uint16 px = (stbi__uint16)stbi__get16le(s);

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00013	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  00018	66 89 44 24 20	 mov	 WORD PTR px$[rsp], ax

; 5852 :     stbi__uint16 fiveBitMask = 31;

  0001d	b8 1f 00 00 00	 mov	 eax, 31
  00022	66 89 44 24 24	 mov	 WORD PTR fiveBitMask$[rsp], ax

; 5853 :     // we have 3 channels with 5bits each
; 5854 :     int r = (px >> 10) & fiveBitMask;

  00027	0f b7 44 24 20	 movzx	 eax, WORD PTR px$[rsp]
  0002c	c1 f8 0a	 sar	 eax, 10
  0002f	0f b7 4c 24 24	 movzx	 ecx, WORD PTR fiveBitMask$[rsp]
  00034	23 c1		 and	 eax, ecx
  00036	89 44 24 28	 mov	 DWORD PTR r$[rsp], eax

; 5855 :     int g = (px >> 5) & fiveBitMask;

  0003a	0f b7 44 24 20	 movzx	 eax, WORD PTR px$[rsp]
  0003f	c1 f8 05	 sar	 eax, 5
  00042	0f b7 4c 24 24	 movzx	 ecx, WORD PTR fiveBitMask$[rsp]
  00047	23 c1		 and	 eax, ecx
  00049	89 44 24 2c	 mov	 DWORD PTR g$[rsp], eax

; 5856 :     int b = px & fiveBitMask;

  0004d	0f b7 44 24 20	 movzx	 eax, WORD PTR px$[rsp]
  00052	0f b7 4c 24 24	 movzx	 ecx, WORD PTR fiveBitMask$[rsp]
  00057	23 c1		 and	 eax, ecx
  00059	89 44 24 30	 mov	 DWORD PTR b$[rsp], eax

; 5857 :     // Note that this saves the data in RGB(A) order, so it doesn't need to be swapped later
; 5858 :     out[0] = (stbi_uc)((r * 255)/31);

  0005d	69 44 24 28 ff
	00 00 00	 imul	 eax, DWORD PTR r$[rsp], 255 ; 000000ffH
  00065	99		 cdq
  00066	b9 1f 00 00 00	 mov	 ecx, 31
  0006b	f7 f9		 idiv	 ecx
  0006d	b9 01 00 00 00	 mov	 ecx, 1
  00072	48 6b c9 00	 imul	 rcx, rcx, 0
  00076	48 8b 54 24 58	 mov	 rdx, QWORD PTR out$[rsp]
  0007b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5859 :     out[1] = (stbi_uc)((g * 255)/31);

  0007e	69 44 24 2c ff
	00 00 00	 imul	 eax, DWORD PTR g$[rsp], 255 ; 000000ffH
  00086	99		 cdq
  00087	b9 1f 00 00 00	 mov	 ecx, 31
  0008c	f7 f9		 idiv	 ecx
  0008e	b9 01 00 00 00	 mov	 ecx, 1
  00093	48 6b c9 01	 imul	 rcx, rcx, 1
  00097	48 8b 54 24 58	 mov	 rdx, QWORD PTR out$[rsp]
  0009c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5860 :     out[2] = (stbi_uc)((b * 255)/31);

  0009f	69 44 24 30 ff
	00 00 00	 imul	 eax, DWORD PTR b$[rsp], 255 ; 000000ffH
  000a7	99		 cdq
  000a8	b9 1f 00 00 00	 mov	 ecx, 31
  000ad	f7 f9		 idiv	 ecx
  000af	b9 01 00 00 00	 mov	 ecx, 1
  000b4	48 6b c9 02	 imul	 rcx, rcx, 2
  000b8	48 8b 54 24 58	 mov	 rdx, QWORD PTR out$[rsp]
  000bd	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5861 :     
; 5862 :     // some people claim that the most significant bit might be used for alpha
; 5863 :     // (possibly if an alpha-bit is set in the "image descriptor byte")
; 5864 :     // but that only made 16bit test images completely translucent..
; 5865 :     // so let's treat all 15 and 16bit TGAs as RGB with no alpha.
; 5866 : }

  000c0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c4	c3		 ret	 0
?stbi__tga_read_rgb16@@YAXPEAUstbi__context@@PEAE@Z ENDP ; stbi__tga_read_rgb16
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv65 = 0
bits_per_pixel$ = 32
is_grey$ = 40
is_rgb16$ = 48
?stbi__tga_get_comp@@YAHHHPEAH@Z PROC			; stbi__tga_get_comp

; 5737 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 18	 sub	 rsp, 24

; 5738 :     // only RGB or RGBA (incl. 16bit) or grey allowed
; 5739 :     if (is_rgb16) *is_rgb16 = 0;

  00011	48 83 7c 24 30
	00		 cmp	 QWORD PTR is_rgb16$[rsp], 0
  00017	74 0b		 je	 SHORT $LN4@stbi__tga_
  00019	48 8b 44 24 30	 mov	 rax, QWORD PTR is_rgb16$[rsp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN4@stbi__tga_:

; 5740 :     switch(bits_per_pixel) {

  00024	8b 44 24 20	 mov	 eax, DWORD PTR bits_per_pixel$[rsp]
  00028	89 04 24	 mov	 DWORD PTR tv65[rsp], eax
  0002b	83 3c 24 08	 cmp	 DWORD PTR tv65[rsp], 8
  0002f	74 1a		 je	 SHORT $LN5@stbi__tga_
  00031	83 3c 24 0f	 cmp	 DWORD PTR tv65[rsp], 15
  00035	74 29		 je	 SHORT $LN8@stbi__tga_
  00037	83 3c 24 10	 cmp	 DWORD PTR tv65[rsp], 16
  0003b	74 15		 je	 SHORT $LN6@stbi__tga_
  0003d	83 3c 24 18	 cmp	 DWORD PTR tv65[rsp], 24
  00041	74 37		 je	 SHORT $LN10@stbi__tga_
  00043	83 3c 24 20	 cmp	 DWORD PTR tv65[rsp], 32	; 00000020H
  00047	74 31		 je	 SHORT $LN10@stbi__tga_
  00049	eb 3e		 jmp	 SHORT $LN11@stbi__tga_
$LN5@stbi__tga_:

; 5741 :         case 8:  return STBI_grey;

  0004b	b8 01 00 00 00	 mov	 eax, 1
  00050	eb 39		 jmp	 SHORT $LN1@stbi__tga_
$LN6@stbi__tga_:

; 5742 :         case 16: if(is_grey) return STBI_grey_alpha;

  00052	83 7c 24 28 00	 cmp	 DWORD PTR is_grey$[rsp], 0
  00057	74 07		 je	 SHORT $LN7@stbi__tga_
  00059	b8 02 00 00 00	 mov	 eax, 2
  0005e	eb 2b		 jmp	 SHORT $LN1@stbi__tga_
$LN7@stbi__tga_:
$LN8@stbi__tga_:

; 5743 :         // fallthrough
; 5744 :         case 15: if(is_rgb16) *is_rgb16 = 1;

  00060	48 83 7c 24 30
	00		 cmp	 QWORD PTR is_rgb16$[rsp], 0
  00066	74 0b		 je	 SHORT $LN9@stbi__tga_
  00068	48 8b 44 24 30	 mov	 rax, QWORD PTR is_rgb16$[rsp]
  0006d	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1
$LN9@stbi__tga_:

; 5745 :         return STBI_rgb;

  00073	b8 03 00 00 00	 mov	 eax, 3
  00078	eb 11		 jmp	 SHORT $LN1@stbi__tga_
$LN10@stbi__tga_:

; 5746 :         case 24: // fallthrough
; 5747 :         case 32: return bits_per_pixel/8;

  0007a	8b 44 24 20	 mov	 eax, DWORD PTR bits_per_pixel$[rsp]
  0007e	99		 cdq
  0007f	83 e2 07	 and	 edx, 7
  00082	03 c2		 add	 eax, edx
  00084	c1 f8 03	 sar	 eax, 3
  00087	eb 02		 jmp	 SHORT $LN1@stbi__tga_
$LN11@stbi__tga_:

; 5748 :         default: return 0;

  00089	33 c0		 xor	 eax, eax
$LN1@stbi__tga_:

; 5749 :     }
; 5750 : }

  0008b	48 83 c4 18	 add	 rsp, 24
  0008f	c3		 ret	 0
?stbi__tga_get_comp@@YAHHHPEAH@Z ENDP			; stbi__tga_get_comp
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
hsz$ = 32
compress$1 = 36
i$2 = 40
tv75 = 44
tv128 = 48
tv138 = 52
tv159 = 56
tv172 = 60
tv178 = 64
tv188 = 68
tv231 = 72
tv236 = 76
tv243 = 80
s$ = 112
info$ = 120
?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z PROC ; stbi__bmp_parse_header

; 5446 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 5447 :     int hsz;
; 5448 :     if (stbi__get8(s) != 'B' || stbi__get8(s) != 'M') return stbi__errpuc("not BMP", "Corrupt BMP");

  0000e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00013	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00018	0f b6 c0	 movzx	 eax, al
  0001b	83 f8 42	 cmp	 eax, 66			; 00000042H
  0001e	75 12		 jne	 SHORT $LN6@stbi__bmp_
  00020	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00025	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0002a	0f b6 c0	 movzx	 eax, al
  0002d	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  00030	74 2c		 je	 SHORT $LN5@stbi__bmp_
$LN6@stbi__bmp_:
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80826
  00039	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0003e	85 c0		 test	 eax, eax
  00040	74 0a		 je	 SHORT $LN32@stbi__bmp_
  00042	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
  0004a	eb 08		 jmp	 SHORT $LN33@stbi__bmp_
$LN32@stbi__bmp_:
  0004c	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN33@stbi__bmp_:
  00054	48 63 44 24 2c	 movsxd	 rax, DWORD PTR tv75[rsp]
  00059	e9 ec 04 00 00	 jmp	 $LN1@stbi__bmp_
$LN5@stbi__bmp_:

; 5449 :     stbi__get32le(s); // discard filesize

  0005e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00063	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5450 :     stbi__get16le(s); // discard reserved

  00068	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0006d	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 5451 :     stbi__get16le(s); // discard reserved

  00072	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00077	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 5452 :     info->offset = stbi__get32le(s);

  0007c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00081	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
  00086	48 8b 4c 24 78	 mov	 rcx, QWORD PTR info$[rsp]
  0008b	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 5453 :     info->hsz = hsz = stbi__get32le(s);

  0008e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00093	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
  00098	89 44 24 20	 mov	 DWORD PTR hsz$[rsp], eax
  0009c	48 8b 44 24 78	 mov	 rax, QWORD PTR info$[rsp]
  000a1	8b 4c 24 20	 mov	 ecx, DWORD PTR hsz$[rsp]
  000a5	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 5454 :     info->mr = info->mg = info->mb = info->ma = 0;

  000a8	48 8b 44 24 78	 mov	 rax, QWORD PTR info$[rsp]
  000ad	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0
  000b4	48 8b 44 24 78	 mov	 rax, QWORD PTR info$[rsp]
  000b9	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0
  000c0	48 8b 44 24 78	 mov	 rax, QWORD PTR info$[rsp]
  000c5	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0
  000cc	48 8b 44 24 78	 mov	 rax, QWORD PTR info$[rsp]
  000d1	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 5455 :     info->extra_read = 14;

  000d8	48 8b 44 24 78	 mov	 rax, QWORD PTR info$[rsp]
  000dd	c7 40 20 0e 00
	00 00		 mov	 DWORD PTR [rax+32], 14

; 5456 :     
; 5457 :     if (info->offset < 0) return stbi__errpuc("bad BMP", "bad BMP");

  000e4	48 8b 44 24 78	 mov	 rax, QWORD PTR info$[rsp]
  000e9	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  000ed	7d 2c		 jge	 SHORT $LN7@stbi__bmp_
  000ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80828
  000f6	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000fb	85 c0		 test	 eax, eax
  000fd	74 0a		 je	 SHORT $LN34@stbi__bmp_
  000ff	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
  00107	eb 08		 jmp	 SHORT $LN35@stbi__bmp_
$LN34@stbi__bmp_:
  00109	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
$LN35@stbi__bmp_:
  00111	48 63 44 24 30	 movsxd	 rax, DWORD PTR tv128[rsp]
  00116	e9 2f 04 00 00	 jmp	 $LN1@stbi__bmp_
$LN7@stbi__bmp_:

; 5458 :     
; 5459 :     if (hsz != 12 && hsz != 40 && hsz != 56 && hsz != 108 && hsz != 124) return stbi__errpuc("unknown BMP", "BMP type not supported: unknown");

  0011b	83 7c 24 20 0c	 cmp	 DWORD PTR hsz$[rsp], 12
  00120	74 48		 je	 SHORT $LN8@stbi__bmp_
  00122	83 7c 24 20 28	 cmp	 DWORD PTR hsz$[rsp], 40	; 00000028H
  00127	74 41		 je	 SHORT $LN8@stbi__bmp_
  00129	83 7c 24 20 38	 cmp	 DWORD PTR hsz$[rsp], 56	; 00000038H
  0012e	74 3a		 je	 SHORT $LN8@stbi__bmp_
  00130	83 7c 24 20 6c	 cmp	 DWORD PTR hsz$[rsp], 108 ; 0000006cH
  00135	74 33		 je	 SHORT $LN8@stbi__bmp_
  00137	83 7c 24 20 7c	 cmp	 DWORD PTR hsz$[rsp], 124 ; 0000007cH
  0013c	74 2c		 je	 SHORT $LN8@stbi__bmp_
  0013e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80830
  00145	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0014a	85 c0		 test	 eax, eax
  0014c	74 0a		 je	 SHORT $LN36@stbi__bmp_
  0014e	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv138[rsp], 0
  00156	eb 08		 jmp	 SHORT $LN37@stbi__bmp_
$LN36@stbi__bmp_:
  00158	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv138[rsp], 0
$LN37@stbi__bmp_:
  00160	48 63 44 24 34	 movsxd	 rax, DWORD PTR tv138[rsp]
  00165	e9 e0 03 00 00	 jmp	 $LN1@stbi__bmp_
$LN8@stbi__bmp_:

; 5460 :     if (hsz == 12) {

  0016a	83 7c 24 20 0c	 cmp	 DWORD PTR hsz$[rsp], 12
  0016f	75 25		 jne	 SHORT $LN9@stbi__bmp_

; 5461 :         s->img_x = stbi__get16le(s);

  00171	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00176	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  0017b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00180	89 01		 mov	 DWORD PTR [rcx], eax

; 5462 :         s->img_y = stbi__get16le(s);

  00182	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00187	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  0018c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00191	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 5463 :     } else {

  00194	eb 23		 jmp	 SHORT $LN10@stbi__bmp_
$LN9@stbi__bmp_:

; 5464 :         s->img_x = stbi__get32le(s);

  00196	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0019b	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
  001a0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  001a5	89 01		 mov	 DWORD PTR [rcx], eax

; 5465 :         s->img_y = stbi__get32le(s);

  001a7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  001ac	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
  001b1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  001b6	89 41 04	 mov	 DWORD PTR [rcx+4], eax
$LN10@stbi__bmp_:

; 5466 :     }
; 5467 :     if (stbi__get16le(s) != 1) return stbi__errpuc("bad BMP", "bad BMP");

  001b9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  001be	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  001c3	83 f8 01	 cmp	 eax, 1
  001c6	74 2c		 je	 SHORT $LN11@stbi__bmp_
  001c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80834
  001cf	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  001d4	85 c0		 test	 eax, eax
  001d6	74 0a		 je	 SHORT $LN38@stbi__bmp_
  001d8	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv159[rsp], 0
  001e0	eb 08		 jmp	 SHORT $LN39@stbi__bmp_
$LN38@stbi__bmp_:
  001e2	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv159[rsp], 0
$LN39@stbi__bmp_:
  001ea	48 63 44 24 38	 movsxd	 rax, DWORD PTR tv159[rsp]
  001ef	e9 56 03 00 00	 jmp	 $LN1@stbi__bmp_
$LN11@stbi__bmp_:

; 5468 :     info->bpp = stbi__get16le(s);

  001f4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  001f9	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  001fe	48 8b 4c 24 78	 mov	 rcx, QWORD PTR info$[rsp]
  00203	89 01		 mov	 DWORD PTR [rcx], eax

; 5469 :     if (hsz != 12) {

  00205	83 7c 24 20 0c	 cmp	 DWORD PTR hsz$[rsp], 12
  0020a	0f 84 35 03 00
	00		 je	 $LN12@stbi__bmp_

; 5470 :         int compress = stbi__get32le(s);

  00210	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00215	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
  0021a	89 44 24 24	 mov	 DWORD PTR compress$1[rsp], eax

; 5471 :         if (compress == 1 || compress == 2) return stbi__errpuc("BMP RLE", "BMP type not supported: RLE");

  0021e	83 7c 24 24 01	 cmp	 DWORD PTR compress$1[rsp], 1
  00223	74 07		 je	 SHORT $LN14@stbi__bmp_
  00225	83 7c 24 24 02	 cmp	 DWORD PTR compress$1[rsp], 2
  0022a	75 2c		 jne	 SHORT $LN13@stbi__bmp_
$LN14@stbi__bmp_:
  0022c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80838
  00233	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00238	85 c0		 test	 eax, eax
  0023a	74 0a		 je	 SHORT $LN40@stbi__bmp_
  0023c	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv172[rsp], 0
  00244	eb 08		 jmp	 SHORT $LN41@stbi__bmp_
$LN40@stbi__bmp_:
  00246	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv172[rsp], 0
$LN41@stbi__bmp_:
  0024e	48 63 44 24 3c	 movsxd	 rax, DWORD PTR tv172[rsp]
  00253	e9 f2 02 00 00	 jmp	 $LN1@stbi__bmp_
$LN13@stbi__bmp_:

; 5472 :         if (compress >= 4) return stbi__errpuc("BMP JPEG/PNG", "BMP type not supported: unsupported compression"); // this includes PNG/JPEG modes

  00258	83 7c 24 24 04	 cmp	 DWORD PTR compress$1[rsp], 4
  0025d	7c 2c		 jl	 SHORT $LN15@stbi__bmp_
  0025f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80840
  00266	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0026b	85 c0		 test	 eax, eax
  0026d	74 0a		 je	 SHORT $LN42@stbi__bmp_
  0026f	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv178[rsp], 0
  00277	eb 08		 jmp	 SHORT $LN43@stbi__bmp_
$LN42@stbi__bmp_:
  00279	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv178[rsp], 0
$LN43@stbi__bmp_:
  00281	48 63 44 24 40	 movsxd	 rax, DWORD PTR tv178[rsp]
  00286	e9 bf 02 00 00	 jmp	 $LN1@stbi__bmp_
$LN15@stbi__bmp_:

; 5473 :         if (compress == 3 && info->bpp != 16 && info->bpp != 32) return stbi__errpuc("bad BMP", "bad BMP"); // bitfields requires 16 or 32 bits/pixel

  0028b	83 7c 24 24 03	 cmp	 DWORD PTR compress$1[rsp], 3
  00290	75 40		 jne	 SHORT $LN16@stbi__bmp_
  00292	48 8b 44 24 78	 mov	 rax, QWORD PTR info$[rsp]
  00297	83 38 10	 cmp	 DWORD PTR [rax], 16
  0029a	74 36		 je	 SHORT $LN16@stbi__bmp_
  0029c	48 8b 44 24 78	 mov	 rax, QWORD PTR info$[rsp]
  002a1	83 38 20	 cmp	 DWORD PTR [rax], 32	; 00000020H
  002a4	74 2c		 je	 SHORT $LN16@stbi__bmp_
  002a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80842
  002ad	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  002b2	85 c0		 test	 eax, eax
  002b4	74 0a		 je	 SHORT $LN44@stbi__bmp_
  002b6	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv188[rsp], 0
  002be	eb 08		 jmp	 SHORT $LN45@stbi__bmp_
$LN44@stbi__bmp_:
  002c0	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv188[rsp], 0
$LN45@stbi__bmp_:
  002c8	48 63 44 24 44	 movsxd	 rax, DWORD PTR tv188[rsp]
  002cd	e9 78 02 00 00	 jmp	 $LN1@stbi__bmp_
$LN16@stbi__bmp_:

; 5474 :         stbi__get32le(s); // discard sizeof

  002d2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  002d7	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5475 :         stbi__get32le(s); // discard hres

  002dc	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  002e1	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5476 :         stbi__get32le(s); // discard vres

  002e6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  002eb	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5477 :         stbi__get32le(s); // discard colorsused

  002f0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  002f5	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5478 :         stbi__get32le(s); // discard max important

  002fa	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  002ff	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5479 :         if (hsz == 40 || hsz == 56) {

  00304	83 7c 24 20 28	 cmp	 DWORD PTR hsz$[rsp], 40	; 00000028H
  00309	74 0b		 je	 SHORT $LN19@stbi__bmp_
  0030b	83 7c 24 20 38	 cmp	 DWORD PTR hsz$[rsp], 56	; 00000038H
  00310	0f 85 38 01 00
	00		 jne	 $LN17@stbi__bmp_
$LN19@stbi__bmp_:

; 5480 :             if (hsz == 56) {

  00316	83 7c 24 20 38	 cmp	 DWORD PTR hsz$[rsp], 56	; 00000038H
  0031b	75 28		 jne	 SHORT $LN20@stbi__bmp_

; 5481 :                 stbi__get32le(s);

  0031d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00322	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5482 :                 stbi__get32le(s);

  00327	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0032c	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5483 :                 stbi__get32le(s);

  00331	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00336	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5484 :                 stbi__get32le(s);

  0033b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00340	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
$LN20@stbi__bmp_:

; 5485 :             }
; 5486 :             if (info->bpp == 16 || info->bpp == 32) {

  00345	48 8b 44 24 78	 mov	 rax, QWORD PTR info$[rsp]
  0034a	83 38 10	 cmp	 DWORD PTR [rax], 16
  0034d	74 0e		 je	 SHORT $LN22@stbi__bmp_
  0034f	48 8b 44 24 78	 mov	 rax, QWORD PTR info$[rsp]
  00354	83 38 20	 cmp	 DWORD PTR [rax], 32	; 00000020H
  00357	0f 85 ec 00 00
	00		 jne	 $LN21@stbi__bmp_
$LN22@stbi__bmp_:

; 5487 :                 if (compress == 0) {

  0035d	83 7c 24 24 00	 cmp	 DWORD PTR compress$1[rsp], 0
  00362	75 13		 jne	 SHORT $LN23@stbi__bmp_

; 5488 :                     stbi__bmp_set_mask_defaults(info, compress);

  00364	8b 54 24 24	 mov	 edx, DWORD PTR compress$1[rsp]
  00368	48 8b 4c 24 78	 mov	 rcx, QWORD PTR info$[rsp]
  0036d	e8 00 00 00 00	 call	 ?stbi__bmp_set_mask_defaults@@YAHPEAUstbi__bmp_data@@H@Z ; stbi__bmp_set_mask_defaults
  00372	e9 d2 00 00 00	 jmp	 $LN24@stbi__bmp_
$LN23@stbi__bmp_:

; 5489 :                 } else if (compress == 3) {

  00377	83 7c 24 24 03	 cmp	 DWORD PTR compress$1[rsp], 3
  0037c	0f 85 9b 00 00
	00		 jne	 $LN25@stbi__bmp_

; 5490 :                     info->mr = stbi__get32le(s);

  00382	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00387	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
  0038c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR info$[rsp]
  00391	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 5491 :                     info->mg = stbi__get32le(s);

  00394	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00399	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
  0039e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR info$[rsp]
  003a3	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 5492 :                     info->mb = stbi__get32le(s);

  003a6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  003ab	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
  003b0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR info$[rsp]
  003b5	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 5493 :                     info->extra_read += 12;

  003b8	48 8b 44 24 78	 mov	 rax, QWORD PTR info$[rsp]
  003bd	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  003c0	83 c0 0c	 add	 eax, 12
  003c3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR info$[rsp]
  003c8	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 5494 :                     // not documented, but generated by photoshop and handled by mspaint
; 5495 :                     if (info->mr == info->mg && info->mg == info->mb) {

  003cb	48 8b 44 24 78	 mov	 rax, QWORD PTR info$[rsp]
  003d0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR info$[rsp]
  003d5	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  003d8	39 48 0c	 cmp	 DWORD PTR [rax+12], ecx
  003db	75 3e		 jne	 SHORT $LN27@stbi__bmp_
  003dd	48 8b 44 24 78	 mov	 rax, QWORD PTR info$[rsp]
  003e2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR info$[rsp]
  003e7	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  003ea	39 48 10	 cmp	 DWORD PTR [rax+16], ecx
  003ed	75 2c		 jne	 SHORT $LN27@stbi__bmp_

; 5496 :                         // ?!?!?
; 5497 :                         return stbi__errpuc("bad BMP", "bad BMP");

  003ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80854
  003f6	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  003fb	85 c0		 test	 eax, eax
  003fd	74 0a		 je	 SHORT $LN46@stbi__bmp_
  003ff	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv231[rsp], 0
  00407	eb 08		 jmp	 SHORT $LN47@stbi__bmp_
$LN46@stbi__bmp_:
  00409	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv231[rsp], 0
$LN47@stbi__bmp_:
  00411	48 63 44 24 48	 movsxd	 rax, DWORD PTR tv231[rsp]
  00416	e9 2f 01 00 00	 jmp	 $LN1@stbi__bmp_
$LN27@stbi__bmp_:

; 5498 :                     }
; 5499 :                 } else

  0041b	eb 2c		 jmp	 SHORT $LN26@stbi__bmp_
$LN25@stbi__bmp_:

; 5500 :                     return stbi__errpuc("bad BMP", "bad BMP");

  0041d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80855
  00424	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00429	85 c0		 test	 eax, eax
  0042b	74 0a		 je	 SHORT $LN48@stbi__bmp_
  0042d	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv236[rsp], 0
  00435	eb 08		 jmp	 SHORT $LN49@stbi__bmp_
$LN48@stbi__bmp_:
  00437	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv236[rsp], 0
$LN49@stbi__bmp_:
  0043f	48 63 44 24 4c	 movsxd	 rax, DWORD PTR tv236[rsp]
  00444	e9 01 01 00 00	 jmp	 $LN1@stbi__bmp_
$LN26@stbi__bmp_:
$LN24@stbi__bmp_:
$LN21@stbi__bmp_:

; 5501 :             }
; 5502 :         } else {

  00449	e9 f7 00 00 00	 jmp	 $LN18@stbi__bmp_
$LN17@stbi__bmp_:

; 5503 :             // V4/V5 header
; 5504 :             int i;
; 5505 :             if (hsz != 108 && hsz != 124)

  0044e	83 7c 24 20 6c	 cmp	 DWORD PTR hsz$[rsp], 108 ; 0000006cH
  00453	74 33		 je	 SHORT $LN28@stbi__bmp_
  00455	83 7c 24 20 7c	 cmp	 DWORD PTR hsz$[rsp], 124 ; 0000007cH
  0045a	74 2c		 je	 SHORT $LN28@stbi__bmp_

; 5506 :                 return stbi__errpuc("bad BMP", "bad BMP");

  0045c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80857
  00463	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00468	85 c0		 test	 eax, eax
  0046a	74 0a		 je	 SHORT $LN50@stbi__bmp_
  0046c	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv243[rsp], 0
  00474	eb 08		 jmp	 SHORT $LN51@stbi__bmp_
$LN50@stbi__bmp_:
  00476	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv243[rsp], 0
$LN51@stbi__bmp_:
  0047e	48 63 44 24 50	 movsxd	 rax, DWORD PTR tv243[rsp]
  00483	e9 c2 00 00 00	 jmp	 $LN1@stbi__bmp_
$LN28@stbi__bmp_:

; 5507 :             info->mr = stbi__get32le(s);

  00488	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0048d	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
  00492	48 8b 4c 24 78	 mov	 rcx, QWORD PTR info$[rsp]
  00497	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 5508 :             info->mg = stbi__get32le(s);

  0049a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0049f	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
  004a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR info$[rsp]
  004a9	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 5509 :             info->mb = stbi__get32le(s);

  004ac	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  004b1	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
  004b6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR info$[rsp]
  004bb	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 5510 :             info->ma = stbi__get32le(s);

  004be	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  004c3	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
  004c8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR info$[rsp]
  004cd	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 5511 :             if (compress != 3) // override mr/mg/mb unless in BI_BITFIELDS mode, as per docs

  004d0	83 7c 24 24 03	 cmp	 DWORD PTR compress$1[rsp], 3
  004d5	74 0e		 je	 SHORT $LN29@stbi__bmp_

; 5512 :                 stbi__bmp_set_mask_defaults(info, compress);

  004d7	8b 54 24 24	 mov	 edx, DWORD PTR compress$1[rsp]
  004db	48 8b 4c 24 78	 mov	 rcx, QWORD PTR info$[rsp]
  004e0	e8 00 00 00 00	 call	 ?stbi__bmp_set_mask_defaults@@YAHPEAUstbi__bmp_data@@H@Z ; stbi__bmp_set_mask_defaults
$LN29@stbi__bmp_:

; 5513 :             stbi__get32le(s); // discard color space

  004e5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  004ea	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5514 :             for (i=0; i < 12; ++i)

  004ef	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  004f7	eb 0a		 jmp	 SHORT $LN4@stbi__bmp_
$LN2@stbi__bmp_:
  004f9	8b 44 24 28	 mov	 eax, DWORD PTR i$2[rsp]
  004fd	ff c0		 inc	 eax
  004ff	89 44 24 28	 mov	 DWORD PTR i$2[rsp], eax
$LN4@stbi__bmp_:
  00503	83 7c 24 28 0c	 cmp	 DWORD PTR i$2[rsp], 12
  00508	7d 0c		 jge	 SHORT $LN3@stbi__bmp_

; 5515 :                 stbi__get32le(s); // discard color space parameters

  0050a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0050f	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
  00514	eb e3		 jmp	 SHORT $LN2@stbi__bmp_
$LN3@stbi__bmp_:

; 5516 :             if (hsz == 124) {

  00516	83 7c 24 20 7c	 cmp	 DWORD PTR hsz$[rsp], 124 ; 0000007cH
  0051b	75 28		 jne	 SHORT $LN30@stbi__bmp_

; 5517 :                 stbi__get32le(s); // discard rendering intent

  0051d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00522	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5518 :                 stbi__get32le(s); // discard offset of profile data

  00527	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0052c	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5519 :                 stbi__get32le(s); // discard size of profile data

  00531	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00536	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5520 :                 stbi__get32le(s); // discard reserved

  0053b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00540	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
$LN30@stbi__bmp_:
$LN18@stbi__bmp_:
$LN12@stbi__bmp_:

; 5521 :             }
; 5522 :         }
; 5523 :     }
; 5524 :     return (void *) 1;

  00545	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__bmp_:

; 5525 : }

  0054a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0054e	c3		 ret	 0
?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z ENDP ; stbi__bmp_parse_header
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
info$ = 8
compress$ = 16
?stbi__bmp_set_mask_defaults@@YAHPEAUstbi__bmp_data@@H@Z PROC ; stbi__bmp_set_mask_defaults

; 5420 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 5421 :     // BI_BITFIELDS specifies masks explicitly, don't override
; 5422 :     if (compress == 3)

  00009	83 7c 24 10 03	 cmp	 DWORD PTR compress$[rsp], 3
  0000e	75 0a		 jne	 SHORT $LN2@stbi__bmp_

; 5423 :         return 1;

  00010	b8 01 00 00 00	 mov	 eax, 1
  00015	e9 bc 00 00 00	 jmp	 $LN1@stbi__bmp_
$LN2@stbi__bmp_:

; 5424 :     
; 5425 :     if (compress == 0) {

  0001a	83 7c 24 10 00	 cmp	 DWORD PTR compress$[rsp], 0
  0001f	0f 85 af 00 00
	00		 jne	 $LN3@stbi__bmp_

; 5426 :         if (info->bpp == 16) {

  00025	48 8b 44 24 08	 mov	 rax, QWORD PTR info$[rsp]
  0002a	83 38 10	 cmp	 DWORD PTR [rax], 16
  0002d	75 26		 jne	 SHORT $LN4@stbi__bmp_

; 5427 :             info->mr = 31u << 10;

  0002f	48 8b 44 24 08	 mov	 rax, QWORD PTR info$[rsp]
  00034	c7 40 0c 00 7c
	00 00		 mov	 DWORD PTR [rax+12], 31744 ; 00007c00H

; 5428 :             info->mg = 31u <<  5;

  0003b	48 8b 44 24 08	 mov	 rax, QWORD PTR info$[rsp]
  00040	c7 40 10 e0 03
	00 00		 mov	 DWORD PTR [rax+16], 992	; 000003e0H

; 5429 :             info->mb = 31u <<  0;

  00047	48 8b 44 24 08	 mov	 rax, QWORD PTR info$[rsp]
  0004c	c7 40 14 1f 00
	00 00		 mov	 DWORD PTR [rax+20], 31
  00053	eb 78		 jmp	 SHORT $LN5@stbi__bmp_
$LN4@stbi__bmp_:

; 5430 :         } else if (info->bpp == 32) {

  00055	48 8b 44 24 08	 mov	 rax, QWORD PTR info$[rsp]
  0005a	83 38 20	 cmp	 DWORD PTR [rax], 32	; 00000020H
  0005d	75 3e		 jne	 SHORT $LN6@stbi__bmp_

; 5431 :             info->mr = 0xffu << 16;

  0005f	48 8b 44 24 08	 mov	 rax, QWORD PTR info$[rsp]
  00064	c7 40 0c 00 00
	ff 00		 mov	 DWORD PTR [rax+12], 16711680 ; 00ff0000H

; 5432 :             info->mg = 0xffu <<  8;

  0006b	48 8b 44 24 08	 mov	 rax, QWORD PTR info$[rsp]
  00070	c7 40 10 00 ff
	00 00		 mov	 DWORD PTR [rax+16], 65280 ; 0000ff00H

; 5433 :             info->mb = 0xffu <<  0;

  00077	48 8b 44 24 08	 mov	 rax, QWORD PTR info$[rsp]
  0007c	c7 40 14 ff 00
	00 00		 mov	 DWORD PTR [rax+20], 255	; 000000ffH

; 5434 :             info->ma = 0xffu << 24;

  00083	48 8b 44 24 08	 mov	 rax, QWORD PTR info$[rsp]
  00088	c7 40 18 00 00
	00 ff		 mov	 DWORD PTR [rax+24], -16777216 ; ff000000H

; 5435 :             info->all_a = 0; // if all_a is 0 at end, then we loaded alpha channel but it was all 0

  0008f	48 8b 44 24 08	 mov	 rax, QWORD PTR info$[rsp]
  00094	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [rax+28], 0

; 5436 :         } else {

  0009b	eb 30		 jmp	 SHORT $LN7@stbi__bmp_
$LN6@stbi__bmp_:

; 5437 :             // otherwise, use defaults, which is all-0
; 5438 :             info->mr = info->mg = info->mb = info->ma = 0;

  0009d	48 8b 44 24 08	 mov	 rax, QWORD PTR info$[rsp]
  000a2	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0
  000a9	48 8b 44 24 08	 mov	 rax, QWORD PTR info$[rsp]
  000ae	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0
  000b5	48 8b 44 24 08	 mov	 rax, QWORD PTR info$[rsp]
  000ba	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0
  000c1	48 8b 44 24 08	 mov	 rax, QWORD PTR info$[rsp]
  000c6	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0
$LN7@stbi__bmp_:
$LN5@stbi__bmp_:

; 5439 :         }
; 5440 :         return 1;

  000cd	b8 01 00 00 00	 mov	 eax, 1
  000d2	eb 02		 jmp	 SHORT $LN1@stbi__bmp_
$LN3@stbi__bmp_:

; 5441 :     }
; 5442 :     return 0; // error

  000d4	33 c0		 xor	 eax, eax
$LN1@stbi__bmp_:

; 5443 : }

  000d6	c3		 ret	 0
?stbi__bmp_set_mask_defaults@@YAHPEAUstbi__bmp_data@@H@Z ENDP ; stbi__bmp_set_mask_defaults
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
v$ = 48
shift$ = 56
bits$ = 64
?stbi__shiftsigned@@YAHIHH@Z PROC			; stbi__shiftsigned

; 5393 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 5394 :     static unsigned int mul_table[9] = {
; 5395 :         0,
; 5396 :         0xff/*0b11111111*/, 0x55/*0b01010101*/, 0x49/*0b01001001*/, 0x11/*0b00010001*/,
; 5397 :         0x21/*0b00100001*/, 0x41/*0b01000001*/, 0x81/*0b10000001*/, 0x01/*0b00000001*/,
; 5398 :     };
; 5399 :     static unsigned int shift_table[9] = {
; 5400 :         0, 0,0,1,0,2,4,6,0,
; 5401 :     };
; 5402 :     if (shift < 0)

  00011	83 7c 24 38 00	 cmp	 DWORD PTR shift$[rsp], 0
  00016	7d 15		 jge	 SHORT $LN2@stbi__shif

; 5403 :         v <<= -shift;

  00018	8b 44 24 38	 mov	 eax, DWORD PTR shift$[rsp]
  0001c	f7 d8		 neg	 eax
  0001e	0f b6 c8	 movzx	 ecx, al
  00021	8b 44 24 30	 mov	 eax, DWORD PTR v$[rsp]
  00025	d3 e0		 shl	 eax, cl
  00027	89 44 24 30	 mov	 DWORD PTR v$[rsp], eax
  0002b	eb 11		 jmp	 SHORT $LN3@stbi__shif
$LN2@stbi__shif:

; 5404 :     else
; 5405 :         v >>= shift;

  0002d	8b 44 24 38	 mov	 eax, DWORD PTR shift$[rsp]
  00031	0f b6 c8	 movzx	 ecx, al
  00034	8b 44 24 30	 mov	 eax, DWORD PTR v$[rsp]
  00038	d3 e8		 shr	 eax, cl
  0003a	89 44 24 30	 mov	 DWORD PTR v$[rsp], eax
$LN3@stbi__shif:

; 5406 :     STBI_ASSERT(v < 256);

  0003e	81 7c 24 30 00
	01 00 00	 cmp	 DWORD PTR v$[rsp], 256	; 00000100H
  00046	72 1b		 jb	 SHORT $LN5@stbi__shif
  00048	41 b8 1e 15 00
	00		 mov	 r8d, 5406		; 0000151eH
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG80758
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80759
  0005c	e8 00 00 00 00	 call	 _wassert
  00061	33 c0		 xor	 eax, eax
$LN5@stbi__shif:

; 5407 :     v >>= (8-bits);

  00063	b8 08 00 00 00	 mov	 eax, 8
  00068	2b 44 24 40	 sub	 eax, DWORD PTR bits$[rsp]
  0006c	0f b6 c8	 movzx	 ecx, al
  0006f	8b 44 24 30	 mov	 eax, DWORD PTR v$[rsp]
  00073	d3 e8		 shr	 eax, cl
  00075	89 44 24 30	 mov	 DWORD PTR v$[rsp], eax

; 5408 :     STBI_ASSERT(bits >= 0 && bits <= 8);

  00079	83 7c 24 40 00	 cmp	 DWORD PTR bits$[rsp], 0
  0007e	7c 07		 jl	 SHORT $LN6@stbi__shif
  00080	83 7c 24 40 08	 cmp	 DWORD PTR bits$[rsp], 8
  00085	7e 1b		 jle	 SHORT $LN7@stbi__shif
$LN6@stbi__shif:
  00087	41 b8 20 15 00
	00		 mov	 r8d, 5408		; 00001520H
  0008d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG80760
  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80761
  0009b	e8 00 00 00 00	 call	 _wassert
  000a0	33 c0		 xor	 eax, eax
$LN7@stbi__shif:

; 5409 :     return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits];

  000a2	48 63 44 24 40	 movsxd	 rax, DWORD PTR bits$[rsp]
  000a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mul_table@?1??stbi__shiftsigned@@YAHIHH@Z@4PAIA
  000ae	8b 54 24 30	 mov	 edx, DWORD PTR v$[rsp]
  000b2	0f af 14 81	 imul	 edx, DWORD PTR [rcx+rax*4]
  000b6	8b c2		 mov	 eax, edx
  000b8	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR bits$[rsp]
  000bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?shift_table@?1??stbi__shiftsigned@@YAHIHH@Z@4PAIA
  000c4	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  000c7	d3 f8		 sar	 eax, cl

; 5410 : }

  000c9	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000cd	c3		 ret	 0
?stbi__shiftsigned@@YAHIHH@Z ENDP			; stbi__shiftsigned
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
a$ = 8
?stbi__bitcount@@YAHI@Z PROC				; stbi__bitcount

; 5380 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 5381 :     a = (a & 0x55555555) + ((a >>  1) & 0x55555555); // max 2

  00004	8b 44 24 08	 mov	 eax, DWORD PTR a$[rsp]
  00008	25 55 55 55 55	 and	 eax, 1431655765		; 55555555H
  0000d	8b 4c 24 08	 mov	 ecx, DWORD PTR a$[rsp]
  00011	d1 e9		 shr	 ecx, 1
  00013	81 e1 55 55 55
	55		 and	 ecx, 1431655765		; 55555555H
  00019	03 c1		 add	 eax, ecx
  0001b	89 44 24 08	 mov	 DWORD PTR a$[rsp], eax

; 5382 :     a = (a & 0x33333333) + ((a >>  2) & 0x33333333); // max 4

  0001f	8b 44 24 08	 mov	 eax, DWORD PTR a$[rsp]
  00023	25 33 33 33 33	 and	 eax, 858993459		; 33333333H
  00028	8b 4c 24 08	 mov	 ecx, DWORD PTR a$[rsp]
  0002c	c1 e9 02	 shr	 ecx, 2
  0002f	81 e1 33 33 33
	33		 and	 ecx, 858993459		; 33333333H
  00035	03 c1		 add	 eax, ecx
  00037	89 44 24 08	 mov	 DWORD PTR a$[rsp], eax

; 5383 :     a = (a + (a >> 4)) & 0x0f0f0f0f; // max 8 per 4, now 8 bits

  0003b	8b 44 24 08	 mov	 eax, DWORD PTR a$[rsp]
  0003f	c1 e8 04	 shr	 eax, 4
  00042	8b 4c 24 08	 mov	 ecx, DWORD PTR a$[rsp]
  00046	03 c8		 add	 ecx, eax
  00048	8b c1		 mov	 eax, ecx
  0004a	25 0f 0f 0f 0f	 and	 eax, 252645135		; 0f0f0f0fH
  0004f	89 44 24 08	 mov	 DWORD PTR a$[rsp], eax

; 5384 :     a = (a + (a >> 8)); // max 16 per 8 bits

  00053	8b 44 24 08	 mov	 eax, DWORD PTR a$[rsp]
  00057	c1 e8 08	 shr	 eax, 8
  0005a	8b 4c 24 08	 mov	 ecx, DWORD PTR a$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 08	 mov	 DWORD PTR a$[rsp], eax

; 5385 :     a = (a + (a >> 16)); // max 32 per 8 bits

  00066	8b 44 24 08	 mov	 eax, DWORD PTR a$[rsp]
  0006a	c1 e8 10	 shr	 eax, 16
  0006d	8b 4c 24 08	 mov	 ecx, DWORD PTR a$[rsp]
  00071	03 c8		 add	 ecx, eax
  00073	8b c1		 mov	 eax, ecx
  00075	89 44 24 08	 mov	 DWORD PTR a$[rsp], eax

; 5386 :     return a & 0xff;

  00079	8b 44 24 08	 mov	 eax, DWORD PTR a$[rsp]
  0007d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH

; 5387 : }

  00082	c3		 ret	 0
?stbi__bitcount@@YAHI@Z ENDP				; stbi__bitcount
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
n$ = 0
z$ = 32
?stbi__high_bit@@YAHI@Z PROC				; stbi__high_bit

; 5368 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 5369 :     int n=0;

  00008	c7 04 24 00 00
	00 00		 mov	 DWORD PTR n$[rsp], 0

; 5370 :     if (z == 0) return -1;

  0000f	83 7c 24 20 00	 cmp	 DWORD PTR z$[rsp], 0
  00014	75 0a		 jne	 SHORT $LN2@stbi__high
  00016	b8 ff ff ff ff	 mov	 eax, -1
  0001b	e9 84 00 00 00	 jmp	 $LN1@stbi__high
$LN2@stbi__high:

; 5371 :     if (z >= 0x10000) { n += 16; z >>= 16; }

  00020	81 7c 24 20 00
	00 01 00	 cmp	 DWORD PTR z$[rsp], 65536 ; 00010000H
  00028	72 14		 jb	 SHORT $LN3@stbi__high
  0002a	8b 04 24	 mov	 eax, DWORD PTR n$[rsp]
  0002d	83 c0 10	 add	 eax, 16
  00030	89 04 24	 mov	 DWORD PTR n$[rsp], eax
  00033	8b 44 24 20	 mov	 eax, DWORD PTR z$[rsp]
  00037	c1 e8 10	 shr	 eax, 16
  0003a	89 44 24 20	 mov	 DWORD PTR z$[rsp], eax
$LN3@stbi__high:

; 5372 :     if (z >= 0x00100) { n +=  8; z >>=  8; }

  0003e	81 7c 24 20 00
	01 00 00	 cmp	 DWORD PTR z$[rsp], 256	; 00000100H
  00046	72 14		 jb	 SHORT $LN4@stbi__high
  00048	8b 04 24	 mov	 eax, DWORD PTR n$[rsp]
  0004b	83 c0 08	 add	 eax, 8
  0004e	89 04 24	 mov	 DWORD PTR n$[rsp], eax
  00051	8b 44 24 20	 mov	 eax, DWORD PTR z$[rsp]
  00055	c1 e8 08	 shr	 eax, 8
  00058	89 44 24 20	 mov	 DWORD PTR z$[rsp], eax
$LN4@stbi__high:

; 5373 :     if (z >= 0x00010) { n +=  4; z >>=  4; }

  0005c	83 7c 24 20 10	 cmp	 DWORD PTR z$[rsp], 16
  00061	72 14		 jb	 SHORT $LN5@stbi__high
  00063	8b 04 24	 mov	 eax, DWORD PTR n$[rsp]
  00066	83 c0 04	 add	 eax, 4
  00069	89 04 24	 mov	 DWORD PTR n$[rsp], eax
  0006c	8b 44 24 20	 mov	 eax, DWORD PTR z$[rsp]
  00070	c1 e8 04	 shr	 eax, 4
  00073	89 44 24 20	 mov	 DWORD PTR z$[rsp], eax
$LN5@stbi__high:

; 5374 :     if (z >= 0x00004) { n +=  2; z >>=  2; }

  00077	83 7c 24 20 04	 cmp	 DWORD PTR z$[rsp], 4
  0007c	72 14		 jb	 SHORT $LN6@stbi__high
  0007e	8b 04 24	 mov	 eax, DWORD PTR n$[rsp]
  00081	83 c0 02	 add	 eax, 2
  00084	89 04 24	 mov	 DWORD PTR n$[rsp], eax
  00087	8b 44 24 20	 mov	 eax, DWORD PTR z$[rsp]
  0008b	c1 e8 02	 shr	 eax, 2
  0008e	89 44 24 20	 mov	 DWORD PTR z$[rsp], eax
$LN6@stbi__high:

; 5375 :     if (z >= 0x00002) { n +=  1;/* >>=  1;*/ }

  00092	83 7c 24 20 02	 cmp	 DWORD PTR z$[rsp], 2
  00097	72 08		 jb	 SHORT $LN7@stbi__high
  00099	8b 04 24	 mov	 eax, DWORD PTR n$[rsp]
  0009c	ff c0		 inc	 eax
  0009e	89 04 24	 mov	 DWORD PTR n$[rsp], eax
$LN7@stbi__high:

; 5376 :     return n;

  000a1	8b 04 24	 mov	 eax, DWORD PTR n$[rsp]
$LN1@stbi__high:

; 5377 : }

  000a4	48 83 c4 18	 add	 rsp, 24
  000a8	c3		 ret	 0
?stbi__high_bit@@YAHI@Z ENDP				; stbi__high_bit
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
sz$ = 32
tv83 = 36
r$ = 40
s$ = 64
?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z PROC	; stbi__bmp_test_raw

; 5344 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 5345 :     int r;
; 5346 :     int sz;
; 5347 :     if (stbi__get8(s) != 'B') return 0;

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00013	0f b6 c0	 movzx	 eax, al
  00016	83 f8 42	 cmp	 eax, 66			; 00000042H
  00019	74 07		 je	 SHORT $LN2@stbi__bmp_
  0001b	33 c0		 xor	 eax, eax
  0001d	e9 8d 00 00 00	 jmp	 $LN1@stbi__bmp_
$LN2@stbi__bmp_:

; 5348 :     if (stbi__get8(s) != 'M') return 0;

  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00027	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0002c	0f b6 c0	 movzx	 eax, al
  0002f	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  00032	74 04		 je	 SHORT $LN3@stbi__bmp_
  00034	33 c0		 xor	 eax, eax
  00036	eb 77		 jmp	 SHORT $LN1@stbi__bmp_
$LN3@stbi__bmp_:

; 5349 :     stbi__get32le(s); // discard filesize

  00038	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0003d	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5350 :     stbi__get16le(s); // discard reserved

  00042	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00047	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 5351 :     stbi__get16le(s); // discard reserved

  0004c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00051	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le

; 5352 :     stbi__get32le(s); // discard data offset

  00056	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0005b	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le

; 5353 :     sz = stbi__get32le(s);

  00060	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00065	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
  0006a	89 44 24 20	 mov	 DWORD PTR sz$[rsp], eax

; 5354 :     r = (sz == 12 || sz == 40 || sz == 56 || sz == 108 || sz == 124);

  0006e	83 7c 24 20 0c	 cmp	 DWORD PTR sz$[rsp], 12
  00073	74 26		 je	 SHORT $LN5@stbi__bmp_
  00075	83 7c 24 20 28	 cmp	 DWORD PTR sz$[rsp], 40	; 00000028H
  0007a	74 1f		 je	 SHORT $LN5@stbi__bmp_
  0007c	83 7c 24 20 38	 cmp	 DWORD PTR sz$[rsp], 56	; 00000038H
  00081	74 18		 je	 SHORT $LN5@stbi__bmp_
  00083	83 7c 24 20 6c	 cmp	 DWORD PTR sz$[rsp], 108	; 0000006cH
  00088	74 11		 je	 SHORT $LN5@stbi__bmp_
  0008a	83 7c 24 20 7c	 cmp	 DWORD PTR sz$[rsp], 124	; 0000007cH
  0008f	74 0a		 je	 SHORT $LN5@stbi__bmp_
  00091	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
  00099	eb 08		 jmp	 SHORT $LN6@stbi__bmp_
$LN5@stbi__bmp_:
  0009b	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv83[rsp], 1
$LN6@stbi__bmp_:
  000a3	8b 44 24 24	 mov	 eax, DWORD PTR tv83[rsp]
  000a7	89 44 24 28	 mov	 DWORD PTR r$[rsp], eax

; 5355 :     return r;

  000ab	8b 44 24 28	 mov	 eax, DWORD PTR r$[rsp]
$LN1@stbi__bmp_:

; 5356 : }

  000af	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b3	c3		 ret	 0
?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z ENDP	; stbi__bmp_test_raw
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
p$ = 48
x$ = 56
y$ = 64
comp$ = 72
?stbi__png_info_raw@@YAHPEAUstbi__png@@PEAH11@Z PROC	; stbi__png_info_raw

; 5308 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 5309 :     if (!stbi__parse_png_file(p, STBI__SCAN_header, 0)) {

  00018	45 33 c0	 xor	 r8d, r8d
  0001b	ba 02 00 00 00	 mov	 edx, 2
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00025	e8 00 00 00 00	 call	 ?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z ; stbi__parse_png_file
  0002a	85 c0		 test	 eax, eax
  0002c	75 11		 jne	 SHORT $LN2@stbi__png_

; 5310 :         stbi__rewind( p->s );

  0002e	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  00033	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00036	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 5311 :         return 0;

  0003b	33 c0		 xor	 eax, eax
  0003d	eb 52		 jmp	 SHORT $LN1@stbi__png_
$LN2@stbi__png_:

; 5312 :     }
; 5313 :     if (x) *x = p->s->img_x;

  0003f	48 83 7c 24 38
	00		 cmp	 QWORD PTR x$[rsp], 0
  00045	74 11		 je	 SHORT $LN3@stbi__png_
  00047	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  0004c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR x$[rsp]
  00054	8b 00		 mov	 eax, DWORD PTR [rax]
  00056	89 01		 mov	 DWORD PTR [rcx], eax
$LN3@stbi__png_:

; 5314 :     if (y) *y = p->s->img_y;

  00058	48 83 7c 24 40
	00		 cmp	 QWORD PTR y$[rsp], 0
  0005e	74 12		 je	 SHORT $LN4@stbi__png_
  00060	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  00065	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00068	48 8b 4c 24 40	 mov	 rcx, QWORD PTR y$[rsp]
  0006d	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00070	89 01		 mov	 DWORD PTR [rcx], eax
$LN4@stbi__png_:

; 5315 :     if (comp) *comp = p->s->img_n;

  00072	48 83 7c 24 48
	00		 cmp	 QWORD PTR comp$[rsp], 0
  00078	74 12		 je	 SHORT $LN5@stbi__png_
  0007a	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  0007f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00082	48 8b 4c 24 48	 mov	 rcx, QWORD PTR comp$[rsp]
  00087	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0008a	89 01		 mov	 DWORD PTR [rcx], eax
$LN5@stbi__png_:

; 5316 :     return 1;

  0008c	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__png_:

; 5317 : }

  00091	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00095	c3		 ret	 0
?stbi__png_info_raw@@YAHPEAUstbi__png@@PEAH11@Z ENDP	; stbi__png_info_raw
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv69 = 48
tv85 = 52
result$ = 56
p$ = 80
x$ = 88
y$ = 96
n$ = 104
req_comp$ = 112
ri$ = 120
?stbi__do_png@@YAPEAXPEAUstbi__png@@PEAH11HPEAUstbi__result_info@@@Z PROC ; stbi__do_png

; 5261 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 5262 :     void *result=NULL;

  00018	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0

; 5263 :     if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");

  00021	83 7c 24 70 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  00026	7c 07		 jl	 SHORT $LN3@stbi__do_p
  00028	83 7c 24 70 04	 cmp	 DWORD PTR req_comp$[rsp], 4
  0002d	7e 2c		 jle	 SHORT $LN2@stbi__do_p
$LN3@stbi__do_p:
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80669
  00036	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0003b	85 c0		 test	 eax, eax
  0003d	74 0a		 je	 SHORT $LN15@stbi__do_p
  0003f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
  00047	eb 08		 jmp	 SHORT $LN16@stbi__do_p
$LN15@stbi__do_p:
  00049	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
$LN16@stbi__do_p:
  00051	48 63 44 24 30	 movsxd	 rax, DWORD PTR tv69[rsp]
  00056	e9 e2 01 00 00	 jmp	 $LN1@stbi__do_p
$LN2@stbi__do_p:

; 5264 :     if (stbi__parse_png_file(p, STBI__SCAN_load, req_comp)) {

  0005b	44 8b 44 24 70	 mov	 r8d, DWORD PTR req_comp$[rsp]
  00060	33 d2		 xor	 edx, edx
  00062	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$[rsp]
  00067	e8 00 00 00 00	 call	 ?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z ; stbi__parse_png_file
  0006c	85 c0		 test	 eax, eax
  0006e	0f 84 73 01 00
	00		 je	 $LN4@stbi__do_p

; 5265 :         if (p->depth <= 8)

  00074	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  00079	83 78 20 08	 cmp	 DWORD PTR [rax+32], 8
  0007d	7f 0d		 jg	 SHORT $LN5@stbi__do_p

; 5266 :             ri->bits_per_channel = 8;

  0007f	48 8b 44 24 78	 mov	 rax, QWORD PTR ri$[rsp]
  00084	c7 00 08 00 00
	00		 mov	 DWORD PTR [rax], 8
  0008a	eb 44		 jmp	 SHORT $LN6@stbi__do_p
$LN5@stbi__do_p:

; 5267 :         else if (p->depth == 16)

  0008c	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  00091	83 78 20 10	 cmp	 DWORD PTR [rax+32], 16
  00095	75 0d		 jne	 SHORT $LN7@stbi__do_p

; 5268 :             ri->bits_per_channel = 16;

  00097	48 8b 44 24 78	 mov	 rax, QWORD PTR ri$[rsp]
  0009c	c7 00 10 00 00
	00		 mov	 DWORD PTR [rax], 16
  000a2	eb 2c		 jmp	 SHORT $LN8@stbi__do_p
$LN7@stbi__do_p:

; 5269 :         else
; 5270 :             return stbi__errpuc("bad bits_per_channel", "PNG not supported: unsupported color depth");

  000a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80675
  000ab	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000b0	85 c0		 test	 eax, eax
  000b2	74 0a		 je	 SHORT $LN17@stbi__do_p
  000b4	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv85[rsp], 0
  000bc	eb 08		 jmp	 SHORT $LN18@stbi__do_p
$LN17@stbi__do_p:
  000be	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv85[rsp], 0
$LN18@stbi__do_p:
  000c6	48 63 44 24 34	 movsxd	 rax, DWORD PTR tv85[rsp]
  000cb	e9 6d 01 00 00	 jmp	 $LN1@stbi__do_p
$LN8@stbi__do_p:
$LN6@stbi__do_p:

; 5271 :         result = p->out;

  000d0	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  000d5	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  000d9	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax

; 5272 :         p->out = NULL;

  000de	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  000e3	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 5273 :         if (req_comp && req_comp != p->s->img_out_n) {

  000eb	83 7c 24 70 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  000f0	0f 84 b4 00 00
	00		 je	 $LN9@stbi__do_p
  000f6	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  000fb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000fe	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00101	39 44 24 70	 cmp	 DWORD PTR req_comp$[rsp], eax
  00105	0f 84 9f 00 00
	00		 je	 $LN9@stbi__do_p

; 5274 :             if (ri->bits_per_channel == 8)

  0010b	48 8b 44 24 78	 mov	 rax, QWORD PTR ri$[rsp]
  00110	83 38 08	 cmp	 DWORD PTR [rax], 8
  00113	75 3b		 jne	 SHORT $LN10@stbi__do_p

; 5275 :                 result = stbi__convert_format((unsigned char *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);

  00115	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  0011a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0011d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$[rsp]
  00122	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00125	48 8b 54 24 50	 mov	 rdx, QWORD PTR p$[rsp]
  0012a	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  0012d	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00130	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00134	44 8b 09	 mov	 r9d, DWORD PTR [rcx]
  00137	44 8b 44 24 70	 mov	 r8d, DWORD PTR req_comp$[rsp]
  0013c	8b 52 0c	 mov	 edx, DWORD PTR [rdx+12]
  0013f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR result$[rsp]
  00144	e8 00 00 00 00	 call	 ?stbi__convert_format@@YAPEAEPEAEHHII@Z ; stbi__convert_format
  00149	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax
  0014e	eb 39		 jmp	 SHORT $LN11@stbi__do_p
$LN10@stbi__do_p:

; 5276 :             else
; 5277 :                 result = stbi__convert_format16((stbi__uint16 *) result, p->s->img_out_n, req_comp, p->s->img_x, p->s->img_y);

  00150	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  00155	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00158	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$[rsp]
  0015d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00160	48 8b 54 24 50	 mov	 rdx, QWORD PTR p$[rsp]
  00165	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00168	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0016b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0016f	44 8b 09	 mov	 r9d, DWORD PTR [rcx]
  00172	44 8b 44 24 70	 mov	 r8d, DWORD PTR req_comp$[rsp]
  00177	8b 52 0c	 mov	 edx, DWORD PTR [rdx+12]
  0017a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR result$[rsp]
  0017f	e8 00 00 00 00	 call	 ?stbi__convert_format16@@YAPEAGPEAGHHII@Z ; stbi__convert_format16
  00184	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax
$LN11@stbi__do_p:

; 5278 :             p->s->img_out_n = req_comp;

  00189	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  0018e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00191	8b 4c 24 70	 mov	 ecx, DWORD PTR req_comp$[rsp]
  00195	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 5279 :             if (result == NULL) return result;

  00198	48 83 7c 24 38
	00		 cmp	 QWORD PTR result$[rsp], 0
  0019e	75 0a		 jne	 SHORT $LN12@stbi__do_p
  001a0	48 8b 44 24 38	 mov	 rax, QWORD PTR result$[rsp]
  001a5	e9 93 00 00 00	 jmp	 $LN1@stbi__do_p
$LN12@stbi__do_p:
$LN9@stbi__do_p:

; 5280 :         }
; 5281 :         *x = p->s->img_x;

  001aa	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  001af	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001b2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR x$[rsp]
  001b7	8b 00		 mov	 eax, DWORD PTR [rax]
  001b9	89 01		 mov	 DWORD PTR [rcx], eax

; 5282 :         *y = p->s->img_y;

  001bb	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  001c0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001c3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR y$[rsp]
  001c8	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  001cb	89 01		 mov	 DWORD PTR [rcx], eax

; 5283 :         if (n) *n = p->s->img_n;

  001cd	48 83 7c 24 68
	00		 cmp	 QWORD PTR n$[rsp], 0
  001d3	74 12		 je	 SHORT $LN13@stbi__do_p
  001d5	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  001da	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001dd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR n$[rsp]
  001e2	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  001e5	89 01		 mov	 DWORD PTR [rcx], eax
$LN13@stbi__do_p:
$LN4@stbi__do_p:

; 5284 :     }
; 5285 :     STBI_FREE(p->out);      p->out      = NULL;

  001e7	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  001ec	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  001f0	e8 00 00 00 00	 call	 free
  001f5	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  001fa	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 5286 :     STBI_FREE(p->expanded); p->expanded = NULL;

  00202	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  00207	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0020b	e8 00 00 00 00	 call	 free
  00210	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  00215	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 5287 :     STBI_FREE(p->idata);    p->idata    = NULL;

  0021d	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  00222	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00226	e8 00 00 00 00	 call	 free
  0022b	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]
  00230	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 5288 :     
; 5289 :     return result;

  00238	48 8b 44 24 38	 mov	 rax, QWORD PTR result$[rsp]
$LN1@stbi__do_p:

; 5290 : }

  0023d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00241	c3		 ret	 0
?stbi__do_png@@YAPEAXPEAUstbi__png@@PEAH11HPEAUstbi__result_info@@@Z ENDP ; stbi__do_png
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
pal_img_n$ = 64
s$ = 72
has_trans$ = 80
i$ = 84
c$1 = 88
k$ = 96
idata_limit$ = 100
ioff$ = 104
color$ = 108
tv78 = 112
pal_len$ = 116
first$ = 120
tc$ = 124
interlace$ = 128
raw_len$2 = 132
is_iphone$ = 136
tv197 = 140
tv194 = 144
tv345 = 148
tv394 = 152
tv461 = 156
comp$3 = 160
filter$4 = 164
bpl$5 = 168
p$6 = 176
idata_limit_old$7 = 184
$T8 = 188
tc16$ = 196
palette$ = 208
__$ArrayPad$ = 1232
z$ = 1264
scan$ = 1272
req_comp$ = 1280
?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z PROC	; stbi__parse_png_file

; 5078 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 81 ec e0 04
	00 00		 sub	 rsp, 1248		; 000004e0H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 d0
	04 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5079 :     stbi_uc palette[1024], pal_img_n=0;

  00028	c6 44 24 40 00	 mov	 BYTE PTR pal_img_n$[rsp], 0

; 5080 :     stbi_uc has_trans=0, tc[3]={0};

  0002d	c6 44 24 50 00	 mov	 BYTE PTR has_trans$[rsp], 0
  00032	48 8d 44 24 7c	 lea	 rax, QWORD PTR tc$[rsp]
  00037	48 8b f8	 mov	 rdi, rax
  0003a	33 c0		 xor	 eax, eax
  0003c	b9 03 00 00 00	 mov	 ecx, 3
  00041	f3 aa		 rep stosb

; 5081 :     stbi__uint16 tc16[3];
; 5082 :     stbi__uint32 ioff=0, idata_limit=0, i, pal_len=0;

  00043	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR ioff$[rsp], 0
  0004b	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR idata_limit$[rsp], 0
  00053	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR pal_len$[rsp], 0

; 5083 :     int first=1,k,interlace=0, color=0, is_iphone=0;

  0005b	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR first$[rsp], 1
  00063	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR interlace$[rsp], 0
  0006e	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR color$[rsp], 0
  00076	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR is_iphone$[rsp], 0

; 5084 :     stbi__context *s = z->s;

  00081	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00089	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008c	48 89 44 24 48	 mov	 QWORD PTR s$[rsp], rax

; 5085 :     
; 5086 :     z->expanded = NULL;

  00091	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00099	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 5087 :     z->idata = NULL;

  000a1	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  000a9	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 5088 :     z->out = NULL;

  000b1	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  000b9	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 5089 :     
; 5090 :     if (!stbi__check_png_header(s)) return 0;

  000c1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  000c6	e8 00 00 00 00	 call	 ?stbi__check_png_header@@YAHPEAUstbi__context@@@Z ; stbi__check_png_header
  000cb	85 c0		 test	 eax, eax
  000cd	75 07		 jne	 SHORT $LN21@stbi__pars
  000cf	33 c0		 xor	 eax, eax
  000d1	e9 a9 0c 00 00	 jmp	 $LN1@stbi__pars
$LN21@stbi__pars:

; 5091 :     
; 5092 :     if (scan == STBI__SCAN_type) return 1;

  000d6	83 bc 24 f8 04
	00 00 01	 cmp	 DWORD PTR scan$[rsp], 1
  000de	75 0a		 jne	 SHORT $LN22@stbi__pars
  000e0	b8 01 00 00 00	 mov	 eax, 1
  000e5	e9 95 0c 00 00	 jmp	 $LN1@stbi__pars
$LN22@stbi__pars:
$LN2@stbi__pars:

; 5093 :     
; 5094 :     for (;;) {
; 5095 :         stbi__pngchunk c = stbi__get_chunk_header(s);

  000ea	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  000ef	e8 00 00 00 00	 call	 ?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z ; stbi__get_chunk_header
  000f4	48 89 84 24 bc
	00 00 00	 mov	 QWORD PTR $T8[rsp], rax
  000fc	48 8b 84 24 bc
	00 00 00	 mov	 rax, QWORD PTR $T8[rsp]
  00104	48 89 44 24 58	 mov	 QWORD PTR c$1[rsp], rax

; 5096 :         switch (c.type) {

  00109	8b 44 24 5c	 mov	 eax, DWORD PTR c$1[rsp+4]
  0010d	89 44 24 70	 mov	 DWORD PTR tv78[rsp], eax
  00111	81 7c 24 70 52
	44 48 49	 cmp	 DWORD PTR tv78[rsp], 1229472850 ; 49484452H
  00119	77 35		 ja	 SHORT $LN107@stbi__pars
  0011b	81 7c 24 70 52
	44 48 49	 cmp	 DWORD PTR tv78[rsp], 1229472850 ; 49484452H
  00123	74 6a		 je	 SHORT $LN24@stbi__pars
  00125	81 7c 24 70 49
	42 67 43	 cmp	 DWORD PTR tv78[rsp], 1130840649 ; 43674249H
  0012d	74 42		 je	 SHORT $LN23@stbi__pars
  0012f	81 7c 24 70 54
	41 44 49	 cmp	 DWORD PTR tv78[rsp], 1229209940 ; 49444154H
  00137	0f 84 52 06 00
	00		 je	 $LN61@stbi__pars
  0013d	81 7c 24 70 44
	4e 45 49	 cmp	 DWORD PTR tv78[rsp], 1229278788 ; 49454e44H
  00145	0f 84 e9 07 00
	00		 je	 $LN72@stbi__pars
  0014b	e9 62 0b 00 00	 jmp	 $LN93@stbi__pars
$LN107@stbi__pars:
  00150	81 7c 24 70 45
	54 4c 50	 cmp	 DWORD PTR tv78[rsp], 1347179589 ; 504c5445H
  00158	0f 84 49 03 00
	00		 je	 $LN44@stbi__pars
  0015e	81 7c 24 70 53
	4e 52 74	 cmp	 DWORD PTR tv78[rsp], 1951551059 ; 74524e53H
  00166	0f 84 2e 04 00
	00		 je	 $LN48@stbi__pars
  0016c	e9 41 0b 00 00	 jmp	 $LN93@stbi__pars
$LN23@stbi__pars:

; 5097 :             case STBI__PNG_TYPE('C','g','B','I'):
; 5098 :             is_iphone = 1;

  00171	c7 84 24 88 00
	00 00 01 00 00
	00		 mov	 DWORD PTR is_iphone$[rsp], 1

; 5099 :             stbi__skip(s, c.length);

  0017c	8b 54 24 58	 mov	 edx, DWORD PTR c$1[rsp]
  00180	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00185	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 5100 :             break;

  0018a	e9 e1 0b 00 00	 jmp	 $LN5@stbi__pars
$LN24@stbi__pars:

; 5101 :             case STBI__PNG_TYPE('I','H','D','R'): {
; 5102 :                 int comp,filter;
; 5103 :                 if (!first) return stbi__err("multiple IHDR","Corrupt PNG");

  0018f	83 7c 24 78 00	 cmp	 DWORD PTR first$[rsp], 0
  00194	75 11		 jne	 SHORT $LN25@stbi__pars
  00196	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80551
  0019d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  001a2	e9 d8 0b 00 00	 jmp	 $LN1@stbi__pars
$LN25@stbi__pars:

; 5104 :                 first = 0;

  001a7	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR first$[rsp], 0

; 5105 :                 if (c.length != 13) return stbi__err("bad IHDR len","Corrupt PNG");

  001af	83 7c 24 58 0d	 cmp	 DWORD PTR c$1[rsp], 13
  001b4	74 11		 je	 SHORT $LN26@stbi__pars
  001b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80553
  001bd	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  001c2	e9 b8 0b 00 00	 jmp	 $LN1@stbi__pars
$LN26@stbi__pars:

; 5106 :                 s->img_x = stbi__get32be(s);

  001c7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  001cc	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
  001d1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  001d6	89 01		 mov	 DWORD PTR [rcx], eax

; 5107 :                 s->img_y = stbi__get32be(s);

  001d8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  001dd	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
  001e2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  001e7	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 5108 :                 if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");

  001ea	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  001ef	81 78 04 00 00
	00 01		 cmp	 DWORD PTR [rax+4], 16777216 ; 01000000H
  001f6	76 11		 jbe	 SHORT $LN27@stbi__pars
  001f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80555
  001ff	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00204	e9 76 0b 00 00	 jmp	 $LN1@stbi__pars
$LN27@stbi__pars:

; 5109 :                 if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");

  00209	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  0020e	81 38 00 00 00
	01		 cmp	 DWORD PTR [rax], 16777216 ; 01000000H
  00214	76 11		 jbe	 SHORT $LN28@stbi__pars
  00216	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80557
  0021d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00222	e9 58 0b 00 00	 jmp	 $LN1@stbi__pars
$LN28@stbi__pars:

; 5110 :                 z->depth = stbi__get8(s);  if (z->depth != 1 && z->depth != 2 && z->depth != 4 && z->depth != 8 && z->depth != 16)  return stbi__err("1/2/4/8/16-bit only","PNG not supported: 1/2/4/8/16-bit only");

  00227	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  0022c	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00231	0f b6 c0	 movzx	 eax, al
  00234	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0023c	89 41 20	 mov	 DWORD PTR [rcx+32], eax
  0023f	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00247	83 78 20 01	 cmp	 DWORD PTR [rax+32], 1
  0024b	74 49		 je	 SHORT $LN29@stbi__pars
  0024d	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00255	83 78 20 02	 cmp	 DWORD PTR [rax+32], 2
  00259	74 3b		 je	 SHORT $LN29@stbi__pars
  0025b	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00263	83 78 20 04	 cmp	 DWORD PTR [rax+32], 4
  00267	74 2d		 je	 SHORT $LN29@stbi__pars
  00269	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00271	83 78 20 08	 cmp	 DWORD PTR [rax+32], 8
  00275	74 1f		 je	 SHORT $LN29@stbi__pars
  00277	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0027f	83 78 20 10	 cmp	 DWORD PTR [rax+32], 16
  00283	74 11		 je	 SHORT $LN29@stbi__pars
  00285	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80559
  0028c	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00291	e9 e9 0a 00 00	 jmp	 $LN1@stbi__pars
$LN29@stbi__pars:

; 5111 :                 color = stbi__get8(s);  if (color > 6)         return stbi__err("bad ctype","Corrupt PNG");

  00296	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  0029b	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  002a0	0f b6 c0	 movzx	 eax, al
  002a3	89 44 24 6c	 mov	 DWORD PTR color$[rsp], eax
  002a7	83 7c 24 6c 06	 cmp	 DWORD PTR color$[rsp], 6
  002ac	7e 11		 jle	 SHORT $LN30@stbi__pars
  002ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80561
  002b5	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  002ba	e9 c0 0a 00 00	 jmp	 $LN1@stbi__pars
$LN30@stbi__pars:

; 5112 :                 if (color == 3 && z->depth == 16)                  return stbi__err("bad ctype","Corrupt PNG");

  002bf	83 7c 24 6c 03	 cmp	 DWORD PTR color$[rsp], 3
  002c4	75 1f		 jne	 SHORT $LN31@stbi__pars
  002c6	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  002ce	83 78 20 10	 cmp	 DWORD PTR [rax+32], 16
  002d2	75 11		 jne	 SHORT $LN31@stbi__pars
  002d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80563
  002db	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  002e0	e9 9a 0a 00 00	 jmp	 $LN1@stbi__pars
$LN31@stbi__pars:

; 5113 :                 if (color == 3) pal_img_n = 3; else if (color & 1) return stbi__err("bad ctype","Corrupt PNG");

  002e5	83 7c 24 6c 03	 cmp	 DWORD PTR color$[rsp], 3
  002ea	75 07		 jne	 SHORT $LN32@stbi__pars
  002ec	c6 44 24 40 03	 mov	 BYTE PTR pal_img_n$[rsp], 3
  002f1	eb 1c		 jmp	 SHORT $LN33@stbi__pars
$LN32@stbi__pars:
  002f3	8b 44 24 6c	 mov	 eax, DWORD PTR color$[rsp]
  002f7	83 e0 01	 and	 eax, 1
  002fa	85 c0		 test	 eax, eax
  002fc	74 11		 je	 SHORT $LN34@stbi__pars
  002fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80567
  00305	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0030a	e9 70 0a 00 00	 jmp	 $LN1@stbi__pars
$LN34@stbi__pars:
$LN33@stbi__pars:

; 5114 :                 comp  = stbi__get8(s);  if (comp) return stbi__err("bad comp method","Corrupt PNG");

  0030f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00314	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00319	0f b6 c0	 movzx	 eax, al
  0031c	89 84 24 a0 00
	00 00		 mov	 DWORD PTR comp$3[rsp], eax
  00323	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR comp$3[rsp], 0
  0032b	74 11		 je	 SHORT $LN35@stbi__pars
  0032d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80569
  00334	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00339	e9 41 0a 00 00	 jmp	 $LN1@stbi__pars
$LN35@stbi__pars:

; 5115 :                 filter= stbi__get8(s);  if (filter) return stbi__err("bad filter method","Corrupt PNG");

  0033e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00343	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00348	0f b6 c0	 movzx	 eax, al
  0034b	89 84 24 a4 00
	00 00		 mov	 DWORD PTR filter$4[rsp], eax
  00352	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR filter$4[rsp], 0
  0035a	74 11		 je	 SHORT $LN36@stbi__pars
  0035c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80571
  00363	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00368	e9 12 0a 00 00	 jmp	 $LN1@stbi__pars
$LN36@stbi__pars:

; 5116 :                 interlace = stbi__get8(s); if (interlace>1) return stbi__err("bad interlace method","Corrupt PNG");

  0036d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00372	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00377	0f b6 c0	 movzx	 eax, al
  0037a	89 84 24 80 00
	00 00		 mov	 DWORD PTR interlace$[rsp], eax
  00381	83 bc 24 80 00
	00 00 01	 cmp	 DWORD PTR interlace$[rsp], 1
  00389	7e 11		 jle	 SHORT $LN37@stbi__pars
  0038b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80573
  00392	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00397	e9 e3 09 00 00	 jmp	 $LN1@stbi__pars
$LN37@stbi__pars:

; 5117 :                 if (!s->img_x || !s->img_y) return stbi__err("0-pixel image","Corrupt PNG");

  0039c	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  003a1	83 38 00	 cmp	 DWORD PTR [rax], 0
  003a4	74 0b		 je	 SHORT $LN39@stbi__pars
  003a6	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  003ab	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  003af	75 11		 jne	 SHORT $LN38@stbi__pars
$LN39@stbi__pars:
  003b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80576
  003b8	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  003bd	e9 bd 09 00 00	 jmp	 $LN1@stbi__pars
$LN38@stbi__pars:

; 5118 :                 if (!pal_img_n) {

  003c2	0f b6 44 24 40	 movzx	 eax, BYTE PTR pal_img_n$[rsp]
  003c7	85 c0		 test	 eax, eax
  003c9	0f 85 95 00 00
	00		 jne	 $LN40@stbi__pars

; 5119 :                     s->img_n = (color & 2 ? 3 : 1) + (color & 4 ? 1 : 0);

  003cf	8b 44 24 6c	 mov	 eax, DWORD PTR color$[rsp]
  003d3	83 e0 02	 and	 eax, 2
  003d6	85 c0		 test	 eax, eax
  003d8	74 0d		 je	 SHORT $LN97@stbi__pars
  003da	c7 84 24 90 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv194[rsp], 3
  003e5	eb 0b		 jmp	 SHORT $LN98@stbi__pars
$LN97@stbi__pars:
  003e7	c7 84 24 90 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv194[rsp], 1
$LN98@stbi__pars:
  003f2	8b 44 24 6c	 mov	 eax, DWORD PTR color$[rsp]
  003f6	83 e0 04	 and	 eax, 4
  003f9	85 c0		 test	 eax, eax
  003fb	74 0d		 je	 SHORT $LN99@stbi__pars
  003fd	c7 84 24 8c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv197[rsp], 1
  00408	eb 0b		 jmp	 SHORT $LN100@stbi__pars
$LN99@stbi__pars:
  0040a	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv197[rsp], 0
$LN100@stbi__pars:
  00415	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv197[rsp]
  0041c	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv194[rsp]
  00423	03 c8		 add	 ecx, eax
  00425	8b c1		 mov	 eax, ecx
  00427	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  0042c	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 5120 :                     if ((1 << 30) / s->img_x / s->img_n < s->img_y) return stbi__err("too large", "Image too large to decode");

  0042f	33 d2		 xor	 edx, edx
  00431	b8 00 00 00 40	 mov	 eax, 1073741824		; 40000000H
  00436	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  0043b	f7 31		 div	 DWORD PTR [rcx]
  0043d	33 d2		 xor	 edx, edx
  0043f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00444	f7 71 08	 div	 DWORD PTR [rcx+8]
  00447	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  0044c	3b 41 04	 cmp	 eax, DWORD PTR [rcx+4]
  0044f	73 11		 jae	 SHORT $LN42@stbi__pars
  00451	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80580
  00458	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0045d	e9 1d 09 00 00	 jmp	 $LN1@stbi__pars
$LN42@stbi__pars:

; 5121 :                 } else {

  00462	eb 3e		 jmp	 SHORT $LN41@stbi__pars
$LN40@stbi__pars:

; 5122 :                     // if paletted, then pal_n is our final components, and
; 5123 :                     // img_n is # components to decompress/filter.
; 5124 :                     s->img_n = 1;

  00464	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00469	c7 40 08 01 00
	00 00		 mov	 DWORD PTR [rax+8], 1

; 5125 :                     if ((1 << 30) / s->img_x / 4 < s->img_y) return stbi__err("too large","Corrupt PNG");

  00470	33 d2		 xor	 edx, edx
  00472	b8 00 00 00 40	 mov	 eax, 1073741824		; 40000000H
  00477	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  0047c	f7 31		 div	 DWORD PTR [rcx]
  0047e	33 d2		 xor	 edx, edx
  00480	b9 04 00 00 00	 mov	 ecx, 4
  00485	f7 f1		 div	 ecx
  00487	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  0048c	3b 41 04	 cmp	 eax, DWORD PTR [rcx+4]
  0048f	73 11		 jae	 SHORT $LN43@stbi__pars
  00491	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80582
  00498	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0049d	e9 dd 08 00 00	 jmp	 $LN1@stbi__pars
$LN43@stbi__pars:
$LN41@stbi__pars:

; 5126 :                 }
; 5127 :                 // even with SCAN_header, have to scan to see if we have a tRNS
; 5128 :                 break;

  004a2	e9 c9 08 00 00	 jmp	 $LN5@stbi__pars
$LN44@stbi__pars:

; 5129 :             }
; 5130 :             
; 5131 :             case STBI__PNG_TYPE('P','L','T','E'):  {
; 5132 :                 if (first) return stbi__err("first not IHDR", "Corrupt PNG");

  004a7	83 7c 24 78 00	 cmp	 DWORD PTR first$[rsp], 0
  004ac	74 11		 je	 SHORT $LN45@stbi__pars
  004ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80585
  004b5	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  004ba	e9 c0 08 00 00	 jmp	 $LN1@stbi__pars
$LN45@stbi__pars:

; 5133 :                 if (c.length > 256*3) return stbi__err("invalid PLTE","Corrupt PNG");

  004bf	81 7c 24 58 00
	03 00 00	 cmp	 DWORD PTR c$1[rsp], 768	; 00000300H
  004c7	76 11		 jbe	 SHORT $LN46@stbi__pars
  004c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80587
  004d0	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  004d5	e9 a5 08 00 00	 jmp	 $LN1@stbi__pars
$LN46@stbi__pars:

; 5134 :                 pal_len = c.length / 3;

  004da	33 d2		 xor	 edx, edx
  004dc	8b 44 24 58	 mov	 eax, DWORD PTR c$1[rsp]
  004e0	b9 03 00 00 00	 mov	 ecx, 3
  004e5	f7 f1		 div	 ecx
  004e7	89 44 24 74	 mov	 DWORD PTR pal_len$[rsp], eax

; 5135 :                 if (pal_len * 3 != c.length) return stbi__err("invalid PLTE","Corrupt PNG");

  004eb	6b 44 24 74 03	 imul	 eax, DWORD PTR pal_len$[rsp], 3
  004f0	3b 44 24 58	 cmp	 eax, DWORD PTR c$1[rsp]
  004f4	74 11		 je	 SHORT $LN47@stbi__pars
  004f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80589
  004fd	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00502	e9 78 08 00 00	 jmp	 $LN1@stbi__pars
$LN47@stbi__pars:

; 5136 :                 for (i=0; i < pal_len; ++i) {

  00507	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0050f	eb 0a		 jmp	 SHORT $LN9@stbi__pars
$LN7@stbi__pars:
  00511	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  00515	ff c0		 inc	 eax
  00517	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN9@stbi__pars:
  0051b	8b 44 24 74	 mov	 eax, DWORD PTR pal_len$[rsp]
  0051f	39 44 24 54	 cmp	 DWORD PTR i$[rsp], eax
  00523	73 70		 jae	 SHORT $LN8@stbi__pars

; 5137 :                     palette[i*4+0] = stbi__get8(s);

  00525	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  0052a	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0052f	8b 4c 24 54	 mov	 ecx, DWORD PTR i$[rsp]
  00533	c1 e1 02	 shl	 ecx, 2
  00536	8b c9		 mov	 ecx, ecx
  00538	88 84 0c d0 00
	00 00		 mov	 BYTE PTR palette$[rsp+rcx], al

; 5138 :                     palette[i*4+1] = stbi__get8(s);

  0053f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00544	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00549	8b 4c 24 54	 mov	 ecx, DWORD PTR i$[rsp]
  0054d	8d 0c 8d 01 00
	00 00		 lea	 ecx, DWORD PTR [rcx*4+1]
  00554	8b c9		 mov	 ecx, ecx
  00556	88 84 0c d0 00
	00 00		 mov	 BYTE PTR palette$[rsp+rcx], al

; 5139 :                     palette[i*4+2] = stbi__get8(s);

  0055d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00562	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00567	8b 4c 24 54	 mov	 ecx, DWORD PTR i$[rsp]
  0056b	8d 0c 8d 02 00
	00 00		 lea	 ecx, DWORD PTR [rcx*4+2]
  00572	8b c9		 mov	 ecx, ecx
  00574	88 84 0c d0 00
	00 00		 mov	 BYTE PTR palette$[rsp+rcx], al

; 5140 :                     palette[i*4+3] = 255;

  0057b	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  0057f	8d 04 85 03 00
	00 00		 lea	 eax, DWORD PTR [rax*4+3]
  00586	8b c0		 mov	 eax, eax
  00588	c6 84 04 d0 00
	00 00 ff	 mov	 BYTE PTR palette$[rsp+rax], 255 ; 000000ffH

; 5141 :                 }

  00590	e9 7c ff ff ff	 jmp	 $LN7@stbi__pars
$LN8@stbi__pars:

; 5142 :                 break;

  00595	e9 d6 07 00 00	 jmp	 $LN5@stbi__pars
$LN48@stbi__pars:

; 5143 :             }
; 5144 :             
; 5145 :             case STBI__PNG_TYPE('t','R','N','S'): {
; 5146 :                 if (first) return stbi__err("first not IHDR", "Corrupt PNG");

  0059a	83 7c 24 78 00	 cmp	 DWORD PTR first$[rsp], 0
  0059f	74 11		 je	 SHORT $LN49@stbi__pars
  005a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80592
  005a8	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  005ad	e9 cd 07 00 00	 jmp	 $LN1@stbi__pars
$LN49@stbi__pars:

; 5147 :                 if (z->idata) return stbi__err("tRNS after IDAT","Corrupt PNG");

  005b2	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  005ba	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  005bf	74 11		 je	 SHORT $LN50@stbi__pars
  005c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80594
  005c8	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  005cd	e9 ad 07 00 00	 jmp	 $LN1@stbi__pars
$LN50@stbi__pars:

; 5148 :                 if (pal_img_n) {

  005d2	0f b6 44 24 40	 movzx	 eax, BYTE PTR pal_img_n$[rsp]
  005d7	85 c0		 test	 eax, eax
  005d9	0f 84 9b 00 00
	00		 je	 $LN51@stbi__pars

; 5149 :                     if (scan == STBI__SCAN_header) { s->img_n = 4; return 1; }

  005df	83 bc 24 f8 04
	00 00 02	 cmp	 DWORD PTR scan$[rsp], 2
  005e7	75 16		 jne	 SHORT $LN53@stbi__pars
  005e9	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  005ee	c7 40 08 04 00
	00 00		 mov	 DWORD PTR [rax+8], 4
  005f5	b8 01 00 00 00	 mov	 eax, 1
  005fa	e9 80 07 00 00	 jmp	 $LN1@stbi__pars
$LN53@stbi__pars:

; 5150 :                     if (pal_len == 0) return stbi__err("tRNS before PLTE","Corrupt PNG");

  005ff	83 7c 24 74 00	 cmp	 DWORD PTR pal_len$[rsp], 0
  00604	75 11		 jne	 SHORT $LN54@stbi__pars
  00606	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80599
  0060d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00612	e9 68 07 00 00	 jmp	 $LN1@stbi__pars
$LN54@stbi__pars:

; 5151 :                     if (c.length > pal_len) return stbi__err("bad tRNS len","Corrupt PNG");

  00617	8b 44 24 74	 mov	 eax, DWORD PTR pal_len$[rsp]
  0061b	39 44 24 58	 cmp	 DWORD PTR c$1[rsp], eax
  0061f	76 11		 jbe	 SHORT $LN55@stbi__pars
  00621	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80601
  00628	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0062d	e9 4d 07 00 00	 jmp	 $LN1@stbi__pars
$LN55@stbi__pars:

; 5152 :                     pal_img_n = 4;

  00632	c6 44 24 40 04	 mov	 BYTE PTR pal_img_n$[rsp], 4

; 5153 :                     for (i=0; i < c.length; ++i)

  00637	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0063f	eb 0a		 jmp	 SHORT $LN12@stbi__pars
$LN10@stbi__pars:
  00641	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  00645	ff c0		 inc	 eax
  00647	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN12@stbi__pars:
  0064b	8b 44 24 58	 mov	 eax, DWORD PTR c$1[rsp]
  0064f	39 44 24 54	 cmp	 DWORD PTR i$[rsp], eax
  00653	73 20		 jae	 SHORT $LN11@stbi__pars

; 5154 :                         palette[i*4+3] = stbi__get8(s);

  00655	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  0065a	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0065f	8b 4c 24 54	 mov	 ecx, DWORD PTR i$[rsp]
  00663	8d 0c 8d 03 00
	00 00		 lea	 ecx, DWORD PTR [rcx*4+3]
  0066a	8b c9		 mov	 ecx, ecx
  0066c	88 84 0c d0 00
	00 00		 mov	 BYTE PTR palette$[rsp+rcx], al
  00673	eb cc		 jmp	 SHORT $LN10@stbi__pars
$LN11@stbi__pars:

; 5155 :                 } else {

  00675	e9 10 01 00 00	 jmp	 $LN52@stbi__pars
$LN51@stbi__pars:

; 5156 :                     if (!(s->img_n & 1)) return stbi__err("tRNS with alpha","Corrupt PNG");

  0067a	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  0067f	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00682	83 e0 01	 and	 eax, 1
  00685	85 c0		 test	 eax, eax
  00687	75 11		 jne	 SHORT $LN56@stbi__pars
  00689	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80603
  00690	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00695	e9 e5 06 00 00	 jmp	 $LN1@stbi__pars
$LN56@stbi__pars:

; 5157 :                     if (c.length != (stbi__uint32) s->img_n*2) return stbi__err("bad tRNS len","Corrupt PNG");

  0069a	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  0069f	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  006a2	d1 e0		 shl	 eax, 1
  006a4	39 44 24 58	 cmp	 DWORD PTR c$1[rsp], eax
  006a8	74 11		 je	 SHORT $LN57@stbi__pars
  006aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80605
  006b1	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  006b6	e9 c4 06 00 00	 jmp	 $LN1@stbi__pars
$LN57@stbi__pars:

; 5158 :                     has_trans = 1;

  006bb	c6 44 24 50 01	 mov	 BYTE PTR has_trans$[rsp], 1

; 5159 :                     // non-paletted with tRNS = constant alpha. if header-scanning, we can stop now.
; 5160 :                     if (scan == STBI__SCAN_header) { ++s->img_n; return 1; }

  006c0	83 bc 24 f8 04
	00 00 02	 cmp	 DWORD PTR scan$[rsp], 2
  006c8	75 1c		 jne	 SHORT $LN58@stbi__pars
  006ca	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  006cf	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  006d2	ff c0		 inc	 eax
  006d4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  006d9	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  006dc	b8 01 00 00 00	 mov	 eax, 1
  006e1	e9 99 06 00 00	 jmp	 $LN1@stbi__pars
$LN58@stbi__pars:

; 5161 :                     if (z->depth == 16) {

  006e6	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  006ee	83 78 20 10	 cmp	 DWORD PTR [rax+32], 16
  006f2	75 3d		 jne	 SHORT $LN59@stbi__pars

; 5162 :                         for (k = 0; k < s->img_n; ++k) tc16[k] = (stbi__uint16)stbi__get16be(s); // copy the values as-is

  006f4	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  006fc	eb 0a		 jmp	 SHORT $LN15@stbi__pars
$LN13@stbi__pars:
  006fe	8b 44 24 60	 mov	 eax, DWORD PTR k$[rsp]
  00702	ff c0		 inc	 eax
  00704	89 44 24 60	 mov	 DWORD PTR k$[rsp], eax
$LN15@stbi__pars:
  00708	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  0070d	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00710	39 44 24 60	 cmp	 DWORD PTR k$[rsp], eax
  00714	7d 19		 jge	 SHORT $LN14@stbi__pars
  00716	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  0071b	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  00720	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR k$[rsp]
  00725	66 89 84 4c c4
	00 00 00	 mov	 WORD PTR tc16$[rsp+rcx*2], ax
  0072d	eb cf		 jmp	 SHORT $LN13@stbi__pars
$LN14@stbi__pars:

; 5163 :                     } else {

  0072f	eb 59		 jmp	 SHORT $LN60@stbi__pars
$LN59@stbi__pars:

; 5164 :                         for (k = 0; k < s->img_n; ++k) tc[k] = (stbi_uc)(stbi__get16be(s) & 255) * stbi__depth_scale_table[z->depth]; // non 8-bit images will be larger

  00731	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  00739	eb 0a		 jmp	 SHORT $LN18@stbi__pars
$LN16@stbi__pars:
  0073b	8b 44 24 60	 mov	 eax, DWORD PTR k$[rsp]
  0073f	ff c0		 inc	 eax
  00741	89 44 24 60	 mov	 DWORD PTR k$[rsp], eax
$LN18@stbi__pars:
  00745	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  0074a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0074d	39 44 24 60	 cmp	 DWORD PTR k$[rsp], eax
  00751	7d 37		 jge	 SHORT $LN17@stbi__pars
  00753	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00758	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  0075d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00762	0f b6 c0	 movzx	 eax, al
  00765	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0076d	48 63 49 20	 movsxd	 rcx, DWORD PTR [rcx+32]
  00771	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?stbi__depth_scale_table@@3QBEB
  00778	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0077c	0f af c1	 imul	 eax, ecx
  0077f	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR k$[rsp]
  00784	88 44 0c 7c	 mov	 BYTE PTR tc$[rsp+rcx], al
  00788	eb b1		 jmp	 SHORT $LN16@stbi__pars
$LN17@stbi__pars:
$LN60@stbi__pars:
$LN52@stbi__pars:

; 5165 :                     }
; 5166 :                 }
; 5167 :                 break;

  0078a	e9 e1 05 00 00	 jmp	 $LN5@stbi__pars
$LN61@stbi__pars:

; 5168 :             }
; 5169 :             
; 5170 :             case STBI__PNG_TYPE('I','D','A','T'): {
; 5171 :                 if (first) return stbi__err("first not IHDR", "Corrupt PNG");

  0078f	83 7c 24 78 00	 cmp	 DWORD PTR first$[rsp], 0
  00794	74 11		 je	 SHORT $LN62@stbi__pars
  00796	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80611
  0079d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  007a2	e9 d8 05 00 00	 jmp	 $LN1@stbi__pars
$LN62@stbi__pars:

; 5172 :                 if (pal_img_n && !pal_len) return stbi__err("no PLTE","Corrupt PNG");

  007a7	0f b6 44 24 40	 movzx	 eax, BYTE PTR pal_img_n$[rsp]
  007ac	85 c0		 test	 eax, eax
  007ae	74 18		 je	 SHORT $LN63@stbi__pars
  007b0	83 7c 24 74 00	 cmp	 DWORD PTR pal_len$[rsp], 0
  007b5	75 11		 jne	 SHORT $LN63@stbi__pars
  007b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80613
  007be	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  007c3	e9 b7 05 00 00	 jmp	 $LN1@stbi__pars
$LN63@stbi__pars:

; 5173 :                 if (scan == STBI__SCAN_header) {

  007c8	83 bc 24 f8 04
	00 00 02	 cmp	 DWORD PTR scan$[rsp], 2
  007d0	75 20		 jne	 SHORT $LN64@stbi__pars

; 5174 :                     // header scan definitely stops at first IDAT
; 5175 :                     if (pal_img_n)

  007d2	0f b6 44 24 40	 movzx	 eax, BYTE PTR pal_img_n$[rsp]
  007d7	85 c0		 test	 eax, eax
  007d9	74 0d		 je	 SHORT $LN65@stbi__pars

; 5176 :                         s->img_n = pal_img_n;

  007db	0f b6 44 24 40	 movzx	 eax, BYTE PTR pal_img_n$[rsp]
  007e0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  007e5	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN65@stbi__pars:

; 5177 :                     return 1;

  007e8	b8 01 00 00 00	 mov	 eax, 1
  007ed	e9 8d 05 00 00	 jmp	 $LN1@stbi__pars
$LN64@stbi__pars:

; 5178 :                 }
; 5179 :                 if (c.length > (1u << 30)) return stbi__err("IDAT size limit", "IDAT section larger than 2^30 bytes");

  007f2	81 7c 24 58 00
	00 00 40	 cmp	 DWORD PTR c$1[rsp], 1073741824 ; 40000000H
  007fa	76 11		 jbe	 SHORT $LN66@stbi__pars
  007fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80617
  00803	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00808	e9 72 05 00 00	 jmp	 $LN1@stbi__pars
$LN66@stbi__pars:

; 5180 :                 if ((int)(ioff + c.length) < (int)ioff) return 0;

  0080d	8b 44 24 58	 mov	 eax, DWORD PTR c$1[rsp]
  00811	8b 4c 24 68	 mov	 ecx, DWORD PTR ioff$[rsp]
  00815	03 c8		 add	 ecx, eax
  00817	8b c1		 mov	 eax, ecx
  00819	3b 44 24 68	 cmp	 eax, DWORD PTR ioff$[rsp]
  0081d	7d 07		 jge	 SHORT $LN67@stbi__pars
  0081f	33 c0		 xor	 eax, eax
  00821	e9 59 05 00 00	 jmp	 $LN1@stbi__pars
$LN67@stbi__pars:

; 5181 :                 if (ioff + c.length > idata_limit) {

  00826	8b 44 24 58	 mov	 eax, DWORD PTR c$1[rsp]
  0082a	8b 4c 24 68	 mov	 ecx, DWORD PTR ioff$[rsp]
  0082e	03 c8		 add	 ecx, eax
  00830	8b c1		 mov	 eax, ecx
  00832	3b 44 24 64	 cmp	 eax, DWORD PTR idata_limit$[rsp]
  00836	0f 86 ac 00 00
	00		 jbe	 $LN68@stbi__pars

; 5182 :                     stbi__uint32 idata_limit_old = idata_limit;

  0083c	8b 44 24 64	 mov	 eax, DWORD PTR idata_limit$[rsp]
  00840	89 84 24 b8 00
	00 00		 mov	 DWORD PTR idata_limit_old$7[rsp], eax

; 5183 :                     stbi_uc *p;
; 5184 :                     if (idata_limit == 0) idata_limit = c.length > 4096 ? c.length : 4096;

  00847	83 7c 24 64 00	 cmp	 DWORD PTR idata_limit$[rsp], 0
  0084c	75 2d		 jne	 SHORT $LN69@stbi__pars
  0084e	81 7c 24 58 00
	10 00 00	 cmp	 DWORD PTR c$1[rsp], 4096 ; 00001000H
  00856	76 0d		 jbe	 SHORT $LN101@stbi__pars
  00858	8b 44 24 58	 mov	 eax, DWORD PTR c$1[rsp]
  0085c	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv345[rsp], eax
  00863	eb 0b		 jmp	 SHORT $LN102@stbi__pars
$LN101@stbi__pars:
  00865	c7 84 24 94 00
	00 00 00 10 00
	00		 mov	 DWORD PTR tv345[rsp], 4096 ; 00001000H
$LN102@stbi__pars:
  00870	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR tv345[rsp]
  00877	89 44 24 64	 mov	 DWORD PTR idata_limit$[rsp], eax
$LN69@stbi__pars:
$LN19@stbi__pars:

; 5185 :                     while (ioff + c.length > idata_limit)

  0087b	8b 44 24 58	 mov	 eax, DWORD PTR c$1[rsp]
  0087f	8b 4c 24 68	 mov	 ecx, DWORD PTR ioff$[rsp]
  00883	03 c8		 add	 ecx, eax
  00885	8b c1		 mov	 eax, ecx
  00887	3b 44 24 64	 cmp	 eax, DWORD PTR idata_limit$[rsp]
  0088b	76 0c		 jbe	 SHORT $LN20@stbi__pars

; 5186 :                         idata_limit *= 2;

  0088d	8b 44 24 64	 mov	 eax, DWORD PTR idata_limit$[rsp]
  00891	d1 e0		 shl	 eax, 1
  00893	89 44 24 64	 mov	 DWORD PTR idata_limit$[rsp], eax
  00897	eb e2		 jmp	 SHORT $LN19@stbi__pars
$LN20@stbi__pars:

; 5187 :                     STBI_NOTUSED(idata_limit_old);
; 5188 :                     p = (stbi_uc *) STBI_REALLOC_SIZED(z->idata, idata_limit_old, idata_limit); if (p == NULL) return stbi__err("outofmem", "Out of memory");

  00899	8b 44 24 64	 mov	 eax, DWORD PTR idata_limit$[rsp]
  0089d	8b d0		 mov	 edx, eax
  0089f	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  008a7	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  008ab	e8 00 00 00 00	 call	 realloc
  008b0	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR p$6[rsp], rax
  008b8	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR p$6[rsp], 0
  008c1	75 11		 jne	 SHORT $LN70@stbi__pars
  008c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80622
  008ca	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  008cf	e9 ab 04 00 00	 jmp	 $LN1@stbi__pars
$LN70@stbi__pars:

; 5189 :                     z->idata = p;

  008d4	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  008dc	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR p$6[rsp]
  008e4	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
$LN68@stbi__pars:

; 5190 :                 }
; 5191 :                 if (!stbi__getn(s, z->idata+ioff,c.length)) return stbi__err("outofdata","Corrupt PNG");

  008e8	8b 44 24 68	 mov	 eax, DWORD PTR ioff$[rsp]
  008ec	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  008f4	48 03 41 08	 add	 rax, QWORD PTR [rcx+8]
  008f8	44 8b 44 24 58	 mov	 r8d, DWORD PTR c$1[rsp]
  008fd	48 8b d0	 mov	 rdx, rax
  00900	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00905	e8 00 00 00 00	 call	 ?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z ; stbi__getn
  0090a	85 c0		 test	 eax, eax
  0090c	75 11		 jne	 SHORT $LN71@stbi__pars
  0090e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80624
  00915	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0091a	e9 60 04 00 00	 jmp	 $LN1@stbi__pars
$LN71@stbi__pars:

; 5192 :                 ioff += c.length;

  0091f	8b 44 24 58	 mov	 eax, DWORD PTR c$1[rsp]
  00923	8b 4c 24 68	 mov	 ecx, DWORD PTR ioff$[rsp]
  00927	03 c8		 add	 ecx, eax
  00929	8b c1		 mov	 eax, ecx
  0092b	89 44 24 68	 mov	 DWORD PTR ioff$[rsp], eax

; 5193 :                 break;

  0092f	e9 3c 04 00 00	 jmp	 $LN5@stbi__pars
$LN72@stbi__pars:

; 5194 :             }
; 5195 :             
; 5196 :             case STBI__PNG_TYPE('I','E','N','D'): {
; 5197 :                 stbi__uint32 raw_len, bpl;
; 5198 :                 if (first) return stbi__err("first not IHDR", "Corrupt PNG");

  00934	83 7c 24 78 00	 cmp	 DWORD PTR first$[rsp], 0
  00939	74 11		 je	 SHORT $LN73@stbi__pars
  0093b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80627
  00942	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00947	e9 33 04 00 00	 jmp	 $LN1@stbi__pars
$LN73@stbi__pars:

; 5199 :                 if (scan != STBI__SCAN_load) return 1;

  0094c	83 bc 24 f8 04
	00 00 00	 cmp	 DWORD PTR scan$[rsp], 0
  00954	74 0a		 je	 SHORT $LN74@stbi__pars
  00956	b8 01 00 00 00	 mov	 eax, 1
  0095b	e9 1f 04 00 00	 jmp	 $LN1@stbi__pars
$LN74@stbi__pars:

; 5200 :                 if (z->idata == NULL) return stbi__err("no IDAT","Corrupt PNG");

  00960	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00968	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0096d	75 11		 jne	 SHORT $LN75@stbi__pars
  0096f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80630
  00976	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0097b	e9 ff 03 00 00	 jmp	 $LN1@stbi__pars
$LN75@stbi__pars:

; 5201 :                 // initial guess for decoded data size to avoid unnecessary reallocs
; 5202 :                 bpl = (s->img_x * z->depth + 7) / 8; // bytes per line, per component

  00980	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00985	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0098d	8b 00		 mov	 eax, DWORD PTR [rax]
  0098f	0f af 41 20	 imul	 eax, DWORD PTR [rcx+32]
  00993	83 c0 07	 add	 eax, 7
  00996	33 d2		 xor	 edx, edx
  00998	b9 08 00 00 00	 mov	 ecx, 8
  0099d	f7 f1		 div	 ecx
  0099f	89 84 24 a8 00
	00 00		 mov	 DWORD PTR bpl$5[rsp], eax

; 5203 :                 raw_len = bpl * s->img_y * s->img_n /* pixels */ + s->img_y /* filter mode per row */;

  009a6	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  009ab	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR bpl$5[rsp]
  009b2	0f af 48 04	 imul	 ecx, DWORD PTR [rax+4]
  009b6	8b c1		 mov	 eax, ecx
  009b8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  009bd	0f af 41 08	 imul	 eax, DWORD PTR [rcx+8]
  009c1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  009c6	03 41 04	 add	 eax, DWORD PTR [rcx+4]
  009c9	89 84 24 84 00
	00 00		 mov	 DWORD PTR raw_len$2[rsp], eax

; 5204 :                 z->expanded = (stbi_uc *) stbi_zlib_decode_malloc_guesssize_headerflag((char *) z->idata, ioff, raw_len, (int *) &raw_len, !is_iphone);

  009d0	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR is_iphone$[rsp], 0
  009d8	75 0d		 jne	 SHORT $LN103@stbi__pars
  009da	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv394[rsp], 1
  009e5	eb 0b		 jmp	 SHORT $LN104@stbi__pars
$LN103@stbi__pars:
  009e7	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv394[rsp], 0
$LN104@stbi__pars:
  009f2	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv394[rsp]
  009f9	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  009fd	4c 8d 8c 24 84
	00 00 00	 lea	 r9, QWORD PTR raw_len$2[rsp]
  00a05	44 8b 84 24 84
	00 00 00	 mov	 r8d, DWORD PTR raw_len$2[rsp]
  00a0d	8b 54 24 68	 mov	 edx, DWORD PTR ioff$[rsp]
  00a11	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00a19	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00a1d	e8 00 00 00 00	 call	 stbi_zlib_decode_malloc_guesssize_headerflag
  00a22	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00a2a	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 5205 :                 if (z->expanded == NULL) return 0; // zlib should set error

  00a2e	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00a36	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00a3b	75 07		 jne	 SHORT $LN76@stbi__pars
  00a3d	33 c0		 xor	 eax, eax
  00a3f	e9 3b 03 00 00	 jmp	 $LN1@stbi__pars
$LN76@stbi__pars:

; 5206 :                 STBI_FREE(z->idata); z->idata = NULL;

  00a44	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00a4c	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00a50	e8 00 00 00 00	 call	 free
  00a55	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00a5d	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 5207 :                 if ((req_comp == s->img_n+1 && req_comp != 3 && !pal_img_n) || has_trans)

  00a65	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00a6a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00a6d	ff c0		 inc	 eax
  00a6f	39 84 24 00 05
	00 00		 cmp	 DWORD PTR req_comp$[rsp], eax
  00a76	75 13		 jne	 SHORT $LN80@stbi__pars
  00a78	83 bc 24 00 05
	00 00 03	 cmp	 DWORD PTR req_comp$[rsp], 3
  00a80	74 09		 je	 SHORT $LN80@stbi__pars
  00a82	0f b6 44 24 40	 movzx	 eax, BYTE PTR pal_img_n$[rsp]
  00a87	85 c0		 test	 eax, eax
  00a89	74 09		 je	 SHORT $LN79@stbi__pars
$LN80@stbi__pars:
  00a8b	0f b6 44 24 50	 movzx	 eax, BYTE PTR has_trans$[rsp]
  00a90	85 c0		 test	 eax, eax
  00a92	74 14		 je	 SHORT $LN77@stbi__pars
$LN79@stbi__pars:

; 5208 :                     s->img_out_n = s->img_n+1;

  00a94	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00a99	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00a9c	ff c0		 inc	 eax
  00a9e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00aa3	89 41 0c	 mov	 DWORD PTR [rcx+12], eax
  00aa6	eb 10		 jmp	 SHORT $LN78@stbi__pars
$LN77@stbi__pars:

; 5209 :                 else
; 5210 :                     s->img_out_n = s->img_n;

  00aa8	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00aad	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00ab2	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00ab5	89 48 0c	 mov	 DWORD PTR [rax+12], ecx
$LN78@stbi__pars:

; 5211 :                 if (!stbi__create_png_image(z, z->expanded, raw_len, s->img_out_n, z->depth, color, interlace)) return 0;

  00ab8	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR interlace$[rsp]
  00abf	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00ac3	8b 44 24 6c	 mov	 eax, DWORD PTR color$[rsp]
  00ac7	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00acb	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00ad3	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00ad6	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00ada	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00adf	44 8b 48 0c	 mov	 r9d, DWORD PTR [rax+12]
  00ae3	44 8b 84 24 84
	00 00 00	 mov	 r8d, DWORD PTR raw_len$2[rsp]
  00aeb	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00af3	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00af7	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00aff	e8 00 00 00 00	 call	 ?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z ; stbi__create_png_image
  00b04	85 c0		 test	 eax, eax
  00b06	75 07		 jne	 SHORT $LN81@stbi__pars
  00b08	33 c0		 xor	 eax, eax
  00b0a	e9 70 02 00 00	 jmp	 $LN1@stbi__pars
$LN81@stbi__pars:

; 5212 :                 if (has_trans) {

  00b0f	0f b6 44 24 50	 movzx	 eax, BYTE PTR has_trans$[rsp]
  00b14	85 c0		 test	 eax, eax
  00b16	74 5f		 je	 SHORT $LN82@stbi__pars

; 5213 :                     if (z->depth == 16) {

  00b18	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00b20	83 78 20 10	 cmp	 DWORD PTR [rax+32], 16
  00b24	75 2b		 jne	 SHORT $LN83@stbi__pars

; 5214 :                         if (!stbi__compute_transparency16(z, tc16, s->img_out_n)) return 0;

  00b26	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00b2b	44 8b 40 0c	 mov	 r8d, DWORD PTR [rax+12]
  00b2f	48 8d 94 24 c4
	00 00 00	 lea	 rdx, QWORD PTR tc16$[rsp]
  00b37	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00b3f	e8 00 00 00 00	 call	 ?stbi__compute_transparency16@@YAHPEAUstbi__png@@QEAGH@Z ; stbi__compute_transparency16
  00b44	85 c0		 test	 eax, eax
  00b46	75 07		 jne	 SHORT $LN85@stbi__pars
  00b48	33 c0		 xor	 eax, eax
  00b4a	e9 30 02 00 00	 jmp	 $LN1@stbi__pars
$LN85@stbi__pars:

; 5215 :                     } else {

  00b4f	eb 26		 jmp	 SHORT $LN84@stbi__pars
$LN83@stbi__pars:

; 5216 :                         if (!stbi__compute_transparency(z, tc, s->img_out_n)) return 0;

  00b51	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00b56	44 8b 40 0c	 mov	 r8d, DWORD PTR [rax+12]
  00b5a	48 8d 54 24 7c	 lea	 rdx, QWORD PTR tc$[rsp]
  00b5f	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00b67	e8 00 00 00 00	 call	 ?stbi__compute_transparency@@YAHPEAUstbi__png@@QEAEH@Z ; stbi__compute_transparency
  00b6c	85 c0		 test	 eax, eax
  00b6e	75 07		 jne	 SHORT $LN86@stbi__pars
  00b70	33 c0		 xor	 eax, eax
  00b72	e9 08 02 00 00	 jmp	 $LN1@stbi__pars
$LN86@stbi__pars:
$LN84@stbi__pars:
$LN82@stbi__pars:

; 5217 :                     }
; 5218 :                 }
; 5219 :                 if (is_iphone && stbi__de_iphone_flag && s->img_out_n > 2)

  00b77	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR is_iphone$[rsp], 0
  00b7f	74 75		 je	 SHORT $LN87@stbi__pars
  00b81	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__de_iphone_flag_set@@3HA
  00b86	8b c0		 mov	 eax, eax
  00b88	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00b8e	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00b97	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00b9b	83 3c 08 00	 cmp	 DWORD PTR [rax+rcx], 0
  00b9f	74 26		 je	 SHORT $LN105@stbi__pars
  00ba1	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__de_iphone_flag_local@@3HA
  00ba6	8b c0		 mov	 eax, eax
  00ba8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00bae	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00bb7	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00bbb	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]
  00bbe	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv461[rsp], eax
  00bc5	eb 0d		 jmp	 SHORT $LN106@stbi__pars
$LN105@stbi__pars:
  00bc7	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?stbi__de_iphone_flag_global@@3HA
  00bcd	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv461[rsp], eax
$LN106@stbi__pars:
  00bd4	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR tv461[rsp], 0
  00bdc	74 18		 je	 SHORT $LN87@stbi__pars
  00bde	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00be3	83 78 0c 02	 cmp	 DWORD PTR [rax+12], 2
  00be7	7e 0d		 jle	 SHORT $LN87@stbi__pars

; 5220 :                     stbi__de_iphone(z);

  00be9	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00bf1	e8 00 00 00 00	 call	 ?stbi__de_iphone@@YAXPEAUstbi__png@@@Z ; stbi__de_iphone
$LN87@stbi__pars:

; 5221 :                 if (pal_img_n) {

  00bf6	0f b6 44 24 40	 movzx	 eax, BYTE PTR pal_img_n$[rsp]
  00bfb	85 c0		 test	 eax, eax
  00bfd	74 63		 je	 SHORT $LN88@stbi__pars

; 5222 :                     // pal_img_n == 3 or 4
; 5223 :                     s->img_n = pal_img_n; // record the actual colors we had

  00bff	0f b6 44 24 40	 movzx	 eax, BYTE PTR pal_img_n$[rsp]
  00c04	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00c09	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 5224 :                     s->img_out_n = pal_img_n;

  00c0c	0f b6 44 24 40	 movzx	 eax, BYTE PTR pal_img_n$[rsp]
  00c11	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00c16	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 5225 :                     if (req_comp >= 3) s->img_out_n = req_comp;

  00c19	83 bc 24 00 05
	00 00 03	 cmp	 DWORD PTR req_comp$[rsp], 3
  00c21	7c 0f		 jl	 SHORT $LN90@stbi__pars
  00c23	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00c28	8b 8c 24 00 05
	00 00		 mov	 ecx, DWORD PTR req_comp$[rsp]
  00c2f	89 48 0c	 mov	 DWORD PTR [rax+12], ecx
$LN90@stbi__pars:

; 5226 :                     if (!stbi__expand_png_palette(z, palette, pal_len, s->img_out_n))

  00c32	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00c37	44 8b 48 0c	 mov	 r9d, DWORD PTR [rax+12]
  00c3b	44 8b 44 24 74	 mov	 r8d, DWORD PTR pal_len$[rsp]
  00c40	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR palette$[rsp]
  00c48	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00c50	e8 00 00 00 00	 call	 ?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z ; stbi__expand_png_palette
  00c55	85 c0		 test	 eax, eax
  00c57	75 07		 jne	 SHORT $LN91@stbi__pars

; 5227 :                         return 0;

  00c59	33 c0		 xor	 eax, eax
  00c5b	e9 1f 01 00 00	 jmp	 $LN1@stbi__pars
$LN91@stbi__pars:
  00c60	eb 1b		 jmp	 SHORT $LN89@stbi__pars
$LN88@stbi__pars:

; 5228 :                 } else if (has_trans) {

  00c62	0f b6 44 24 50	 movzx	 eax, BYTE PTR has_trans$[rsp]
  00c67	85 c0		 test	 eax, eax
  00c69	74 12		 je	 SHORT $LN92@stbi__pars

; 5229 :                     // non-paletted image with tRNS -> source image has (constant) alpha
; 5230 :                     ++s->img_n;

  00c6b	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  00c70	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00c73	ff c0		 inc	 eax
  00c75	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00c7a	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN92@stbi__pars:
$LN89@stbi__pars:

; 5231 :                 }
; 5232 :                 STBI_FREE(z->expanded); z->expanded = NULL;

  00c7d	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00c85	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00c89	e8 00 00 00 00	 call	 free
  00c8e	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00c96	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 5233 :                 // end of PNG chunk, read and skip CRC
; 5234 :                 stbi__get32be(s);

  00c9e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00ca3	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be

; 5235 :                 return 1;

  00ca8	b8 01 00 00 00	 mov	 eax, 1
  00cad	e9 cd 00 00 00	 jmp	 $LN1@stbi__pars
$LN93@stbi__pars:

; 5236 :             }
; 5237 :             
; 5238 :             default:
; 5239 :             // if critical, fail
; 5240 :             if (first) return stbi__err("first not IHDR", "Corrupt PNG");

  00cb2	83 7c 24 78 00	 cmp	 DWORD PTR first$[rsp], 0
  00cb7	74 11		 je	 SHORT $LN94@stbi__pars
  00cb9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80650
  00cc0	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00cc5	e9 b5 00 00 00	 jmp	 $LN1@stbi__pars
$LN94@stbi__pars:

; 5241 :             if ((c.type & (1 << 29)) == 0) {

  00cca	8b 44 24 5c	 mov	 eax, DWORD PTR c$1[rsp+4]
  00cce	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00cd3	85 c0		 test	 eax, eax
  00cd5	0f 85 87 00 00
	00		 jne	 $LN95@stbi__pars

; 5242 : #ifndef STBI_NO_FAILURE_STRINGS
; 5243 :                 // not threadsafe
; 5244 :                 static char invalid_chunk[] = "XXXX PNG chunk not known";
; 5245 :                 invalid_chunk[0] = STBI__BYTECAST(c.type >> 24);

  00cdb	8b 44 24 5c	 mov	 eax, DWORD PTR c$1[rsp+4]
  00cdf	c1 e8 18	 shr	 eax, 24
  00ce2	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00ce7	b9 01 00 00 00	 mov	 ecx, 1
  00cec	48 6b c9 00	 imul	 rcx, rcx, 0
  00cf0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?invalid_chunk@?JM@??stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z@4PADA
  00cf7	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5246 :                 invalid_chunk[1] = STBI__BYTECAST(c.type >> 16);

  00cfa	8b 44 24 5c	 mov	 eax, DWORD PTR c$1[rsp+4]
  00cfe	c1 e8 10	 shr	 eax, 16
  00d01	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00d06	b9 01 00 00 00	 mov	 ecx, 1
  00d0b	48 6b c9 01	 imul	 rcx, rcx, 1
  00d0f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?invalid_chunk@?JM@??stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z@4PADA
  00d16	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5247 :                 invalid_chunk[2] = STBI__BYTECAST(c.type >>  8);

  00d19	8b 44 24 5c	 mov	 eax, DWORD PTR c$1[rsp+4]
  00d1d	c1 e8 08	 shr	 eax, 8
  00d20	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00d25	b9 01 00 00 00	 mov	 ecx, 1
  00d2a	48 6b c9 02	 imul	 rcx, rcx, 2
  00d2e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?invalid_chunk@?JM@??stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z@4PADA
  00d35	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5248 :                 invalid_chunk[3] = STBI__BYTECAST(c.type >>  0);

  00d38	8b 44 24 5c	 mov	 eax, DWORD PTR c$1[rsp+4]
  00d3c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00d41	b9 01 00 00 00	 mov	 ecx, 1
  00d46	48 6b c9 03	 imul	 rcx, rcx, 3
  00d4a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?invalid_chunk@?JM@??stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z@4PADA
  00d51	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5249 : #endif
; 5250 :                 return stbi__err(invalid_chunk, "PNG not supported: unknown PNG chunk type");

  00d54	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?invalid_chunk@?JM@??stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z@4PADA
  00d5b	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00d60	eb 1d		 jmp	 SHORT $LN1@stbi__pars
$LN95@stbi__pars:

; 5251 :             }
; 5252 :             stbi__skip(s, c.length);

  00d62	8b 54 24 58	 mov	 edx, DWORD PTR c$1[rsp]
  00d66	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00d6b	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip
$LN5@stbi__pars:

; 5253 :             break;
; 5254 :         }
; 5255 :         // end of PNG chunk, read and skip CRC
; 5256 :         stbi__get32be(s);

  00d70	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00d75	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be

; 5257 :     }

  00d7a	e9 6b f3 ff ff	 jmp	 $LN2@stbi__pars
$LN1@stbi__pars:

; 5258 : }

  00d7f	48 8b 8c 24 d0
	04 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00d87	48 33 cc	 xor	 rcx, rsp
  00d8a	e8 00 00 00 00	 call	 __security_check_cookie
  00d8f	48 81 c4 e0 04
	00 00		 add	 rsp, 1248		; 000004e0H
  00d96	5f		 pop	 rdi
  00d97	c3		 ret	 0
?stbi__parse_png_file@@YAHPEAUstbi__png@@HH@Z ENDP	; stbi__parse_png_file
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
a$1 = 32
half$2 = 33
p$ = 40
t$3 = 48
i$ = 52
t$4 = 56
t$5 = 57
pixel_count$ = 60
tv133 = 64
s$ = 72
z$ = 96
?stbi__de_iphone@@YAXPEAUstbi__png@@@Z PROC		; stbi__de_iphone

; 5033 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 5034 :     stbi__context *s = z->s;

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR z$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 44 24 48	 mov	 QWORD PTR s$[rsp], rax

; 5035 :     stbi__uint32 i, pixel_count = s->img_x * s->img_y;

  00016	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  0001b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR s$[rsp]
  00020	8b 00		 mov	 eax, DWORD PTR [rax]
  00022	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  00026	89 44 24 3c	 mov	 DWORD PTR pixel_count$[rsp], eax

; 5036 :     stbi_uc *p = z->out;

  0002a	48 8b 44 24 60	 mov	 rax, QWORD PTR z$[rsp]
  0002f	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  00033	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax

; 5037 :     
; 5038 :     if (s->img_out_n == 3) {  // convert bgr to rgb

  00038	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  0003d	83 78 0c 03	 cmp	 DWORD PTR [rax+12], 3
  00041	0f 85 83 00 00
	00		 jne	 $LN11@stbi__de_i

; 5039 :         for (i=0; i < pixel_count; ++i) {

  00047	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0004f	eb 0a		 jmp	 SHORT $LN4@stbi__de_i
$LN2@stbi__de_i:
  00051	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00055	ff c0		 inc	 eax
  00057	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__de_i:
  0005b	8b 44 24 3c	 mov	 eax, DWORD PTR pixel_count$[rsp]
  0005f	39 44 24 34	 cmp	 DWORD PTR i$[rsp], eax
  00063	73 60		 jae	 SHORT $LN3@stbi__de_i

; 5040 :             stbi_uc t = p[0];

  00065	b8 01 00 00 00	 mov	 eax, 1
  0006a	48 6b c0 00	 imul	 rax, rax, 0
  0006e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$[rsp]
  00073	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00077	88 44 24 38	 mov	 BYTE PTR t$4[rsp], al

; 5041 :             p[0] = p[2];

  0007b	b8 01 00 00 00	 mov	 eax, 1
  00080	48 6b c0 02	 imul	 rax, rax, 2
  00084	b9 01 00 00 00	 mov	 ecx, 1
  00089	48 6b c9 00	 imul	 rcx, rcx, 0
  0008d	48 8b 54 24 28	 mov	 rdx, QWORD PTR p$[rsp]
  00092	4c 8b 44 24 28	 mov	 r8, QWORD PTR p$[rsp]
  00097	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0009c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5042 :             p[2] = t;

  0009f	b8 01 00 00 00	 mov	 eax, 1
  000a4	48 6b c0 02	 imul	 rax, rax, 2
  000a8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$[rsp]
  000ad	0f b6 54 24 38	 movzx	 edx, BYTE PTR t$4[rsp]
  000b2	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 5043 :             p += 3;

  000b5	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  000ba	48 83 c0 03	 add	 rax, 3
  000be	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax

; 5044 :         }

  000c3	eb 8c		 jmp	 SHORT $LN2@stbi__de_i
$LN3@stbi__de_i:

; 5045 :     } else {

  000c5	e9 51 02 00 00	 jmp	 $LN12@stbi__de_i
$LN11@stbi__de_i:

; 5046 :         STBI_ASSERT(s->img_out_n == 4);

  000ca	48 8b 44 24 48	 mov	 rax, QWORD PTR s$[rsp]
  000cf	83 78 0c 04	 cmp	 DWORD PTR [rax+12], 4
  000d3	74 1b		 je	 SHORT $LN18@stbi__de_i
  000d5	41 b8 b6 13 00
	00		 mov	 r8d, 5046		; 000013b6H
  000db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG80452
  000e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80453
  000e9	e8 00 00 00 00	 call	 _wassert
  000ee	33 c0		 xor	 eax, eax
$LN18@stbi__de_i:

; 5047 :         if (stbi__unpremultiply_on_load) {

  000f0	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__unpremultiply_on_load_set@@3HA
  000f5	8b c0		 mov	 eax, eax
  000f7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000fd	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00106	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0010a	83 3c 08 00	 cmp	 DWORD PTR [rax+rcx], 0
  0010e	74 23		 je	 SHORT $LN19@stbi__de_i
  00110	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__unpremultiply_on_load_local@@3HA
  00115	8b c0		 mov	 eax, eax
  00117	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0011d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00126	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0012a	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]
  0012d	89 44 24 40	 mov	 DWORD PTR tv133[rsp], eax
  00131	eb 0a		 jmp	 SHORT $LN20@stbi__de_i
$LN19@stbi__de_i:
  00133	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?stbi__unpremultiply_on_load_global@@3HA
  00139	89 44 24 40	 mov	 DWORD PTR tv133[rsp], eax
$LN20@stbi__de_i:
  0013d	83 7c 24 40 00	 cmp	 DWORD PTR tv133[rsp], 0
  00142	0f 84 55 01 00
	00		 je	 $LN13@stbi__de_i

; 5048 :             // convert bgr to rgb and unpremultiply
; 5049 :             for (i=0; i < pixel_count; ++i) {

  00148	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00150	eb 0a		 jmp	 SHORT $LN7@stbi__de_i
$LN5@stbi__de_i:
  00152	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00156	ff c0		 inc	 eax
  00158	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN7@stbi__de_i:
  0015c	8b 44 24 3c	 mov	 eax, DWORD PTR pixel_count$[rsp]
  00160	39 44 24 34	 cmp	 DWORD PTR i$[rsp], eax
  00164	0f 83 31 01 00
	00		 jae	 $LN6@stbi__de_i

; 5050 :                 stbi_uc a = p[3];

  0016a	b8 01 00 00 00	 mov	 eax, 1
  0016f	48 6b c0 03	 imul	 rax, rax, 3
  00173	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$[rsp]
  00178	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0017c	88 44 24 20	 mov	 BYTE PTR a$1[rsp], al

; 5051 :                 stbi_uc t = p[0];

  00180	b8 01 00 00 00	 mov	 eax, 1
  00185	48 6b c0 00	 imul	 rax, rax, 0
  00189	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$[rsp]
  0018e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00192	88 44 24 30	 mov	 BYTE PTR t$3[rsp], al

; 5052 :                 if (a) {

  00196	0f b6 44 24 20	 movzx	 eax, BYTE PTR a$1[rsp]
  0019b	85 c0		 test	 eax, eax
  0019d	0f 84 ab 00 00
	00		 je	 $LN15@stbi__de_i

; 5053 :                     stbi_uc half = a / 2;

  001a3	0f b6 44 24 20	 movzx	 eax, BYTE PTR a$1[rsp]
  001a8	99		 cdq
  001a9	2b c2		 sub	 eax, edx
  001ab	d1 f8		 sar	 eax, 1
  001ad	88 44 24 21	 mov	 BYTE PTR half$2[rsp], al

; 5054 :                     p[0] = (p[2] * 255 + half) / a;

  001b1	b8 01 00 00 00	 mov	 eax, 1
  001b6	48 6b c0 02	 imul	 rax, rax, 2
  001ba	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$[rsp]
  001bf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001c3	69 c0 ff 00 00
	00		 imul	 eax, eax, 255		; 000000ffH
  001c9	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR half$2[rsp]
  001ce	03 c1		 add	 eax, ecx
  001d0	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR a$1[rsp]
  001d5	99		 cdq
  001d6	f7 f9		 idiv	 ecx
  001d8	b9 01 00 00 00	 mov	 ecx, 1
  001dd	48 6b c9 00	 imul	 rcx, rcx, 0
  001e1	48 8b 54 24 28	 mov	 rdx, QWORD PTR p$[rsp]
  001e6	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5055 :                     p[1] = (p[1] * 255 + half) / a;

  001e9	b8 01 00 00 00	 mov	 eax, 1
  001ee	48 6b c0 01	 imul	 rax, rax, 1
  001f2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$[rsp]
  001f7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001fb	69 c0 ff 00 00
	00		 imul	 eax, eax, 255		; 000000ffH
  00201	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR half$2[rsp]
  00206	03 c1		 add	 eax, ecx
  00208	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR a$1[rsp]
  0020d	99		 cdq
  0020e	f7 f9		 idiv	 ecx
  00210	b9 01 00 00 00	 mov	 ecx, 1
  00215	48 6b c9 01	 imul	 rcx, rcx, 1
  00219	48 8b 54 24 28	 mov	 rdx, QWORD PTR p$[rsp]
  0021e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5056 :                     p[2] = ( t   * 255 + half) / a;

  00221	0f b6 44 24 30	 movzx	 eax, BYTE PTR t$3[rsp]
  00226	69 c0 ff 00 00
	00		 imul	 eax, eax, 255		; 000000ffH
  0022c	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR half$2[rsp]
  00231	03 c1		 add	 eax, ecx
  00233	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR a$1[rsp]
  00238	99		 cdq
  00239	f7 f9		 idiv	 ecx
  0023b	b9 01 00 00 00	 mov	 ecx, 1
  00240	48 6b c9 02	 imul	 rcx, rcx, 2
  00244	48 8b 54 24 28	 mov	 rdx, QWORD PTR p$[rsp]
  00249	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5057 :                 } else {

  0024c	eb 3a		 jmp	 SHORT $LN16@stbi__de_i
$LN15@stbi__de_i:

; 5058 :                     p[0] = p[2];

  0024e	b8 01 00 00 00	 mov	 eax, 1
  00253	48 6b c0 02	 imul	 rax, rax, 2
  00257	b9 01 00 00 00	 mov	 ecx, 1
  0025c	48 6b c9 00	 imul	 rcx, rcx, 0
  00260	48 8b 54 24 28	 mov	 rdx, QWORD PTR p$[rsp]
  00265	4c 8b 44 24 28	 mov	 r8, QWORD PTR p$[rsp]
  0026a	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0026f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5059 :                     p[2] = t;

  00272	b8 01 00 00 00	 mov	 eax, 1
  00277	48 6b c0 02	 imul	 rax, rax, 2
  0027b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$[rsp]
  00280	0f b6 54 24 30	 movzx	 edx, BYTE PTR t$3[rsp]
  00285	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
$LN16@stbi__de_i:

; 5060 :                 }
; 5061 :                 p += 4;

  00288	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  0028d	48 83 c0 04	 add	 rax, 4
  00291	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax

; 5062 :             }

  00296	e9 b7 fe ff ff	 jmp	 $LN5@stbi__de_i
$LN6@stbi__de_i:

; 5063 :         } else {

  0029b	eb 7e		 jmp	 SHORT $LN14@stbi__de_i
$LN13@stbi__de_i:

; 5064 :             // convert bgr to rgb
; 5065 :             for (i=0; i < pixel_count; ++i) {

  0029d	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  002a5	eb 0a		 jmp	 SHORT $LN10@stbi__de_i
$LN8@stbi__de_i:
  002a7	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  002ab	ff c0		 inc	 eax
  002ad	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN10@stbi__de_i:
  002b1	8b 44 24 3c	 mov	 eax, DWORD PTR pixel_count$[rsp]
  002b5	39 44 24 34	 cmp	 DWORD PTR i$[rsp], eax
  002b9	73 60		 jae	 SHORT $LN9@stbi__de_i

; 5066 :                 stbi_uc t = p[0];

  002bb	b8 01 00 00 00	 mov	 eax, 1
  002c0	48 6b c0 00	 imul	 rax, rax, 0
  002c4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$[rsp]
  002c9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002cd	88 44 24 39	 mov	 BYTE PTR t$5[rsp], al

; 5067 :                 p[0] = p[2];

  002d1	b8 01 00 00 00	 mov	 eax, 1
  002d6	48 6b c0 02	 imul	 rax, rax, 2
  002da	b9 01 00 00 00	 mov	 ecx, 1
  002df	48 6b c9 00	 imul	 rcx, rcx, 0
  002e3	48 8b 54 24 28	 mov	 rdx, QWORD PTR p$[rsp]
  002e8	4c 8b 44 24 28	 mov	 r8, QWORD PTR p$[rsp]
  002ed	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  002f2	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5068 :                 p[2] = t;

  002f5	b8 01 00 00 00	 mov	 eax, 1
  002fa	48 6b c0 02	 imul	 rax, rax, 2
  002fe	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$[rsp]
  00303	0f b6 54 24 39	 movzx	 edx, BYTE PTR t$5[rsp]
  00308	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 5069 :                 p += 4;

  0030b	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  00310	48 83 c0 04	 add	 rax, 4
  00314	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax

; 5070 :             }

  00319	eb 8c		 jmp	 SHORT $LN8@stbi__de_i
$LN9@stbi__de_i:
$LN14@stbi__de_i:
$LN12@stbi__de_i:

; 5071 :         }
; 5072 :     }
; 5073 : }

  0031b	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0031f	c3		 ret	 0
?stbi__de_iphone@@YAXPEAUstbi__png@@@Z ENDP		; stbi__de_iphone
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
i$ = 32
n$1 = 36
n$2 = 40
pixel_count$ = 44
p$ = 48
orig$ = 56
temp_out$ = 64
a$ = 96
palette$ = 104
len$ = 112
pal_img_n$ = 120
?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z PROC ; stbi__expand_png_palette

; 4956 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4957 :     stbi__uint32 i, pixel_count = a->s->img_x * a->s->img_y;

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  0001d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00020	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp]
  00025	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00028	8b 00		 mov	 eax, DWORD PTR [rax]
  0002a	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  0002e	89 44 24 2c	 mov	 DWORD PTR pixel_count$[rsp], eax

; 4958 :     stbi_uc *p, *temp_out, *orig = a->out;

  00032	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  00037	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0003b	48 89 44 24 38	 mov	 QWORD PTR orig$[rsp], rax

; 4959 :     
; 4960 :     p = (stbi_uc *) stbi__malloc_mad2(pixel_count, pal_img_n, 0);

  00040	45 33 c0	 xor	 r8d, r8d
  00043	8b 54 24 78	 mov	 edx, DWORD PTR pal_img_n$[rsp]
  00047	8b 4c 24 2c	 mov	 ecx, DWORD PTR pixel_count$[rsp]
  0004b	e8 00 00 00 00	 call	 ?stbi__malloc_mad2@@YAPEAXHHH@Z ; stbi__malloc_mad2
  00050	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 4961 :     if (p == NULL) return stbi__err("outofmem", "Out of memory");

  00055	48 83 7c 24 30
	00		 cmp	 QWORD PTR p$[rsp], 0
  0005b	75 11		 jne	 SHORT $LN8@stbi__expa
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80406
  00064	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00069	e9 bf 01 00 00	 jmp	 $LN1@stbi__expa
$LN8@stbi__expa:

; 4962 :     
; 4963 :     // between here and free(out) below, exitting would leak
; 4964 :     temp_out = p;

  0006e	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  00073	48 89 44 24 40	 mov	 QWORD PTR temp_out$[rsp], rax

; 4965 :     
; 4966 :     if (pal_img_n == 3) {

  00078	83 7c 24 78 03	 cmp	 DWORD PTR pal_img_n$[rsp], 3
  0007d	0f 85 b5 00 00
	00		 jne	 $LN9@stbi__expa

; 4967 :         for (i=0; i < pixel_count; ++i) {

  00083	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0008b	eb 0a		 jmp	 SHORT $LN4@stbi__expa
$LN2@stbi__expa:
  0008d	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00091	ff c0		 inc	 eax
  00093	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__expa:
  00097	8b 44 24 2c	 mov	 eax, DWORD PTR pixel_count$[rsp]
  0009b	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0009f	0f 83 8e 00 00
	00		 jae	 $LN3@stbi__expa

; 4968 :             int n = orig[i]*4;

  000a5	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000a9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR orig$[rsp]
  000ae	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000b2	c1 e0 02	 shl	 eax, 2
  000b5	89 44 24 28	 mov	 DWORD PTR n$2[rsp], eax

; 4969 :             p[0] = palette[n  ];

  000b9	48 63 44 24 28	 movsxd	 rax, DWORD PTR n$2[rsp]
  000be	b9 01 00 00 00	 mov	 ecx, 1
  000c3	48 6b c9 00	 imul	 rcx, rcx, 0
  000c7	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  000cc	4c 8b 44 24 68	 mov	 r8, QWORD PTR palette$[rsp]
  000d1	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  000d6	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4970 :             p[1] = palette[n+1];

  000d9	8b 44 24 28	 mov	 eax, DWORD PTR n$2[rsp]
  000dd	ff c0		 inc	 eax
  000df	48 98		 cdqe
  000e1	b9 01 00 00 00	 mov	 ecx, 1
  000e6	48 6b c9 01	 imul	 rcx, rcx, 1
  000ea	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  000ef	4c 8b 44 24 68	 mov	 r8, QWORD PTR palette$[rsp]
  000f4	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  000f9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4971 :             p[2] = palette[n+2];

  000fc	8b 44 24 28	 mov	 eax, DWORD PTR n$2[rsp]
  00100	83 c0 02	 add	 eax, 2
  00103	48 98		 cdqe
  00105	b9 01 00 00 00	 mov	 ecx, 1
  0010a	48 6b c9 02	 imul	 rcx, rcx, 2
  0010e	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  00113	4c 8b 44 24 68	 mov	 r8, QWORD PTR palette$[rsp]
  00118	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0011d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4972 :             p += 3;

  00120	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  00125	48 83 c0 03	 add	 rax, 3
  00129	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 4973 :         }

  0012e	e9 5a ff ff ff	 jmp	 $LN2@stbi__expa
$LN3@stbi__expa:

; 4974 :     } else {

  00133	e9 d4 00 00 00	 jmp	 $LN10@stbi__expa
$LN9@stbi__expa:

; 4975 :         for (i=0; i < pixel_count; ++i) {

  00138	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00140	eb 0a		 jmp	 SHORT $LN7@stbi__expa
$LN5@stbi__expa:
  00142	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00146	ff c0		 inc	 eax
  00148	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@stbi__expa:
  0014c	8b 44 24 2c	 mov	 eax, DWORD PTR pixel_count$[rsp]
  00150	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00154	0f 83 b2 00 00
	00		 jae	 $LN6@stbi__expa

; 4976 :             int n = orig[i]*4;

  0015a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0015e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR orig$[rsp]
  00163	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00167	c1 e0 02	 shl	 eax, 2
  0016a	89 44 24 24	 mov	 DWORD PTR n$1[rsp], eax

; 4977 :             p[0] = palette[n  ];

  0016e	48 63 44 24 24	 movsxd	 rax, DWORD PTR n$1[rsp]
  00173	b9 01 00 00 00	 mov	 ecx, 1
  00178	48 6b c9 00	 imul	 rcx, rcx, 0
  0017c	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  00181	4c 8b 44 24 68	 mov	 r8, QWORD PTR palette$[rsp]
  00186	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0018b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4978 :             p[1] = palette[n+1];

  0018e	8b 44 24 24	 mov	 eax, DWORD PTR n$1[rsp]
  00192	ff c0		 inc	 eax
  00194	48 98		 cdqe
  00196	b9 01 00 00 00	 mov	 ecx, 1
  0019b	48 6b c9 01	 imul	 rcx, rcx, 1
  0019f	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  001a4	4c 8b 44 24 68	 mov	 r8, QWORD PTR palette$[rsp]
  001a9	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  001ae	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4979 :             p[2] = palette[n+2];

  001b1	8b 44 24 24	 mov	 eax, DWORD PTR n$1[rsp]
  001b5	83 c0 02	 add	 eax, 2
  001b8	48 98		 cdqe
  001ba	b9 01 00 00 00	 mov	 ecx, 1
  001bf	48 6b c9 02	 imul	 rcx, rcx, 2
  001c3	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  001c8	4c 8b 44 24 68	 mov	 r8, QWORD PTR palette$[rsp]
  001cd	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  001d2	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4980 :             p[3] = palette[n+3];

  001d5	8b 44 24 24	 mov	 eax, DWORD PTR n$1[rsp]
  001d9	83 c0 03	 add	 eax, 3
  001dc	48 98		 cdqe
  001de	b9 01 00 00 00	 mov	 ecx, 1
  001e3	48 6b c9 03	 imul	 rcx, rcx, 3
  001e7	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  001ec	4c 8b 44 24 68	 mov	 r8, QWORD PTR palette$[rsp]
  001f1	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  001f6	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4981 :             p += 4;

  001f9	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  001fe	48 83 c0 04	 add	 rax, 4
  00202	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 4982 :         }

  00207	e9 36 ff ff ff	 jmp	 $LN5@stbi__expa
$LN6@stbi__expa:
$LN10@stbi__expa:

; 4983 :     }
; 4984 :     STBI_FREE(a->out);

  0020c	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  00211	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00215	e8 00 00 00 00	 call	 free

; 4985 :     a->out = temp_out;

  0021a	48 8b 44 24 60	 mov	 rax, QWORD PTR a$[rsp]
  0021f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR temp_out$[rsp]
  00224	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 4986 :     
; 4987 :     STBI_NOTUSED(len);
; 4988 :     
; 4989 :     return 1;

  00228	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__expa:

; 4990 : }

  0022d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00231	c3		 ret	 0
?stbi__expand_png_palette@@YAHPEAUstbi__png@@PEAEHH@Z ENDP ; stbi__expand_png_palette
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
i$ = 32
tv87 = 36
pixel_count$ = 40
p$ = 48
s$ = 56
z$ = 80
tc$ = 88
out_n$ = 96
?stbi__compute_transparency16@@YAHPEAUstbi__png@@QEAGH@Z PROC ; stbi__compute_transparency16

; 4931 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4932 :     stbi__context *s = z->s;

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00018	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001b	48 89 44 24 38	 mov	 QWORD PTR s$[rsp], rax

; 4933 :     stbi__uint32 i, pixel_count = s->img_x * s->img_y;

  00020	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  00025	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  0002a	8b 00		 mov	 eax, DWORD PTR [rax]
  0002c	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  00030	89 44 24 28	 mov	 DWORD PTR pixel_count$[rsp], eax

; 4934 :     stbi__uint16 *p = (stbi__uint16*) z->out;

  00034	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00039	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0003d	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 4935 :     
; 4936 :     // compute color-based transparency, assuming we've
; 4937 :     // already got 65535 as the alpha value in the output
; 4938 :     STBI_ASSERT(out_n == 2 || out_n == 4);

  00042	83 7c 24 60 02	 cmp	 DWORD PTR out_n$[rsp], 2
  00047	74 22		 je	 SHORT $LN12@stbi__comp
  00049	83 7c 24 60 04	 cmp	 DWORD PTR out_n$[rsp], 4
  0004e	74 1b		 je	 SHORT $LN12@stbi__comp
  00050	41 b8 4a 13 00
	00		 mov	 r8d, 4938		; 0000134aH
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG80379
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80380
  00064	e8 00 00 00 00	 call	 _wassert
  00069	33 c0		 xor	 eax, eax
$LN12@stbi__comp:

; 4939 :     
; 4940 :     if (out_n == 2) {

  0006b	83 7c 24 60 02	 cmp	 DWORD PTR out_n$[rsp], 2
  00070	0f 85 84 00 00
	00		 jne	 $LN8@stbi__comp

; 4941 :         for (i = 0; i < pixel_count; ++i) {

  00076	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0007e	eb 0a		 jmp	 SHORT $LN4@stbi__comp
$LN2@stbi__comp:
  00080	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00084	ff c0		 inc	 eax
  00086	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__comp:
  0008a	8b 44 24 28	 mov	 eax, DWORD PTR pixel_count$[rsp]
  0008e	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00092	73 61		 jae	 SHORT $LN3@stbi__comp

; 4942 :             p[1] = (p[0] == tc[0] ? 0 : 65535);

  00094	b8 02 00 00 00	 mov	 eax, 2
  00099	48 6b c0 00	 imul	 rax, rax, 0
  0009d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  000a2	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  000a6	b9 02 00 00 00	 mov	 ecx, 2
  000ab	48 6b c9 00	 imul	 rcx, rcx, 0
  000af	48 8b 54 24 58	 mov	 rdx, QWORD PTR tc$[rsp]
  000b4	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  000b8	3b c1		 cmp	 eax, ecx
  000ba	75 0a		 jne	 SHORT $LN13@stbi__comp
  000bc	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv87[rsp], 0
  000c4	eb 08		 jmp	 SHORT $LN14@stbi__comp
$LN13@stbi__comp:
  000c6	c7 44 24 24 ff
	ff 00 00	 mov	 DWORD PTR tv87[rsp], 65535 ; 0000ffffH
$LN14@stbi__comp:
  000ce	b8 02 00 00 00	 mov	 eax, 2
  000d3	48 6b c0 01	 imul	 rax, rax, 1
  000d7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  000dc	0f b7 54 24 24	 movzx	 edx, WORD PTR tv87[rsp]
  000e1	66 89 14 01	 mov	 WORD PTR [rcx+rax], dx

; 4943 :             p += 2;

  000e5	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  000ea	48 83 c0 04	 add	 rax, 4
  000ee	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 4944 :         }

  000f3	eb 8b		 jmp	 SHORT $LN2@stbi__comp
$LN3@stbi__comp:

; 4945 :     } else {

  000f5	e9 c1 00 00 00	 jmp	 $LN9@stbi__comp
$LN8@stbi__comp:

; 4946 :         for (i = 0; i < pixel_count; ++i) {

  000fa	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00102	eb 0a		 jmp	 SHORT $LN7@stbi__comp
$LN5@stbi__comp:
  00104	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00108	ff c0		 inc	 eax
  0010a	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@stbi__comp:
  0010e	8b 44 24 28	 mov	 eax, DWORD PTR pixel_count$[rsp]
  00112	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00116	0f 83 9f 00 00
	00		 jae	 $LN6@stbi__comp

; 4947 :             if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])

  0011c	b8 02 00 00 00	 mov	 eax, 2
  00121	48 6b c0 00	 imul	 rax, rax, 0
  00125	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  0012a	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  0012e	b9 02 00 00 00	 mov	 ecx, 2
  00133	48 6b c9 00	 imul	 rcx, rcx, 0
  00137	48 8b 54 24 58	 mov	 rdx, QWORD PTR tc$[rsp]
  0013c	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  00140	3b c1		 cmp	 eax, ecx
  00142	75 64		 jne	 SHORT $LN10@stbi__comp
  00144	b8 02 00 00 00	 mov	 eax, 2
  00149	48 6b c0 01	 imul	 rax, rax, 1
  0014d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00152	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  00156	b9 02 00 00 00	 mov	 ecx, 2
  0015b	48 6b c9 01	 imul	 rcx, rcx, 1
  0015f	48 8b 54 24 58	 mov	 rdx, QWORD PTR tc$[rsp]
  00164	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  00168	3b c1		 cmp	 eax, ecx
  0016a	75 3c		 jne	 SHORT $LN10@stbi__comp
  0016c	b8 02 00 00 00	 mov	 eax, 2
  00171	48 6b c0 02	 imul	 rax, rax, 2
  00175	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  0017a	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  0017e	b9 02 00 00 00	 mov	 ecx, 2
  00183	48 6b c9 02	 imul	 rcx, rcx, 2
  00187	48 8b 54 24 58	 mov	 rdx, QWORD PTR tc$[rsp]
  0018c	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  00190	3b c1		 cmp	 eax, ecx
  00192	75 14		 jne	 SHORT $LN10@stbi__comp

; 4948 :                 p[3] = 0;

  00194	b8 02 00 00 00	 mov	 eax, 2
  00199	48 6b c0 03	 imul	 rax, rax, 3
  0019d	33 c9		 xor	 ecx, ecx
  0019f	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  001a4	66 89 0c 02	 mov	 WORD PTR [rdx+rax], cx
$LN10@stbi__comp:

; 4949 :             p += 4;

  001a8	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  001ad	48 83 c0 08	 add	 rax, 8
  001b1	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 4950 :         }

  001b6	e9 49 ff ff ff	 jmp	 $LN5@stbi__comp
$LN6@stbi__comp:
$LN9@stbi__comp:

; 4951 :     }
; 4952 :     return 1;

  001bb	b8 01 00 00 00	 mov	 eax, 1

; 4953 : }

  001c0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001c4	c3		 ret	 0
?stbi__compute_transparency16@@YAHPEAUstbi__png@@QEAGH@Z ENDP ; stbi__compute_transparency16
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
i$ = 32
tv87 = 36
pixel_count$ = 40
p$ = 48
s$ = 56
z$ = 80
tc$ = 88
out_n$ = 96
?stbi__compute_transparency@@YAHPEAUstbi__png@@QEAEH@Z PROC ; stbi__compute_transparency

; 4906 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4907 :     stbi__context *s = z->s;

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00018	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001b	48 89 44 24 38	 mov	 QWORD PTR s$[rsp], rax

; 4908 :     stbi__uint32 i, pixel_count = s->img_x * s->img_y;

  00020	48 8b 44 24 38	 mov	 rax, QWORD PTR s$[rsp]
  00025	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  0002a	8b 00		 mov	 eax, DWORD PTR [rax]
  0002c	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  00030	89 44 24 28	 mov	 DWORD PTR pixel_count$[rsp], eax

; 4909 :     stbi_uc *p = z->out;

  00034	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00039	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0003d	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 4910 :     
; 4911 :     // compute color-based transparency, assuming we've
; 4912 :     // already got 255 as the alpha value in the output
; 4913 :     STBI_ASSERT(out_n == 2 || out_n == 4);

  00042	83 7c 24 60 02	 cmp	 DWORD PTR out_n$[rsp], 2
  00047	74 22		 je	 SHORT $LN12@stbi__comp
  00049	83 7c 24 60 04	 cmp	 DWORD PTR out_n$[rsp], 4
  0004e	74 1b		 je	 SHORT $LN12@stbi__comp
  00050	41 b8 31 13 00
	00		 mov	 r8d, 4913		; 00001331H
  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG80356
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80357
  00064	e8 00 00 00 00	 call	 _wassert
  00069	33 c0		 xor	 eax, eax
$LN12@stbi__comp:

; 4914 :     
; 4915 :     if (out_n == 2) {

  0006b	83 7c 24 60 02	 cmp	 DWORD PTR out_n$[rsp], 2
  00070	0f 85 83 00 00
	00		 jne	 $LN8@stbi__comp

; 4916 :         for (i=0; i < pixel_count; ++i) {

  00076	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0007e	eb 0a		 jmp	 SHORT $LN4@stbi__comp
$LN2@stbi__comp:
  00080	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00084	ff c0		 inc	 eax
  00086	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__comp:
  0008a	8b 44 24 28	 mov	 eax, DWORD PTR pixel_count$[rsp]
  0008e	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00092	73 60		 jae	 SHORT $LN3@stbi__comp

; 4917 :             p[1] = (p[0] == tc[0] ? 0 : 255);

  00094	b8 01 00 00 00	 mov	 eax, 1
  00099	48 6b c0 00	 imul	 rax, rax, 0
  0009d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  000a2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000a6	b9 01 00 00 00	 mov	 ecx, 1
  000ab	48 6b c9 00	 imul	 rcx, rcx, 0
  000af	48 8b 54 24 58	 mov	 rdx, QWORD PTR tc$[rsp]
  000b4	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000b8	3b c1		 cmp	 eax, ecx
  000ba	75 0a		 jne	 SHORT $LN13@stbi__comp
  000bc	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv87[rsp], 0
  000c4	eb 08		 jmp	 SHORT $LN14@stbi__comp
$LN13@stbi__comp:
  000c6	c7 44 24 24 ff
	00 00 00	 mov	 DWORD PTR tv87[rsp], 255 ; 000000ffH
$LN14@stbi__comp:
  000ce	b8 01 00 00 00	 mov	 eax, 1
  000d3	48 6b c0 01	 imul	 rax, rax, 1
  000d7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  000dc	0f b6 54 24 24	 movzx	 edx, BYTE PTR tv87[rsp]
  000e1	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 4918 :             p += 2;

  000e4	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  000e9	48 83 c0 02	 add	 rax, 2
  000ed	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 4919 :         }

  000f2	eb 8c		 jmp	 SHORT $LN2@stbi__comp
$LN3@stbi__comp:

; 4920 :     } else {

  000f4	e9 bf 00 00 00	 jmp	 $LN9@stbi__comp
$LN8@stbi__comp:

; 4921 :         for (i=0; i < pixel_count; ++i) {

  000f9	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00101	eb 0a		 jmp	 SHORT $LN7@stbi__comp
$LN5@stbi__comp:
  00103	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00107	ff c0		 inc	 eax
  00109	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@stbi__comp:
  0010d	8b 44 24 28	 mov	 eax, DWORD PTR pixel_count$[rsp]
  00111	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00115	0f 83 9d 00 00
	00		 jae	 $LN6@stbi__comp

; 4922 :             if (p[0] == tc[0] && p[1] == tc[1] && p[2] == tc[2])

  0011b	b8 01 00 00 00	 mov	 eax, 1
  00120	48 6b c0 00	 imul	 rax, rax, 0
  00124	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00129	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0012d	b9 01 00 00 00	 mov	 ecx, 1
  00132	48 6b c9 00	 imul	 rcx, rcx, 0
  00136	48 8b 54 24 58	 mov	 rdx, QWORD PTR tc$[rsp]
  0013b	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0013f	3b c1		 cmp	 eax, ecx
  00141	75 62		 jne	 SHORT $LN10@stbi__comp
  00143	b8 01 00 00 00	 mov	 eax, 1
  00148	48 6b c0 01	 imul	 rax, rax, 1
  0014c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00151	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00155	b9 01 00 00 00	 mov	 ecx, 1
  0015a	48 6b c9 01	 imul	 rcx, rcx, 1
  0015e	48 8b 54 24 58	 mov	 rdx, QWORD PTR tc$[rsp]
  00163	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00167	3b c1		 cmp	 eax, ecx
  00169	75 3a		 jne	 SHORT $LN10@stbi__comp
  0016b	b8 01 00 00 00	 mov	 eax, 1
  00170	48 6b c0 02	 imul	 rax, rax, 2
  00174	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00179	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0017d	b9 01 00 00 00	 mov	 ecx, 1
  00182	48 6b c9 02	 imul	 rcx, rcx, 2
  00186	48 8b 54 24 58	 mov	 rdx, QWORD PTR tc$[rsp]
  0018b	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0018f	3b c1		 cmp	 eax, ecx
  00191	75 12		 jne	 SHORT $LN10@stbi__comp

; 4923 :                 p[3] = 0;

  00193	b8 01 00 00 00	 mov	 eax, 1
  00198	48 6b c0 03	 imul	 rax, rax, 3
  0019c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  001a1	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
$LN10@stbi__comp:

; 4924 :             p += 4;

  001a5	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  001aa	48 83 c0 04	 add	 rax, 4
  001ae	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 4925 :         }

  001b3	e9 4b ff ff ff	 jmp	 $LN5@stbi__comp
$LN6@stbi__comp:
$LN9@stbi__comp:

; 4926 :     }
; 4927 :     return 1;

  001b8	b8 01 00 00 00	 mov	 eax, 1

; 4928 : }

  001bd	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001c1	c3		 ret	 0
?stbi__compute_transparency@@YAHPEAUstbi__png@@QEAEH@Z ENDP ; stbi__compute_transparency
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
p$ = 64
j$1 = 68
x$2 = 72
i$3 = 76
out_bytes$ = 80
y$4 = 84
tv65 = 88
img_len$5 = 92
final$ = 96
bytes$ = 104
out_y$6 = 108
out_x$7 = 112
tv280 = 120
yspc$8 = 128
xspc$9 = 160
yorig$10 = 192
xorig$11 = 224
__$ArrayPad$ = 256
a$ = 288
image_data$ = 296
image_data_len$ = 304
out_n$ = 312
depth$ = 320
color$ = 328
interlaced$ = 336
?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z PROC ; stbi__create_png_image

; 4861 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4862 :     int bytes = (depth == 16 ? 2 : 1);

  0002d	83 bc 24 40 01
	00 00 10	 cmp	 DWORD PTR depth$[rsp], 16
  00035	75 0a		 jne	 SHORT $LN16@stbi__crea
  00037	c7 44 24 58 02
	00 00 00	 mov	 DWORD PTR tv65[rsp], 2
  0003f	eb 08		 jmp	 SHORT $LN17@stbi__crea
$LN16@stbi__crea:
  00041	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv65[rsp], 1
$LN17@stbi__crea:
  00049	8b 44 24 58	 mov	 eax, DWORD PTR tv65[rsp]
  0004d	89 44 24 68	 mov	 DWORD PTR bytes$[rsp], eax

; 4863 :     int out_bytes = out_n * bytes;

  00051	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR out_n$[rsp]
  00058	0f af 44 24 68	 imul	 eax, DWORD PTR bytes$[rsp]
  0005d	89 44 24 50	 mov	 DWORD PTR out_bytes$[rsp], eax

; 4864 :     stbi_uc *final;
; 4865 :     int p;
; 4866 :     if (!interlaced)

  00061	83 bc 24 50 01
	00 00 00	 cmp	 DWORD PTR interlaced$[rsp], 0
  00069	75 63		 jne	 SHORT $LN11@stbi__crea

; 4867 :         return stbi__create_png_image_raw(a, image_data, image_data_len, out_n, a->s->img_x, a->s->img_y, depth, color);

  0006b	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00073	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00076	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0007e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00081	8b 94 24 48 01
	00 00		 mov	 edx, DWORD PTR color$[rsp]
  00088	89 54 24 38	 mov	 DWORD PTR [rsp+56], edx
  0008c	8b 94 24 40 01
	00 00		 mov	 edx, DWORD PTR depth$[rsp]
  00093	89 54 24 30	 mov	 DWORD PTR [rsp+48], edx
  00097	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0009a	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0009e	8b 01		 mov	 eax, DWORD PTR [rcx]
  000a0	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000a4	44 8b 8c 24 38
	01 00 00	 mov	 r9d, DWORD PTR out_n$[rsp]
  000ac	44 8b 84 24 30
	01 00 00	 mov	 r8d, DWORD PTR image_data_len$[rsp]
  000b4	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR image_data$[rsp]
  000bc	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  000c4	e8 00 00 00 00	 call	 ?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z ; stbi__create_png_image_raw
  000c9	e9 1e 04 00 00	 jmp	 $LN1@stbi__crea
$LN11@stbi__crea:

; 4868 :     
; 4869 :     // de-interlacing
; 4870 :     final = (stbi_uc *) stbi__malloc_mad3(a->s->img_x, a->s->img_y, out_bytes, 0);

  000ce	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  000d6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d9	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  000e1	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000e4	45 33 c9	 xor	 r9d, r9d
  000e7	44 8b 44 24 50	 mov	 r8d, DWORD PTR out_bytes$[rsp]
  000ec	8b 50 04	 mov	 edx, DWORD PTR [rax+4]
  000ef	8b 09		 mov	 ecx, DWORD PTR [rcx]
  000f1	e8 00 00 00 00	 call	 ?stbi__malloc_mad3@@YAPEAXHHHH@Z ; stbi__malloc_mad3
  000f6	48 89 44 24 60	 mov	 QWORD PTR final$[rsp], rax

; 4871 :     if (!final) return stbi__err("outofmem", "Out of memory");

  000fb	48 83 7c 24 60
	00		 cmp	 QWORD PTR final$[rsp], 0
  00101	75 11		 jne	 SHORT $LN12@stbi__crea
  00103	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80336
  0010a	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0010f	e9 d8 03 00 00	 jmp	 $LN1@stbi__crea
$LN12@stbi__crea:

; 4872 :     for (p=0; p < 7; ++p) {

  00114	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR p$[rsp], 0
  0011c	eb 0a		 jmp	 SHORT $LN4@stbi__crea
$LN2@stbi__crea:
  0011e	8b 44 24 40	 mov	 eax, DWORD PTR p$[rsp]
  00122	ff c0		 inc	 eax
  00124	89 44 24 40	 mov	 DWORD PTR p$[rsp], eax
$LN4@stbi__crea:
  00128	83 7c 24 40 07	 cmp	 DWORD PTR p$[rsp], 7
  0012d	0f 8d a3 03 00
	00		 jge	 $LN3@stbi__crea

; 4873 :         int xorig[] = { 0,4,0,2,0,1,0 };

  00133	c7 84 24 e0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR xorig$11[rsp], 0
  0013e	c7 84 24 e4 00
	00 00 04 00 00
	00		 mov	 DWORD PTR xorig$11[rsp+4], 4
  00149	c7 84 24 e8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR xorig$11[rsp+8], 0
  00154	c7 84 24 ec 00
	00 00 02 00 00
	00		 mov	 DWORD PTR xorig$11[rsp+12], 2
  0015f	c7 84 24 f0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR xorig$11[rsp+16], 0
  0016a	c7 84 24 f4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR xorig$11[rsp+20], 1
  00175	c7 84 24 f8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR xorig$11[rsp+24], 0

; 4874 :         int yorig[] = { 0,0,4,0,2,0,1 };

  00180	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR yorig$10[rsp], 0
  0018b	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR yorig$10[rsp+4], 0
  00196	c7 84 24 c8 00
	00 00 04 00 00
	00		 mov	 DWORD PTR yorig$10[rsp+8], 4
  001a1	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR yorig$10[rsp+12], 0
  001ac	c7 84 24 d0 00
	00 00 02 00 00
	00		 mov	 DWORD PTR yorig$10[rsp+16], 2
  001b7	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR yorig$10[rsp+20], 0
  001c2	c7 84 24 d8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR yorig$10[rsp+24], 1

; 4875 :         int xspc[]  = { 8,8,4,4,2,2,1 };

  001cd	c7 84 24 a0 00
	00 00 08 00 00
	00		 mov	 DWORD PTR xspc$9[rsp], 8
  001d8	c7 84 24 a4 00
	00 00 08 00 00
	00		 mov	 DWORD PTR xspc$9[rsp+4], 8
  001e3	c7 84 24 a8 00
	00 00 04 00 00
	00		 mov	 DWORD PTR xspc$9[rsp+8], 4
  001ee	c7 84 24 ac 00
	00 00 04 00 00
	00		 mov	 DWORD PTR xspc$9[rsp+12], 4
  001f9	c7 84 24 b0 00
	00 00 02 00 00
	00		 mov	 DWORD PTR xspc$9[rsp+16], 2
  00204	c7 84 24 b4 00
	00 00 02 00 00
	00		 mov	 DWORD PTR xspc$9[rsp+20], 2
  0020f	c7 84 24 b8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR xspc$9[rsp+24], 1

; 4876 :         int yspc[]  = { 8,8,8,4,4,2,2 };

  0021a	c7 84 24 80 00
	00 00 08 00 00
	00		 mov	 DWORD PTR yspc$8[rsp], 8
  00225	c7 84 24 84 00
	00 00 08 00 00
	00		 mov	 DWORD PTR yspc$8[rsp+4], 8
  00230	c7 84 24 88 00
	00 00 08 00 00
	00		 mov	 DWORD PTR yspc$8[rsp+8], 8
  0023b	c7 84 24 8c 00
	00 00 04 00 00
	00		 mov	 DWORD PTR yspc$8[rsp+12], 4
  00246	c7 84 24 90 00
	00 00 04 00 00
	00		 mov	 DWORD PTR yspc$8[rsp+16], 4
  00251	c7 84 24 94 00
	00 00 02 00 00
	00		 mov	 DWORD PTR yspc$8[rsp+20], 2
  0025c	c7 84 24 98 00
	00 00 02 00 00
	00		 mov	 DWORD PTR yspc$8[rsp+24], 2

; 4877 :         int i,j,x,y;
; 4878 :         // pass1_x[4] = 0, pass1_x[5] = 1, pass1_x[12] = 1
; 4879 :         x = (a->s->img_x - xorig[p] + xspc[p]-1) / xspc[p];

  00267	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  0026f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00272	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR p$[rsp]
  00277	8b 8c 8c e0 00
	00 00		 mov	 ecx, DWORD PTR xorig$11[rsp+rcx*4]
  0027e	8b 00		 mov	 eax, DWORD PTR [rax]
  00280	2b c1		 sub	 eax, ecx
  00282	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR p$[rsp]
  00287	8b 8c 8c a0 00
	00 00		 mov	 ecx, DWORD PTR xspc$9[rsp+rcx*4]
  0028e	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00292	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR p$[rsp]
  00297	33 d2		 xor	 edx, edx
  00299	f7 b4 8c a0 00
	00 00		 div	 DWORD PTR xspc$9[rsp+rcx*4]
  002a0	89 44 24 48	 mov	 DWORD PTR x$2[rsp], eax

; 4880 :         y = (a->s->img_y - yorig[p] + yspc[p]-1) / yspc[p];

  002a4	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  002ac	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002af	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR p$[rsp]
  002b4	8b 8c 8c c0 00
	00 00		 mov	 ecx, DWORD PTR yorig$10[rsp+rcx*4]
  002bb	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  002be	2b c1		 sub	 eax, ecx
  002c0	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR p$[rsp]
  002c5	8b 8c 8c 80 00
	00 00		 mov	 ecx, DWORD PTR yspc$8[rsp+rcx*4]
  002cc	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  002d0	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR p$[rsp]
  002d5	33 d2		 xor	 edx, edx
  002d7	f7 b4 8c 80 00
	00 00		 div	 DWORD PTR yspc$8[rsp+rcx*4]
  002de	89 44 24 54	 mov	 DWORD PTR y$4[rsp], eax

; 4881 :         if (x && y) {

  002e2	83 7c 24 48 00	 cmp	 DWORD PTR x$2[rsp], 0
  002e7	0f 84 e4 01 00
	00		 je	 $LN13@stbi__crea
  002ed	83 7c 24 54 00	 cmp	 DWORD PTR y$4[rsp], 0
  002f2	0f 84 d9 01 00
	00		 je	 $LN13@stbi__crea

; 4882 :             stbi__uint32 img_len = ((((a->s->img_n * x * depth) + 7) >> 3) + 1) * y;

  002f8	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00300	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00303	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00306	0f af 44 24 48	 imul	 eax, DWORD PTR x$2[rsp]
  0030b	0f af 84 24 40
	01 00 00	 imul	 eax, DWORD PTR depth$[rsp]
  00313	83 c0 07	 add	 eax, 7
  00316	c1 f8 03	 sar	 eax, 3
  00319	ff c0		 inc	 eax
  0031b	0f af 44 24 54	 imul	 eax, DWORD PTR y$4[rsp]
  00320	89 44 24 5c	 mov	 DWORD PTR img_len$5[rsp], eax

; 4883 :             if (!stbi__create_png_image_raw(a, image_data, image_data_len, out_n, x, y, depth, color)) {

  00324	8b 84 24 48 01
	00 00		 mov	 eax, DWORD PTR color$[rsp]
  0032b	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0032f	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR depth$[rsp]
  00336	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0033a	8b 44 24 54	 mov	 eax, DWORD PTR y$4[rsp]
  0033e	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00342	8b 44 24 48	 mov	 eax, DWORD PTR x$2[rsp]
  00346	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0034a	44 8b 8c 24 38
	01 00 00	 mov	 r9d, DWORD PTR out_n$[rsp]
  00352	44 8b 84 24 30
	01 00 00	 mov	 r8d, DWORD PTR image_data_len$[rsp]
  0035a	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR image_data$[rsp]
  00362	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0036a	e8 00 00 00 00	 call	 ?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z ; stbi__create_png_image_raw
  0036f	85 c0		 test	 eax, eax
  00371	75 11		 jne	 SHORT $LN14@stbi__crea

; 4884 :                 STBI_FREE(final);

  00373	48 8b 4c 24 60	 mov	 rcx, QWORD PTR final$[rsp]
  00378	e8 00 00 00 00	 call	 free

; 4885 :                 return 0;

  0037d	33 c0		 xor	 eax, eax
  0037f	e9 68 01 00 00	 jmp	 $LN1@stbi__crea
$LN14@stbi__crea:

; 4886 :             }
; 4887 :             for (j=0; j < y; ++j) {

  00384	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR j$1[rsp], 0
  0038c	eb 0a		 jmp	 SHORT $LN7@stbi__crea
$LN5@stbi__crea:
  0038e	8b 44 24 44	 mov	 eax, DWORD PTR j$1[rsp]
  00392	ff c0		 inc	 eax
  00394	89 44 24 44	 mov	 DWORD PTR j$1[rsp], eax
$LN7@stbi__crea:
  00398	8b 44 24 54	 mov	 eax, DWORD PTR y$4[rsp]
  0039c	39 44 24 44	 cmp	 DWORD PTR j$1[rsp], eax
  003a0	0f 8d ea 00 00
	00		 jge	 $LN6@stbi__crea

; 4888 :                 for (i=0; i < x; ++i) {

  003a6	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR i$3[rsp], 0
  003ae	eb 0a		 jmp	 SHORT $LN10@stbi__crea
$LN8@stbi__crea:
  003b0	8b 44 24 4c	 mov	 eax, DWORD PTR i$3[rsp]
  003b4	ff c0		 inc	 eax
  003b6	89 44 24 4c	 mov	 DWORD PTR i$3[rsp], eax
$LN10@stbi__crea:
  003ba	8b 44 24 48	 mov	 eax, DWORD PTR x$2[rsp]
  003be	39 44 24 4c	 cmp	 DWORD PTR i$3[rsp], eax
  003c2	0f 8d c3 00 00
	00		 jge	 $LN9@stbi__crea

; 4889 :                     int out_y = j*yspc[p]+yorig[p];

  003c8	48 63 44 24 40	 movsxd	 rax, DWORD PTR p$[rsp]
  003cd	8b 4c 24 44	 mov	 ecx, DWORD PTR j$1[rsp]
  003d1	0f af 8c 84 80
	00 00 00	 imul	 ecx, DWORD PTR yspc$8[rsp+rax*4]
  003d9	8b c1		 mov	 eax, ecx
  003db	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR p$[rsp]
  003e0	03 84 8c c0 00
	00 00		 add	 eax, DWORD PTR yorig$10[rsp+rcx*4]
  003e7	89 44 24 6c	 mov	 DWORD PTR out_y$6[rsp], eax

; 4890 :                     int out_x = i*xspc[p]+xorig[p];

  003eb	48 63 44 24 40	 movsxd	 rax, DWORD PTR p$[rsp]
  003f0	8b 4c 24 4c	 mov	 ecx, DWORD PTR i$3[rsp]
  003f4	0f af 8c 84 a0
	00 00 00	 imul	 ecx, DWORD PTR xspc$9[rsp+rax*4]
  003fc	8b c1		 mov	 eax, ecx
  003fe	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR p$[rsp]
  00403	03 84 8c e0 00
	00 00		 add	 eax, DWORD PTR xorig$11[rsp+rcx*4]
  0040a	89 44 24 70	 mov	 DWORD PTR out_x$7[rsp], eax

; 4891 :                     memcpy(final + out_y*a->s->img_x*out_bytes + out_x*out_bytes,

  0040e	48 63 44 24 50	 movsxd	 rax, DWORD PTR out_bytes$[rsp]
  00413	8b 4c 24 44	 mov	 ecx, DWORD PTR j$1[rsp]
  00417	0f af 4c 24 48	 imul	 ecx, DWORD PTR x$2[rsp]
  0041c	03 4c 24 4c	 add	 ecx, DWORD PTR i$3[rsp]
  00420	0f af 4c 24 50	 imul	 ecx, DWORD PTR out_bytes$[rsp]
  00425	48 63 c9	 movsxd	 rcx, ecx
  00428	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR a$[rsp]
  00430	48 03 4a 18	 add	 rcx, QWORD PTR [rdx+24]
  00434	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR a$[rsp]
  0043c	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  0043f	44 8b 44 24 6c	 mov	 r8d, DWORD PTR out_y$6[rsp]
  00444	44 0f af 02	 imul	 r8d, DWORD PTR [rdx]
  00448	41 8b d0	 mov	 edx, r8d
  0044b	0f af 54 24 50	 imul	 edx, DWORD PTR out_bytes$[rsp]
  00450	8b d2		 mov	 edx, edx
  00452	4c 8b 44 24 60	 mov	 r8, QWORD PTR final$[rsp]
  00457	4c 03 c2	 add	 r8, rdx
  0045a	49 8b d0	 mov	 rdx, r8
  0045d	44 8b 44 24 70	 mov	 r8d, DWORD PTR out_x$7[rsp]
  00462	44 0f af 44 24
	50		 imul	 r8d, DWORD PTR out_bytes$[rsp]
  00468	4d 63 c0	 movsxd	 r8, r8d
  0046b	49 03 d0	 add	 rdx, r8
  0046e	48 89 54 24 78	 mov	 QWORD PTR tv280[rsp], rdx
  00473	4c 8b c0	 mov	 r8, rax
  00476	48 8b d1	 mov	 rdx, rcx
  00479	48 8b 44 24 78	 mov	 rax, QWORD PTR tv280[rsp]
  0047e	48 8b c8	 mov	 rcx, rax
  00481	e8 00 00 00 00	 call	 memcpy

; 4892 :                            a->out + (j*x+i)*out_bytes, out_bytes);
; 4893 :                 }

  00486	e9 25 ff ff ff	 jmp	 $LN8@stbi__crea
$LN9@stbi__crea:

; 4894 :             }

  0048b	e9 fe fe ff ff	 jmp	 $LN5@stbi__crea
$LN6@stbi__crea:

; 4895 :             STBI_FREE(a->out);

  00490	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00498	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  0049c	e8 00 00 00 00	 call	 free

; 4896 :             image_data += img_len;

  004a1	8b 44 24 5c	 mov	 eax, DWORD PTR img_len$5[rsp]
  004a5	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR image_data$[rsp]
  004ad	48 03 c8	 add	 rcx, rax
  004b0	48 8b c1	 mov	 rax, rcx
  004b3	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR image_data$[rsp], rax

; 4897 :             image_data_len -= img_len;

  004bb	8b 44 24 5c	 mov	 eax, DWORD PTR img_len$5[rsp]
  004bf	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR image_data_len$[rsp]
  004c6	2b c8		 sub	 ecx, eax
  004c8	8b c1		 mov	 eax, ecx
  004ca	89 84 24 30 01
	00 00		 mov	 DWORD PTR image_data_len$[rsp], eax
$LN13@stbi__crea:

; 4898 :         }
; 4899 :     }

  004d1	e9 48 fc ff ff	 jmp	 $LN2@stbi__crea
$LN3@stbi__crea:

; 4900 :     a->out = final;

  004d6	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR a$[rsp]
  004de	48 8b 4c 24 60	 mov	 rcx, QWORD PTR final$[rsp]
  004e3	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 4901 :     
; 4902 :     return 1;

  004e7	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__crea:

; 4903 : }

  004ec	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004f4	48 33 cc	 xor	 rcx, rsp
  004f7	e8 00 00 00 00	 call	 __security_check_cookie
  004fc	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  00503	c3		 ret	 0
?stbi__create_png_image@@YAHPEAUstbi__png@@PEAEIHHHH@Z ENDP ; stbi__create_png_image
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
inb$1 = 32
k$ = 36
i$ = 40
cur$2 = 48
scale$3 = 56
filter_bytes$ = 60
img_n$ = 64
img_width_bytes$ = 68
j$ = 72
nk$4 = 76
dest16$5 = 80
filter$6 = 88
in$7 = 96
out$8 = 104
bytes$ = 112
nsmp$9 = 116
prior$10 = 120
dest$11 = 128
tv65 = 136
width$ = 140
tv181 = 144
tv340 = 148
all_ok$ = 152
filter_buf$ = 160
output_bytes$ = 168
img_len$ = 172
stride$ = 176
tv304 = 180
tv287 = 184
nsmp$12 = 188
s$ = 192
a$ = 224
raw$ = 232
raw_len$ = 240
out_n$ = 248
x$ = 256
y$ = 264
depth$ = 272
color$ = 280
?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z PROC ; stbi__create_png_image_raw

; 4696 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 4697 :     int bytes = (depth == 16 ? 2 : 1);

  0001b	83 bc 24 10 01
	00 00 10	 cmp	 DWORD PTR depth$[rsp], 16
  00023	75 0d		 jne	 SHORT $LN81@stbi__crea
  00025	c7 84 24 88 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv65[rsp], 2
  00030	eb 0b		 jmp	 SHORT $LN82@stbi__crea
$LN81@stbi__crea:
  00032	c7 84 24 88 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv65[rsp], 1
$LN82@stbi__crea:
  0003d	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv65[rsp]
  00044	89 44 24 70	 mov	 DWORD PTR bytes$[rsp], eax

; 4698 :     stbi__context *s = a->s;

  00048	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00050	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00053	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR s$[rsp], rax

; 4699 :     stbi__uint32 i,j,stride = x*out_n*bytes;

  0005b	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00062	0f af 84 24 f8
	00 00 00	 imul	 eax, DWORD PTR out_n$[rsp]
  0006a	0f af 44 24 70	 imul	 eax, DWORD PTR bytes$[rsp]
  0006f	89 84 24 b0 00
	00 00		 mov	 DWORD PTR stride$[rsp], eax

; 4700 :     stbi__uint32 img_len, img_width_bytes;
; 4701 :     stbi_uc *filter_buf;
; 4702 :     int all_ok = 1;

  00076	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR all_ok$[rsp], 1

; 4703 :     int k;
; 4704 :     int img_n = s->img_n; // copy it into a local for later

  00081	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00089	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0008c	89 44 24 40	 mov	 DWORD PTR img_n$[rsp], eax

; 4705 :     
; 4706 :     int output_bytes = out_n*bytes;

  00090	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR out_n$[rsp]
  00097	0f af 44 24 70	 imul	 eax, DWORD PTR bytes$[rsp]
  0009c	89 84 24 a8 00
	00 00		 mov	 DWORD PTR output_bytes$[rsp], eax

; 4707 :     int filter_bytes = img_n*bytes;

  000a3	8b 44 24 40	 mov	 eax, DWORD PTR img_n$[rsp]
  000a7	0f af 44 24 70	 imul	 eax, DWORD PTR bytes$[rsp]
  000ac	89 44 24 3c	 mov	 DWORD PTR filter_bytes$[rsp], eax

; 4708 :     int width = x;

  000b0	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  000b7	89 84 24 8c 00
	00 00		 mov	 DWORD PTR width$[rsp], eax

; 4709 :     
; 4710 :     STBI_ASSERT(out_n == s->img_n || out_n == s->img_n+1);

  000be	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000c6	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000c9	39 84 24 f8 00
	00 00		 cmp	 DWORD PTR out_n$[rsp], eax
  000d0	74 31		 je	 SHORT $LN83@stbi__crea
  000d2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000da	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000dd	ff c0		 inc	 eax
  000df	39 84 24 f8 00
	00 00		 cmp	 DWORD PTR out_n$[rsp], eax
  000e6	74 1b		 je	 SHORT $LN83@stbi__crea
  000e8	41 b8 66 12 00
	00		 mov	 r8d, 4710		; 00001266H
  000ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG80252
  000f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80253
  000fc	e8 00 00 00 00	 call	 _wassert
  00101	33 c0		 xor	 eax, eax
$LN83@stbi__crea:

; 4711 :     a->out = (stbi_uc *) stbi__malloc_mad3(x, y, output_bytes, 0); // extra bytes to write off the end into

  00103	45 33 c9	 xor	 r9d, r9d
  00106	44 8b 84 24 a8
	00 00 00	 mov	 r8d, DWORD PTR output_bytes$[rsp]
  0010e	8b 94 24 08 01
	00 00		 mov	 edx, DWORD PTR y$[rsp]
  00115	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR x$[rsp]
  0011c	e8 00 00 00 00	 call	 ?stbi__malloc_mad3@@YAPEAXHHHH@Z ; stbi__malloc_mad3
  00121	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00129	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 4712 :     if (!a->out) return stbi__err("outofmem", "Out of memory");

  0012d	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR a$[rsp]
  00135	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0013a	75 11		 jne	 SHORT $LN46@stbi__crea
  0013c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80255
  00143	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00148	e9 0a 0b 00 00	 jmp	 $LN1@stbi__crea
$LN46@stbi__crea:

; 4713 :     
; 4714 :     // note: error exits here don't need to clean up a->out individually,
; 4715 :     // stbi__do_png always does on error.
; 4716 :     if (!stbi__mad3sizes_valid(img_n, x, depth, 7)) return stbi__err("too large", "Corrupt PNG");

  0014d	41 b9 07 00 00
	00		 mov	 r9d, 7
  00153	44 8b 84 24 10
	01 00 00	 mov	 r8d, DWORD PTR depth$[rsp]
  0015b	8b 94 24 00 01
	00 00		 mov	 edx, DWORD PTR x$[rsp]
  00162	8b 4c 24 40	 mov	 ecx, DWORD PTR img_n$[rsp]
  00166	e8 00 00 00 00	 call	 ?stbi__mad3sizes_valid@@YAHHHHH@Z ; stbi__mad3sizes_valid
  0016b	85 c0		 test	 eax, eax
  0016d	75 11		 jne	 SHORT $LN47@stbi__crea
  0016f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80257
  00176	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0017b	e9 d7 0a 00 00	 jmp	 $LN1@stbi__crea
$LN47@stbi__crea:

; 4717 :     img_width_bytes = (((img_n * x * depth) + 7) >> 3);

  00180	8b 44 24 40	 mov	 eax, DWORD PTR img_n$[rsp]
  00184	0f af 84 24 00
	01 00 00	 imul	 eax, DWORD PTR x$[rsp]
  0018c	0f af 84 24 10
	01 00 00	 imul	 eax, DWORD PTR depth$[rsp]
  00194	83 c0 07	 add	 eax, 7
  00197	c1 e8 03	 shr	 eax, 3
  0019a	89 44 24 44	 mov	 DWORD PTR img_width_bytes$[rsp], eax

; 4718 :     if (!stbi__mad2sizes_valid(img_width_bytes, y, img_width_bytes)) return stbi__err("too large", "Corrupt PNG");

  0019e	44 8b 44 24 44	 mov	 r8d, DWORD PTR img_width_bytes$[rsp]
  001a3	8b 94 24 08 01
	00 00		 mov	 edx, DWORD PTR y$[rsp]
  001aa	8b 4c 24 44	 mov	 ecx, DWORD PTR img_width_bytes$[rsp]
  001ae	e8 00 00 00 00	 call	 ?stbi__mad2sizes_valid@@YAHHHH@Z ; stbi__mad2sizes_valid
  001b3	85 c0		 test	 eax, eax
  001b5	75 11		 jne	 SHORT $LN48@stbi__crea
  001b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80259
  001be	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  001c3	e9 8f 0a 00 00	 jmp	 $LN1@stbi__crea
$LN48@stbi__crea:

; 4719 :     img_len = (img_width_bytes + 1) * y;

  001c8	8b 44 24 44	 mov	 eax, DWORD PTR img_width_bytes$[rsp]
  001cc	ff c0		 inc	 eax
  001ce	0f af 84 24 08
	01 00 00	 imul	 eax, DWORD PTR y$[rsp]
  001d6	89 84 24 ac 00
	00 00		 mov	 DWORD PTR img_len$[rsp], eax

; 4720 :     
; 4721 :     // we used to check for exact match between raw_len and img_len on non-interlaced PNGs,
; 4722 :     // but issue #276 reported a PNG in the wild that had extra data at the end (all zeros),
; 4723 :     // so just check for raw_len < img_len always.
; 4724 :     if (raw_len < img_len) return stbi__err("not enough pixels","Corrupt PNG");

  001dd	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR img_len$[rsp]
  001e4	39 84 24 f0 00
	00 00		 cmp	 DWORD PTR raw_len$[rsp], eax
  001eb	73 11		 jae	 SHORT $LN49@stbi__crea
  001ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80261
  001f4	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  001f9	e9 59 0a 00 00	 jmp	 $LN1@stbi__crea
$LN49@stbi__crea:

; 4725 :     
; 4726 :     // Allocate two scan lines worth of filter workspace buffer.
; 4727 :     filter_buf = (stbi_uc *) stbi__malloc_mad2(img_width_bytes, 2, 0);

  001fe	45 33 c0	 xor	 r8d, r8d
  00201	ba 02 00 00 00	 mov	 edx, 2
  00206	8b 4c 24 44	 mov	 ecx, DWORD PTR img_width_bytes$[rsp]
  0020a	e8 00 00 00 00	 call	 ?stbi__malloc_mad2@@YAPEAXHHH@Z ; stbi__malloc_mad2
  0020f	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR filter_buf$[rsp], rax

; 4728 :     if (!filter_buf) return stbi__err("outofmem", "Out of memory");

  00217	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR filter_buf$[rsp], 0
  00220	75 11		 jne	 SHORT $LN50@stbi__crea
  00222	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80263
  00229	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0022e	e9 24 0a 00 00	 jmp	 $LN1@stbi__crea
$LN50@stbi__crea:

; 4729 :     
; 4730 :     // Filtering for low-bit-depth images
; 4731 :     if (depth < 8) {

  00233	83 bc 24 10 01
	00 00 08	 cmp	 DWORD PTR depth$[rsp], 8
  0023b	7d 13		 jge	 SHORT $LN51@stbi__crea

; 4732 :         filter_bytes = 1;

  0023d	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR filter_bytes$[rsp], 1

; 4733 :         width = img_width_bytes;

  00245	8b 44 24 44	 mov	 eax, DWORD PTR img_width_bytes$[rsp]
  00249	89 84 24 8c 00
	00 00		 mov	 DWORD PTR width$[rsp], eax
$LN51@stbi__crea:

; 4734 :     }
; 4735 :     
; 4736 :     for (j=0; j < y; ++j) {

  00250	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00258	eb 0a		 jmp	 SHORT $LN4@stbi__crea
$LN2@stbi__crea:
  0025a	8b 44 24 48	 mov	 eax, DWORD PTR j$[rsp]
  0025e	ff c0		 inc	 eax
  00260	89 44 24 48	 mov	 DWORD PTR j$[rsp], eax
$LN4@stbi__crea:
  00264	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR y$[rsp]
  0026b	39 44 24 48	 cmp	 DWORD PTR j$[rsp], eax
  0026f	0f 83 c2 09 00
	00		 jae	 $LN3@stbi__crea

; 4737 :         // cur/prior filter buffers alternate
; 4738 :         stbi_uc *cur = filter_buf + (j & 1)*img_width_bytes;

  00275	8b 44 24 48	 mov	 eax, DWORD PTR j$[rsp]
  00279	83 e0 01	 and	 eax, 1
  0027c	0f af 44 24 44	 imul	 eax, DWORD PTR img_width_bytes$[rsp]
  00281	8b c0		 mov	 eax, eax
  00283	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR filter_buf$[rsp]
  0028b	48 03 c8	 add	 rcx, rax
  0028e	48 8b c1	 mov	 rax, rcx
  00291	48 89 44 24 30	 mov	 QWORD PTR cur$2[rsp], rax

; 4739 :         stbi_uc *prior = filter_buf + (~j & 1)*img_width_bytes;

  00296	8b 44 24 48	 mov	 eax, DWORD PTR j$[rsp]
  0029a	f7 d0		 not	 eax
  0029c	83 e0 01	 and	 eax, 1
  0029f	0f af 44 24 44	 imul	 eax, DWORD PTR img_width_bytes$[rsp]
  002a4	8b c0		 mov	 eax, eax
  002a6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR filter_buf$[rsp]
  002ae	48 03 c8	 add	 rcx, rax
  002b1	48 8b c1	 mov	 rax, rcx
  002b4	48 89 44 24 78	 mov	 QWORD PTR prior$10[rsp], rax

; 4740 :         stbi_uc *dest = a->out + stride*j;

  002b9	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR stride$[rsp]
  002c0	0f af 44 24 48	 imul	 eax, DWORD PTR j$[rsp]
  002c5	8b c0		 mov	 eax, eax
  002c7	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  002cf	48 03 41 18	 add	 rax, QWORD PTR [rcx+24]
  002d3	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR dest$11[rsp], rax

; 4741 :         int nk = width * filter_bytes;

  002db	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR width$[rsp]
  002e2	0f af 44 24 3c	 imul	 eax, DWORD PTR filter_bytes$[rsp]
  002e7	89 44 24 4c	 mov	 DWORD PTR nk$4[rsp], eax

; 4742 :         int filter = *raw++;

  002eb	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR raw$[rsp]
  002f3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002f6	89 44 24 58	 mov	 DWORD PTR filter$6[rsp], eax
  002fa	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR raw$[rsp]
  00302	48 ff c0	 inc	 rax
  00305	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR raw$[rsp], rax

; 4743 :         
; 4744 :         // check filter type
; 4745 :         if (filter > 4) {

  0030d	83 7c 24 58 04	 cmp	 DWORD PTR filter$6[rsp], 4
  00312	7e 18		 jle	 SHORT $LN52@stbi__crea

; 4746 :             all_ok = stbi__err("invalid filter","Corrupt PNG");

  00314	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80266
  0031b	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00320	89 84 24 98 00
	00 00		 mov	 DWORD PTR all_ok$[rsp], eax

; 4747 :             break;

  00327	e9 0b 09 00 00	 jmp	 $LN3@stbi__crea
$LN52@stbi__crea:

; 4748 :         }
; 4749 :         
; 4750 :         // if first row, use special filter that doesn't sample previous row
; 4751 :         if (j == 0) filter = first_row_filter[filter];

  0032c	83 7c 24 48 00	 cmp	 DWORD PTR j$[rsp], 0
  00331	75 14		 jne	 SHORT $LN53@stbi__crea
  00333	48 63 44 24 58	 movsxd	 rax, DWORD PTR filter$6[rsp]
  00338	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?first_row_filter@@3PAEA
  0033f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00343	89 44 24 58	 mov	 DWORD PTR filter$6[rsp], eax
$LN53@stbi__crea:

; 4752 :         
; 4753 :         // perform actual filtering
; 4754 :         switch (filter) {

  00347	8b 44 24 58	 mov	 eax, DWORD PTR filter$6[rsp]
  0034b	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv181[rsp], eax
  00352	83 bc 24 90 00
	00 00 05	 cmp	 DWORD PTR tv181[rsp], 5
  0035a	0f 87 60 03 00
	00		 ja	 $LN5@stbi__crea
  00360	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR tv181[rsp]
  00368	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0036f	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN89@stbi__crea[rcx+rax*4]
  00376	48 03 c1	 add	 rax, rcx
  00379	ff e0		 jmp	 rax
$LN54@stbi__crea:

; 4755 :             case STBI__F_none:
; 4756 :             memcpy(cur, raw, nk);

  0037b	48 63 44 24 4c	 movsxd	 rax, DWORD PTR nk$4[rsp]
  00380	4c 8b c0	 mov	 r8, rax
  00383	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR raw$[rsp]
  0038b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cur$2[rsp]
  00390	e8 00 00 00 00	 call	 memcpy

; 4757 :             break;

  00395	e9 26 03 00 00	 jmp	 $LN5@stbi__crea
$LN55@stbi__crea:

; 4758 :             case STBI__F_sub:
; 4759 :             memcpy(cur, raw, filter_bytes);

  0039a	48 63 44 24 3c	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  0039f	4c 8b c0	 mov	 r8, rax
  003a2	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR raw$[rsp]
  003aa	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cur$2[rsp]
  003af	e8 00 00 00 00	 call	 memcpy

; 4760 :             for (k = filter_bytes; k < nk; ++k)

  003b4	8b 44 24 3c	 mov	 eax, DWORD PTR filter_bytes$[rsp]
  003b8	89 44 24 24	 mov	 DWORD PTR k$[rsp], eax
  003bc	eb 0a		 jmp	 SHORT $LN9@stbi__crea
$LN7@stbi__crea:
  003be	8b 44 24 24	 mov	 eax, DWORD PTR k$[rsp]
  003c2	ff c0		 inc	 eax
  003c4	89 44 24 24	 mov	 DWORD PTR k$[rsp], eax
$LN9@stbi__crea:
  003c8	8b 44 24 4c	 mov	 eax, DWORD PTR nk$4[rsp]
  003cc	39 44 24 24	 cmp	 DWORD PTR k$[rsp], eax
  003d0	7d 3f		 jge	 SHORT $LN8@stbi__crea

; 4761 :                 cur[k] = STBI__BYTECAST(raw[k] + cur[k-filter_bytes]);

  003d2	48 63 44 24 24	 movsxd	 rax, DWORD PTR k$[rsp]
  003d7	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  003df	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003e3	8b 4c 24 3c	 mov	 ecx, DWORD PTR filter_bytes$[rsp]
  003e7	8b 54 24 24	 mov	 edx, DWORD PTR k$[rsp]
  003eb	2b d1		 sub	 edx, ecx
  003ed	8b ca		 mov	 ecx, edx
  003ef	48 63 c9	 movsxd	 rcx, ecx
  003f2	48 8b 54 24 30	 mov	 rdx, QWORD PTR cur$2[rsp]
  003f7	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  003fb	03 c1		 add	 eax, ecx
  003fd	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00402	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR k$[rsp]
  00407	48 8b 54 24 30	 mov	 rdx, QWORD PTR cur$2[rsp]
  0040c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0040f	eb ad		 jmp	 SHORT $LN7@stbi__crea
$LN8@stbi__crea:

; 4762 :             break;

  00411	e9 aa 02 00 00	 jmp	 $LN5@stbi__crea
$LN56@stbi__crea:

; 4763 :             case STBI__F_up:
; 4764 :             for (k = 0; k < nk; ++k)

  00416	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  0041e	eb 0a		 jmp	 SHORT $LN12@stbi__crea
$LN10@stbi__crea:
  00420	8b 44 24 24	 mov	 eax, DWORD PTR k$[rsp]
  00424	ff c0		 inc	 eax
  00426	89 44 24 24	 mov	 DWORD PTR k$[rsp], eax
$LN12@stbi__crea:
  0042a	8b 44 24 4c	 mov	 eax, DWORD PTR nk$4[rsp]
  0042e	39 44 24 24	 cmp	 DWORD PTR k$[rsp], eax
  00432	7d 35		 jge	 SHORT $LN11@stbi__crea

; 4765 :                 cur[k] = STBI__BYTECAST(raw[k] + prior[k]);

  00434	48 63 44 24 24	 movsxd	 rax, DWORD PTR k$[rsp]
  00439	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00441	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00445	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR k$[rsp]
  0044a	48 8b 54 24 78	 mov	 rdx, QWORD PTR prior$10[rsp]
  0044f	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00453	03 c1		 add	 eax, ecx
  00455	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0045a	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR k$[rsp]
  0045f	48 8b 54 24 30	 mov	 rdx, QWORD PTR cur$2[rsp]
  00464	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00467	eb b7		 jmp	 SHORT $LN10@stbi__crea
$LN11@stbi__crea:

; 4766 :             break;

  00469	e9 52 02 00 00	 jmp	 $LN5@stbi__crea
$LN57@stbi__crea:

; 4767 :             case STBI__F_avg:
; 4768 :             for (k = 0; k < filter_bytes; ++k)

  0046e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  00476	eb 0a		 jmp	 SHORT $LN15@stbi__crea
$LN13@stbi__crea:
  00478	8b 44 24 24	 mov	 eax, DWORD PTR k$[rsp]
  0047c	ff c0		 inc	 eax
  0047e	89 44 24 24	 mov	 DWORD PTR k$[rsp], eax
$LN15@stbi__crea:
  00482	8b 44 24 3c	 mov	 eax, DWORD PTR filter_bytes$[rsp]
  00486	39 44 24 24	 cmp	 DWORD PTR k$[rsp], eax
  0048a	7d 37		 jge	 SHORT $LN14@stbi__crea

; 4769 :                 cur[k] = STBI__BYTECAST(raw[k] + (prior[k]>>1));

  0048c	48 63 44 24 24	 movsxd	 rax, DWORD PTR k$[rsp]
  00491	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00499	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0049d	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR k$[rsp]
  004a2	48 8b 54 24 78	 mov	 rdx, QWORD PTR prior$10[rsp]
  004a7	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  004ab	d1 f9		 sar	 ecx, 1
  004ad	03 c1		 add	 eax, ecx
  004af	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  004b4	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR k$[rsp]
  004b9	48 8b 54 24 30	 mov	 rdx, QWORD PTR cur$2[rsp]
  004be	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  004c1	eb b5		 jmp	 SHORT $LN13@stbi__crea
$LN14@stbi__crea:

; 4770 :             for (k = filter_bytes; k < nk; ++k)

  004c3	8b 44 24 3c	 mov	 eax, DWORD PTR filter_bytes$[rsp]
  004c7	89 44 24 24	 mov	 DWORD PTR k$[rsp], eax
  004cb	eb 0a		 jmp	 SHORT $LN18@stbi__crea
$LN16@stbi__crea:
  004cd	8b 44 24 24	 mov	 eax, DWORD PTR k$[rsp]
  004d1	ff c0		 inc	 eax
  004d3	89 44 24 24	 mov	 DWORD PTR k$[rsp], eax
$LN18@stbi__crea:
  004d7	8b 44 24 4c	 mov	 eax, DWORD PTR nk$4[rsp]
  004db	39 44 24 24	 cmp	 DWORD PTR k$[rsp], eax
  004df	7d 55		 jge	 SHORT $LN17@stbi__crea

; 4771 :                 cur[k] = STBI__BYTECAST(raw[k] + ((prior[k] + cur[k-filter_bytes])>>1));

  004e1	48 63 44 24 24	 movsxd	 rax, DWORD PTR k$[rsp]
  004e6	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  004ee	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004f2	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR k$[rsp]
  004f7	48 8b 54 24 78	 mov	 rdx, QWORD PTR prior$10[rsp]
  004fc	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00500	8b 54 24 3c	 mov	 edx, DWORD PTR filter_bytes$[rsp]
  00504	44 8b 44 24 24	 mov	 r8d, DWORD PTR k$[rsp]
  00509	44 2b c2	 sub	 r8d, edx
  0050c	41 8b d0	 mov	 edx, r8d
  0050f	48 63 d2	 movsxd	 rdx, edx
  00512	4c 8b 44 24 30	 mov	 r8, QWORD PTR cur$2[rsp]
  00517	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  0051c	03 ca		 add	 ecx, edx
  0051e	d1 f9		 sar	 ecx, 1
  00520	03 c1		 add	 eax, ecx
  00522	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00527	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR k$[rsp]
  0052c	48 8b 54 24 30	 mov	 rdx, QWORD PTR cur$2[rsp]
  00531	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00534	eb 97		 jmp	 SHORT $LN16@stbi__crea
$LN17@stbi__crea:

; 4772 :             break;

  00536	e9 85 01 00 00	 jmp	 $LN5@stbi__crea
$LN58@stbi__crea:

; 4773 :             case STBI__F_paeth:
; 4774 :             for (k = 0; k < filter_bytes; ++k)

  0053b	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  00543	eb 0a		 jmp	 SHORT $LN21@stbi__crea
$LN19@stbi__crea:
  00545	8b 44 24 24	 mov	 eax, DWORD PTR k$[rsp]
  00549	ff c0		 inc	 eax
  0054b	89 44 24 24	 mov	 DWORD PTR k$[rsp], eax
$LN21@stbi__crea:
  0054f	8b 44 24 3c	 mov	 eax, DWORD PTR filter_bytes$[rsp]
  00553	39 44 24 24	 cmp	 DWORD PTR k$[rsp], eax
  00557	7d 35		 jge	 SHORT $LN20@stbi__crea

; 4775 :                 cur[k] = STBI__BYTECAST(raw[k] + prior[k]); // prior[k] == stbi__paeth(0,prior[k],0)

  00559	48 63 44 24 24	 movsxd	 rax, DWORD PTR k$[rsp]
  0055e	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  00566	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0056a	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR k$[rsp]
  0056f	48 8b 54 24 78	 mov	 rdx, QWORD PTR prior$10[rsp]
  00574	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00578	03 c1		 add	 eax, ecx
  0057a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0057f	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR k$[rsp]
  00584	48 8b 54 24 30	 mov	 rdx, QWORD PTR cur$2[rsp]
  00589	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0058c	eb b7		 jmp	 SHORT $LN19@stbi__crea
$LN20@stbi__crea:

; 4776 :             for (k = filter_bytes; k < nk; ++k)

  0058e	8b 44 24 3c	 mov	 eax, DWORD PTR filter_bytes$[rsp]
  00592	89 44 24 24	 mov	 DWORD PTR k$[rsp], eax
  00596	eb 0a		 jmp	 SHORT $LN24@stbi__crea
$LN22@stbi__crea:
  00598	8b 44 24 24	 mov	 eax, DWORD PTR k$[rsp]
  0059c	ff c0		 inc	 eax
  0059e	89 44 24 24	 mov	 DWORD PTR k$[rsp], eax
$LN24@stbi__crea:
  005a2	8b 44 24 4c	 mov	 eax, DWORD PTR nk$4[rsp]
  005a6	39 44 24 24	 cmp	 DWORD PTR k$[rsp], eax
  005aa	0f 8d 95 00 00
	00		 jge	 $LN23@stbi__crea

; 4777 :                 cur[k] = STBI__BYTECAST(raw[k] + stbi__paeth(cur[k-filter_bytes], prior[k], prior[k-filter_bytes]));

  005b0	48 63 44 24 24	 movsxd	 rax, DWORD PTR k$[rsp]
  005b5	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  005bd	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  005c1	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv287[rsp], eax
  005c8	8b 4c 24 3c	 mov	 ecx, DWORD PTR filter_bytes$[rsp]
  005cc	8b 54 24 24	 mov	 edx, DWORD PTR k$[rsp]
  005d0	2b d1		 sub	 edx, ecx
  005d2	8b ca		 mov	 ecx, edx
  005d4	48 63 c9	 movsxd	 rcx, ecx
  005d7	48 8b 54 24 78	 mov	 rdx, QWORD PTR prior$10[rsp]
  005dc	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  005e0	48 63 54 24 24	 movsxd	 rdx, DWORD PTR k$[rsp]
  005e5	4c 8b 44 24 78	 mov	 r8, QWORD PTR prior$10[rsp]
  005ea	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  005ef	44 8b 44 24 3c	 mov	 r8d, DWORD PTR filter_bytes$[rsp]
  005f4	44 8b 4c 24 24	 mov	 r9d, DWORD PTR k$[rsp]
  005f9	45 2b c8	 sub	 r9d, r8d
  005fc	45 8b c1	 mov	 r8d, r9d
  005ff	4d 63 c0	 movsxd	 r8, r8d
  00602	4c 8b 4c 24 30	 mov	 r9, QWORD PTR cur$2[rsp]
  00607	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  0060c	44 89 84 24 b4
	00 00 00	 mov	 DWORD PTR tv304[rsp], r8d
  00614	44 8b c1	 mov	 r8d, ecx
  00617	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv304[rsp]
  0061e	e8 00 00 00 00	 call	 ?stbi__paeth@@YAHHHH@Z	; stbi__paeth
  00623	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv287[rsp]
  0062a	03 c8		 add	 ecx, eax
  0062c	8b c1		 mov	 eax, ecx
  0062e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00633	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR k$[rsp]
  00638	48 8b 54 24 30	 mov	 rdx, QWORD PTR cur$2[rsp]
  0063d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00640	e9 53 ff ff ff	 jmp	 $LN22@stbi__crea
$LN23@stbi__crea:

; 4778 :             break;

  00645	eb 79		 jmp	 SHORT $LN5@stbi__crea
$LN59@stbi__crea:

; 4779 :             case STBI__F_avg_first:
; 4780 :             memcpy(cur, raw, filter_bytes);

  00647	48 63 44 24 3c	 movsxd	 rax, DWORD PTR filter_bytes$[rsp]
  0064c	4c 8b c0	 mov	 r8, rax
  0064f	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR raw$[rsp]
  00657	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cur$2[rsp]
  0065c	e8 00 00 00 00	 call	 memcpy

; 4781 :             for (k = filter_bytes; k < nk; ++k)

  00661	8b 44 24 3c	 mov	 eax, DWORD PTR filter_bytes$[rsp]
  00665	89 44 24 24	 mov	 DWORD PTR k$[rsp], eax
  00669	eb 0a		 jmp	 SHORT $LN27@stbi__crea
$LN25@stbi__crea:
  0066b	8b 44 24 24	 mov	 eax, DWORD PTR k$[rsp]
  0066f	ff c0		 inc	 eax
  00671	89 44 24 24	 mov	 DWORD PTR k$[rsp], eax
$LN27@stbi__crea:
  00675	8b 44 24 4c	 mov	 eax, DWORD PTR nk$4[rsp]
  00679	39 44 24 24	 cmp	 DWORD PTR k$[rsp], eax
  0067d	7d 41		 jge	 SHORT $LN26@stbi__crea

; 4782 :                 cur[k] = STBI__BYTECAST(raw[k] + (cur[k-filter_bytes] >> 1));

  0067f	48 63 44 24 24	 movsxd	 rax, DWORD PTR k$[rsp]
  00684	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  0068c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00690	8b 4c 24 3c	 mov	 ecx, DWORD PTR filter_bytes$[rsp]
  00694	8b 54 24 24	 mov	 edx, DWORD PTR k$[rsp]
  00698	2b d1		 sub	 edx, ecx
  0069a	8b ca		 mov	 ecx, edx
  0069c	48 63 c9	 movsxd	 rcx, ecx
  0069f	48 8b 54 24 30	 mov	 rdx, QWORD PTR cur$2[rsp]
  006a4	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  006a8	d1 f9		 sar	 ecx, 1
  006aa	03 c1		 add	 eax, ecx
  006ac	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006b1	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR k$[rsp]
  006b6	48 8b 54 24 30	 mov	 rdx, QWORD PTR cur$2[rsp]
  006bb	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  006be	eb ab		 jmp	 SHORT $LN25@stbi__crea
$LN26@stbi__crea:
$LN5@stbi__crea:

; 4783 :             break;
; 4784 :         }
; 4785 :         
; 4786 :         raw += nk;

  006c0	48 63 44 24 4c	 movsxd	 rax, DWORD PTR nk$4[rsp]
  006c5	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR raw$[rsp]
  006cd	48 03 c8	 add	 rcx, rax
  006d0	48 8b c1	 mov	 rax, rcx
  006d3	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR raw$[rsp], rax

; 4787 :         
; 4788 :         // expand decoded bits in cur to dest, also adding an extra alpha channel if desired
; 4789 :         if (depth < 8) {

  006db	83 bc 24 10 01
	00 00 08	 cmp	 DWORD PTR depth$[rsp], 8
  006e3	0f 8d 3b 02 00
	00		 jge	 $LN60@stbi__crea

; 4790 :             stbi_uc scale = (color == 0) ? stbi__depth_scale_table[depth] : 1; // scale grayscale values to 0..255 range

  006e9	83 bc 24 18 01
	00 00 00	 cmp	 DWORD PTR color$[rsp], 0
  006f1	75 1c		 jne	 SHORT $LN84@stbi__crea
  006f3	48 63 84 24 10
	01 00 00	 movsxd	 rax, DWORD PTR depth$[rsp]
  006fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__depth_scale_table@@3QBEB
  00702	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00706	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv340[rsp], eax
  0070d	eb 0b		 jmp	 SHORT $LN85@stbi__crea
$LN84@stbi__crea:
  0070f	c7 84 24 94 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv340[rsp], 1
$LN85@stbi__crea:
  0071a	0f b6 84 24 94
	00 00 00	 movzx	 eax, BYTE PTR tv340[rsp]
  00722	88 44 24 38	 mov	 BYTE PTR scale$3[rsp], al

; 4791 :             stbi_uc *in = cur;

  00726	48 8b 44 24 30	 mov	 rax, QWORD PTR cur$2[rsp]
  0072b	48 89 44 24 60	 mov	 QWORD PTR in$7[rsp], rax

; 4792 :             stbi_uc *out = dest;

  00730	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dest$11[rsp]
  00738	48 89 44 24 68	 mov	 QWORD PTR out$8[rsp], rax

; 4793 :             stbi_uc inb = 0;

  0073d	c6 44 24 20 00	 mov	 BYTE PTR inb$1[rsp], 0

; 4794 :             stbi__uint32 nsmp = x*img_n;

  00742	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00749	0f af 44 24 40	 imul	 eax, DWORD PTR img_n$[rsp]
  0074e	89 44 24 74	 mov	 DWORD PTR nsmp$9[rsp], eax

; 4795 :             
; 4796 :             // expand bits to bytes first
; 4797 :             if (depth == 4) {

  00752	83 bc 24 10 01
	00 00 04	 cmp	 DWORD PTR depth$[rsp], 4
  0075a	75 79		 jne	 SHORT $LN62@stbi__crea

; 4798 :                 for (i=0; i < nsmp; ++i) {

  0075c	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00764	eb 0a		 jmp	 SHORT $LN30@stbi__crea
$LN28@stbi__crea:
  00766	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0076a	ff c0		 inc	 eax
  0076c	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN30@stbi__crea:
  00770	8b 44 24 74	 mov	 eax, DWORD PTR nsmp$9[rsp]
  00774	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00778	73 56		 jae	 SHORT $LN29@stbi__crea

; 4799 :                     if ((i & 1) == 0) inb = *in++;

  0077a	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0077e	83 e0 01	 and	 eax, 1
  00781	85 c0		 test	 eax, eax
  00783	75 19		 jne	 SHORT $LN64@stbi__crea
  00785	48 8b 44 24 60	 mov	 rax, QWORD PTR in$7[rsp]
  0078a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0078d	88 44 24 20	 mov	 BYTE PTR inb$1[rsp], al
  00791	48 8b 44 24 60	 mov	 rax, QWORD PTR in$7[rsp]
  00796	48 ff c0	 inc	 rax
  00799	48 89 44 24 60	 mov	 QWORD PTR in$7[rsp], rax
$LN64@stbi__crea:

; 4800 :                     *out++ = scale * (inb >> 4);

  0079e	0f b6 44 24 38	 movzx	 eax, BYTE PTR scale$3[rsp]
  007a3	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR inb$1[rsp]
  007a8	c1 f9 04	 sar	 ecx, 4
  007ab	0f af c1	 imul	 eax, ecx
  007ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR out$8[rsp]
  007b3	88 01		 mov	 BYTE PTR [rcx], al
  007b5	48 8b 44 24 68	 mov	 rax, QWORD PTR out$8[rsp]
  007ba	48 ff c0	 inc	 rax
  007bd	48 89 44 24 68	 mov	 QWORD PTR out$8[rsp], rax

; 4801 :                     inb <<= 4;

  007c2	0f b6 44 24 20	 movzx	 eax, BYTE PTR inb$1[rsp]
  007c7	c0 e0 04	 shl	 al, 4
  007ca	88 44 24 20	 mov	 BYTE PTR inb$1[rsp], al

; 4802 :                 }

  007ce	eb 96		 jmp	 SHORT $LN28@stbi__crea
$LN29@stbi__crea:

; 4803 :             } else if (depth == 2) {

  007d0	e9 1b 01 00 00	 jmp	 $LN63@stbi__crea
$LN62@stbi__crea:
  007d5	83 bc 24 10 01
	00 00 02	 cmp	 DWORD PTR depth$[rsp], 2
  007dd	75 79		 jne	 SHORT $LN65@stbi__crea

; 4804 :                 for (i=0; i < nsmp; ++i) {

  007df	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  007e7	eb 0a		 jmp	 SHORT $LN33@stbi__crea
$LN31@stbi__crea:
  007e9	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  007ed	ff c0		 inc	 eax
  007ef	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN33@stbi__crea:
  007f3	8b 44 24 74	 mov	 eax, DWORD PTR nsmp$9[rsp]
  007f7	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  007fb	73 56		 jae	 SHORT $LN32@stbi__crea

; 4805 :                     if ((i & 3) == 0) inb = *in++;

  007fd	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00801	83 e0 03	 and	 eax, 3
  00804	85 c0		 test	 eax, eax
  00806	75 19		 jne	 SHORT $LN67@stbi__crea
  00808	48 8b 44 24 60	 mov	 rax, QWORD PTR in$7[rsp]
  0080d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00810	88 44 24 20	 mov	 BYTE PTR inb$1[rsp], al
  00814	48 8b 44 24 60	 mov	 rax, QWORD PTR in$7[rsp]
  00819	48 ff c0	 inc	 rax
  0081c	48 89 44 24 60	 mov	 QWORD PTR in$7[rsp], rax
$LN67@stbi__crea:

; 4806 :                     *out++ = scale * (inb >> 6);

  00821	0f b6 44 24 38	 movzx	 eax, BYTE PTR scale$3[rsp]
  00826	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR inb$1[rsp]
  0082b	c1 f9 06	 sar	 ecx, 6
  0082e	0f af c1	 imul	 eax, ecx
  00831	48 8b 4c 24 68	 mov	 rcx, QWORD PTR out$8[rsp]
  00836	88 01		 mov	 BYTE PTR [rcx], al
  00838	48 8b 44 24 68	 mov	 rax, QWORD PTR out$8[rsp]
  0083d	48 ff c0	 inc	 rax
  00840	48 89 44 24 68	 mov	 QWORD PTR out$8[rsp], rax

; 4807 :                     inb <<= 2;

  00845	0f b6 44 24 20	 movzx	 eax, BYTE PTR inb$1[rsp]
  0084a	c0 e0 02	 shl	 al, 2
  0084d	88 44 24 20	 mov	 BYTE PTR inb$1[rsp], al

; 4808 :                 }

  00851	eb 96		 jmp	 SHORT $LN31@stbi__crea
$LN32@stbi__crea:

; 4809 :             } else {

  00853	e9 98 00 00 00	 jmp	 $LN66@stbi__crea
$LN65@stbi__crea:

; 4810 :                 STBI_ASSERT(depth == 1);

  00858	83 bc 24 10 01
	00 00 01	 cmp	 DWORD PTR depth$[rsp], 1
  00860	74 1b		 je	 SHORT $LN86@stbi__crea
  00862	41 b8 ca 12 00
	00		 mov	 r8d, 4810		; 000012caH
  00868	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG80282
  0086f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80283
  00876	e8 00 00 00 00	 call	 _wassert
  0087b	33 c0		 xor	 eax, eax
$LN86@stbi__crea:

; 4811 :                 for (i=0; i < nsmp; ++i) {

  0087d	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00885	eb 0a		 jmp	 SHORT $LN36@stbi__crea
$LN34@stbi__crea:
  00887	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0088b	ff c0		 inc	 eax
  0088d	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN36@stbi__crea:
  00891	8b 44 24 74	 mov	 eax, DWORD PTR nsmp$9[rsp]
  00895	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00899	73 55		 jae	 SHORT $LN35@stbi__crea

; 4812 :                     if ((i & 7) == 0) inb = *in++;

  0089b	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0089f	83 e0 07	 and	 eax, 7
  008a2	85 c0		 test	 eax, eax
  008a4	75 19		 jne	 SHORT $LN68@stbi__crea
  008a6	48 8b 44 24 60	 mov	 rax, QWORD PTR in$7[rsp]
  008ab	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  008ae	88 44 24 20	 mov	 BYTE PTR inb$1[rsp], al
  008b2	48 8b 44 24 60	 mov	 rax, QWORD PTR in$7[rsp]
  008b7	48 ff c0	 inc	 rax
  008ba	48 89 44 24 60	 mov	 QWORD PTR in$7[rsp], rax
$LN68@stbi__crea:

; 4813 :                     *out++ = scale * (inb >> 7);

  008bf	0f b6 44 24 38	 movzx	 eax, BYTE PTR scale$3[rsp]
  008c4	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR inb$1[rsp]
  008c9	c1 f9 07	 sar	 ecx, 7
  008cc	0f af c1	 imul	 eax, ecx
  008cf	48 8b 4c 24 68	 mov	 rcx, QWORD PTR out$8[rsp]
  008d4	88 01		 mov	 BYTE PTR [rcx], al
  008d6	48 8b 44 24 68	 mov	 rax, QWORD PTR out$8[rsp]
  008db	48 ff c0	 inc	 rax
  008de	48 89 44 24 68	 mov	 QWORD PTR out$8[rsp], rax

; 4814 :                     inb <<= 1;

  008e3	0f b6 44 24 20	 movzx	 eax, BYTE PTR inb$1[rsp]
  008e8	d0 e0		 shl	 al, 1
  008ea	88 44 24 20	 mov	 BYTE PTR inb$1[rsp], al

; 4815 :                 }

  008ee	eb 97		 jmp	 SHORT $LN34@stbi__crea
$LN35@stbi__crea:
$LN66@stbi__crea:
$LN63@stbi__crea:

; 4816 :             }
; 4817 :             
; 4818 :             // insert alpha=255 values if desired
; 4819 :             if (img_n != out_n)

  008f0	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR out_n$[rsp]
  008f7	39 44 24 40	 cmp	 DWORD PTR img_n$[rsp], eax
  008fb	74 22		 je	 SHORT $LN69@stbi__crea

; 4820 :                 stbi__create_png_alpha_expand8(dest, dest, x, img_n);

  008fd	44 8b 4c 24 40	 mov	 r9d, DWORD PTR img_n$[rsp]
  00902	44 8b 84 24 00
	01 00 00	 mov	 r8d, DWORD PTR x$[rsp]
  0090a	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR dest$11[rsp]
  00912	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dest$11[rsp]
  0091a	e8 00 00 00 00	 call	 ?stbi__create_png_alpha_expand8@@YAXPEAE0IH@Z ; stbi__create_png_alpha_expand8
$LN69@stbi__crea:
  0091f	e9 0e 03 00 00	 jmp	 $LN61@stbi__crea
$LN60@stbi__crea:

; 4821 :         } else if (depth == 8) {

  00924	83 bc 24 10 01
	00 00 08	 cmp	 DWORD PTR depth$[rsp], 8
  0092c	75 56		 jne	 SHORT $LN70@stbi__crea

; 4822 :             if (img_n == out_n)

  0092e	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR out_n$[rsp]
  00935	39 44 24 40	 cmp	 DWORD PTR img_n$[rsp], eax
  00939	75 25		 jne	 SHORT $LN72@stbi__crea

; 4823 :                 memcpy(dest, cur, x*img_n);

  0093b	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00942	0f af 44 24 40	 imul	 eax, DWORD PTR img_n$[rsp]
  00947	8b c0		 mov	 eax, eax
  00949	44 8b c0	 mov	 r8d, eax
  0094c	48 8b 54 24 30	 mov	 rdx, QWORD PTR cur$2[rsp]
  00951	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dest$11[rsp]
  00959	e8 00 00 00 00	 call	 memcpy
  0095e	eb 1f		 jmp	 SHORT $LN73@stbi__crea
$LN72@stbi__crea:

; 4824 :             else
; 4825 :                 stbi__create_png_alpha_expand8(dest, cur, x, img_n);

  00960	44 8b 4c 24 40	 mov	 r9d, DWORD PTR img_n$[rsp]
  00965	44 8b 84 24 00
	01 00 00	 mov	 r8d, DWORD PTR x$[rsp]
  0096d	48 8b 54 24 30	 mov	 rdx, QWORD PTR cur$2[rsp]
  00972	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dest$11[rsp]
  0097a	e8 00 00 00 00	 call	 ?stbi__create_png_alpha_expand8@@YAXPEAE0IH@Z ; stbi__create_png_alpha_expand8
$LN73@stbi__crea:
  0097f	e9 ae 02 00 00	 jmp	 $LN71@stbi__crea
$LN70@stbi__crea:

; 4826 :         } else if (depth == 16) {

  00984	83 bc 24 10 01
	00 00 10	 cmp	 DWORD PTR depth$[rsp], 16
  0098c	0f 85 a0 02 00
	00		 jne	 $LN74@stbi__crea

; 4827 :             // convert the image data from big-endian to platform-native
; 4828 :             stbi__uint16 *dest16 = (stbi__uint16*)dest;

  00992	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dest$11[rsp]
  0099a	48 89 44 24 50	 mov	 QWORD PTR dest16$5[rsp], rax

; 4829 :             stbi__uint32 nsmp = x*img_n;

  0099f	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  009a6	0f af 44 24 40	 imul	 eax, DWORD PTR img_n$[rsp]
  009ab	89 84 24 bc 00
	00 00		 mov	 DWORD PTR nsmp$12[rsp], eax

; 4830 :             
; 4831 :             if (img_n == out_n) {

  009b2	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR out_n$[rsp]
  009b9	39 44 24 40	 cmp	 DWORD PTR img_n$[rsp], eax
  009bd	75 75		 jne	 SHORT $LN75@stbi__crea

; 4832 :                 for (i = 0; i < nsmp; ++i, ++dest16, cur += 2)

  009bf	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  009c7	eb 26		 jmp	 SHORT $LN39@stbi__crea
$LN37@stbi__crea:
  009c9	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  009cd	ff c0		 inc	 eax
  009cf	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
  009d3	48 8b 44 24 50	 mov	 rax, QWORD PTR dest16$5[rsp]
  009d8	48 83 c0 02	 add	 rax, 2
  009dc	48 89 44 24 50	 mov	 QWORD PTR dest16$5[rsp], rax
  009e1	48 8b 44 24 30	 mov	 rax, QWORD PTR cur$2[rsp]
  009e6	48 83 c0 02	 add	 rax, 2
  009ea	48 89 44 24 30	 mov	 QWORD PTR cur$2[rsp], rax
$LN39@stbi__crea:
  009ef	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR nsmp$12[rsp]
  009f6	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  009fa	73 33		 jae	 SHORT $LN38@stbi__crea

; 4833 :                     *dest16 = (cur[0] << 8) | cur[1];

  009fc	b8 01 00 00 00	 mov	 eax, 1
  00a01	48 6b c0 00	 imul	 rax, rax, 0
  00a05	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cur$2[rsp]
  00a0a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00a0e	c1 e0 08	 shl	 eax, 8
  00a11	b9 01 00 00 00	 mov	 ecx, 1
  00a16	48 6b c9 01	 imul	 rcx, rcx, 1
  00a1a	48 8b 54 24 30	 mov	 rdx, QWORD PTR cur$2[rsp]
  00a1f	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00a23	0b c1		 or	 eax, ecx
  00a25	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dest16$5[rsp]
  00a2a	66 89 01	 mov	 WORD PTR [rcx], ax
  00a2d	eb 9a		 jmp	 SHORT $LN37@stbi__crea
$LN38@stbi__crea:

; 4834 :             } else {

  00a2f	e9 fe 01 00 00	 jmp	 $LN76@stbi__crea
$LN75@stbi__crea:

; 4835 :                 STBI_ASSERT(img_n+1 == out_n);

  00a34	8b 44 24 40	 mov	 eax, DWORD PTR img_n$[rsp]
  00a38	ff c0		 inc	 eax
  00a3a	3b 84 24 f8 00
	00 00		 cmp	 eax, DWORD PTR out_n$[rsp]
  00a41	74 1b		 je	 SHORT $LN87@stbi__crea
  00a43	41 b8 e3 12 00
	00		 mov	 r8d, 4835		; 000012e3H
  00a49	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG80293
  00a50	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80294
  00a57	e8 00 00 00 00	 call	 _wassert
  00a5c	33 c0		 xor	 eax, eax
$LN87@stbi__crea:

; 4836 :                 if (img_n == 1) {

  00a5e	83 7c 24 40 01	 cmp	 DWORD PTR img_n$[rsp], 1
  00a63	0f 85 99 00 00
	00		 jne	 $LN77@stbi__crea

; 4837 :                     for (i = 0; i < x; ++i, dest16 += 2, cur += 2) {

  00a69	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00a71	eb 26		 jmp	 SHORT $LN42@stbi__crea
$LN40@stbi__crea:
  00a73	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00a77	ff c0		 inc	 eax
  00a79	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
  00a7d	48 8b 44 24 50	 mov	 rax, QWORD PTR dest16$5[rsp]
  00a82	48 83 c0 04	 add	 rax, 4
  00a86	48 89 44 24 50	 mov	 QWORD PTR dest16$5[rsp], rax
  00a8b	48 8b 44 24 30	 mov	 rax, QWORD PTR cur$2[rsp]
  00a90	48 83 c0 02	 add	 rax, 2
  00a94	48 89 44 24 30	 mov	 QWORD PTR cur$2[rsp], rax
$LN42@stbi__crea:
  00a99	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00aa0	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00aa4	73 57		 jae	 SHORT $LN41@stbi__crea

; 4838 :                         dest16[0] = (cur[0] << 8) | cur[1];

  00aa6	b8 01 00 00 00	 mov	 eax, 1
  00aab	48 6b c0 00	 imul	 rax, rax, 0
  00aaf	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cur$2[rsp]
  00ab4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00ab8	c1 e0 08	 shl	 eax, 8
  00abb	b9 01 00 00 00	 mov	 ecx, 1
  00ac0	48 6b c9 01	 imul	 rcx, rcx, 1
  00ac4	48 8b 54 24 30	 mov	 rdx, QWORD PTR cur$2[rsp]
  00ac9	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00acd	0b c1		 or	 eax, ecx
  00acf	b9 02 00 00 00	 mov	 ecx, 2
  00ad4	48 6b c9 00	 imul	 rcx, rcx, 0
  00ad8	48 8b 54 24 50	 mov	 rdx, QWORD PTR dest16$5[rsp]
  00add	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax

; 4839 :                         dest16[1] = 0xffff;

  00ae1	b8 02 00 00 00	 mov	 eax, 2
  00ae6	48 6b c0 01	 imul	 rax, rax, 1
  00aea	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00aef	48 8b 54 24 50	 mov	 rdx, QWORD PTR dest16$5[rsp]
  00af4	66 89 0c 02	 mov	 WORD PTR [rdx+rax], cx

; 4840 :                     }

  00af8	e9 76 ff ff ff	 jmp	 $LN40@stbi__crea
$LN41@stbi__crea:

; 4841 :                 } else {

  00afd	e9 30 01 00 00	 jmp	 $LN78@stbi__crea
$LN77@stbi__crea:

; 4842 :                     STBI_ASSERT(img_n == 3);

  00b02	83 7c 24 40 03	 cmp	 DWORD PTR img_n$[rsp], 3
  00b07	74 1b		 je	 SHORT $LN88@stbi__crea
  00b09	41 b8 ea 12 00
	00		 mov	 r8d, 4842		; 000012eaH
  00b0f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG80297
  00b16	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80298
  00b1d	e8 00 00 00 00	 call	 _wassert
  00b22	33 c0		 xor	 eax, eax
$LN88@stbi__crea:

; 4843 :                     for (i = 0; i < x; ++i, dest16 += 4, cur += 6) {

  00b24	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00b2c	eb 26		 jmp	 SHORT $LN45@stbi__crea
$LN43@stbi__crea:
  00b2e	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00b32	ff c0		 inc	 eax
  00b34	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
  00b38	48 8b 44 24 50	 mov	 rax, QWORD PTR dest16$5[rsp]
  00b3d	48 83 c0 08	 add	 rax, 8
  00b41	48 89 44 24 50	 mov	 QWORD PTR dest16$5[rsp], rax
  00b46	48 8b 44 24 30	 mov	 rax, QWORD PTR cur$2[rsp]
  00b4b	48 83 c0 06	 add	 rax, 6
  00b4f	48 89 44 24 30	 mov	 QWORD PTR cur$2[rsp], rax
$LN45@stbi__crea:
  00b54	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00b5b	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00b5f	0f 83 cd 00 00
	00		 jae	 $LN44@stbi__crea

; 4844 :                         dest16[0] = (cur[0] << 8) | cur[1];

  00b65	b8 01 00 00 00	 mov	 eax, 1
  00b6a	48 6b c0 00	 imul	 rax, rax, 0
  00b6e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cur$2[rsp]
  00b73	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b77	c1 e0 08	 shl	 eax, 8
  00b7a	b9 01 00 00 00	 mov	 ecx, 1
  00b7f	48 6b c9 01	 imul	 rcx, rcx, 1
  00b83	48 8b 54 24 30	 mov	 rdx, QWORD PTR cur$2[rsp]
  00b88	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00b8c	0b c1		 or	 eax, ecx
  00b8e	b9 02 00 00 00	 mov	 ecx, 2
  00b93	48 6b c9 00	 imul	 rcx, rcx, 0
  00b97	48 8b 54 24 50	 mov	 rdx, QWORD PTR dest16$5[rsp]
  00b9c	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax

; 4845 :                         dest16[1] = (cur[2] << 8) | cur[3];

  00ba0	b8 01 00 00 00	 mov	 eax, 1
  00ba5	48 6b c0 02	 imul	 rax, rax, 2
  00ba9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cur$2[rsp]
  00bae	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00bb2	c1 e0 08	 shl	 eax, 8
  00bb5	b9 01 00 00 00	 mov	 ecx, 1
  00bba	48 6b c9 03	 imul	 rcx, rcx, 3
  00bbe	48 8b 54 24 30	 mov	 rdx, QWORD PTR cur$2[rsp]
  00bc3	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00bc7	0b c1		 or	 eax, ecx
  00bc9	b9 02 00 00 00	 mov	 ecx, 2
  00bce	48 6b c9 01	 imul	 rcx, rcx, 1
  00bd2	48 8b 54 24 50	 mov	 rdx, QWORD PTR dest16$5[rsp]
  00bd7	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax

; 4846 :                         dest16[2] = (cur[4] << 8) | cur[5];

  00bdb	b8 01 00 00 00	 mov	 eax, 1
  00be0	48 6b c0 04	 imul	 rax, rax, 4
  00be4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cur$2[rsp]
  00be9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00bed	c1 e0 08	 shl	 eax, 8
  00bf0	b9 01 00 00 00	 mov	 ecx, 1
  00bf5	48 6b c9 05	 imul	 rcx, rcx, 5
  00bf9	48 8b 54 24 30	 mov	 rdx, QWORD PTR cur$2[rsp]
  00bfe	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00c02	0b c1		 or	 eax, ecx
  00c04	b9 02 00 00 00	 mov	 ecx, 2
  00c09	48 6b c9 02	 imul	 rcx, rcx, 2
  00c0d	48 8b 54 24 50	 mov	 rdx, QWORD PTR dest16$5[rsp]
  00c12	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax

; 4847 :                         dest16[3] = 0xffff;

  00c16	b8 02 00 00 00	 mov	 eax, 2
  00c1b	48 6b c0 03	 imul	 rax, rax, 3
  00c1f	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00c24	48 8b 54 24 50	 mov	 rdx, QWORD PTR dest16$5[rsp]
  00c29	66 89 0c 02	 mov	 WORD PTR [rdx+rax], cx

; 4848 :                     }

  00c2d	e9 fc fe ff ff	 jmp	 $LN43@stbi__crea
$LN44@stbi__crea:
$LN78@stbi__crea:
$LN76@stbi__crea:
$LN74@stbi__crea:
$LN71@stbi__crea:
$LN61@stbi__crea:

; 4849 :                 }
; 4850 :             }
; 4851 :         }
; 4852 :     }

  00c32	e9 23 f6 ff ff	 jmp	 $LN2@stbi__crea
$LN3@stbi__crea:

; 4853 :     
; 4854 :     STBI_FREE(filter_buf);

  00c37	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR filter_buf$[rsp]
  00c3f	e8 00 00 00 00	 call	 free

; 4855 :     if (!all_ok) return 0;

  00c44	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR all_ok$[rsp], 0
  00c4c	75 04		 jne	 SHORT $LN79@stbi__crea
  00c4e	33 c0		 xor	 eax, eax
  00c50	eb 05		 jmp	 SHORT $LN1@stbi__crea
$LN79@stbi__crea:

; 4856 :     
; 4857 :     return 1;

  00c52	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__crea:

; 4858 : }

  00c57	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  00c5e	c3		 ret	 0
  00c5f	90		 npad	 1
$LN89@stbi__crea:
  00c60	00 00 00 00	 DD	 $LN54@stbi__crea
  00c64	00 00 00 00	 DD	 $LN55@stbi__crea
  00c68	00 00 00 00	 DD	 $LN56@stbi__crea
  00c6c	00 00 00 00	 DD	 $LN57@stbi__crea
  00c70	00 00 00 00	 DD	 $LN58@stbi__crea
  00c74	00 00 00 00	 DD	 $LN59@stbi__crea
?stbi__create_png_image_raw@@YAHPEAUstbi__png@@PEAEIHIIHH@Z ENDP ; stbi__create_png_image_raw
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
i$ = 32
dest$ = 64
src$ = 72
x$ = 80
img_n$ = 88
?stbi__create_png_alpha_expand8@@YAXPEAE0IH@Z PROC	; stbi__create_png_alpha_expand8

; 4675 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4676 :     int i;
; 4677 :     // must process data backwards since we allow dest==src
; 4678 :     if (img_n == 1) {

  00018	83 7c 24 58 01	 cmp	 DWORD PTR img_n$[rsp], 1
  0001d	75 57		 jne	 SHORT $LN8@stbi__crea

; 4679 :         for (i=x-1; i >= 0; --i) {

  0001f	8b 44 24 50	 mov	 eax, DWORD PTR x$[rsp]
  00023	ff c8		 dec	 eax
  00025	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00029	eb 0a		 jmp	 SHORT $LN4@stbi__crea
$LN2@stbi__crea:
  0002b	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0002f	ff c8		 dec	 eax
  00031	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__crea:
  00035	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  0003a	7c 35		 jl	 SHORT $LN3@stbi__crea

; 4680 :             dest[i*2+1] = 255;

  0003c	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00040	8d 44 00 01	 lea	 eax, DWORD PTR [rax+rax+1]
  00044	48 98		 cdqe
  00046	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dest$[rsp]
  0004b	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 4681 :             dest[i*2+0] = src[i];

  0004f	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00054	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00058	03 c9		 add	 ecx, ecx
  0005a	48 63 c9	 movsxd	 rcx, ecx
  0005d	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest$[rsp]
  00062	4c 8b 44 24 48	 mov	 r8, QWORD PTR src$[rsp]
  00067	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0006c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4682 :         }

  0006f	eb ba		 jmp	 SHORT $LN2@stbi__crea
$LN3@stbi__crea:

; 4683 :     } else {

  00071	e9 d4 00 00 00	 jmp	 $LN9@stbi__crea
$LN8@stbi__crea:

; 4684 :         STBI_ASSERT(img_n == 3);

  00076	83 7c 24 58 03	 cmp	 DWORD PTR img_n$[rsp], 3
  0007b	74 1b		 je	 SHORT $LN11@stbi__crea
  0007d	41 b8 4c 12 00
	00		 mov	 r8d, 4684		; 0000124cH
  00083	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG80152
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80153
  00091	e8 00 00 00 00	 call	 _wassert
  00096	33 c0		 xor	 eax, eax
$LN11@stbi__crea:

; 4685 :         for (i=x-1; i >= 0; --i) {

  00098	8b 44 24 50	 mov	 eax, DWORD PTR x$[rsp]
  0009c	ff c8		 dec	 eax
  0009e	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  000a2	eb 0a		 jmp	 SHORT $LN7@stbi__crea
$LN5@stbi__crea:
  000a4	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000a8	ff c8		 dec	 eax
  000aa	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@stbi__crea:
  000ae	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  000b3	0f 8c 91 00 00
	00		 jl	 $LN6@stbi__crea

; 4686 :             dest[i*4+3] = 255;

  000b9	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000bd	8d 04 85 03 00
	00 00		 lea	 eax, DWORD PTR [rax*4+3]
  000c4	48 98		 cdqe
  000c6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dest$[rsp]
  000cb	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 4687 :             dest[i*4+2] = src[i*3+2];

  000cf	6b 44 24 20 03	 imul	 eax, DWORD PTR i$[rsp], 3
  000d4	83 c0 02	 add	 eax, 2
  000d7	48 98		 cdqe
  000d9	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  000dd	8d 0c 8d 02 00
	00 00		 lea	 ecx, DWORD PTR [rcx*4+2]
  000e4	48 63 c9	 movsxd	 rcx, ecx
  000e7	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest$[rsp]
  000ec	4c 8b 44 24 48	 mov	 r8, QWORD PTR src$[rsp]
  000f1	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  000f6	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4688 :             dest[i*4+1] = src[i*3+1];

  000f9	6b 44 24 20 03	 imul	 eax, DWORD PTR i$[rsp], 3
  000fe	ff c0		 inc	 eax
  00100	48 98		 cdqe
  00102	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00106	8d 0c 8d 01 00
	00 00		 lea	 ecx, DWORD PTR [rcx*4+1]
  0010d	48 63 c9	 movsxd	 rcx, ecx
  00110	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest$[rsp]
  00115	4c 8b 44 24 48	 mov	 r8, QWORD PTR src$[rsp]
  0011a	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0011f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4689 :             dest[i*4+0] = src[i*3+0];

  00122	6b 44 24 20 03	 imul	 eax, DWORD PTR i$[rsp], 3
  00127	48 98		 cdqe
  00129	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0012d	c1 e1 02	 shl	 ecx, 2
  00130	48 63 c9	 movsxd	 rcx, ecx
  00133	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest$[rsp]
  00138	4c 8b 44 24 48	 mov	 r8, QWORD PTR src$[rsp]
  0013d	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00142	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4690 :         }

  00145	e9 5a ff ff ff	 jmp	 $LN5@stbi__crea
$LN6@stbi__crea:
$LN9@stbi__crea:

; 4691 :     }
; 4692 : }

  0014a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0014e	c3		 ret	 0
?stbi__create_png_alpha_expand8@@YAXPEAE0IH@Z ENDP	; stbi__create_png_alpha_expand8
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv68 = 0
tv70 = 4
tv72 = 8
lo$ = 12
thresh$ = 16
hi$ = 20
tv74 = 24
t0$ = 28
t1$ = 32
a$ = 64
b$ = 72
c$ = 80
?stbi__paeth@@YAHHHH@Z PROC				; stbi__paeth

; 4657 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4658 :     // This formulation looks very different from the reference in the PNG spec, but is
; 4659 :     // actually equivalent and has favorable data dependencies and admits straightforward
; 4660 :     // generation of branch-free code, which helps performance significantly.
; 4661 :     int thresh = c*3 - (a + b);

  00011	6b 44 24 50 03	 imul	 eax, DWORD PTR c$[rsp], 3
  00016	8b 4c 24 48	 mov	 ecx, DWORD PTR b$[rsp]
  0001a	8b 54 24 40	 mov	 edx, DWORD PTR a$[rsp]
  0001e	03 d1		 add	 edx, ecx
  00020	8b ca		 mov	 ecx, edx
  00022	2b c1		 sub	 eax, ecx
  00024	89 44 24 10	 mov	 DWORD PTR thresh$[rsp], eax

; 4662 :     int lo = a < b ? a : b;

  00028	8b 44 24 48	 mov	 eax, DWORD PTR b$[rsp]
  0002c	39 44 24 40	 cmp	 DWORD PTR a$[rsp], eax
  00030	7d 09		 jge	 SHORT $LN3@stbi__paet
  00032	8b 44 24 40	 mov	 eax, DWORD PTR a$[rsp]
  00036	89 04 24	 mov	 DWORD PTR tv68[rsp], eax
  00039	eb 07		 jmp	 SHORT $LN4@stbi__paet
$LN3@stbi__paet:
  0003b	8b 44 24 48	 mov	 eax, DWORD PTR b$[rsp]
  0003f	89 04 24	 mov	 DWORD PTR tv68[rsp], eax
$LN4@stbi__paet:
  00042	8b 04 24	 mov	 eax, DWORD PTR tv68[rsp]
  00045	89 44 24 0c	 mov	 DWORD PTR lo$[rsp], eax

; 4663 :     int hi = a < b ? b : a;

  00049	8b 44 24 48	 mov	 eax, DWORD PTR b$[rsp]
  0004d	39 44 24 40	 cmp	 DWORD PTR a$[rsp], eax
  00051	7d 0a		 jge	 SHORT $LN5@stbi__paet
  00053	8b 44 24 48	 mov	 eax, DWORD PTR b$[rsp]
  00057	89 44 24 04	 mov	 DWORD PTR tv70[rsp], eax
  0005b	eb 08		 jmp	 SHORT $LN6@stbi__paet
$LN5@stbi__paet:
  0005d	8b 44 24 40	 mov	 eax, DWORD PTR a$[rsp]
  00061	89 44 24 04	 mov	 DWORD PTR tv70[rsp], eax
$LN6@stbi__paet:
  00065	8b 44 24 04	 mov	 eax, DWORD PTR tv70[rsp]
  00069	89 44 24 14	 mov	 DWORD PTR hi$[rsp], eax

; 4664 :     int t0 = (hi <= thresh) ? lo : c;

  0006d	8b 44 24 10	 mov	 eax, DWORD PTR thresh$[rsp]
  00071	39 44 24 14	 cmp	 DWORD PTR hi$[rsp], eax
  00075	7f 0a		 jg	 SHORT $LN7@stbi__paet
  00077	8b 44 24 0c	 mov	 eax, DWORD PTR lo$[rsp]
  0007b	89 44 24 08	 mov	 DWORD PTR tv72[rsp], eax
  0007f	eb 08		 jmp	 SHORT $LN8@stbi__paet
$LN7@stbi__paet:
  00081	8b 44 24 50	 mov	 eax, DWORD PTR c$[rsp]
  00085	89 44 24 08	 mov	 DWORD PTR tv72[rsp], eax
$LN8@stbi__paet:
  00089	8b 44 24 08	 mov	 eax, DWORD PTR tv72[rsp]
  0008d	89 44 24 1c	 mov	 DWORD PTR t0$[rsp], eax

; 4665 :     int t1 = (thresh <= lo) ? hi : t0;

  00091	8b 44 24 0c	 mov	 eax, DWORD PTR lo$[rsp]
  00095	39 44 24 10	 cmp	 DWORD PTR thresh$[rsp], eax
  00099	7f 0a		 jg	 SHORT $LN9@stbi__paet
  0009b	8b 44 24 14	 mov	 eax, DWORD PTR hi$[rsp]
  0009f	89 44 24 18	 mov	 DWORD PTR tv74[rsp], eax
  000a3	eb 08		 jmp	 SHORT $LN10@stbi__paet
$LN9@stbi__paet:
  000a5	8b 44 24 1c	 mov	 eax, DWORD PTR t0$[rsp]
  000a9	89 44 24 18	 mov	 DWORD PTR tv74[rsp], eax
$LN10@stbi__paet:
  000ad	8b 44 24 18	 mov	 eax, DWORD PTR tv74[rsp]
  000b1	89 44 24 20	 mov	 DWORD PTR t1$[rsp], eax

; 4666 :     return t1;

  000b5	8b 44 24 20	 mov	 eax, DWORD PTR t1$[rsp]

; 4667 : }

  000b9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bd	c3		 ret	 0
?stbi__paeth@@YAHHHH@Z ENDP				; stbi__paeth
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
i$ = 32
s$ = 64
?stbi__check_png_header@@YAHPEAUstbi__context@@@Z PROC	; stbi__check_png_header

; 4621 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4622 :     static const stbi_uc png_sig[8] = { 137,80,78,71,13,10,26,10 };
; 4623 :     int i;
; 4624 :     for (i=0; i < 8; ++i)

  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00011	eb 0a		 jmp	 SHORT $LN4@stbi__chec
$LN2@stbi__chec:
  00013	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00017	ff c0		 inc	 eax
  00019	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__chec:
  0001d	83 7c 24 20 08	 cmp	 DWORD PTR i$[rsp], 8
  00022	7d 31		 jge	 SHORT $LN3@stbi__chec

; 4625 :         if (stbi__get8(s) != png_sig[i]) return stbi__err("bad png sig","Not a PNG");

  00024	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00029	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0002e	0f b6 c0	 movzx	 eax, al
  00031	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?png_sig@?1??stbi__check_png_header@@YAHPEAUstbi__context@@@Z@4QBEB
  0003d	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00041	3b c1		 cmp	 eax, ecx
  00043	74 0e		 je	 SHORT $LN5@stbi__chec
  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80098
  0004c	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00051	eb 07		 jmp	 SHORT $LN1@stbi__chec
$LN5@stbi__chec:
  00053	eb be		 jmp	 SHORT $LN2@stbi__chec
$LN3@stbi__chec:

; 4626 :     return 1;

  00055	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__chec:

; 4627 : }

  0005a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005e	c3		 ret	 0
?stbi__check_png_header@@YAHPEAUstbi__context@@@Z ENDP	; stbi__check_png_header
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
c$ = 32
s$ = 64
?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z PROC ; stbi__get_chunk_header

; 4613 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4614 :     stbi__pngchunk c;
; 4615 :     c.length = stbi__get32be(s);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
  00013	89 44 24 20	 mov	 DWORD PTR c$[rsp], eax

; 4616 :     c.type   = stbi__get32be(s);

  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001c	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
  00021	89 44 24 24	 mov	 DWORD PTR c$[rsp+4], eax

; 4617 :     return c;

  00025	48 8b 44 24 20	 mov	 rax, QWORD PTR c$[rsp]

; 4618 : }

  0002a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002e	c3		 ret	 0
?stbi__get_chunk_header@@YA?AUstbi__pngchunk@@PEAUstbi__context@@@Z ENDP ; stbi__get_chunk_header
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
a$ = 48
obuf$ = 56
olen$ = 64
exp$ = 72
parse_header$ = 80
?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z PROC	; stbi__do_zlib

; 4510 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4511 :     a->zout_start = obuf;

  00018	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0001d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR obuf$[rsp]
  00022	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 4512 :     a->zout       = obuf;

  00026	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  0002b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR obuf$[rsp]
  00030	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 4513 :     a->zout_end   = obuf + olen;

  00034	48 63 44 24 40	 movsxd	 rax, DWORD PTR olen$[rsp]
  00039	48 8b 4c 24 38	 mov	 rcx, QWORD PTR obuf$[rsp]
  0003e	48 03 c8	 add	 rcx, rax
  00041	48 8b c1	 mov	 rax, rcx
  00044	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a$[rsp]
  00049	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 4514 :     a->z_expandable = exp;

  0004d	48 8b 44 24 30	 mov	 rax, QWORD PTR a$[rsp]
  00052	8b 4c 24 48	 mov	 ecx, DWORD PTR exp$[rsp]
  00056	89 48 38	 mov	 DWORD PTR [rax+56], ecx

; 4515 :     
; 4516 :     return stbi__parse_zlib(a, parse_header);

  00059	8b 54 24 50	 mov	 edx, DWORD PTR parse_header$[rsp]
  0005d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a$[rsp]
  00062	e8 00 00 00 00	 call	 ?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z ; stbi__parse_zlib

; 4517 : }

  00067	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006b	c3		 ret	 0
?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z ENDP	; stbi__do_zlib
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
type$ = 32
final$ = 36
a$ = 64
parse_header$ = 72
?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z PROC		; stbi__parse_zlib

; 4481 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4482 :     int final, type;
; 4483 :     if (parse_header)

  0000d	83 7c 24 48 00	 cmp	 DWORD PTR parse_header$[rsp], 0
  00012	74 15		 je	 SHORT $LN5@stbi__pars

; 4484 :         if (!stbi__parse_zlib_header(a)) return 0;

  00014	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  00019	e8 00 00 00 00	 call	 ?stbi__parse_zlib_header@@YAHPEAUstbi__zbuf@@@Z ; stbi__parse_zlib_header
  0001e	85 c0		 test	 eax, eax
  00020	75 07		 jne	 SHORT $LN6@stbi__pars
  00022	33 c0		 xor	 eax, eax
  00024	e9 06 01 00 00	 jmp	 $LN1@stbi__pars
$LN6@stbi__pars:
$LN5@stbi__pars:

; 4485 :     a->num_bits = 0;

  00029	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  0002e	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 4486 :     a->code_buffer = 0;

  00035	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  0003a	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 4487 :     a->hit_zeof_once = 0;

  00041	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  00046	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0
$LN4@stbi__pars:

; 4488 :     do {
; 4489 :         final = stbi__zreceive(a,1);

  0004d	ba 01 00 00 00	 mov	 edx, 1
  00052	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  00057	e8 00 00 00 00	 call	 ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z ; stbi__zreceive
  0005c	89 44 24 24	 mov	 DWORD PTR final$[rsp], eax

; 4490 :         type = stbi__zreceive(a,2);

  00060	ba 02 00 00 00	 mov	 edx, 2
  00065	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  0006a	e8 00 00 00 00	 call	 ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z ; stbi__zreceive
  0006f	89 44 24 20	 mov	 DWORD PTR type$[rsp], eax

; 4491 :         if (type == 0) {

  00073	83 7c 24 20 00	 cmp	 DWORD PTR type$[rsp], 0
  00078	75 1a		 jne	 SHORT $LN7@stbi__pars

; 4492 :             if (!stbi__parse_uncompressed_block(a)) return 0;

  0007a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  0007f	e8 00 00 00 00	 call	 ?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z ; stbi__parse_uncompressed_block
  00084	85 c0		 test	 eax, eax
  00086	75 07		 jne	 SHORT $LN9@stbi__pars
  00088	33 c0		 xor	 eax, eax
  0008a	e9 a0 00 00 00	 jmp	 $LN1@stbi__pars
$LN9@stbi__pars:
  0008f	e9 8b 00 00 00	 jmp	 $LN8@stbi__pars
$LN7@stbi__pars:

; 4493 :         } else if (type == 3) {

  00094	83 7c 24 20 03	 cmp	 DWORD PTR type$[rsp], 3
  00099	75 09		 jne	 SHORT $LN10@stbi__pars

; 4494 :             return 0;

  0009b	33 c0		 xor	 eax, eax
  0009d	e9 8d 00 00 00	 jmp	 $LN1@stbi__pars

; 4495 :         } else {

  000a2	eb 7b		 jmp	 SHORT $LN11@stbi__pars
$LN10@stbi__pars:

; 4496 :             if (type == 1) {

  000a4	83 7c 24 20 01	 cmp	 DWORD PTR type$[rsp], 1
  000a9	75 50		 jne	 SHORT $LN12@stbi__pars

; 4497 :                 // use fixed code lengths
; 4498 :                 if (!stbi__zbuild_huffman(&a->z_length  , stbi__zdefault_length  , STBI__ZNSYMS)) return 0;

  000ab	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  000b0	48 83 c0 3c	 add	 rax, 60			; 0000003cH
  000b4	41 b8 20 01 00
	00		 mov	 r8d, 288		; 00000120H
  000ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?stbi__zdefault_length@@3QBEB
  000c1	48 8b c8	 mov	 rcx, rax
  000c4	e8 00 00 00 00	 call	 ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z ; stbi__zbuild_huffman
  000c9	85 c0		 test	 eax, eax
  000cb	75 04		 jne	 SHORT $LN14@stbi__pars
  000cd	33 c0		 xor	 eax, eax
  000cf	eb 5e		 jmp	 SHORT $LN1@stbi__pars
$LN14@stbi__pars:

; 4499 :                 if (!stbi__zbuild_huffman(&a->z_distance, stbi__zdefault_distance,  32)) return 0;

  000d1	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  000d6	48 05 20 08 00
	00		 add	 rax, 2080		; 00000820H
  000dc	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  000e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?stbi__zdefault_distance@@3QBEB
  000e9	48 8b c8	 mov	 rcx, rax
  000ec	e8 00 00 00 00	 call	 ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z ; stbi__zbuild_huffman
  000f1	85 c0		 test	 eax, eax
  000f3	75 04		 jne	 SHORT $LN15@stbi__pars
  000f5	33 c0		 xor	 eax, eax
  000f7	eb 36		 jmp	 SHORT $LN1@stbi__pars
$LN15@stbi__pars:

; 4500 :             } else {

  000f9	eb 12		 jmp	 SHORT $LN13@stbi__pars
$LN12@stbi__pars:

; 4501 :                 if (!stbi__compute_huffman_codes(a)) return 0;

  000fb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  00100	e8 00 00 00 00	 call	 ?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z ; stbi__compute_huffman_codes
  00105	85 c0		 test	 eax, eax
  00107	75 04		 jne	 SHORT $LN16@stbi__pars
  00109	33 c0		 xor	 eax, eax
  0010b	eb 22		 jmp	 SHORT $LN1@stbi__pars
$LN16@stbi__pars:
$LN13@stbi__pars:

; 4502 :             }
; 4503 :             if (!stbi__parse_huffman_block(a)) return 0;

  0010d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  00112	e8 00 00 00 00	 call	 ?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z ; stbi__parse_huffman_block
  00117	85 c0		 test	 eax, eax
  00119	75 04		 jne	 SHORT $LN17@stbi__pars
  0011b	33 c0		 xor	 eax, eax
  0011d	eb 10		 jmp	 SHORT $LN1@stbi__pars
$LN17@stbi__pars:
$LN11@stbi__pars:
$LN8@stbi__pars:

; 4504 :         }
; 4505 :     } while (!final);

  0011f	83 7c 24 24 00	 cmp	 DWORD PTR final$[rsp], 0
  00124	0f 84 23 ff ff
	ff		 je	 $LN4@stbi__pars

; 4506 :     return 1;

  0012a	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__pars:

; 4507 : }

  0012f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00133	c3		 ret	 0
?stbi__parse_zlib@@YAHPEAUstbi__zbuf@@H@Z ENDP		; stbi__parse_zlib
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
cmf$ = 32
flg$ = 36
cm$ = 40
a$ = 64
?stbi__parse_zlib_header@@YAHPEAUstbi__zbuf@@@Z PROC	; stbi__parse_zlib_header

; 4438 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4439 :     int cmf   = stbi__zget8(a);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z ; stbi__zget8
  00013	0f b6 c0	 movzx	 eax, al
  00016	89 44 24 20	 mov	 DWORD PTR cmf$[rsp], eax

; 4440 :     int cm    = cmf & 15;

  0001a	8b 44 24 20	 mov	 eax, DWORD PTR cmf$[rsp]
  0001e	83 e0 0f	 and	 eax, 15
  00021	89 44 24 28	 mov	 DWORD PTR cm$[rsp], eax

; 4441 :     /* int cinfo = cmf >> 4; */
; 4442 :     int flg   = stbi__zget8(a);

  00025	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  0002a	e8 00 00 00 00	 call	 ?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z ; stbi__zget8
  0002f	0f b6 c0	 movzx	 eax, al
  00032	89 44 24 24	 mov	 DWORD PTR flg$[rsp], eax

; 4443 :     if (stbi__zeof(a)) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec

  00036	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  0003b	e8 00 00 00 00	 call	 ?stbi__zeof@@YAHPEAUstbi__zbuf@@@Z ; stbi__zeof
  00040	85 c0		 test	 eax, eax
  00042	74 0e		 je	 SHORT $LN2@stbi__pars
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79955
  0004b	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00050	eb 5b		 jmp	 SHORT $LN1@stbi__pars
$LN2@stbi__pars:

; 4444 :     if ((cmf*256+flg) % 31 != 0) return stbi__err("bad zlib header","Corrupt PNG"); // zlib spec

  00052	69 44 24 20 00
	01 00 00	 imul	 eax, DWORD PTR cmf$[rsp], 256 ; 00000100H
  0005a	03 44 24 24	 add	 eax, DWORD PTR flg$[rsp]
  0005e	99		 cdq
  0005f	b9 1f 00 00 00	 mov	 ecx, 31
  00064	f7 f9		 idiv	 ecx
  00066	8b c2		 mov	 eax, edx
  00068	85 c0		 test	 eax, eax
  0006a	74 0e		 je	 SHORT $LN3@stbi__pars
  0006c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79957
  00073	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00078	eb 33		 jmp	 SHORT $LN1@stbi__pars
$LN3@stbi__pars:

; 4445 :     if (flg & 32) return stbi__err("no preset dict","Corrupt PNG"); // preset dictionary not allowed in png

  0007a	8b 44 24 24	 mov	 eax, DWORD PTR flg$[rsp]
  0007e	83 e0 20	 and	 eax, 32			; 00000020H
  00081	85 c0		 test	 eax, eax
  00083	74 0e		 je	 SHORT $LN4@stbi__pars
  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79959
  0008c	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00091	eb 1a		 jmp	 SHORT $LN1@stbi__pars
$LN4@stbi__pars:

; 4446 :     if (cm != 8) return stbi__err("bad compression","Corrupt PNG"); // DEFLATE required for png

  00093	83 7c 24 28 08	 cmp	 DWORD PTR cm$[rsp], 8
  00098	74 0e		 je	 SHORT $LN5@stbi__pars
  0009a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79961
  000a1	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000a6	eb 05		 jmp	 SHORT $LN1@stbi__pars
$LN5@stbi__pars:

; 4447 :     // window = 1 << (8 + cinfo)... but who cares, we fully buffer output
; 4448 :     return 1;

  000a8	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__pars:

; 4449 : }

  000ad	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b1	c3		 ret	 0
?stbi__parse_zlib_header@@YAHPEAUstbi__zbuf@@@Z ENDP	; stbi__parse_zlib_header
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
k$ = 32
len$ = 36
header$ = 40
nlen$ = 44
a$ = 64
?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z PROC ; stbi__parse_uncompressed_block

; 4409 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4410 :     stbi_uc header[4];
; 4411 :     int len,nlen,k;
; 4412 :     if (a->num_bits & 7)

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  0000e	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00011	83 e0 07	 and	 eax, 7
  00014	85 c0		 test	 eax, eax
  00016	74 17		 je	 SHORT $LN6@stbi__pars

; 4413 :         stbi__zreceive(a, a->num_bits & 7); // discard

  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  0001d	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00020	83 e0 07	 and	 eax, 7
  00023	8b d0		 mov	 edx, eax
  00025	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  0002a	e8 00 00 00 00	 call	 ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z ; stbi__zreceive
$LN6@stbi__pars:

; 4414 :     // drain the bit-packed data into header
; 4415 :     k = 0;

  0002f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
$LN2@stbi__pars:

; 4416 :     while (a->num_bits > 0) {

  00037	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  0003c	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  00040	7e 48		 jle	 SHORT $LN3@stbi__pars

; 4417 :         header[k++] = (stbi_uc) (a->code_buffer & 255); // suppress MSVC run-time check

  00042	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  00047	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0004a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0004f	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  00054	88 44 0c 28	 mov	 BYTE PTR header$[rsp+rcx], al
  00058	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  0005c	ff c0		 inc	 eax
  0005e	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 4418 :         a->code_buffer >>= 8;

  00062	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  00067	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0006a	c1 e8 08	 shr	 eax, 8
  0006d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  00072	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 4419 :         a->num_bits -= 8;

  00075	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  0007a	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0007d	83 e8 08	 sub	 eax, 8
  00080	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  00085	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4420 :     }

  00088	eb ad		 jmp	 SHORT $LN2@stbi__pars
$LN3@stbi__pars:

; 4421 :     if (a->num_bits < 0) return stbi__err("zlib corrupt","Corrupt PNG");

  0008a	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  0008f	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  00093	7d 11		 jge	 SHORT $LN7@stbi__pars
  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79941
  0009c	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000a1	e9 47 01 00 00	 jmp	 $LN1@stbi__pars
$LN7@stbi__pars:
$LN4@stbi__pars:

; 4422 :     // now fill header the normal way
; 4423 :     while (k < 4)

  000a6	83 7c 24 20 04	 cmp	 DWORD PTR k$[rsp], 4
  000ab	7d 1f		 jge	 SHORT $LN5@stbi__pars

; 4424 :         header[k++] = stbi__zget8(a);

  000ad	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  000b2	e8 00 00 00 00	 call	 ?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z ; stbi__zget8
  000b7	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  000bc	88 44 0c 28	 mov	 BYTE PTR header$[rsp+rcx], al
  000c0	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  000c4	ff c0		 inc	 eax
  000c6	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
  000ca	eb da		 jmp	 SHORT $LN4@stbi__pars
$LN5@stbi__pars:

; 4425 :     len  = header[1] * 256 + header[0];

  000cc	b8 01 00 00 00	 mov	 eax, 1
  000d1	48 6b c0 01	 imul	 rax, rax, 1
  000d5	0f b6 44 04 28	 movzx	 eax, BYTE PTR header$[rsp+rax]
  000da	69 c0 00 01 00
	00		 imul	 eax, eax, 256		; 00000100H
  000e0	b9 01 00 00 00	 mov	 ecx, 1
  000e5	48 6b c9 00	 imul	 rcx, rcx, 0
  000e9	0f b6 4c 0c 28	 movzx	 ecx, BYTE PTR header$[rsp+rcx]
  000ee	03 c1		 add	 eax, ecx
  000f0	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax

; 4426 :     nlen = header[3] * 256 + header[2];

  000f4	b8 01 00 00 00	 mov	 eax, 1
  000f9	48 6b c0 03	 imul	 rax, rax, 3
  000fd	0f b6 44 04 28	 movzx	 eax, BYTE PTR header$[rsp+rax]
  00102	69 c0 00 01 00
	00		 imul	 eax, eax, 256		; 00000100H
  00108	b9 01 00 00 00	 mov	 ecx, 1
  0010d	48 6b c9 02	 imul	 rcx, rcx, 2
  00111	0f b6 4c 0c 28	 movzx	 ecx, BYTE PTR header$[rsp+rcx]
  00116	03 c1		 add	 eax, ecx
  00118	89 44 24 2c	 mov	 DWORD PTR nlen$[rsp], eax

; 4427 :     if (nlen != (len ^ 0xffff)) return stbi__err("zlib corrupt","Corrupt PNG");

  0011c	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  00120	35 ff ff 00 00	 xor	 eax, 65535		; 0000ffffH
  00125	39 44 24 2c	 cmp	 DWORD PTR nlen$[rsp], eax
  00129	74 11		 je	 SHORT $LN8@stbi__pars
  0012b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79943
  00132	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00137	e9 b1 00 00 00	 jmp	 $LN1@stbi__pars
$LN8@stbi__pars:

; 4428 :     if (a->zbuffer + len > a->zbuffer_end) return stbi__err("read past buffer","Corrupt PNG");

  0013c	48 63 44 24 24	 movsxd	 rax, DWORD PTR len$[rsp]
  00141	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  00146	48 03 01	 add	 rax, QWORD PTR [rcx]
  00149	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  0014e	48 3b 41 08	 cmp	 rax, QWORD PTR [rcx+8]
  00152	76 11		 jbe	 SHORT $LN9@stbi__pars
  00154	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79945
  0015b	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00160	e9 88 00 00 00	 jmp	 $LN1@stbi__pars
$LN9@stbi__pars:

; 4429 :     if (a->zout + len > a->zout_end)

  00165	48 63 44 24 24	 movsxd	 rax, DWORD PTR len$[rsp]
  0016a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  0016f	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  00173	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  00178	48 3b 41 30	 cmp	 rax, QWORD PTR [rcx+48]
  0017c	76 20		 jbe	 SHORT $LN10@stbi__pars

; 4430 :         if (!stbi__zexpand(a, a->zout, len)) return 0;

  0017e	44 8b 44 24 24	 mov	 r8d, DWORD PTR len$[rsp]
  00183	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  00188	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  0018c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  00191	e8 00 00 00 00	 call	 ?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z ; stbi__zexpand
  00196	85 c0		 test	 eax, eax
  00198	75 04		 jne	 SHORT $LN11@stbi__pars
  0019a	33 c0		 xor	 eax, eax
  0019c	eb 4f		 jmp	 SHORT $LN1@stbi__pars
$LN11@stbi__pars:
$LN10@stbi__pars:

; 4431 :     memcpy(a->zout, a->zbuffer, len);

  0019e	48 63 44 24 24	 movsxd	 rax, DWORD PTR len$[rsp]
  001a3	4c 8b c0	 mov	 r8, rax
  001a6	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  001ab	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  001ae	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  001b3	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  001b7	e8 00 00 00 00	 call	 memcpy

; 4432 :     a->zbuffer += len;

  001bc	48 63 44 24 24	 movsxd	 rax, DWORD PTR len$[rsp]
  001c1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  001c6	48 03 01	 add	 rax, QWORD PTR [rcx]
  001c9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  001ce	48 89 01	 mov	 QWORD PTR [rcx], rax

; 4433 :     a->zout += len;

  001d1	48 63 44 24 24	 movsxd	 rax, DWORD PTR len$[rsp]
  001d6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  001db	48 03 41 20	 add	 rax, QWORD PTR [rcx+32]
  001df	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  001e4	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 4434 :     return 1;

  001e8	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__pars:

; 4435 : }

  001ed	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001f1	c3		 ret	 0
?stbi__parse_uncompressed_block@@YAHPEAUstbi__zbuf@@@Z ENDP ; stbi__parse_uncompressed_block
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
c$1 = 32
fill$2 = 36
n$ = 40
i$ = 44
ntot$ = 48
hlit$ = 52
hdist$ = 56
hclen$ = 60
s$3 = 64
tv175 = 72
z_codelength$ = 80
codelength_sizes$ = 2112
lencodes$ = 2144
__$ArrayPad$ = 2608
a$ = 2640
?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z PROC ; stbi__compute_huffman_codes

; 4359 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 48 0a
	00 00		 sub	 rsp, 2632		; 00000a48H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 30
	0a 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4360 :     static const stbi_uc length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
; 4361 :     stbi__zhuffman z_codelength;
; 4362 :     stbi_uc lencodes[286+32+137];//padding for maximum single op
; 4363 :     stbi_uc codelength_sizes[19];
; 4364 :     int i,n;
; 4365 :     
; 4366 :     int hlit  = stbi__zreceive(a,5) + 257;

  0001e	ba 05 00 00 00	 mov	 edx, 5
  00023	48 8b 8c 24 50
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0002b	e8 00 00 00 00	 call	 ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z ; stbi__zreceive
  00030	05 01 01 00 00	 add	 eax, 257		; 00000101H
  00035	89 44 24 34	 mov	 DWORD PTR hlit$[rsp], eax

; 4367 :     int hdist = stbi__zreceive(a,5) + 1;

  00039	ba 05 00 00 00	 mov	 edx, 5
  0003e	48 8b 8c 24 50
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00046	e8 00 00 00 00	 call	 ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z ; stbi__zreceive
  0004b	ff c0		 inc	 eax
  0004d	89 44 24 38	 mov	 DWORD PTR hdist$[rsp], eax

; 4368 :     int hclen = stbi__zreceive(a,4) + 4;

  00051	ba 04 00 00 00	 mov	 edx, 4
  00056	48 8b 8c 24 50
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0005e	e8 00 00 00 00	 call	 ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z ; stbi__zreceive
  00063	83 c0 04	 add	 eax, 4
  00066	89 44 24 3c	 mov	 DWORD PTR hclen$[rsp], eax

; 4369 :     int ntot  = hlit + hdist;

  0006a	8b 44 24 38	 mov	 eax, DWORD PTR hdist$[rsp]
  0006e	8b 4c 24 34	 mov	 ecx, DWORD PTR hlit$[rsp]
  00072	03 c8		 add	 ecx, eax
  00074	8b c1		 mov	 eax, ecx
  00076	89 44 24 30	 mov	 DWORD PTR ntot$[rsp], eax

; 4370 :     
; 4371 :     memset(codelength_sizes, 0, sizeof(codelength_sizes));

  0007a	41 b8 13 00 00
	00		 mov	 r8d, 19
  00080	33 d2		 xor	 edx, edx
  00082	48 8d 8c 24 40
	08 00 00	 lea	 rcx, QWORD PTR codelength_sizes$[rsp]
  0008a	e8 00 00 00 00	 call	 memset

; 4372 :     for (i=0; i < hclen; ++i) {

  0008f	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00097	eb 0a		 jmp	 SHORT $LN4@stbi__comp
$LN2@stbi__comp:
  00099	8b 44 24 2c	 mov	 eax, DWORD PTR i$[rsp]
  0009d	ff c0		 inc	 eax
  0009f	89 44 24 2c	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__comp:
  000a3	8b 44 24 3c	 mov	 eax, DWORD PTR hclen$[rsp]
  000a7	39 44 24 2c	 cmp	 DWORD PTR i$[rsp], eax
  000ab	7d 34		 jge	 SHORT $LN3@stbi__comp

; 4373 :         int s = stbi__zreceive(a,3);

  000ad	ba 03 00 00 00	 mov	 edx, 3
  000b2	48 8b 8c 24 50
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  000ba	e8 00 00 00 00	 call	 ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z ; stbi__zreceive
  000bf	89 44 24 40	 mov	 DWORD PTR s$3[rsp], eax

; 4374 :         codelength_sizes[length_dezigzag[i]] = (stbi_uc) s;

  000c3	48 63 44 24 2c	 movsxd	 rax, DWORD PTR i$[rsp]
  000c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?length_dezigzag@?1??stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z@4QBEB
  000cf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000d3	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR s$3[rsp]
  000d8	88 8c 04 40 08
	00 00		 mov	 BYTE PTR codelength_sizes$[rsp+rax], cl

; 4375 :     }

  000df	eb b8		 jmp	 SHORT $LN2@stbi__comp
$LN3@stbi__comp:

; 4376 :     if (!stbi__zbuild_huffman(&z_codelength, codelength_sizes, 19)) return 0;

  000e1	41 b8 13 00 00
	00		 mov	 r8d, 19
  000e7	48 8d 94 24 40
	08 00 00	 lea	 rdx, QWORD PTR codelength_sizes$[rsp]
  000ef	48 8d 4c 24 50	 lea	 rcx, QWORD PTR z_codelength$[rsp]
  000f4	e8 00 00 00 00	 call	 ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z ; stbi__zbuild_huffman
  000f9	85 c0		 test	 eax, eax
  000fb	75 07		 jne	 SHORT $LN7@stbi__comp
  000fd	33 c0		 xor	 eax, eax
  000ff	e9 f7 01 00 00	 jmp	 $LN1@stbi__comp
$LN7@stbi__comp:

; 4377 :     
; 4378 :     n = 0;

  00104	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
$LN5@stbi__comp:

; 4379 :     while (n < ntot) {

  0010c	8b 44 24 30	 mov	 eax, DWORD PTR ntot$[rsp]
  00110	39 44 24 28	 cmp	 DWORD PTR n$[rsp], eax
  00114	0f 8d 6a 01 00
	00		 jge	 $LN6@stbi__comp

; 4380 :         int c = stbi__zhuffman_decode(a, &z_codelength);

  0011a	48 8d 54 24 50	 lea	 rdx, QWORD PTR z_codelength$[rsp]
  0011f	48 8b 8c 24 50
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  00127	e8 00 00 00 00	 call	 ?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z ; stbi__zhuffman_decode
  0012c	89 44 24 20	 mov	 DWORD PTR c$1[rsp], eax

; 4381 :         if (c < 0 || c >= 19) return stbi__err("bad codelengths", "Corrupt PNG");

  00130	83 7c 24 20 00	 cmp	 DWORD PTR c$1[rsp], 0
  00135	7c 07		 jl	 SHORT $LN9@stbi__comp
  00137	83 7c 24 20 13	 cmp	 DWORD PTR c$1[rsp], 19
  0013c	7c 11		 jl	 SHORT $LN8@stbi__comp
$LN9@stbi__comp:
  0013e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79909
  00145	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0014a	e9 ac 01 00 00	 jmp	 $LN1@stbi__comp
$LN8@stbi__comp:

; 4382 :         if (c < 16)

  0014f	83 7c 24 20 10	 cmp	 DWORD PTR c$1[rsp], 16
  00154	7d 20		 jge	 SHORT $LN10@stbi__comp

; 4383 :             lencodes[n++] = (stbi_uc) c;

  00156	48 63 44 24 28	 movsxd	 rax, DWORD PTR n$[rsp]
  0015b	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR c$1[rsp]
  00160	88 8c 04 60 08
	00 00		 mov	 BYTE PTR lencodes$[rsp+rax], cl
  00167	8b 44 24 28	 mov	 eax, DWORD PTR n$[rsp]
  0016b	ff c0		 inc	 eax
  0016d	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax
  00171	e9 09 01 00 00	 jmp	 $LN11@stbi__comp
$LN10@stbi__comp:

; 4384 :         else {
; 4385 :             stbi_uc fill = 0;

  00176	c6 44 24 24 00	 mov	 BYTE PTR fill$2[rsp], 0

; 4386 :             if (c == 16) {

  0017b	83 7c 24 20 10	 cmp	 DWORD PTR c$1[rsp], 16
  00180	75 47		 jne	 SHORT $LN12@stbi__comp

; 4387 :                 c = stbi__zreceive(a,2)+3;

  00182	ba 02 00 00 00	 mov	 edx, 2
  00187	48 8b 8c 24 50
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  0018f	e8 00 00 00 00	 call	 ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z ; stbi__zreceive
  00194	83 c0 03	 add	 eax, 3
  00197	89 44 24 20	 mov	 DWORD PTR c$1[rsp], eax

; 4388 :                 if (n == 0) return stbi__err("bad codelengths", "Corrupt PNG");

  0019b	83 7c 24 28 00	 cmp	 DWORD PTR n$[rsp], 0
  001a0	75 11		 jne	 SHORT $LN14@stbi__comp
  001a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79915
  001a9	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  001ae	e9 48 01 00 00	 jmp	 $LN1@stbi__comp
$LN14@stbi__comp:

; 4389 :                 fill = lencodes[n-1];

  001b3	8b 44 24 28	 mov	 eax, DWORD PTR n$[rsp]
  001b7	ff c8		 dec	 eax
  001b9	48 98		 cdqe
  001bb	0f b6 84 04 60
	08 00 00	 movzx	 eax, BYTE PTR lencodes$[rsp+rax]
  001c3	88 44 24 24	 mov	 BYTE PTR fill$2[rsp], al
  001c7	eb 55		 jmp	 SHORT $LN13@stbi__comp
$LN12@stbi__comp:

; 4390 :             } else if (c == 17) {

  001c9	83 7c 24 20 11	 cmp	 DWORD PTR c$1[rsp], 17
  001ce	75 1b		 jne	 SHORT $LN15@stbi__comp

; 4391 :                 c = stbi__zreceive(a,3)+3;

  001d0	ba 03 00 00 00	 mov	 edx, 3
  001d5	48 8b 8c 24 50
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  001dd	e8 00 00 00 00	 call	 ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z ; stbi__zreceive
  001e2	83 c0 03	 add	 eax, 3
  001e5	89 44 24 20	 mov	 DWORD PTR c$1[rsp], eax
  001e9	eb 33		 jmp	 SHORT $LN16@stbi__comp
$LN15@stbi__comp:

; 4392 :             } else if (c == 18) {

  001eb	83 7c 24 20 12	 cmp	 DWORD PTR c$1[rsp], 18
  001f0	75 1b		 jne	 SHORT $LN17@stbi__comp

; 4393 :                 c = stbi__zreceive(a,7)+11;

  001f2	ba 07 00 00 00	 mov	 edx, 7
  001f7	48 8b 8c 24 50
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  001ff	e8 00 00 00 00	 call	 ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z ; stbi__zreceive
  00204	83 c0 0b	 add	 eax, 11
  00207	89 44 24 20	 mov	 DWORD PTR c$1[rsp], eax

; 4394 :             } else {

  0020b	eb 11		 jmp	 SHORT $LN18@stbi__comp
$LN17@stbi__comp:

; 4395 :                 return stbi__err("bad codelengths", "Corrupt PNG");

  0020d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79920
  00214	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00219	e9 dd 00 00 00	 jmp	 $LN1@stbi__comp
$LN18@stbi__comp:
$LN16@stbi__comp:
$LN13@stbi__comp:

; 4396 :             }
; 4397 :             if (ntot - n < c) return stbi__err("bad codelengths", "Corrupt PNG");

  0021e	8b 44 24 28	 mov	 eax, DWORD PTR n$[rsp]
  00222	8b 4c 24 30	 mov	 ecx, DWORD PTR ntot$[rsp]
  00226	2b c8		 sub	 ecx, eax
  00228	8b c1		 mov	 eax, ecx
  0022a	3b 44 24 20	 cmp	 eax, DWORD PTR c$1[rsp]
  0022e	7d 11		 jge	 SHORT $LN19@stbi__comp
  00230	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79922
  00237	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0023c	e9 ba 00 00 00	 jmp	 $LN1@stbi__comp
$LN19@stbi__comp:

; 4398 :             memset(lencodes+n, fill, c);

  00241	48 63 44 24 20	 movsxd	 rax, DWORD PTR c$1[rsp]
  00246	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR fill$2[rsp]
  0024b	48 63 54 24 28	 movsxd	 rdx, DWORD PTR n$[rsp]
  00250	48 8d 94 14 60
	08 00 00	 lea	 rdx, QWORD PTR lencodes$[rsp+rdx]
  00258	48 89 54 24 48	 mov	 QWORD PTR tv175[rsp], rdx
  0025d	4c 8b c0	 mov	 r8, rax
  00260	8b d1		 mov	 edx, ecx
  00262	48 8b 44 24 48	 mov	 rax, QWORD PTR tv175[rsp]
  00267	48 8b c8	 mov	 rcx, rax
  0026a	e8 00 00 00 00	 call	 memset

; 4399 :             n += c;

  0026f	8b 44 24 20	 mov	 eax, DWORD PTR c$1[rsp]
  00273	8b 4c 24 28	 mov	 ecx, DWORD PTR n$[rsp]
  00277	03 c8		 add	 ecx, eax
  00279	8b c1		 mov	 eax, ecx
  0027b	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax
$LN11@stbi__comp:

; 4400 :         }
; 4401 :     }

  0027f	e9 88 fe ff ff	 jmp	 $LN5@stbi__comp
$LN6@stbi__comp:

; 4402 :     if (n != ntot) return stbi__err("bad codelengths","Corrupt PNG");

  00284	8b 44 24 30	 mov	 eax, DWORD PTR ntot$[rsp]
  00288	39 44 24 28	 cmp	 DWORD PTR n$[rsp], eax
  0028c	74 0e		 je	 SHORT $LN20@stbi__comp
  0028e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79924
  00295	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0029a	eb 5f		 jmp	 SHORT $LN1@stbi__comp
$LN20@stbi__comp:

; 4403 :     if (!stbi__zbuild_huffman(&a->z_length, lencodes, hlit)) return 0;

  0029c	48 8b 84 24 50
	0a 00 00	 mov	 rax, QWORD PTR a$[rsp]
  002a4	48 83 c0 3c	 add	 rax, 60			; 0000003cH
  002a8	44 8b 44 24 34	 mov	 r8d, DWORD PTR hlit$[rsp]
  002ad	48 8d 94 24 60
	08 00 00	 lea	 rdx, QWORD PTR lencodes$[rsp]
  002b5	48 8b c8	 mov	 rcx, rax
  002b8	e8 00 00 00 00	 call	 ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z ; stbi__zbuild_huffman
  002bd	85 c0		 test	 eax, eax
  002bf	75 04		 jne	 SHORT $LN21@stbi__comp
  002c1	33 c0		 xor	 eax, eax
  002c3	eb 36		 jmp	 SHORT $LN1@stbi__comp
$LN21@stbi__comp:

; 4404 :     if (!stbi__zbuild_huffman(&a->z_distance, lencodes+hlit, hdist)) return 0;

  002c5	48 63 44 24 34	 movsxd	 rax, DWORD PTR hlit$[rsp]
  002ca	48 8d 84 04 60
	08 00 00	 lea	 rax, QWORD PTR lencodes$[rsp+rax]
  002d2	48 8b 8c 24 50
	0a 00 00	 mov	 rcx, QWORD PTR a$[rsp]
  002da	48 81 c1 20 08
	00 00		 add	 rcx, 2080		; 00000820H
  002e1	44 8b 44 24 38	 mov	 r8d, DWORD PTR hdist$[rsp]
  002e6	48 8b d0	 mov	 rdx, rax
  002e9	e8 00 00 00 00	 call	 ?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z ; stbi__zbuild_huffman
  002ee	85 c0		 test	 eax, eax
  002f0	75 04		 jne	 SHORT $LN22@stbi__comp
  002f2	33 c0		 xor	 eax, eax
  002f4	eb 05		 jmp	 SHORT $LN1@stbi__comp
$LN22@stbi__comp:

; 4405 :     return 1;

  002f6	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__comp:

; 4406 : }

  002fb	48 8b 8c 24 30
	0a 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00303	48 33 cc	 xor	 rcx, rsp
  00306	e8 00 00 00 00	 call	 __security_check_cookie
  0030b	48 81 c4 48 0a
	00 00		 add	 rsp, 2632		; 00000a48H
  00312	c3		 ret	 0
?stbi__compute_huffman_codes@@YAHPEAUstbi__zbuf@@@Z ENDP ; stbi__compute_huffman_codes
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
v$1 = 32
z$2 = 36
len$3 = 40
dist$4 = 44
zout$ = 48
p$5 = 56
a$ = 80
?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z PROC	; stbi__parse_huffman_block

; 4309 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4310 :     char *zout = a->zout;

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  0000e	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00012	48 89 44 24 30	 mov	 QWORD PTR zout$[rsp], rax
$LN2@stbi__pars:

; 4311 :     for(;;) {
; 4312 :         int z = stbi__zhuffman_decode(a, &a->z_length);

  00017	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  0001c	48 83 c0 3c	 add	 rax, 60			; 0000003cH
  00020	48 8b d0	 mov	 rdx, rax
  00023	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  00028	e8 00 00 00 00	 call	 ?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z ; stbi__zhuffman_decode
  0002d	89 44 24 24	 mov	 DWORD PTR z$2[rsp], eax

; 4313 :         if (z < 256) {

  00031	81 7c 24 24 00
	01 00 00	 cmp	 DWORD PTR z$2[rsp], 256	; 00000100H
  00039	7d 74		 jge	 SHORT $LN11@stbi__pars

; 4314 :             if (z < 0) return stbi__err("bad huffman code","Corrupt PNG"); // error in huffman codes

  0003b	83 7c 24 24 00	 cmp	 DWORD PTR z$2[rsp], 0
  00040	7d 11		 jge	 SHORT $LN13@stbi__pars
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79861
  00049	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0004e	e9 b4 02 00 00	 jmp	 $LN1@stbi__pars
$LN13@stbi__pars:

; 4315 :             if (zout >= a->zout_end) {

  00053	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00058	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0005c	48 39 44 24 30	 cmp	 QWORD PTR zout$[rsp], rax
  00061	72 2e		 jb	 SHORT $LN14@stbi__pars

; 4316 :                 if (!stbi__zexpand(a, zout, 1)) return 0;

  00063	41 b8 01 00 00
	00		 mov	 r8d, 1
  00069	48 8b 54 24 30	 mov	 rdx, QWORD PTR zout$[rsp]
  0006e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  00073	e8 00 00 00 00	 call	 ?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z ; stbi__zexpand
  00078	85 c0		 test	 eax, eax
  0007a	75 07		 jne	 SHORT $LN15@stbi__pars
  0007c	33 c0		 xor	 eax, eax
  0007e	e9 84 02 00 00	 jmp	 $LN1@stbi__pars
$LN15@stbi__pars:

; 4317 :                 zout = a->zout;

  00083	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00088	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0008c	48 89 44 24 30	 mov	 QWORD PTR zout$[rsp], rax
$LN14@stbi__pars:

; 4318 :             }
; 4319 :             *zout++ = (char) z;

  00091	48 8b 44 24 30	 mov	 rax, QWORD PTR zout$[rsp]
  00096	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR z$2[rsp]
  0009b	88 08		 mov	 BYTE PTR [rax], cl
  0009d	48 8b 44 24 30	 mov	 rax, QWORD PTR zout$[rsp]
  000a2	48 ff c0	 inc	 rax
  000a5	48 89 44 24 30	 mov	 QWORD PTR zout$[rsp], rax

; 4320 :         } else {

  000aa	e9 53 02 00 00	 jmp	 $LN12@stbi__pars
$LN11@stbi__pars:

; 4321 :             stbi_uc *p;
; 4322 :             int len,dist;
; 4323 :             if (z == 256) {

  000af	81 7c 24 24 00
	01 00 00	 cmp	 DWORD PTR z$2[rsp], 256	; 00000100H
  000b7	75 3f		 jne	 SHORT $LN16@stbi__pars

; 4324 :                 a->zout = zout;

  000b9	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  000be	48 8b 4c 24 30	 mov	 rcx, QWORD PTR zout$[rsp]
  000c3	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 4325 :                 if (a->hit_zeof_once && a->num_bits < 16) {

  000c7	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  000cc	83 78 14 00	 cmp	 DWORD PTR [rax+20], 0
  000d0	74 1c		 je	 SHORT $LN17@stbi__pars
  000d2	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  000d7	83 78 10 10	 cmp	 DWORD PTR [rax+16], 16
  000db	7d 11		 jge	 SHORT $LN17@stbi__pars

; 4326 :                     // The first time we hit zeof, we inserted 16 extra zero bits into our bit
; 4327 :                     // buffer so the decoder can just do its speculative decoding. But if we
; 4328 :                     // actually consumed any of those bits (which is the case when num_bits < 16),
; 4329 :                     // the stream actually read past the end so it is malformed.
; 4330 :                     return stbi__err("unexpected end","Corrupt PNG");

  000dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79866
  000e4	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000e9	e9 19 02 00 00	 jmp	 $LN1@stbi__pars
$LN17@stbi__pars:

; 4331 :                 }
; 4332 :                 return 1;

  000ee	b8 01 00 00 00	 mov	 eax, 1
  000f3	e9 0f 02 00 00	 jmp	 $LN1@stbi__pars
$LN16@stbi__pars:

; 4333 :             }
; 4334 :             if (z >= 286) return stbi__err("bad huffman code","Corrupt PNG"); // per DEFLATE, length codes 286 and 287 must not appear in compressed data

  000f8	81 7c 24 24 1e
	01 00 00	 cmp	 DWORD PTR z$2[rsp], 286	; 0000011eH
  00100	7c 11		 jl	 SHORT $LN18@stbi__pars
  00102	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79868
  00109	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0010e	e9 f4 01 00 00	 jmp	 $LN1@stbi__pars
$LN18@stbi__pars:

; 4335 :             z -= 257;

  00113	8b 44 24 24	 mov	 eax, DWORD PTR z$2[rsp]
  00117	2d 01 01 00 00	 sub	 eax, 257		; 00000101H
  0011c	89 44 24 24	 mov	 DWORD PTR z$2[rsp], eax

; 4336 :             len = stbi__zlength_base[z];

  00120	48 63 44 24 24	 movsxd	 rax, DWORD PTR z$2[rsp]
  00125	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__zlength_base@@3QBHB
  0012c	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0012f	89 44 24 28	 mov	 DWORD PTR len$3[rsp], eax

; 4337 :             if (stbi__zlength_extra[z]) len += stbi__zreceive(a, stbi__zlength_extra[z]);

  00133	48 63 44 24 24	 movsxd	 rax, DWORD PTR z$2[rsp]
  00138	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__zlength_extra@@3QBHB
  0013f	83 3c 81 00	 cmp	 DWORD PTR [rcx+rax*4], 0
  00143	74 25		 je	 SHORT $LN19@stbi__pars
  00145	48 63 44 24 24	 movsxd	 rax, DWORD PTR z$2[rsp]
  0014a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__zlength_extra@@3QBHB
  00151	8b 14 81	 mov	 edx, DWORD PTR [rcx+rax*4]
  00154	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  00159	e8 00 00 00 00	 call	 ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z ; stbi__zreceive
  0015e	8b 4c 24 28	 mov	 ecx, DWORD PTR len$3[rsp]
  00162	03 c8		 add	 ecx, eax
  00164	8b c1		 mov	 eax, ecx
  00166	89 44 24 28	 mov	 DWORD PTR len$3[rsp], eax
$LN19@stbi__pars:

; 4338 :             z = stbi__zhuffman_decode(a, &a->z_distance);

  0016a	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  0016f	48 05 20 08 00
	00		 add	 rax, 2080		; 00000820H
  00175	48 8b d0	 mov	 rdx, rax
  00178	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  0017d	e8 00 00 00 00	 call	 ?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z ; stbi__zhuffman_decode
  00182	89 44 24 24	 mov	 DWORD PTR z$2[rsp], eax

; 4339 :             if (z < 0 || z >= 30) return stbi__err("bad huffman code","Corrupt PNG"); // per DEFLATE, distance codes 30 and 31 must not appear in compressed data

  00186	83 7c 24 24 00	 cmp	 DWORD PTR z$2[rsp], 0
  0018b	7c 07		 jl	 SHORT $LN21@stbi__pars
  0018d	83 7c 24 24 1e	 cmp	 DWORD PTR z$2[rsp], 30
  00192	7c 11		 jl	 SHORT $LN20@stbi__pars
$LN21@stbi__pars:
  00194	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79872
  0019b	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  001a0	e9 62 01 00 00	 jmp	 $LN1@stbi__pars
$LN20@stbi__pars:

; 4340 :             dist = stbi__zdist_base[z];

  001a5	48 63 44 24 24	 movsxd	 rax, DWORD PTR z$2[rsp]
  001aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__zdist_base@@3QBHB
  001b1	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  001b4	89 44 24 2c	 mov	 DWORD PTR dist$4[rsp], eax

; 4341 :             if (stbi__zdist_extra[z]) dist += stbi__zreceive(a, stbi__zdist_extra[z]);

  001b8	48 63 44 24 24	 movsxd	 rax, DWORD PTR z$2[rsp]
  001bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__zdist_extra@@3QBHB
  001c4	83 3c 81 00	 cmp	 DWORD PTR [rcx+rax*4], 0
  001c8	74 25		 je	 SHORT $LN22@stbi__pars
  001ca	48 63 44 24 24	 movsxd	 rax, DWORD PTR z$2[rsp]
  001cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__zdist_extra@@3QBHB
  001d6	8b 14 81	 mov	 edx, DWORD PTR [rcx+rax*4]
  001d9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  001de	e8 00 00 00 00	 call	 ?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z ; stbi__zreceive
  001e3	8b 4c 24 2c	 mov	 ecx, DWORD PTR dist$4[rsp]
  001e7	03 c8		 add	 ecx, eax
  001e9	8b c1		 mov	 eax, ecx
  001eb	89 44 24 2c	 mov	 DWORD PTR dist$4[rsp], eax
$LN22@stbi__pars:

; 4342 :             if (zout - a->zout_start < dist) return stbi__err("bad dist","Corrupt PNG");

  001ef	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  001f4	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  001f8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR zout$[rsp]
  001fd	48 2b c8	 sub	 rcx, rax
  00200	48 8b c1	 mov	 rax, rcx
  00203	48 63 4c 24 2c	 movsxd	 rcx, DWORD PTR dist$4[rsp]
  00208	48 3b c1	 cmp	 rax, rcx
  0020b	7d 11		 jge	 SHORT $LN23@stbi__pars
  0020d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79875
  00214	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00219	e9 e9 00 00 00	 jmp	 $LN1@stbi__pars
$LN23@stbi__pars:

; 4343 :             if (len > a->zout_end - zout) {

  0021e	48 63 44 24 28	 movsxd	 rax, DWORD PTR len$3[rsp]
  00223	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  00228	48 8b 54 24 30	 mov	 rdx, QWORD PTR zout$[rsp]
  0022d	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00231	48 2b ca	 sub	 rcx, rdx
  00234	48 3b c1	 cmp	 rax, rcx
  00237	7e 2d		 jle	 SHORT $LN24@stbi__pars

; 4344 :                 if (!stbi__zexpand(a, zout, len)) return 0;

  00239	44 8b 44 24 28	 mov	 r8d, DWORD PTR len$3[rsp]
  0023e	48 8b 54 24 30	 mov	 rdx, QWORD PTR zout$[rsp]
  00243	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  00248	e8 00 00 00 00	 call	 ?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z ; stbi__zexpand
  0024d	85 c0		 test	 eax, eax
  0024f	75 07		 jne	 SHORT $LN25@stbi__pars
  00251	33 c0		 xor	 eax, eax
  00253	e9 af 00 00 00	 jmp	 $LN1@stbi__pars
$LN25@stbi__pars:

; 4345 :                 zout = a->zout;

  00258	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  0025d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00261	48 89 44 24 30	 mov	 QWORD PTR zout$[rsp], rax
$LN24@stbi__pars:

; 4346 :             }
; 4347 :             p = (stbi_uc *) (zout - dist);

  00266	48 63 44 24 2c	 movsxd	 rax, DWORD PTR dist$4[rsp]
  0026b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR zout$[rsp]
  00270	48 2b c8	 sub	 rcx, rax
  00273	48 8b c1	 mov	 rax, rcx
  00276	48 89 44 24 38	 mov	 QWORD PTR p$5[rsp], rax

; 4348 :             if (dist == 1) { // run of one byte; common in images.

  0027b	83 7c 24 2c 01	 cmp	 DWORD PTR dist$4[rsp], 1
  00280	75 3f		 jne	 SHORT $LN26@stbi__pars

; 4349 :                 stbi_uc v = *p;

  00282	48 8b 44 24 38	 mov	 rax, QWORD PTR p$5[rsp]
  00287	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0028a	88 44 24 20	 mov	 BYTE PTR v$1[rsp], al

; 4350 :                 if (len) { do *zout++ = v; while (--len); }

  0028e	83 7c 24 28 00	 cmp	 DWORD PTR len$3[rsp], 0
  00293	74 2a		 je	 SHORT $LN28@stbi__pars
$LN7@stbi__pars:
  00295	48 8b 44 24 30	 mov	 rax, QWORD PTR zout$[rsp]
  0029a	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR v$1[rsp]
  0029f	88 08		 mov	 BYTE PTR [rax], cl
  002a1	48 8b 44 24 30	 mov	 rax, QWORD PTR zout$[rsp]
  002a6	48 ff c0	 inc	 rax
  002a9	48 89 44 24 30	 mov	 QWORD PTR zout$[rsp], rax
  002ae	8b 44 24 28	 mov	 eax, DWORD PTR len$3[rsp]
  002b2	ff c8		 dec	 eax
  002b4	89 44 24 28	 mov	 DWORD PTR len$3[rsp], eax
  002b8	83 7c 24 28 00	 cmp	 DWORD PTR len$3[rsp], 0
  002bd	75 d6		 jne	 SHORT $LN7@stbi__pars
$LN28@stbi__pars:

; 4351 :             } else {

  002bf	eb 41		 jmp	 SHORT $LN27@stbi__pars
$LN26@stbi__pars:

; 4352 :                 if (len) { do *zout++ = *p++; while (--len); }

  002c1	83 7c 24 28 00	 cmp	 DWORD PTR len$3[rsp], 0
  002c6	74 3a		 je	 SHORT $LN29@stbi__pars
$LN10@stbi__pars:
  002c8	48 8b 44 24 30	 mov	 rax, QWORD PTR zout$[rsp]
  002cd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$5[rsp]
  002d2	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  002d5	88 08		 mov	 BYTE PTR [rax], cl
  002d7	48 8b 44 24 30	 mov	 rax, QWORD PTR zout$[rsp]
  002dc	48 ff c0	 inc	 rax
  002df	48 89 44 24 30	 mov	 QWORD PTR zout$[rsp], rax
  002e4	48 8b 44 24 38	 mov	 rax, QWORD PTR p$5[rsp]
  002e9	48 ff c0	 inc	 rax
  002ec	48 89 44 24 38	 mov	 QWORD PTR p$5[rsp], rax
  002f1	8b 44 24 28	 mov	 eax, DWORD PTR len$3[rsp]
  002f5	ff c8		 dec	 eax
  002f7	89 44 24 28	 mov	 DWORD PTR len$3[rsp], eax
  002fb	83 7c 24 28 00	 cmp	 DWORD PTR len$3[rsp], 0
  00300	75 c6		 jne	 SHORT $LN10@stbi__pars
$LN29@stbi__pars:
$LN27@stbi__pars:
$LN12@stbi__pars:

; 4353 :             }
; 4354 :         }
; 4355 :     }

  00302	e9 10 fd ff ff	 jmp	 $LN2@stbi__pars
$LN1@stbi__pars:

; 4356 : }

  00307	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0030b	c3		 ret	 0
?stbi__parse_huffman_block@@YAHPEAUstbi__zbuf@@@Z ENDP	; stbi__parse_huffman_block
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
limit$ = 32
cur$ = 36
old_limit$ = 40
q$ = 48
z$ = 80
zout$ = 88
n$ = 96
?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z PROC		; stbi__zexpand

; 4273 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4274 :     char *q;
; 4275 :     unsigned int cur, limit, old_limit;
; 4276 :     z->zout = zout;

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00018	48 8b 4c 24 58	 mov	 rcx, QWORD PTR zout$[rsp]
  0001d	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 4277 :     if (!z->z_expandable) return stbi__err("output buffer limit","Corrupt PNG");

  00021	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00026	83 78 38 00	 cmp	 DWORD PTR [rax+56], 0
  0002a	75 11		 jne	 SHORT $LN4@stbi__zexp
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79827
  00033	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00038	e9 02 01 00 00	 jmp	 $LN1@stbi__zexp
$LN4@stbi__zexp:

; 4278 :     cur   = (unsigned int) (z->zout - z->zout_start);

  0003d	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00042	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00047	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0004b	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0004f	48 2b c1	 sub	 rax, rcx
  00052	89 44 24 24	 mov	 DWORD PTR cur$[rsp], eax

; 4279 :     limit = old_limit = (unsigned) (z->zout_end - z->zout_start);

  00056	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0005b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00060	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00064	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00068	48 2b c1	 sub	 rax, rcx
  0006b	89 44 24 28	 mov	 DWORD PTR old_limit$[rsp], eax
  0006f	8b 44 24 28	 mov	 eax, DWORD PTR old_limit$[rsp]
  00073	89 44 24 20	 mov	 DWORD PTR limit$[rsp], eax

; 4280 :     if (UINT_MAX - cur < (unsigned) n) return stbi__err("outofmem", "Out of memory");

  00077	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  0007c	2b 44 24 24	 sub	 eax, DWORD PTR cur$[rsp]
  00080	3b 44 24 60	 cmp	 eax, DWORD PTR n$[rsp]
  00084	73 11		 jae	 SHORT $LN5@stbi__zexp
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79829
  0008d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00092	e9 a8 00 00 00	 jmp	 $LN1@stbi__zexp
$LN5@stbi__zexp:
$LN2@stbi__zexp:

; 4281 :     while (cur + n > limit) {

  00097	8b 44 24 60	 mov	 eax, DWORD PTR n$[rsp]
  0009b	8b 4c 24 24	 mov	 ecx, DWORD PTR cur$[rsp]
  0009f	03 c8		 add	 ecx, eax
  000a1	8b c1		 mov	 eax, ecx
  000a3	3b 44 24 20	 cmp	 eax, DWORD PTR limit$[rsp]
  000a7	76 24		 jbe	 SHORT $LN3@stbi__zexp

; 4282 :         if(limit > UINT_MAX / 2) return stbi__err("outofmem", "Out of memory");

  000a9	81 7c 24 20 ff
	ff ff 7f	 cmp	 DWORD PTR limit$[rsp], 2147483647 ; 7fffffffH
  000b1	76 0e		 jbe	 SHORT $LN6@stbi__zexp
  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79831
  000ba	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000bf	eb 7e		 jmp	 SHORT $LN1@stbi__zexp
$LN6@stbi__zexp:

; 4283 :         limit *= 2;

  000c1	8b 44 24 20	 mov	 eax, DWORD PTR limit$[rsp]
  000c5	d1 e0		 shl	 eax, 1
  000c7	89 44 24 20	 mov	 DWORD PTR limit$[rsp], eax

; 4284 :     }

  000cb	eb ca		 jmp	 SHORT $LN2@stbi__zexp
$LN3@stbi__zexp:

; 4285 :     q = (char *) STBI_REALLOC_SIZED(z->zout_start, old_limit, limit);

  000cd	8b 44 24 20	 mov	 eax, DWORD PTR limit$[rsp]
  000d1	8b d0		 mov	 edx, eax
  000d3	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  000d8	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  000dc	e8 00 00 00 00	 call	 realloc
  000e1	48 89 44 24 30	 mov	 QWORD PTR q$[rsp], rax

; 4286 :     STBI_NOTUSED(old_limit);
; 4287 :     if (q == NULL) return stbi__err("outofmem", "Out of memory");

  000e6	48 83 7c 24 30
	00		 cmp	 QWORD PTR q$[rsp], 0
  000ec	75 0e		 jne	 SHORT $LN7@stbi__zexp
  000ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79833
  000f5	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000fa	eb 43		 jmp	 SHORT $LN1@stbi__zexp
$LN7@stbi__zexp:

; 4288 :     z->zout_start = q;

  000fc	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00101	48 8b 4c 24 30	 mov	 rcx, QWORD PTR q$[rsp]
  00106	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 4289 :     z->zout       = q + cur;

  0010a	8b 44 24 24	 mov	 eax, DWORD PTR cur$[rsp]
  0010e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR q$[rsp]
  00113	48 03 c8	 add	 rcx, rax
  00116	48 8b c1	 mov	 rax, rcx
  00119	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  0011e	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 4290 :     z->zout_end   = q + limit;

  00122	8b 44 24 20	 mov	 eax, DWORD PTR limit$[rsp]
  00126	48 8b 4c 24 30	 mov	 rcx, QWORD PTR q$[rsp]
  0012b	48 03 c8	 add	 rcx, rax
  0012e	48 8b c1	 mov	 rax, rcx
  00131	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00136	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 4291 :     return 1;

  0013a	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__zexp:

; 4292 : }

  0013f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00143	c3		 ret	 0
?stbi__zexpand@@YAHPEAUstbi__zbuf@@PEADH@Z ENDP		; stbi__zexpand
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
b$ = 32
s$ = 36
tv144 = 40
a$ = 64
z$ = 72
?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z PROC ; stbi__zhuffman_decode

; 4243 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4244 :     int b,s;
; 4245 :     if (a->num_bits < 16) {

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  00013	83 78 10 10	 cmp	 DWORD PTR [rax+16], 16
  00017	7d 50		 jge	 SHORT $LN2@stbi__zhuf

; 4246 :         if (stbi__zeof(a)) {

  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  0001e	e8 00 00 00 00	 call	 ?stbi__zeof@@YAHPEAUstbi__zbuf@@@Z ; stbi__zeof
  00023	85 c0		 test	 eax, eax
  00025	74 38		 je	 SHORT $LN3@stbi__zhuf

; 4247 :             if (!a->hit_zeof_once) {

  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  0002c	83 78 14 00	 cmp	 DWORD PTR [rax+20], 0
  00030	75 21		 jne	 SHORT $LN5@stbi__zhuf

; 4248 :                 // This is the first time we hit eof, insert 16 extra padding btis
; 4249 :                 // to allow us to keep going; if we actually consume any of them
; 4250 :                 // though, that is invalid data. This is caught later.
; 4251 :                 a->hit_zeof_once = 1;

  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  00037	c7 40 14 01 00
	00 00		 mov	 DWORD PTR [rax+20], 1

; 4252 :                 a->num_bits += 16; // add 16 implicit zero bits

  0003e	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  00043	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00046	83 c0 10	 add	 eax, 16
  00049	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  0004e	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4253 :             } else {

  00051	eb 0a		 jmp	 SHORT $LN6@stbi__zhuf
$LN5@stbi__zhuf:

; 4254 :                 // We already inserted our extra 16 padding bits and are again
; 4255 :                 // out, this stream is actually prematurely terminated.
; 4256 :                 return -1;

  00053	b8 ff ff ff ff	 mov	 eax, -1
  00058	e9 8d 00 00 00	 jmp	 $LN1@stbi__zhuf
$LN6@stbi__zhuf:

; 4257 :             }
; 4258 :         } else {

  0005d	eb 0a		 jmp	 SHORT $LN4@stbi__zhuf
$LN3@stbi__zhuf:

; 4259 :             stbi__fill_bits(a);

  0005f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  00064	e8 00 00 00 00	 call	 ?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z ; stbi__fill_bits
$LN4@stbi__zhuf:
$LN2@stbi__zhuf:

; 4260 :         }
; 4261 :     }
; 4262 :     b = z->fast[a->code_buffer & STBI__ZFAST_MASK];

  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  0006e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00071	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  00076	8b c0		 mov	 eax, eax
  00078	48 8b 4c 24 48	 mov	 rcx, QWORD PTR z$[rsp]
  0007d	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00081	89 44 24 20	 mov	 DWORD PTR b$[rsp], eax

; 4263 :     if (b) {

  00085	83 7c 24 20 00	 cmp	 DWORD PTR b$[rsp], 0
  0008a	74 4f		 je	 SHORT $LN7@stbi__zhuf

; 4264 :         s = b >> 9;

  0008c	8b 44 24 20	 mov	 eax, DWORD PTR b$[rsp]
  00090	c1 f8 09	 sar	 eax, 9
  00093	89 44 24 24	 mov	 DWORD PTR s$[rsp], eax

; 4265 :         a->code_buffer >>= s;

  00097	8b 44 24 24	 mov	 eax, DWORD PTR s$[rsp]
  0009b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  000a0	48 89 4c 24 28	 mov	 QWORD PTR tv144[rsp], rcx
  000a5	0f b6 c8	 movzx	 ecx, al
  000a8	48 8b 44 24 28	 mov	 rax, QWORD PTR tv144[rsp]
  000ad	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000b0	d3 e8		 shr	 eax, cl
  000b2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  000b7	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 4266 :         a->num_bits -= s;

  000ba	48 8b 44 24 40	 mov	 rax, QWORD PTR a$[rsp]
  000bf	8b 4c 24 24	 mov	 ecx, DWORD PTR s$[rsp]
  000c3	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000c6	2b c1		 sub	 eax, ecx
  000c8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  000cd	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4267 :         return b & 511;

  000d0	8b 44 24 20	 mov	 eax, DWORD PTR b$[rsp]
  000d4	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  000d9	eb 0f		 jmp	 SHORT $LN1@stbi__zhuf
$LN7@stbi__zhuf:

; 4268 :     }
; 4269 :     return stbi__zhuffman_decode_slowpath(a, z);

  000db	48 8b 54 24 48	 mov	 rdx, QWORD PTR z$[rsp]
  000e0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR a$[rsp]
  000e5	e8 00 00 00 00	 call	 ?stbi__zhuffman_decode_slowpath@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z ; stbi__zhuffman_decode_slowpath
$LN1@stbi__zhuf:

; 4270 : }

  000ea	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ee	c3		 ret	 0
?stbi__zhuffman_decode@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z ENDP ; stbi__zhuffman_decode
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
s$ = 32
b$ = 36
k$ = 40
tv158 = 48
a$ = 80
z$ = 88
?stbi__zhuffman_decode_slowpath@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z PROC ; stbi__zhuffman_decode_slowpath

; 4224 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4225 :     int b,s,k;
; 4226 :     // not resolved by fast table, so compute it the slow way
; 4227 :     // use jpeg approach, which requires MSbits at top
; 4228 :     k = stbi__bit_reverse(a->code_buffer, 16);

  0000e	ba 10 00 00 00	 mov	 edx, 16
  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  00018	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  0001b	e8 00 00 00 00	 call	 ?stbi__bit_reverse@@YAHHH@Z ; stbi__bit_reverse
  00020	89 44 24 28	 mov	 DWORD PTR k$[rsp], eax

; 4229 :     for (s=STBI__ZFAST_BITS+1; ; ++s)

  00024	c7 44 24 20 0a
	00 00 00	 mov	 DWORD PTR s$[rsp], 10
  0002c	eb 0a		 jmp	 SHORT $LN4@stbi__zhuf
$LN2@stbi__zhuf:
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR s$[rsp]
  00032	ff c0		 inc	 eax
  00034	89 44 24 20	 mov	 DWORD PTR s$[rsp], eax
$LN4@stbi__zhuf:

; 4230 :         if (k < z->maxcode[s])

  00038	48 63 44 24 20	 movsxd	 rax, DWORD PTR s$[rsp]
  0003d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR z$[rsp]
  00042	8b 84 81 20 04
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+1056]
  00049	39 44 24 28	 cmp	 DWORD PTR k$[rsp], eax
  0004d	7d 02		 jge	 SHORT $LN5@stbi__zhuf

; 4231 :         break;

  0004f	eb 02		 jmp	 SHORT $LN3@stbi__zhuf
$LN5@stbi__zhuf:
  00051	eb db		 jmp	 SHORT $LN2@stbi__zhuf
$LN3@stbi__zhuf:

; 4232 :     if (s >= 16) return -1; // invalid code!

  00053	83 7c 24 20 10	 cmp	 DWORD PTR s$[rsp], 16
  00058	7c 0a		 jl	 SHORT $LN6@stbi__zhuf
  0005a	b8 ff ff ff ff	 mov	 eax, -1
  0005f	e9 b9 00 00 00	 jmp	 $LN1@stbi__zhuf
$LN6@stbi__zhuf:

; 4233 :     // code size is s, so:
; 4234 :     b = (k >> (16-s)) - z->firstcode[s] + z->firstsymbol[s];

  00064	b8 10 00 00 00	 mov	 eax, 16
  00069	2b 44 24 20	 sub	 eax, DWORD PTR s$[rsp]
  0006d	0f b6 c8	 movzx	 ecx, al
  00070	8b 44 24 28	 mov	 eax, DWORD PTR k$[rsp]
  00074	d3 f8		 sar	 eax, cl
  00076	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR s$[rsp]
  0007b	48 8b 54 24 58	 mov	 rdx, QWORD PTR z$[rsp]
  00080	0f b7 8c 4a 00
	04 00 00	 movzx	 ecx, WORD PTR [rdx+rcx*2+1024]
  00088	2b c1		 sub	 eax, ecx
  0008a	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR s$[rsp]
  0008f	48 8b 54 24 58	 mov	 rdx, QWORD PTR z$[rsp]
  00094	0f b7 8c 4a 64
	04 00 00	 movzx	 ecx, WORD PTR [rdx+rcx*2+1124]
  0009c	03 c1		 add	 eax, ecx
  0009e	89 44 24 24	 mov	 DWORD PTR b$[rsp], eax

; 4235 :     if (b >= STBI__ZNSYMS) return -1; // some data was corrupt somewhere!

  000a2	81 7c 24 24 20
	01 00 00	 cmp	 DWORD PTR b$[rsp], 288	; 00000120H
  000aa	7c 07		 jl	 SHORT $LN7@stbi__zhuf
  000ac	b8 ff ff ff ff	 mov	 eax, -1
  000b1	eb 6a		 jmp	 SHORT $LN1@stbi__zhuf
$LN7@stbi__zhuf:

; 4236 :     if (z->size[b] != s) return -1;  // was originally an assert, but report failure instead.

  000b3	48 63 44 24 24	 movsxd	 rax, DWORD PTR b$[rsp]
  000b8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR z$[rsp]
  000bd	0f b6 84 01 84
	04 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1156]
  000c5	3b 44 24 20	 cmp	 eax, DWORD PTR s$[rsp]
  000c9	74 07		 je	 SHORT $LN8@stbi__zhuf
  000cb	b8 ff ff ff ff	 mov	 eax, -1
  000d0	eb 4b		 jmp	 SHORT $LN1@stbi__zhuf
$LN8@stbi__zhuf:

; 4237 :     a->code_buffer >>= s;

  000d2	8b 44 24 20	 mov	 eax, DWORD PTR s$[rsp]
  000d6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  000db	48 89 4c 24 30	 mov	 QWORD PTR tv158[rsp], rcx
  000e0	0f b6 c8	 movzx	 ecx, al
  000e3	48 8b 44 24 30	 mov	 rax, QWORD PTR tv158[rsp]
  000e8	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000eb	d3 e8		 shr	 eax, cl
  000ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  000f2	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 4238 :     a->num_bits -= s;

  000f5	48 8b 44 24 50	 mov	 rax, QWORD PTR a$[rsp]
  000fa	8b 4c 24 20	 mov	 ecx, DWORD PTR s$[rsp]
  000fe	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00101	2b c1		 sub	 eax, ecx
  00103	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp]
  00108	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4239 :     return z->value[b];

  0010b	48 63 44 24 24	 movsxd	 rax, DWORD PTR b$[rsp]
  00110	48 8b 4c 24 58	 mov	 rcx, QWORD PTR z$[rsp]
  00115	0f b7 84 41 a4
	05 00 00	 movzx	 eax, WORD PTR [rcx+rax*2+1444]
$LN1@stbi__zhuf:

; 4240 : }

  0011d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00121	c3		 ret	 0
?stbi__zhuffman_decode_slowpath@@YAHPEAUstbi__zbuf@@PEAUstbi__zhuffman@@@Z ENDP ; stbi__zhuffman_decode_slowpath
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv83 = 32
k$ = 36
tv89 = 40
z$ = 64
n$ = 72
?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z PROC		; stbi__zreceive

; 4214 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4215 :     unsigned int k;
; 4216 :     if (z->num_bits < n) stbi__fill_bits(z);

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  00012	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  00016	39 48 10	 cmp	 DWORD PTR [rax+16], ecx
  00019	7d 0a		 jge	 SHORT $LN2@stbi__zrec
  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00020	e8 00 00 00 00	 call	 ?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z ; stbi__fill_bits
$LN2@stbi__zrec:

; 4217 :     k = z->code_buffer & ((1 << n) - 1);

  00025	8b 44 24 48	 mov	 eax, DWORD PTR n$[rsp]
  00029	b9 01 00 00 00	 mov	 ecx, 1
  0002e	89 4c 24 20	 mov	 DWORD PTR tv83[rsp], ecx
  00032	0f b6 c8	 movzx	 ecx, al
  00035	8b 44 24 20	 mov	 eax, DWORD PTR tv83[rsp]
  00039	d3 e0		 shl	 eax, cl
  0003b	ff c8		 dec	 eax
  0003d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00042	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  00045	23 c8		 and	 ecx, eax
  00047	8b c1		 mov	 eax, ecx
  00049	89 44 24 24	 mov	 DWORD PTR k$[rsp], eax

; 4218 :     z->code_buffer >>= n;

  0004d	8b 44 24 48	 mov	 eax, DWORD PTR n$[rsp]
  00051	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00056	48 89 4c 24 28	 mov	 QWORD PTR tv89[rsp], rcx
  0005b	0f b6 c8	 movzx	 ecx, al
  0005e	48 8b 44 24 28	 mov	 rax, QWORD PTR tv89[rsp]
  00063	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00066	d3 e8		 shr	 eax, cl
  00068	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  0006d	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 4219 :     z->num_bits -= n;

  00070	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  00075	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  00079	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0007c	2b c1		 sub	 eax, ecx
  0007e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00083	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4220 :     return k;

  00086	8b 44 24 24	 mov	 eax, DWORD PTR k$[rsp]

; 4221 : }

  0008a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008e	c3		 ret	 0
?stbi__zreceive@@YAIPEAUstbi__zbuf@@H@Z ENDP		; stbi__zreceive
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv91 = 32
z$ = 64
?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z PROC		; stbi__fill_bits

; 4202 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@stbi__fill:

; 4203 :     do {
; 4204 :         if (z->code_buffer >= (1U << z->num_bits)) {

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  0000e	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00011	b9 01 00 00 00	 mov	 ecx, 1
  00016	89 4c 24 20	 mov	 DWORD PTR tv91[rsp], ecx
  0001a	0f b6 c8	 movzx	 ecx, al
  0001d	8b 44 24 20	 mov	 eax, DWORD PTR tv91[rsp]
  00021	d3 e0		 shl	 eax, cl
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00028	39 41 18	 cmp	 DWORD PTR [rcx+24], eax
  0002b	72 13		 jb	 SHORT $LN5@stbi__fill

; 4205 :             z->zbuffer = z->zbuffer_end;  /* treat this as EOF so we fail. */

  0002d	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  00032	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00037	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0003b	48 89 08	 mov	 QWORD PTR [rax], rcx

; 4206 :             return;

  0003e	eb 49		 jmp	 SHORT $LN1@stbi__fill
$LN5@stbi__fill:

; 4207 :         }
; 4208 :         z->code_buffer |= (unsigned int) stbi__zget8(z) << z->num_bits;

  00040	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00045	e8 00 00 00 00	 call	 ?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z ; stbi__zget8
  0004a	0f b6 c0	 movzx	 eax, al
  0004d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00052	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  00055	d3 e0		 shl	 eax, cl
  00057	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  0005c	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  0005f	0b c8		 or	 ecx, eax
  00061	8b c1		 mov	 eax, ecx
  00063	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00068	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 4209 :         z->num_bits += 8;

  0006b	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  00070	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00073	83 c0 08	 add	 eax, 8
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  0007b	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 4210 :     } while (z->num_bits <= 24);

  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  00083	83 78 10 18	 cmp	 DWORD PTR [rax+16], 24
  00087	7e 80		 jle	 SHORT $LN4@stbi__fill
$LN1@stbi__fill:

; 4211 : }

  00089	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008d	c3		 ret	 0
?stbi__fill_bits@@YAXPEAUstbi__zbuf@@@Z ENDP		; stbi__fill_bits
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv73 = 32
z$ = 64
?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z PROC		; stbi__zget8

; 4197 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4198 :     return stbi__zeof(z) ? 0 : *z->zbuffer++;

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__zeof@@YAHPEAUstbi__zbuf@@@Z ; stbi__zeof
  00013	85 c0		 test	 eax, eax
  00015	74 0a		 je	 SHORT $LN3@stbi__zget
  00017	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
  0001f	eb 22		 jmp	 SHORT $LN4@stbi__zget
$LN3@stbi__zget:
  00021	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  00026	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00029	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002c	89 44 24 20	 mov	 DWORD PTR tv73[rsp], eax
  00030	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  00035	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00038	48 ff c0	 inc	 rax
  0003b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00040	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN4@stbi__zget:
  00043	0f b6 44 24 20	 movzx	 eax, BYTE PTR tv73[rsp]

; 4199 : }

  00048	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004c	c3		 ret	 0
?stbi__zget8@@YAEPEAUstbi__zbuf@@@Z ENDP		; stbi__zget8
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv67 = 0
z$ = 32
?stbi__zeof@@YAHPEAUstbi__zbuf@@@Z PROC			; stbi__zeof

; 4192 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 4193 :     return (z->zbuffer >= z->zbuffer_end);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR z$[rsp]
  0000e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR z$[rsp]
  00013	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00017	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0001a	72 09		 jb	 SHORT $LN3@stbi__zeof
  0001c	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv67[rsp], 1
  00023	eb 07		 jmp	 SHORT $LN4@stbi__zeof
$LN3@stbi__zeof:
  00025	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv67[rsp], 0
$LN4@stbi__zeof:
  0002c	8b 04 24	 mov	 eax, DWORD PTR tv67[rsp]

; 4194 : }

  0002f	48 83 c4 18	 add	 rsp, 24
  00033	c3		 ret	 0
?stbi__zeof@@YAHPEAUstbi__zbuf@@@Z ENDP			; stbi__zeof
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
i$ = 32
s$1 = 36
code$ = 40
j$2 = 44
fastv$3 = 48
k$ = 52
c$4 = 56
tv288 = 60
sizes$ = 64
next_code$ = 144
__$ArrayPad$ = 208
z$ = 240
sizelist$ = 248
num$ = 256
?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z PROC ; stbi__zbuild_huffman

; 4124 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4125 :     int i,k=0;

  00028	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0

; 4126 :     int code, next_code[16], sizes[17];
; 4127 :     
; 4128 :     // DEFLATE spec for generating codes
; 4129 :     memset(sizes, 0, sizeof(sizes));

  00030	41 b8 44 00 00
	00		 mov	 r8d, 68			; 00000044H
  00036	33 d2		 xor	 edx, edx
  00038	48 8d 4c 24 40	 lea	 rcx, QWORD PTR sizes$[rsp]
  0003d	e8 00 00 00 00	 call	 memset

; 4130 :     memset(z->fast, 0, sizeof(z->fast));

  00042	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0004a	41 b8 00 04 00
	00		 mov	 r8d, 1024		; 00000400H
  00050	33 d2		 xor	 edx, edx
  00052	48 8b c8	 mov	 rcx, rax
  00055	e8 00 00 00 00	 call	 memset

; 4131 :     for (i=0; i < num; ++i)

  0005a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00062	eb 0a		 jmp	 SHORT $LN4@stbi__zbui
$LN2@stbi__zbui:
  00064	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00068	ff c0		 inc	 eax
  0006a	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__zbui:
  0006e	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR num$[rsp]
  00075	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00079	7d 2e		 jge	 SHORT $LN3@stbi__zbui

; 4132 :         ++sizes[sizelist[i]];

  0007b	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00080	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR sizelist$[rsp]
  00088	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0008c	8b 44 84 40	 mov	 eax, DWORD PTR sizes$[rsp+rax*4]
  00090	ff c0		 inc	 eax
  00092	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00097	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR sizelist$[rsp]
  0009f	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000a3	89 44 8c 40	 mov	 DWORD PTR sizes$[rsp+rcx*4], eax
  000a7	eb bb		 jmp	 SHORT $LN2@stbi__zbui
$LN3@stbi__zbui:

; 4133 :     sizes[0] = 0;

  000a9	b8 04 00 00 00	 mov	 eax, 4
  000ae	48 6b c0 00	 imul	 rax, rax, 0
  000b2	c7 44 04 40 00
	00 00 00	 mov	 DWORD PTR sizes$[rsp+rax], 0

; 4134 :     for (i=1; i < 16; ++i)

  000ba	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  000c2	eb 0a		 jmp	 SHORT $LN7@stbi__zbui
$LN5@stbi__zbui:
  000c4	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000c8	ff c0		 inc	 eax
  000ca	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@stbi__zbui:
  000ce	83 7c 24 20 10	 cmp	 DWORD PTR i$[rsp], 16
  000d3	7d 2b		 jge	 SHORT $LN6@stbi__zbui

; 4135 :         if (sizes[i] > (1 << i))

  000d5	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000da	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  000de	ba 01 00 00 00	 mov	 edx, 1
  000e3	d3 e2		 shl	 edx, cl
  000e5	8b ca		 mov	 ecx, edx
  000e7	39 4c 84 40	 cmp	 DWORD PTR sizes$[rsp+rax*4], ecx
  000eb	7e 11		 jle	 SHORT $LN16@stbi__zbui

; 4136 :         return stbi__err("bad sizes", "Corrupt PNG");

  000ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79735
  000f4	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000f9	e9 6a 02 00 00	 jmp	 $LN1@stbi__zbui
$LN16@stbi__zbui:
  000fe	eb c4		 jmp	 SHORT $LN5@stbi__zbui
$LN6@stbi__zbui:

; 4137 :     code = 0;

  00100	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR code$[rsp], 0

; 4138 :     for (i=1; i < 16; ++i) {

  00108	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  00110	eb 0a		 jmp	 SHORT $LN10@stbi__zbui
$LN8@stbi__zbui:
  00112	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00116	ff c0		 inc	 eax
  00118	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN10@stbi__zbui:
  0011c	83 7c 24 20 10	 cmp	 DWORD PTR i$[rsp], 16
  00121	0f 8d d7 00 00
	00		 jge	 $LN9@stbi__zbui

; 4139 :         next_code[i] = code;

  00127	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0012c	8b 4c 24 28	 mov	 ecx, DWORD PTR code$[rsp]
  00130	89 8c 84 90 00
	00 00		 mov	 DWORD PTR next_code$[rsp+rax*4], ecx

; 4140 :         z->firstcode[i] = (stbi__uint16) code;

  00137	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0013c	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00144	0f b7 54 24 28	 movzx	 edx, WORD PTR code$[rsp]
  00149	66 89 94 41 00
	04 00 00	 mov	 WORD PTR [rcx+rax*2+1024], dx

; 4141 :         z->firstsymbol[i] = (stbi__uint16) k;

  00151	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00156	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0015e	0f b7 54 24 34	 movzx	 edx, WORD PTR k$[rsp]
  00163	66 89 94 41 64
	04 00 00	 mov	 WORD PTR [rcx+rax*2+1124], dx

; 4142 :         code = (code + sizes[i]);

  0016b	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00170	8b 44 84 40	 mov	 eax, DWORD PTR sizes$[rsp+rax*4]
  00174	8b 4c 24 28	 mov	 ecx, DWORD PTR code$[rsp]
  00178	03 c8		 add	 ecx, eax
  0017a	8b c1		 mov	 eax, ecx
  0017c	89 44 24 28	 mov	 DWORD PTR code$[rsp], eax

; 4143 :         if (sizes[i])

  00180	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00185	83 7c 84 40 00	 cmp	 DWORD PTR sizes$[rsp+rax*4], 0
  0018a	74 28		 je	 SHORT $LN17@stbi__zbui

; 4144 :             if (code-1 >= (1 << i)) return stbi__err("bad codelengths","Corrupt PNG");

  0018c	8b 44 24 28	 mov	 eax, DWORD PTR code$[rsp]
  00190	ff c8		 dec	 eax
  00192	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00196	ba 01 00 00 00	 mov	 edx, 1
  0019b	d3 e2		 shl	 edx, cl
  0019d	8b ca		 mov	 ecx, edx
  0019f	3b c1		 cmp	 eax, ecx
  001a1	7c 11		 jl	 SHORT $LN18@stbi__zbui
  001a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79738
  001aa	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  001af	e9 b4 01 00 00	 jmp	 $LN1@stbi__zbui
$LN18@stbi__zbui:
$LN17@stbi__zbui:

; 4145 :         z->maxcode[i] = code << (16-i); // preshift for inner loop

  001b4	b8 10 00 00 00	 mov	 eax, 16
  001b9	2b 44 24 20	 sub	 eax, DWORD PTR i$[rsp]
  001bd	0f b6 c8	 movzx	 ecx, al
  001c0	8b 44 24 28	 mov	 eax, DWORD PTR code$[rsp]
  001c4	d3 e0		 shl	 eax, cl
  001c6	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  001cb	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  001d3	89 84 8a 20 04
	00 00		 mov	 DWORD PTR [rdx+rcx*4+1056], eax

; 4146 :         code <<= 1;

  001da	8b 44 24 28	 mov	 eax, DWORD PTR code$[rsp]
  001de	d1 e0		 shl	 eax, 1
  001e0	89 44 24 28	 mov	 DWORD PTR code$[rsp], eax

; 4147 :         k += sizes[i];

  001e4	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  001e9	8b 44 84 40	 mov	 eax, DWORD PTR sizes$[rsp+rax*4]
  001ed	8b 4c 24 34	 mov	 ecx, DWORD PTR k$[rsp]
  001f1	03 c8		 add	 ecx, eax
  001f3	8b c1		 mov	 eax, ecx
  001f5	89 44 24 34	 mov	 DWORD PTR k$[rsp], eax

; 4148 :     }

  001f9	e9 14 ff ff ff	 jmp	 $LN8@stbi__zbui
$LN9@stbi__zbui:

; 4149 :     z->maxcode[16] = 0x10000; // sentinel

  001fe	b8 04 00 00 00	 mov	 eax, 4
  00203	48 6b c0 10	 imul	 rax, rax, 16
  00207	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0020f	c7 84 01 20 04
	00 00 00 00 01
	00		 mov	 DWORD PTR [rcx+rax+1056], 65536 ; 00010000H

; 4150 :     for (i=0; i < num; ++i) {

  0021a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00222	eb 0a		 jmp	 SHORT $LN13@stbi__zbui
$LN11@stbi__zbui:
  00224	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00228	ff c0		 inc	 eax
  0022a	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN13@stbi__zbui:
  0022e	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR num$[rsp]
  00235	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00239	0f 8d 24 01 00
	00		 jge	 $LN12@stbi__zbui

; 4151 :         int s = sizelist[i];

  0023f	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00244	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR sizelist$[rsp]
  0024c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00250	89 44 24 24	 mov	 DWORD PTR s$1[rsp], eax

; 4152 :         if (s) {

  00254	83 7c 24 24 00	 cmp	 DWORD PTR s$1[rsp], 0
  00259	0f 84 ff 00 00
	00		 je	 $LN19@stbi__zbui

; 4153 :             int c = next_code[s] - z->firstcode[s] + z->firstsymbol[s];

  0025f	48 63 44 24 24	 movsxd	 rax, DWORD PTR s$1[rsp]
  00264	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR s$1[rsp]
  00269	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00271	0f b7 8c 4a 00
	04 00 00	 movzx	 ecx, WORD PTR [rdx+rcx*2+1024]
  00279	8b 84 84 90 00
	00 00		 mov	 eax, DWORD PTR next_code$[rsp+rax*4]
  00280	2b c1		 sub	 eax, ecx
  00282	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR s$1[rsp]
  00287	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  0028f	0f b7 8c 4a 64
	04 00 00	 movzx	 ecx, WORD PTR [rdx+rcx*2+1124]
  00297	03 c1		 add	 eax, ecx
  00299	89 44 24 38	 mov	 DWORD PTR c$4[rsp], eax

; 4154 :             stbi__uint16 fastv = (stbi__uint16) ((s << 9) | i);

  0029d	8b 44 24 24	 mov	 eax, DWORD PTR s$1[rsp]
  002a1	c1 e0 09	 shl	 eax, 9
  002a4	0b 44 24 20	 or	 eax, DWORD PTR i$[rsp]
  002a8	66 89 44 24 30	 mov	 WORD PTR fastv$3[rsp], ax

; 4155 :             z->size [c] = (stbi_uc     ) s;

  002ad	48 63 44 24 38	 movsxd	 rax, DWORD PTR c$4[rsp]
  002b2	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  002ba	0f b6 54 24 24	 movzx	 edx, BYTE PTR s$1[rsp]
  002bf	88 94 01 84 04
	00 00		 mov	 BYTE PTR [rcx+rax+1156], dl

; 4156 :             z->value[c] = (stbi__uint16) i;

  002c6	48 63 44 24 38	 movsxd	 rax, DWORD PTR c$4[rsp]
  002cb	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  002d3	0f b7 54 24 20	 movzx	 edx, WORD PTR i$[rsp]
  002d8	66 89 94 41 a4
	05 00 00	 mov	 WORD PTR [rcx+rax*2+1444], dx

; 4157 :             if (s <= STBI__ZFAST_BITS) {

  002e0	83 7c 24 24 09	 cmp	 DWORD PTR s$1[rsp], 9
  002e5	7f 5d		 jg	 SHORT $LN20@stbi__zbui

; 4158 :                 int j = stbi__bit_reverse(next_code[s],s);

  002e7	48 63 44 24 24	 movsxd	 rax, DWORD PTR s$1[rsp]
  002ec	8b 54 24 24	 mov	 edx, DWORD PTR s$1[rsp]
  002f0	8b 8c 84 90 00
	00 00		 mov	 ecx, DWORD PTR next_code$[rsp+rax*4]
  002f7	e8 00 00 00 00	 call	 ?stbi__bit_reverse@@YAHHH@Z ; stbi__bit_reverse
  002fc	89 44 24 2c	 mov	 DWORD PTR j$2[rsp], eax
$LN14@stbi__zbui:

; 4159 :                 while (j < (1 << STBI__ZFAST_BITS)) {

  00300	81 7c 24 2c 00
	02 00 00	 cmp	 DWORD PTR j$2[rsp], 512	; 00000200H
  00308	7d 3a		 jge	 SHORT $LN15@stbi__zbui

; 4160 :                     z->fast[j] = fastv;

  0030a	48 63 44 24 2c	 movsxd	 rax, DWORD PTR j$2[rsp]
  0030f	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00317	0f b7 54 24 30	 movzx	 edx, WORD PTR fastv$3[rsp]
  0031c	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx

; 4161 :                     j += (1 << s);

  00320	8b 44 24 24	 mov	 eax, DWORD PTR s$1[rsp]
  00324	b9 01 00 00 00	 mov	 ecx, 1
  00329	89 4c 24 3c	 mov	 DWORD PTR tv288[rsp], ecx
  0032d	0f b6 c8	 movzx	 ecx, al
  00330	8b 44 24 3c	 mov	 eax, DWORD PTR tv288[rsp]
  00334	d3 e0		 shl	 eax, cl
  00336	8b 4c 24 2c	 mov	 ecx, DWORD PTR j$2[rsp]
  0033a	03 c8		 add	 ecx, eax
  0033c	8b c1		 mov	 eax, ecx
  0033e	89 44 24 2c	 mov	 DWORD PTR j$2[rsp], eax

; 4162 :                 }

  00342	eb bc		 jmp	 SHORT $LN14@stbi__zbui
$LN15@stbi__zbui:
$LN20@stbi__zbui:

; 4163 :             }
; 4164 :             ++next_code[s];

  00344	48 63 44 24 24	 movsxd	 rax, DWORD PTR s$1[rsp]
  00349	8b 84 84 90 00
	00 00		 mov	 eax, DWORD PTR next_code$[rsp+rax*4]
  00350	ff c0		 inc	 eax
  00352	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR s$1[rsp]
  00357	89 84 8c 90 00
	00 00		 mov	 DWORD PTR next_code$[rsp+rcx*4], eax
$LN19@stbi__zbui:

; 4165 :         }
; 4166 :     }

  0035e	e9 c1 fe ff ff	 jmp	 $LN11@stbi__zbui
$LN12@stbi__zbui:

; 4167 :     return 1;

  00363	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__zbui:

; 4168 : }

  00368	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00370	48 33 cc	 xor	 rcx, rsp
  00373	e8 00 00 00 00	 call	 __security_check_cookie
  00378	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  0037f	c3		 ret	 0
?stbi__zbuild_huffman@@YAHPEAUstbi__zhuffman@@PEBEH@Z ENDP ; stbi__zbuild_huffman
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
v$ = 48
bits$ = 56
?stbi__bit_reverse@@YAHHH@Z PROC			; stbi__bit_reverse

; 4116 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4117 :     STBI_ASSERT(bits <= 16);

  0000c	83 7c 24 38 10	 cmp	 DWORD PTR bits$[rsp], 16
  00011	7e 1b		 jle	 SHORT $LN3@stbi__bit_
  00013	41 b8 15 10 00
	00		 mov	 r8d, 4117		; 00001015H
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG79699
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79700
  00027	e8 00 00 00 00	 call	 _wassert
  0002c	33 c0		 xor	 eax, eax
$LN3@stbi__bit_:

; 4118 :     // to bit reverse n bits, reverse 16 and shift
; 4119 :     // e.g. 11 bits, bit reverse and shift away 5
; 4120 :     return stbi__bitreverse16(v) >> (16-bits);

  0002e	8b 4c 24 30	 mov	 ecx, DWORD PTR v$[rsp]
  00032	e8 00 00 00 00	 call	 ?stbi__bitreverse16@@YAHH@Z ; stbi__bitreverse16
  00037	b9 10 00 00 00	 mov	 ecx, 16
  0003c	2b 4c 24 38	 sub	 ecx, DWORD PTR bits$[rsp]
  00040	d3 f8		 sar	 eax, cl

; 4121 : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
?stbi__bit_reverse@@YAHHH@Z ENDP			; stbi__bit_reverse
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
n$ = 8
?stbi__bitreverse16@@YAHH@Z PROC			; stbi__bitreverse16

; 4107 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 4108 :     n = ((n & 0xAAAA) >>  1) | ((n & 0x5555) << 1);

  00004	8b 44 24 08	 mov	 eax, DWORD PTR n$[rsp]
  00008	25 aa aa 00 00	 and	 eax, 43690		; 0000aaaaH
  0000d	d1 f8		 sar	 eax, 1
  0000f	8b 4c 24 08	 mov	 ecx, DWORD PTR n$[rsp]
  00013	81 e1 55 55 00
	00		 and	 ecx, 21845		; 00005555H
  00019	d1 e1		 shl	 ecx, 1
  0001b	0b c1		 or	 eax, ecx
  0001d	89 44 24 08	 mov	 DWORD PTR n$[rsp], eax

; 4109 :     n = ((n & 0xCCCC) >>  2) | ((n & 0x3333) << 2);

  00021	8b 44 24 08	 mov	 eax, DWORD PTR n$[rsp]
  00025	25 cc cc 00 00	 and	 eax, 52428		; 0000ccccH
  0002a	c1 f8 02	 sar	 eax, 2
  0002d	8b 4c 24 08	 mov	 ecx, DWORD PTR n$[rsp]
  00031	81 e1 33 33 00
	00		 and	 ecx, 13107		; 00003333H
  00037	c1 e1 02	 shl	 ecx, 2
  0003a	0b c1		 or	 eax, ecx
  0003c	89 44 24 08	 mov	 DWORD PTR n$[rsp], eax

; 4110 :     n = ((n & 0xF0F0) >>  4) | ((n & 0x0F0F) << 4);

  00040	8b 44 24 08	 mov	 eax, DWORD PTR n$[rsp]
  00044	25 f0 f0 00 00	 and	 eax, 61680		; 0000f0f0H
  00049	c1 f8 04	 sar	 eax, 4
  0004c	8b 4c 24 08	 mov	 ecx, DWORD PTR n$[rsp]
  00050	81 e1 0f 0f 00
	00		 and	 ecx, 3855		; 00000f0fH
  00056	c1 e1 04	 shl	 ecx, 4
  00059	0b c1		 or	 eax, ecx
  0005b	89 44 24 08	 mov	 DWORD PTR n$[rsp], eax

; 4111 :     n = ((n & 0xFF00) >>  8) | ((n & 0x00FF) << 8);

  0005f	8b 44 24 08	 mov	 eax, DWORD PTR n$[rsp]
  00063	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00068	c1 f8 08	 sar	 eax, 8
  0006b	8b 4c 24 08	 mov	 ecx, DWORD PTR n$[rsp]
  0006f	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00075	c1 e1 08	 shl	 ecx, 8
  00078	0b c1		 or	 eax, ecx
  0007a	89 44 24 08	 mov	 DWORD PTR n$[rsp], eax

; 4112 :     return n;

  0007e	8b 44 24 08	 mov	 eax, DWORD PTR n$[rsp]

; 4113 : }

  00082	c3		 ret	 0
?stbi__bitreverse16@@YAHH@Z ENDP			; stbi__bitreverse16
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv80 = 32
j$ = 64
x$ = 72
y$ = 80
comp$ = 88
?stbi__jpeg_info_raw@@YAHPEAUstbi__jpeg@@PEAH11@Z PROC	; stbi__jpeg_info_raw

; 4056 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4057 :     if (!stbi__decode_jpeg_header(j, STBI__SCAN_header)) {

  00018	ba 02 00 00 00	 mov	 edx, 2
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00022	e8 00 00 00 00	 call	 ?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z ; stbi__decode_jpeg_header
  00027	85 c0		 test	 eax, eax
  00029	75 11		 jne	 SHORT $LN2@stbi__jpeg

; 4058 :         stbi__rewind( j->s );

  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00030	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00033	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 4059 :         return 0;

  00038	33 c0		 xor	 eax, eax
  0003a	eb 6b		 jmp	 SHORT $LN1@stbi__jpeg
$LN2@stbi__jpeg:

; 4060 :     }
; 4061 :     if (x) *x = j->s->img_x;

  0003c	48 83 7c 24 48
	00		 cmp	 QWORD PTR x$[rsp], 0
  00042	74 11		 je	 SHORT $LN3@stbi__jpeg
  00044	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00049	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR x$[rsp]
  00051	8b 00		 mov	 eax, DWORD PTR [rax]
  00053	89 01		 mov	 DWORD PTR [rcx], eax
$LN3@stbi__jpeg:

; 4062 :     if (y) *y = j->s->img_y;

  00055	48 83 7c 24 50
	00		 cmp	 QWORD PTR y$[rsp], 0
  0005b	74 12		 je	 SHORT $LN4@stbi__jpeg
  0005d	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00062	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00065	48 8b 4c 24 50	 mov	 rcx, QWORD PTR y$[rsp]
  0006a	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0006d	89 01		 mov	 DWORD PTR [rcx], eax
$LN4@stbi__jpeg:

; 4063 :     if (comp) *comp = j->s->img_n >= 3 ? 3 : 1;

  0006f	48 83 7c 24 58
	00		 cmp	 QWORD PTR comp$[rsp], 0
  00075	74 2b		 je	 SHORT $LN5@stbi__jpeg
  00077	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0007c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007f	83 78 08 03	 cmp	 DWORD PTR [rax+8], 3
  00083	7c 0a		 jl	 SHORT $LN7@stbi__jpeg
  00085	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR tv80[rsp], 3
  0008d	eb 08		 jmp	 SHORT $LN8@stbi__jpeg
$LN7@stbi__jpeg:
  0008f	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
$LN8@stbi__jpeg:
  00097	48 8b 44 24 58	 mov	 rax, QWORD PTR comp$[rsp]
  0009c	8b 4c 24 20	 mov	 ecx, DWORD PTR tv80[rsp]
  000a0	89 08		 mov	 DWORD PTR [rax], ecx
$LN5@stbi__jpeg:

; 4064 :     return 1;

  000a2	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__jpeg:

; 4065 : }

  000a7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ab	c3		 ret	 0
?stbi__jpeg_info_raw@@YAHPEAUstbi__jpeg@@PEAH11@Z ENDP	; stbi__jpeg_info_raw
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
i$1 = 48
out$2 = 56
k$3 = 64
m$4 = 68
m$5 = 69
m$6 = 70
n$ = 72
r$7 = 80
r$8 = 88
b$9 = 96
g$10 = 97
r$11 = 98
j$12 = 100
decode_n$ = 104
is_rgb$ = 108
tv92 = 112
tv160 = 116
tv234 = 120
tv255 = 124
y_bot$13 = 128
tv283 = 132
tv291 = 136
tv697 = 140
tv71 = 144
tv80 = 148
tv82 = 152
y$14 = 160
tv519 = 168
tv548 = 172
tv629 = 176
tv659 = 180
output$15 = 184
tv268 = 192
tv273 = 200
y$16 = 208
tv166 = 216
tv174 = 224
coutput$17 = 232
res_comp$18 = 272
__$ArrayPad$ = 464
z$ = 496
out_x$ = 504
out_y$ = 512
comp$ = 520
req_comp$ = 528
?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z PROC	; load_jpeg_image

; 3865 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec e8 01
	00 00		 sub	 rsp, 488		; 000001e8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 d0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3866 :     int n, decode_n, is_rgb;
; 3867 :     z->s->img_n = 0; // make stbi__cleanup_jpeg safe

  0002d	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00035	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00038	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 3868 :     
; 3869 :     // validate req_comp
; 3870 :     if (req_comp < 0 || req_comp > 4) return stbi__errpuc("bad req_comp", "Internal error");

  0003f	83 bc 24 10 02
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  00047	7c 0a		 jl	 SHORT $LN42@load_jpeg_
  00049	83 bc 24 10 02
	00 00 04	 cmp	 DWORD PTR req_comp$[rsp], 4
  00051	7e 35		 jle	 SHORT $LN41@load_jpeg_
$LN42@load_jpeg_:
  00053	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79579
  0005a	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0005f	85 c0		 test	 eax, eax
  00061	74 0d		 je	 SHORT $LN83@load_jpeg_
  00063	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv71[rsp], 0
  0006e	eb 0b		 jmp	 SHORT $LN84@load_jpeg_
$LN83@load_jpeg_:
  00070	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv71[rsp], 0
$LN84@load_jpeg_:
  0007b	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR tv71[rsp]
  00083	e9 02 11 00 00	 jmp	 $LN1@load_jpeg_
$LN41@load_jpeg_:

; 3871 :     
; 3872 :     // load a jpeg image from whichever source, but leave in YCbCr format
; 3873 :     if (!stbi__decode_jpeg_image(z)) { stbi__cleanup_jpeg(z); return NULL; }

  00088	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00090	e8 00 00 00 00	 call	 ?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z ; stbi__decode_jpeg_image
  00095	85 c0		 test	 eax, eax
  00097	75 14		 jne	 SHORT $LN43@load_jpeg_
  00099	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  000a1	e8 00 00 00 00	 call	 ?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z ; stbi__cleanup_jpeg
  000a6	33 c0		 xor	 eax, eax
  000a8	e9 dd 10 00 00	 jmp	 $LN1@load_jpeg_
$LN43@load_jpeg_:

; 3874 :     
; 3875 :     // determine actual number of components to generate
; 3876 :     n = req_comp ? req_comp : z->s->img_n >= 3 ? 3 : 1;

  000ad	83 bc 24 10 02
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  000b5	74 10		 je	 SHORT $LN87@load_jpeg_
  000b7	8b 84 24 10 02
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  000be	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv82[rsp], eax
  000c5	eb 37		 jmp	 SHORT $LN88@load_jpeg_
$LN87@load_jpeg_:
  000c7	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  000cf	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d2	83 78 08 03	 cmp	 DWORD PTR [rax+8], 3
  000d6	7c 0d		 jl	 SHORT $LN85@load_jpeg_
  000d8	c7 84 24 94 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv80[rsp], 3
  000e3	eb 0b		 jmp	 SHORT $LN86@load_jpeg_
$LN85@load_jpeg_:
  000e5	c7 84 24 94 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv80[rsp], 1
$LN86@load_jpeg_:
  000f0	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR tv80[rsp]
  000f7	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv82[rsp], eax
$LN88@load_jpeg_:
  000fe	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv82[rsp]
  00105	89 44 24 48	 mov	 DWORD PTR n$[rsp], eax

; 3877 :     
; 3878 :     is_rgb = z->s->img_n == 3 && (z->rgb == 3 || (z->app14_color_transform == 0 && !z->jfif));

  00109	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00111	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00114	83 78 08 03	 cmp	 DWORD PTR [rax+8], 3
  00118	75 3d		 jne	 SHORT $LN91@load_jpeg_
  0011a	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00122	83 b8 50 48 00
	00 03		 cmp	 DWORD PTR [rax+18512], 3
  00129	74 22		 je	 SHORT $LN90@load_jpeg_
  0012b	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00133	83 b8 4c 48 00
	00 00		 cmp	 DWORD PTR [rax+18508], 0
  0013a	75 1b		 jne	 SHORT $LN89@load_jpeg_
  0013c	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00144	83 b8 48 48 00
	00 00		 cmp	 DWORD PTR [rax+18504], 0
  0014b	75 0a		 jne	 SHORT $LN91@load_jpeg_
$LN90@load_jpeg_:
  0014d	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  00155	eb 08		 jmp	 SHORT $LN92@load_jpeg_
$LN91@load_jpeg_:
$LN89@load_jpeg_:
  00157	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN92@load_jpeg_:
  0015f	8b 44 24 70	 mov	 eax, DWORD PTR tv92[rsp]
  00163	89 44 24 6c	 mov	 DWORD PTR is_rgb$[rsp], eax

; 3879 :     
; 3880 :     if (z->s->img_n == 3 && n < 3 && !is_rgb)

  00167	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0016f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00172	83 78 08 03	 cmp	 DWORD PTR [rax+8], 3
  00176	75 18		 jne	 SHORT $LN44@load_jpeg_
  00178	83 7c 24 48 03	 cmp	 DWORD PTR n$[rsp], 3
  0017d	7d 11		 jge	 SHORT $LN44@load_jpeg_
  0017f	83 7c 24 6c 00	 cmp	 DWORD PTR is_rgb$[rsp], 0
  00184	75 0a		 jne	 SHORT $LN44@load_jpeg_

; 3881 :         decode_n = 1;

  00186	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR decode_n$[rsp], 1
  0018e	eb 12		 jmp	 SHORT $LN45@load_jpeg_
$LN44@load_jpeg_:

; 3882 :     else
; 3883 :         decode_n = z->s->img_n;

  00190	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00198	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0019b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0019e	89 44 24 68	 mov	 DWORD PTR decode_n$[rsp], eax
$LN45@load_jpeg_:

; 3884 :     
; 3885 :     // nothing to do if no components requested; check this now to avoid
; 3886 :     // accessing uninitialized coutput[0] later
; 3887 :     if (decode_n <= 0) { stbi__cleanup_jpeg(z); return NULL; }

  001a2	83 7c 24 68 00	 cmp	 DWORD PTR decode_n$[rsp], 0
  001a7	7f 14		 jg	 SHORT $LN46@load_jpeg_
  001a9	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  001b1	e8 00 00 00 00	 call	 ?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z ; stbi__cleanup_jpeg
  001b6	33 c0		 xor	 eax, eax
  001b8	e9 cd 0f 00 00	 jmp	 $LN1@load_jpeg_
$LN46@load_jpeg_:

; 3888 :     
; 3889 :     // resample and color-convert
; 3890 :     {
; 3891 :         int k;
; 3892 :         unsigned int i,j;
; 3893 :         stbi_uc *output;
; 3894 :         stbi_uc *coutput[4] = { NULL, NULL, NULL, NULL };

  001bd	48 c7 84 24 e8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR coutput$17[rsp], 0
  001c9	48 c7 84 24 f0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR coutput$17[rsp+8], 0
  001d5	48 c7 84 24 f8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR coutput$17[rsp+16], 0
  001e1	48 c7 84 24 00
	01 00 00 00 00
	00 00		 mov	 QWORD PTR coutput$17[rsp+24], 0

; 3895 :         
; 3896 :         stbi__resample res_comp[4];
; 3897 :         
; 3898 :         for (k=0; k < decode_n; ++k) {

  001ed	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR k$3[rsp], 0
  001f5	eb 0a		 jmp	 SHORT $LN4@load_jpeg_
$LN2@load_jpeg_:
  001f7	8b 44 24 40	 mov	 eax, DWORD PTR k$3[rsp]
  001fb	ff c0		 inc	 eax
  001fd	89 44 24 40	 mov	 DWORD PTR k$3[rsp], eax
$LN4@load_jpeg_:
  00201	8b 44 24 68	 mov	 eax, DWORD PTR decode_n$[rsp]
  00205	39 44 24 40	 cmp	 DWORD PTR k$3[rsp], eax
  00209	0f 8d 55 02 00
	00		 jge	 $LN3@load_jpeg_

; 3899 :             stbi__resample *r = &res_comp[k];

  0020f	48 63 44 24 40	 movsxd	 rax, DWORD PTR k$3[rsp]
  00214	48 6b c0 30	 imul	 rax, rax, 48		; 00000030H
  00218	48 8d 84 04 10
	01 00 00	 lea	 rax, QWORD PTR res_comp$18[rsp+rax]
  00220	48 89 44 24 50	 mov	 QWORD PTR r$7[rsp], rax

; 3900 :             
; 3901 :             // allocate line buffer big enough for upsampling off the edges
; 3902 :             // with upsample factor of 4
; 3903 :             z->img_comp[k].linebuf = (stbi_uc *) stbi__malloc(z->s->img_x + 3);

  00225	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0022d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00230	8b 00		 mov	 eax, DWORD PTR [rax]
  00232	83 c0 03	 add	 eax, 3
  00235	8b c0		 mov	 eax, eax
  00237	8b c8		 mov	 ecx, eax
  00239	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  0023e	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR k$3[rsp]
  00243	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00247	48 8b 94 24 f0
	01 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  0024f	48 89 84 0a e8
	46 00 00	 mov	 QWORD PTR [rdx+rcx+18152], rax

; 3904 :             if (!z->img_comp[k].linebuf) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

  00257	48 63 44 24 40	 movsxd	 rax, DWORD PTR k$3[rsp]
  0025c	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00260	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00268	48 83 bc 01 e8
	46 00 00 00	 cmp	 QWORD PTR [rcx+rax+18152], 0
  00271	75 39		 jne	 SHORT $LN47@load_jpeg_
  00273	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0027b	e8 00 00 00 00	 call	 ?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z ; stbi__cleanup_jpeg
  00280	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79585
  00287	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0028c	85 c0		 test	 eax, eax
  0028e	74 0a		 je	 SHORT $LN93@load_jpeg_
  00290	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv160[rsp], 0
  00298	eb 08		 jmp	 SHORT $LN94@load_jpeg_
$LN93@load_jpeg_:
  0029a	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv160[rsp], 0
$LN94@load_jpeg_:
  002a2	48 63 44 24 74	 movsxd	 rax, DWORD PTR tv160[rsp]
  002a7	e9 de 0e 00 00	 jmp	 $LN1@load_jpeg_
$LN47@load_jpeg_:

; 3905 :             
; 3906 :             r->hs      = z->img_h_max / z->img_comp[k].h;

  002ac	48 63 44 24 40	 movsxd	 rax, DWORD PTR k$3[rsp]
  002b1	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  002b5	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv166[rsp], rax
  002bd	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  002c5	8b 81 88 46 00
	00		 mov	 eax, DWORD PTR [rcx+18056]
  002cb	99		 cdq
  002cc	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  002d4	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR tv166[rsp]
  002dc	42 f7 bc 01 a4
	46 00 00	 idiv	 DWORD PTR [rcx+r8+18084]
  002e4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$7[rsp]
  002e9	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 3907 :             r->vs      = z->img_v_max / z->img_comp[k].v;

  002ec	48 63 44 24 40	 movsxd	 rax, DWORD PTR k$3[rsp]
  002f1	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  002f5	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv174[rsp], rax
  002fd	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00305	8b 81 8c 46 00
	00		 mov	 eax, DWORD PTR [rcx+18060]
  0030b	99		 cdq
  0030c	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00314	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR tv174[rsp]
  0031c	42 f7 bc 01 a8
	46 00 00	 idiv	 DWORD PTR [rcx+r8+18088]
  00324	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$7[rsp]
  00329	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 3908 :             r->ystep   = r->vs >> 1;

  0032c	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  00331	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00334	d1 f8		 sar	 eax, 1
  00336	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$7[rsp]
  0033b	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 3909 :             r->w_lores = (z->s->img_x + r->hs-1) / r->hs;

  0033e	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00346	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00349	8b 00		 mov	 eax, DWORD PTR [rax]
  0034b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$7[rsp]
  00350	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  00353	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00357	33 d2		 xor	 edx, edx
  00359	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$7[rsp]
  0035e	f7 71 18	 div	 DWORD PTR [rcx+24]
  00361	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$7[rsp]
  00366	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 3910 :             r->ypos    = 0;

  00369	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  0036e	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [rax+40], 0

; 3911 :             r->line0   = r->line1 = z->img_comp[k].data;

  00375	48 63 44 24 40	 movsxd	 rax, DWORD PTR k$3[rsp]
  0037a	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0037e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$7[rsp]
  00383	48 8b 94 24 f0
	01 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  0038b	48 8b 84 02 d0
	46 00 00	 mov	 rax, QWORD PTR [rdx+rax+18128]
  00393	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  00397	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  0039c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR r$7[rsp]
  003a1	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  003a5	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 3912 :             
; 3913 :             if      (r->hs == 1 && r->vs == 1) r->resample = resample_row_1;

  003a9	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  003ae	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  003b2	75 1f		 jne	 SHORT $LN48@load_jpeg_
  003b4	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  003b9	83 78 1c 01	 cmp	 DWORD PTR [rax+28], 1
  003bd	75 14		 jne	 SHORT $LN48@load_jpeg_
  003bf	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  003c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?resample_row_1@@YAPEAEPEAE00HH@Z ; resample_row_1
  003cb	48 89 08	 mov	 QWORD PTR [rax], rcx
  003ce	e9 8c 00 00 00	 jmp	 $LN49@load_jpeg_
$LN48@load_jpeg_:

; 3914 :             else if (r->hs == 1 && r->vs == 2) r->resample = stbi__resample_row_v_2;

  003d3	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  003d8	83 78 18 01	 cmp	 DWORD PTR [rax+24], 1
  003dc	75 1c		 jne	 SHORT $LN50@load_jpeg_
  003de	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  003e3	83 78 1c 02	 cmp	 DWORD PTR [rax+28], 2
  003e7	75 11		 jne	 SHORT $LN50@load_jpeg_
  003e9	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  003ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z ; stbi__resample_row_v_2
  003f5	48 89 08	 mov	 QWORD PTR [rax], rcx
  003f8	eb 65		 jmp	 SHORT $LN51@load_jpeg_
$LN50@load_jpeg_:

; 3915 :             else if (r->hs == 2 && r->vs == 1) r->resample = stbi__resample_row_h_2;

  003fa	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  003ff	83 78 18 02	 cmp	 DWORD PTR [rax+24], 2
  00403	75 1c		 jne	 SHORT $LN52@load_jpeg_
  00405	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  0040a	83 78 1c 01	 cmp	 DWORD PTR [rax+28], 1
  0040e	75 11		 jne	 SHORT $LN52@load_jpeg_
  00410	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  00415	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z ; stbi__resample_row_h_2
  0041c	48 89 08	 mov	 QWORD PTR [rax], rcx
  0041f	eb 3e		 jmp	 SHORT $LN53@load_jpeg_
$LN52@load_jpeg_:

; 3916 :             else if (r->hs == 2 && r->vs == 2) r->resample = z->resample_row_hv_2_kernel;

  00421	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  00426	83 78 18 02	 cmp	 DWORD PTR [rax+24], 2
  0042a	75 24		 jne	 SHORT $LN54@load_jpeg_
  0042c	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  00431	83 78 1c 02	 cmp	 DWORD PTR [rax+28], 2
  00435	75 19		 jne	 SHORT $LN54@load_jpeg_
  00437	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  0043c	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00444	48 8b 89 80 48
	00 00		 mov	 rcx, QWORD PTR [rcx+18560]
  0044b	48 89 08	 mov	 QWORD PTR [rax], rcx
  0044e	eb 0f		 jmp	 SHORT $LN55@load_jpeg_
$LN54@load_jpeg_:

; 3917 :             else                               r->resample = stbi__resample_row_generic;

  00450	48 8b 44 24 50	 mov	 rax, QWORD PTR r$7[rsp]
  00455	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__resample_row_generic@@YAPEAEPEAE00HH@Z ; stbi__resample_row_generic
  0045c	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN55@load_jpeg_:
$LN53@load_jpeg_:
$LN51@load_jpeg_:
$LN49@load_jpeg_:

; 3918 :         }

  0045f	e9 93 fd ff ff	 jmp	 $LN2@load_jpeg_
$LN3@load_jpeg_:

; 3919 :         
; 3920 :         // can't error after this so, this is safe
; 3921 :         output = (stbi_uc *) stbi__malloc_mad3(n, z->s->img_x, z->s->img_y, 1);

  00464	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0046c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0046f	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00477	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0047a	41 b9 01 00 00
	00		 mov	 r9d, 1
  00480	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  00484	8b 11		 mov	 edx, DWORD PTR [rcx]
  00486	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  0048a	e8 00 00 00 00	 call	 ?stbi__malloc_mad3@@YAPEAXHHHH@Z ; stbi__malloc_mad3
  0048f	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR output$15[rsp], rax

; 3922 :         if (!output) { stbi__cleanup_jpeg(z); return stbi__errpuc("outofmem", "Out of memory"); }

  00497	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR output$15[rsp], 0
  004a0	75 39		 jne	 SHORT $LN56@load_jpeg_
  004a2	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  004aa	e8 00 00 00 00	 call	 ?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z ; stbi__cleanup_jpeg
  004af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79595
  004b6	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  004bb	85 c0		 test	 eax, eax
  004bd	74 0a		 je	 SHORT $LN95@load_jpeg_
  004bf	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv234[rsp], 0
  004c7	eb 08		 jmp	 SHORT $LN96@load_jpeg_
$LN95@load_jpeg_:
  004c9	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv234[rsp], 0
$LN96@load_jpeg_:
  004d1	48 63 44 24 78	 movsxd	 rax, DWORD PTR tv234[rsp]
  004d6	e9 af 0c 00 00	 jmp	 $LN1@load_jpeg_
$LN56@load_jpeg_:

; 3923 :         
; 3924 :         // now go ahead and resample
; 3925 :         for (j=0; j < z->s->img_y; ++j) {

  004db	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR j$12[rsp], 0
  004e3	eb 0a		 jmp	 SHORT $LN7@load_jpeg_
$LN5@load_jpeg_:
  004e5	8b 44 24 64	 mov	 eax, DWORD PTR j$12[rsp]
  004e9	ff c0		 inc	 eax
  004eb	89 44 24 64	 mov	 DWORD PTR j$12[rsp], eax
$LN7@load_jpeg_:
  004ef	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  004f7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004fa	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  004fd	39 44 24 64	 cmp	 DWORD PTR j$12[rsp], eax
  00501	0f 83 fa 0b 00
	00		 jae	 $LN6@load_jpeg_

; 3926 :             stbi_uc *out = output + n * z->s->img_x * j;

  00507	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0050f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00512	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  00516	0f af 08	 imul	 ecx, DWORD PTR [rax]
  00519	8b c1		 mov	 eax, ecx
  0051b	0f af 44 24 64	 imul	 eax, DWORD PTR j$12[rsp]
  00520	8b c0		 mov	 eax, eax
  00522	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR output$15[rsp]
  0052a	48 03 c8	 add	 rcx, rax
  0052d	48 8b c1	 mov	 rax, rcx
  00530	48 89 44 24 38	 mov	 QWORD PTR out$2[rsp], rax

; 3927 :             for (k=0; k < decode_n; ++k) {

  00535	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR k$3[rsp], 0
  0053d	eb 0a		 jmp	 SHORT $LN10@load_jpeg_
$LN8@load_jpeg_:
  0053f	8b 44 24 40	 mov	 eax, DWORD PTR k$3[rsp]
  00543	ff c0		 inc	 eax
  00545	89 44 24 40	 mov	 DWORD PTR k$3[rsp], eax
$LN10@load_jpeg_:
  00549	8b 44 24 68	 mov	 eax, DWORD PTR decode_n$[rsp]
  0054d	39 44 24 40	 cmp	 DWORD PTR k$3[rsp], eax
  00551	0f 8d b9 01 00
	00		 jge	 $LN9@load_jpeg_

; 3928 :                 stbi__resample *r = &res_comp[k];

  00557	48 63 44 24 40	 movsxd	 rax, DWORD PTR k$3[rsp]
  0055c	48 6b c0 30	 imul	 rax, rax, 48		; 00000030H
  00560	48 8d 84 04 10
	01 00 00	 lea	 rax, QWORD PTR res_comp$18[rsp+rax]
  00568	48 89 44 24 58	 mov	 QWORD PTR r$8[rsp], rax

; 3929 :                 int y_bot = r->ystep >= (r->vs >> 1);

  0056d	48 8b 44 24 58	 mov	 rax, QWORD PTR r$8[rsp]
  00572	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00575	d1 f8		 sar	 eax, 1
  00577	48 8b 4c 24 58	 mov	 rcx, QWORD PTR r$8[rsp]
  0057c	39 41 24	 cmp	 DWORD PTR [rcx+36], eax
  0057f	7c 0a		 jl	 SHORT $LN97@load_jpeg_
  00581	c7 44 24 7c 01
	00 00 00	 mov	 DWORD PTR tv255[rsp], 1
  00589	eb 08		 jmp	 SHORT $LN98@load_jpeg_
$LN97@load_jpeg_:
  0058b	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv255[rsp], 0
$LN98@load_jpeg_:
  00593	8b 44 24 7c	 mov	 eax, DWORD PTR tv255[rsp]
  00597	89 84 24 80 00
	00 00		 mov	 DWORD PTR y_bot$13[rsp], eax

; 3930 :                 coutput[k] = r->resample(z->img_comp[k].linebuf,

  0059e	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR y_bot$13[rsp], 0
  005a6	74 13		 je	 SHORT $LN99@load_jpeg_
  005a8	48 8b 44 24 58	 mov	 rax, QWORD PTR r$8[rsp]
  005ad	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  005b1	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv268[rsp], rax
  005b9	eb 11		 jmp	 SHORT $LN100@load_jpeg_
$LN99@load_jpeg_:
  005bb	48 8b 44 24 58	 mov	 rax, QWORD PTR r$8[rsp]
  005c0	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  005c4	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv268[rsp], rax
$LN100@load_jpeg_:
  005cc	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR y_bot$13[rsp], 0
  005d4	74 13		 je	 SHORT $LN101@load_jpeg_
  005d6	48 8b 44 24 58	 mov	 rax, QWORD PTR r$8[rsp]
  005db	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  005df	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv273[rsp], rax
  005e7	eb 11		 jmp	 SHORT $LN102@load_jpeg_
$LN101@load_jpeg_:
  005e9	48 8b 44 24 58	 mov	 rax, QWORD PTR r$8[rsp]
  005ee	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  005f2	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv273[rsp], rax
$LN102@load_jpeg_:
  005fa	48 63 44 24 40	 movsxd	 rax, DWORD PTR k$3[rsp]
  005ff	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00603	48 8b 4c 24 58	 mov	 rcx, QWORD PTR r$8[rsp]
  00608	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  0060b	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0060f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR r$8[rsp]
  00614	44 8b 49 20	 mov	 r9d, DWORD PTR [rcx+32]
  00618	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR tv268[rsp]
  00620	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR tv273[rsp]
  00628	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00630	48 8b 8c 01 e8
	46 00 00	 mov	 rcx, QWORD PTR [rcx+rax+18152]
  00638	48 8b 44 24 58	 mov	 rax, QWORD PTR r$8[rsp]
  0063d	ff 10		 call	 QWORD PTR [rax]
  0063f	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR k$3[rsp]
  00644	48 89 84 cc e8
	00 00 00	 mov	 QWORD PTR coutput$17[rsp+rcx*8], rax

; 3931 :                                          y_bot ? r->line1 : r->line0,
; 3932 :                                          y_bot ? r->line0 : r->line1,
; 3933 :                                          r->w_lores, r->hs);
; 3934 :                 if (++r->ystep >= r->vs) {

  0064c	48 8b 44 24 58	 mov	 rax, QWORD PTR r$8[rsp]
  00651	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00654	ff c0		 inc	 eax
  00656	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv283[rsp], eax
  0065d	48 8b 44 24 58	 mov	 rax, QWORD PTR r$8[rsp]
  00662	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv283[rsp]
  00669	89 48 24	 mov	 DWORD PTR [rax+36], ecx
  0066c	48 8b 44 24 58	 mov	 rax, QWORD PTR r$8[rsp]
  00671	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00674	39 84 24 84 00
	00 00		 cmp	 DWORD PTR tv283[rsp], eax
  0067b	0f 8c 8a 00 00
	00		 jl	 $LN57@load_jpeg_

; 3935 :                     r->ystep = 0;

  00681	48 8b 44 24 58	 mov	 rax, QWORD PTR r$8[rsp]
  00686	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [rax+36], 0

; 3936 :                     r->line0 = r->line1;

  0068d	48 8b 44 24 58	 mov	 rax, QWORD PTR r$8[rsp]
  00692	48 8b 4c 24 58	 mov	 rcx, QWORD PTR r$8[rsp]
  00697	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0069b	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 3937 :                     if (++r->ypos < z->img_comp[k].y)

  0069f	48 8b 44 24 58	 mov	 rax, QWORD PTR r$8[rsp]
  006a4	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  006a7	ff c0		 inc	 eax
  006a9	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv291[rsp], eax
  006b0	48 8b 44 24 58	 mov	 rax, QWORD PTR r$8[rsp]
  006b5	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv291[rsp]
  006bc	89 48 28	 mov	 DWORD PTR [rax+40], ecx
  006bf	48 63 44 24 40	 movsxd	 rax, DWORD PTR k$3[rsp]
  006c4	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  006c8	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  006d0	8b 84 01 c0 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18112]
  006d7	39 84 24 88 00
	00 00		 cmp	 DWORD PTR tv291[rsp], eax
  006de	7d 2b		 jge	 SHORT $LN58@load_jpeg_

; 3938 :                         r->line1 += z->img_comp[k].w2;

  006e0	48 63 44 24 40	 movsxd	 rax, DWORD PTR k$3[rsp]
  006e5	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  006e9	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  006f1	48 63 84 01 c4
	46 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+18116]
  006f9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR r$8[rsp]
  006fe	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  00702	48 8b 4c 24 58	 mov	 rcx, QWORD PTR r$8[rsp]
  00707	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
$LN58@load_jpeg_:
$LN57@load_jpeg_:

; 3939 :                 }
; 3940 :             }

  0070b	e9 2f fe ff ff	 jmp	 $LN8@load_jpeg_
$LN9@load_jpeg_:

; 3941 :             if (n >= 3) {

  00710	83 7c 24 48 03	 cmp	 DWORD PTR n$[rsp], 3
  00715	0f 8c 45 05 00
	00		 jl	 $LN59@load_jpeg_

; 3942 :                 stbi_uc *y = coutput[0];

  0071b	b8 08 00 00 00	 mov	 eax, 8
  00720	48 6b c0 00	 imul	 rax, rax, 0
  00724	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  0072c	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR y$14[rsp], rax

; 3943 :                 if (z->s->img_n == 3) {

  00734	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0073c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0073f	83 78 08 03	 cmp	 DWORD PTR [rax+8], 3
  00743	0f 85 39 01 00
	00		 jne	 $LN61@load_jpeg_

; 3944 :                     if (is_rgb) {

  00749	83 7c 24 6c 00	 cmp	 DWORD PTR is_rgb$[rsp], 0
  0074e	0f 84 d1 00 00
	00		 je	 $LN63@load_jpeg_

; 3945 :                         for (i=0; i < z->s->img_x; ++i) {

  00754	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  0075c	eb 0a		 jmp	 SHORT $LN13@load_jpeg_
$LN11@load_jpeg_:
  0075e	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  00762	ff c0		 inc	 eax
  00764	89 44 24 30	 mov	 DWORD PTR i$1[rsp], eax
$LN13@load_jpeg_:
  00768	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00770	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00773	8b 00		 mov	 eax, DWORD PTR [rax]
  00775	39 44 24 30	 cmp	 DWORD PTR i$1[rsp], eax
  00779	0f 83 a4 00 00
	00		 jae	 $LN12@load_jpeg_

; 3946 :                             out[0] = y[i];

  0077f	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  00783	b9 01 00 00 00	 mov	 ecx, 1
  00788	48 6b c9 00	 imul	 rcx, rcx, 0
  0078c	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$2[rsp]
  00791	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR y$14[rsp]
  00799	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0079e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3947 :                             out[1] = coutput[1][i];

  007a1	b8 08 00 00 00	 mov	 eax, 8
  007a6	48 6b c0 01	 imul	 rax, rax, 1
  007aa	8b 4c 24 30	 mov	 ecx, DWORD PTR i$1[rsp]
  007ae	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  007b6	ba 01 00 00 00	 mov	 edx, 1
  007bb	48 6b d2 01	 imul	 rdx, rdx, 1
  007bf	4c 8b 44 24 38	 mov	 r8, QWORD PTR out$2[rsp]
  007c4	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  007c8	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al

; 3948 :                             out[2] = coutput[2][i];

  007cc	b8 08 00 00 00	 mov	 eax, 8
  007d1	48 6b c0 02	 imul	 rax, rax, 2
  007d5	8b 4c 24 30	 mov	 ecx, DWORD PTR i$1[rsp]
  007d9	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  007e1	ba 01 00 00 00	 mov	 edx, 1
  007e6	48 6b d2 02	 imul	 rdx, rdx, 2
  007ea	4c 8b 44 24 38	 mov	 r8, QWORD PTR out$2[rsp]
  007ef	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  007f3	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al

; 3949 :                             out[3] = 255;

  007f7	b8 01 00 00 00	 mov	 eax, 1
  007fc	48 6b c0 03	 imul	 rax, rax, 3
  00800	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  00805	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 3950 :                             out += n;

  00809	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$[rsp]
  0080e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  00813	48 03 c8	 add	 rcx, rax
  00816	48 8b c1	 mov	 rax, rcx
  00819	48 89 44 24 38	 mov	 QWORD PTR out$2[rsp], rax

; 3951 :                         }

  0081e	e9 3b ff ff ff	 jmp	 $LN11@load_jpeg_
$LN12@load_jpeg_:

; 3952 :                     } else {

  00823	eb 58		 jmp	 SHORT $LN64@load_jpeg_
$LN63@load_jpeg_:

; 3953 :                         z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);

  00825	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0082d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00830	b9 08 00 00 00	 mov	 ecx, 8
  00835	48 6b c9 02	 imul	 rcx, rcx, 2
  00839	ba 08 00 00 00	 mov	 edx, 8
  0083e	48 6b d2 01	 imul	 rdx, rdx, 1
  00842	44 8b 44 24 48	 mov	 r8d, DWORD PTR n$[rsp]
  00847	44 89 44 24 28	 mov	 DWORD PTR [rsp+40], r8d
  0084c	8b 00		 mov	 eax, DWORD PTR [rax]
  0084e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00852	4c 8b 8c 0c e8
	00 00 00	 mov	 r9, QWORD PTR coutput$17[rsp+rcx]
  0085a	4c 8b 84 14 e8
	00 00 00	 mov	 r8, QWORD PTR coutput$17[rsp+rdx]
  00862	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR y$14[rsp]
  0086a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  0086f	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00877	ff 90 78 48 00
	00		 call	 QWORD PTR [rax+18552]
$LN64@load_jpeg_:

; 3954 :                     }

  0087d	e9 d9 03 00 00	 jmp	 $LN62@load_jpeg_
$LN61@load_jpeg_:

; 3955 :                 } else if (z->s->img_n == 4) {

  00882	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0088a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0088d	83 78 08 04	 cmp	 DWORD PTR [rax+8], 4
  00891	0f 85 03 03 00
	00		 jne	 $LN65@load_jpeg_

; 3956 :                     if (z->app14_color_transform == 0) { // CMYK

  00897	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0089f	83 b8 4c 48 00
	00 00		 cmp	 DWORD PTR [rax+18508], 0
  008a6	0f 85 15 01 00
	00		 jne	 $LN67@load_jpeg_

; 3957 :                         for (i=0; i < z->s->img_x; ++i) {

  008ac	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  008b4	eb 0a		 jmp	 SHORT $LN16@load_jpeg_
$LN14@load_jpeg_:
  008b6	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  008ba	ff c0		 inc	 eax
  008bc	89 44 24 30	 mov	 DWORD PTR i$1[rsp], eax
$LN16@load_jpeg_:
  008c0	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  008c8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  008cb	8b 00		 mov	 eax, DWORD PTR [rax]
  008cd	39 44 24 30	 cmp	 DWORD PTR i$1[rsp], eax
  008d1	0f 83 e5 00 00
	00		 jae	 $LN15@load_jpeg_

; 3958 :                             stbi_uc m = coutput[3][i];

  008d7	b8 08 00 00 00	 mov	 eax, 8
  008dc	48 6b c0 03	 imul	 rax, rax, 3
  008e0	8b 4c 24 30	 mov	 ecx, DWORD PTR i$1[rsp]
  008e4	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  008ec	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  008f0	88 44 24 44	 mov	 BYTE PTR m$4[rsp], al

; 3959 :                             out[0] = stbi__blinn_8x8(coutput[0][i], m);

  008f4	b8 08 00 00 00	 mov	 eax, 8
  008f9	48 6b c0 00	 imul	 rax, rax, 0
  008fd	8b 4c 24 30	 mov	 ecx, DWORD PTR i$1[rsp]
  00901	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  00909	0f b6 54 24 44	 movzx	 edx, BYTE PTR m$4[rsp]
  0090e	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00912	e8 00 00 00 00	 call	 ?stbi__blinn_8x8@@YAEEE@Z ; stbi__blinn_8x8
  00917	b9 01 00 00 00	 mov	 ecx, 1
  0091c	48 6b c9 00	 imul	 rcx, rcx, 0
  00920	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$2[rsp]
  00925	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3960 :                             out[1] = stbi__blinn_8x8(coutput[1][i], m);

  00928	b8 08 00 00 00	 mov	 eax, 8
  0092d	48 6b c0 01	 imul	 rax, rax, 1
  00931	8b 4c 24 30	 mov	 ecx, DWORD PTR i$1[rsp]
  00935	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  0093d	0f b6 54 24 44	 movzx	 edx, BYTE PTR m$4[rsp]
  00942	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00946	e8 00 00 00 00	 call	 ?stbi__blinn_8x8@@YAEEE@Z ; stbi__blinn_8x8
  0094b	b9 01 00 00 00	 mov	 ecx, 1
  00950	48 6b c9 01	 imul	 rcx, rcx, 1
  00954	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$2[rsp]
  00959	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3961 :                             out[2] = stbi__blinn_8x8(coutput[2][i], m);

  0095c	b8 08 00 00 00	 mov	 eax, 8
  00961	48 6b c0 02	 imul	 rax, rax, 2
  00965	8b 4c 24 30	 mov	 ecx, DWORD PTR i$1[rsp]
  00969	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  00971	0f b6 54 24 44	 movzx	 edx, BYTE PTR m$4[rsp]
  00976	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  0097a	e8 00 00 00 00	 call	 ?stbi__blinn_8x8@@YAEEE@Z ; stbi__blinn_8x8
  0097f	b9 01 00 00 00	 mov	 ecx, 1
  00984	48 6b c9 02	 imul	 rcx, rcx, 2
  00988	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$2[rsp]
  0098d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3962 :                             out[3] = 255;

  00990	b8 01 00 00 00	 mov	 eax, 1
  00995	48 6b c0 03	 imul	 rax, rax, 3
  00999	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  0099e	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 3963 :                             out += n;

  009a2	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$[rsp]
  009a7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  009ac	48 03 c8	 add	 rcx, rax
  009af	48 8b c1	 mov	 rax, rcx
  009b2	48 89 44 24 38	 mov	 QWORD PTR out$2[rsp], rax

; 3964 :                         }

  009b7	e9 fa fe ff ff	 jmp	 $LN14@load_jpeg_
$LN15@load_jpeg_:

; 3965 :                     } else if (z->app14_color_transform == 2) { // YCCK

  009bc	e9 d4 01 00 00	 jmp	 $LN68@load_jpeg_
$LN67@load_jpeg_:
  009c1	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  009c9	83 b8 4c 48 00
	00 02		 cmp	 DWORD PTR [rax+18508], 2
  009d0	0f 85 67 01 00
	00		 jne	 $LN69@load_jpeg_

; 3966 :                         z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);

  009d6	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  009de	48 8b 00	 mov	 rax, QWORD PTR [rax]
  009e1	b9 08 00 00 00	 mov	 ecx, 8
  009e6	48 6b c9 02	 imul	 rcx, rcx, 2
  009ea	ba 08 00 00 00	 mov	 edx, 8
  009ef	48 6b d2 01	 imul	 rdx, rdx, 1
  009f3	44 8b 44 24 48	 mov	 r8d, DWORD PTR n$[rsp]
  009f8	44 89 44 24 28	 mov	 DWORD PTR [rsp+40], r8d
  009fd	8b 00		 mov	 eax, DWORD PTR [rax]
  009ff	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00a03	4c 8b 8c 0c e8
	00 00 00	 mov	 r9, QWORD PTR coutput$17[rsp+rcx]
  00a0b	4c 8b 84 14 e8
	00 00 00	 mov	 r8, QWORD PTR coutput$17[rsp+rdx]
  00a13	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR y$14[rsp]
  00a1b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  00a20	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00a28	ff 90 78 48 00
	00		 call	 QWORD PTR [rax+18552]

; 3967 :                         for (i=0; i < z->s->img_x; ++i) {

  00a2e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00a36	eb 0a		 jmp	 SHORT $LN19@load_jpeg_
$LN17@load_jpeg_:
  00a38	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  00a3c	ff c0		 inc	 eax
  00a3e	89 44 24 30	 mov	 DWORD PTR i$1[rsp], eax
$LN19@load_jpeg_:
  00a42	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00a4a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00a4d	8b 00		 mov	 eax, DWORD PTR [rax]
  00a4f	39 44 24 30	 cmp	 DWORD PTR i$1[rsp], eax
  00a53	0f 83 e2 00 00
	00		 jae	 $LN18@load_jpeg_

; 3968 :                             stbi_uc m = coutput[3][i];

  00a59	b8 08 00 00 00	 mov	 eax, 8
  00a5e	48 6b c0 03	 imul	 rax, rax, 3
  00a62	8b 4c 24 30	 mov	 ecx, DWORD PTR i$1[rsp]
  00a66	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  00a6e	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00a72	88 44 24 45	 mov	 BYTE PTR m$5[rsp], al

; 3969 :                             out[0] = stbi__blinn_8x8(255 - out[0], m);

  00a76	b8 01 00 00 00	 mov	 eax, 1
  00a7b	48 6b c0 00	 imul	 rax, rax, 0
  00a7f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  00a84	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00a88	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00a8d	2b c8		 sub	 ecx, eax
  00a8f	8b c1		 mov	 eax, ecx
  00a91	0f b6 54 24 45	 movzx	 edx, BYTE PTR m$5[rsp]
  00a96	0f b6 c8	 movzx	 ecx, al
  00a99	e8 00 00 00 00	 call	 ?stbi__blinn_8x8@@YAEEE@Z ; stbi__blinn_8x8
  00a9e	b9 01 00 00 00	 mov	 ecx, 1
  00aa3	48 6b c9 00	 imul	 rcx, rcx, 0
  00aa7	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$2[rsp]
  00aac	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3970 :                             out[1] = stbi__blinn_8x8(255 - out[1], m);

  00aaf	b8 01 00 00 00	 mov	 eax, 1
  00ab4	48 6b c0 01	 imul	 rax, rax, 1
  00ab8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  00abd	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00ac1	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00ac6	2b c8		 sub	 ecx, eax
  00ac8	8b c1		 mov	 eax, ecx
  00aca	0f b6 54 24 45	 movzx	 edx, BYTE PTR m$5[rsp]
  00acf	0f b6 c8	 movzx	 ecx, al
  00ad2	e8 00 00 00 00	 call	 ?stbi__blinn_8x8@@YAEEE@Z ; stbi__blinn_8x8
  00ad7	b9 01 00 00 00	 mov	 ecx, 1
  00adc	48 6b c9 01	 imul	 rcx, rcx, 1
  00ae0	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$2[rsp]
  00ae5	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3971 :                             out[2] = stbi__blinn_8x8(255 - out[2], m);

  00ae8	b8 01 00 00 00	 mov	 eax, 1
  00aed	48 6b c0 02	 imul	 rax, rax, 2
  00af1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  00af6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00afa	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00aff	2b c8		 sub	 ecx, eax
  00b01	8b c1		 mov	 eax, ecx
  00b03	0f b6 54 24 45	 movzx	 edx, BYTE PTR m$5[rsp]
  00b08	0f b6 c8	 movzx	 ecx, al
  00b0b	e8 00 00 00 00	 call	 ?stbi__blinn_8x8@@YAEEE@Z ; stbi__blinn_8x8
  00b10	b9 01 00 00 00	 mov	 ecx, 1
  00b15	48 6b c9 02	 imul	 rcx, rcx, 2
  00b19	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$2[rsp]
  00b1e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3972 :                             out += n;

  00b21	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$[rsp]
  00b26	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  00b2b	48 03 c8	 add	 rcx, rax
  00b2e	48 8b c1	 mov	 rax, rcx
  00b31	48 89 44 24 38	 mov	 QWORD PTR out$2[rsp], rax

; 3973 :                         }

  00b36	e9 fd fe ff ff	 jmp	 $LN17@load_jpeg_
$LN18@load_jpeg_:

; 3974 :                     } else { // YCbCr + alpha?  Ignore the fourth channel for now

  00b3b	eb 58		 jmp	 SHORT $LN70@load_jpeg_
$LN69@load_jpeg_:

; 3975 :                         z->YCbCr_to_RGB_kernel(out, y, coutput[1], coutput[2], z->s->img_x, n);

  00b3d	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00b45	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00b48	b9 08 00 00 00	 mov	 ecx, 8
  00b4d	48 6b c9 02	 imul	 rcx, rcx, 2
  00b51	ba 08 00 00 00	 mov	 edx, 8
  00b56	48 6b d2 01	 imul	 rdx, rdx, 1
  00b5a	44 8b 44 24 48	 mov	 r8d, DWORD PTR n$[rsp]
  00b5f	44 89 44 24 28	 mov	 DWORD PTR [rsp+40], r8d
  00b64	8b 00		 mov	 eax, DWORD PTR [rax]
  00b66	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00b6a	4c 8b 8c 0c e8
	00 00 00	 mov	 r9, QWORD PTR coutput$17[rsp+rcx]
  00b72	4c 8b 84 14 e8
	00 00 00	 mov	 r8, QWORD PTR coutput$17[rsp+rdx]
  00b7a	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR y$14[rsp]
  00b82	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  00b87	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00b8f	ff 90 78 48 00
	00		 call	 QWORD PTR [rax+18552]
$LN70@load_jpeg_:
$LN68@load_jpeg_:

; 3976 :                     }
; 3977 :                 } else

  00b95	e9 c1 00 00 00	 jmp	 $LN66@load_jpeg_
$LN65@load_jpeg_:

; 3978 :                     for (i=0; i < z->s->img_x; ++i) {

  00b9a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00ba2	eb 0a		 jmp	 SHORT $LN22@load_jpeg_
$LN20@load_jpeg_:
  00ba4	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  00ba8	ff c0		 inc	 eax
  00baa	89 44 24 30	 mov	 DWORD PTR i$1[rsp], eax
$LN22@load_jpeg_:
  00bae	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00bb6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00bb9	8b 00		 mov	 eax, DWORD PTR [rax]
  00bbb	39 44 24 30	 cmp	 DWORD PTR i$1[rsp], eax
  00bbf	0f 83 96 00 00
	00		 jae	 $LN21@load_jpeg_

; 3979 :                     out[0] = out[1] = out[2] = y[i];

  00bc5	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  00bc9	b9 01 00 00 00	 mov	 ecx, 1
  00bce	48 6b c9 02	 imul	 rcx, rcx, 2
  00bd2	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$2[rsp]
  00bd7	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR y$14[rsp]
  00bdf	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00be4	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00be7	b8 01 00 00 00	 mov	 eax, 1
  00bec	48 6b c0 02	 imul	 rax, rax, 2
  00bf0	b9 01 00 00 00	 mov	 ecx, 1
  00bf5	48 6b c9 01	 imul	 rcx, rcx, 1
  00bf9	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$2[rsp]
  00bfe	4c 8b 44 24 38	 mov	 r8, QWORD PTR out$2[rsp]
  00c03	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00c08	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00c0b	b8 01 00 00 00	 mov	 eax, 1
  00c10	48 6b c0 01	 imul	 rax, rax, 1
  00c14	b9 01 00 00 00	 mov	 ecx, 1
  00c19	48 6b c9 00	 imul	 rcx, rcx, 0
  00c1d	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$2[rsp]
  00c22	4c 8b 44 24 38	 mov	 r8, QWORD PTR out$2[rsp]
  00c27	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00c2c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3980 :                     out[3] = 255; // not used if n==3

  00c2f	b8 01 00 00 00	 mov	 eax, 1
  00c34	48 6b c0 03	 imul	 rax, rax, 3
  00c38	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  00c3d	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 3981 :                     out += n;

  00c41	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$[rsp]
  00c46	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  00c4b	48 03 c8	 add	 rcx, rax
  00c4e	48 8b c1	 mov	 rax, rcx
  00c51	48 89 44 24 38	 mov	 QWORD PTR out$2[rsp], rax

; 3982 :                 }

  00c56	e9 49 ff ff ff	 jmp	 $LN20@load_jpeg_
$LN21@load_jpeg_:
$LN66@load_jpeg_:
$LN62@load_jpeg_:

; 3983 :             } else {

  00c5b	e9 9c 04 00 00	 jmp	 $LN60@load_jpeg_
$LN59@load_jpeg_:

; 3984 :                 if (is_rgb) {

  00c60	83 7c 24 6c 00	 cmp	 DWORD PTR is_rgb$[rsp], 0
  00c65	0f 84 88 01 00
	00		 je	 $LN71@load_jpeg_

; 3985 :                     if (n == 1)

  00c6b	83 7c 24 48 01	 cmp	 DWORD PTR n$[rsp], 1
  00c70	0f 85 b0 00 00
	00		 jne	 $LN73@load_jpeg_

; 3986 :                         for (i=0; i < z->s->img_x; ++i)

  00c76	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00c7e	eb 0a		 jmp	 SHORT $LN25@load_jpeg_
$LN23@load_jpeg_:
  00c80	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  00c84	ff c0		 inc	 eax
  00c86	89 44 24 30	 mov	 DWORD PTR i$1[rsp], eax
$LN25@load_jpeg_:
  00c8a	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00c92	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00c95	8b 00		 mov	 eax, DWORD PTR [rax]
  00c97	39 44 24 30	 cmp	 DWORD PTR i$1[rsp], eax
  00c9b	0f 83 80 00 00
	00		 jae	 $LN24@load_jpeg_

; 3987 :                         *out++ = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);

  00ca1	b8 08 00 00 00	 mov	 eax, 8
  00ca6	48 6b c0 02	 imul	 rax, rax, 2
  00caa	8b 4c 24 30	 mov	 ecx, DWORD PTR i$1[rsp]
  00cae	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  00cb6	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00cba	b9 08 00 00 00	 mov	 ecx, 8
  00cbf	48 6b c9 01	 imul	 rcx, rcx, 1
  00cc3	8b 54 24 30	 mov	 edx, DWORD PTR i$1[rsp]
  00cc7	48 8b 8c 0c e8
	00 00 00	 mov	 rcx, QWORD PTR coutput$17[rsp+rcx]
  00ccf	0f b6 0c 11	 movzx	 ecx, BYTE PTR [rcx+rdx]
  00cd3	ba 08 00 00 00	 mov	 edx, 8
  00cd8	48 6b d2 00	 imul	 rdx, rdx, 0
  00cdc	44 8b 44 24 30	 mov	 r8d, DWORD PTR i$1[rsp]
  00ce1	48 8b 94 14 e8
	00 00 00	 mov	 rdx, QWORD PTR coutput$17[rsp+rdx]
  00ce9	42 0f b6 14 02	 movzx	 edx, BYTE PTR [rdx+r8]
  00cee	89 94 24 a8 00
	00 00		 mov	 DWORD PTR tv519[rsp], edx
  00cf5	44 8b c0	 mov	 r8d, eax
  00cf8	8b d1		 mov	 edx, ecx
  00cfa	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR tv519[rsp]
  00d01	8b c8		 mov	 ecx, eax
  00d03	e8 00 00 00 00	 call	 ?stbi__compute_y@@YAEHHH@Z ; stbi__compute_y
  00d08	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  00d0d	88 01		 mov	 BYTE PTR [rcx], al
  00d0f	48 8b 44 24 38	 mov	 rax, QWORD PTR out$2[rsp]
  00d14	48 ff c0	 inc	 rax
  00d17	48 89 44 24 38	 mov	 QWORD PTR out$2[rsp], rax
  00d1c	e9 5f ff ff ff	 jmp	 $LN23@load_jpeg_
$LN24@load_jpeg_:
  00d21	e9 c8 00 00 00	 jmp	 $LN74@load_jpeg_
$LN73@load_jpeg_:

; 3988 :                     else {
; 3989 :                         for (i=0; i < z->s->img_x; ++i, out += 2) {

  00d26	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00d2e	eb 18		 jmp	 SHORT $LN28@load_jpeg_
$LN26@load_jpeg_:
  00d30	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  00d34	ff c0		 inc	 eax
  00d36	89 44 24 30	 mov	 DWORD PTR i$1[rsp], eax
  00d3a	48 8b 44 24 38	 mov	 rax, QWORD PTR out$2[rsp]
  00d3f	48 83 c0 02	 add	 rax, 2
  00d43	48 89 44 24 38	 mov	 QWORD PTR out$2[rsp], rax
$LN28@load_jpeg_:
  00d48	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00d50	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00d53	8b 00		 mov	 eax, DWORD PTR [rax]
  00d55	39 44 24 30	 cmp	 DWORD PTR i$1[rsp], eax
  00d59	0f 83 8f 00 00
	00		 jae	 $LN27@load_jpeg_

; 3990 :                             out[0] = stbi__compute_y(coutput[0][i], coutput[1][i], coutput[2][i]);

  00d5f	b8 08 00 00 00	 mov	 eax, 8
  00d64	48 6b c0 02	 imul	 rax, rax, 2
  00d68	8b 4c 24 30	 mov	 ecx, DWORD PTR i$1[rsp]
  00d6c	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  00d74	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00d78	b9 08 00 00 00	 mov	 ecx, 8
  00d7d	48 6b c9 01	 imul	 rcx, rcx, 1
  00d81	8b 54 24 30	 mov	 edx, DWORD PTR i$1[rsp]
  00d85	48 8b 8c 0c e8
	00 00 00	 mov	 rcx, QWORD PTR coutput$17[rsp+rcx]
  00d8d	0f b6 0c 11	 movzx	 ecx, BYTE PTR [rcx+rdx]
  00d91	ba 08 00 00 00	 mov	 edx, 8
  00d96	48 6b d2 00	 imul	 rdx, rdx, 0
  00d9a	44 8b 44 24 30	 mov	 r8d, DWORD PTR i$1[rsp]
  00d9f	48 8b 94 14 e8
	00 00 00	 mov	 rdx, QWORD PTR coutput$17[rsp+rdx]
  00da7	42 0f b6 14 02	 movzx	 edx, BYTE PTR [rdx+r8]
  00dac	89 94 24 ac 00
	00 00		 mov	 DWORD PTR tv548[rsp], edx
  00db3	44 8b c0	 mov	 r8d, eax
  00db6	8b d1		 mov	 edx, ecx
  00db8	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR tv548[rsp]
  00dbf	8b c8		 mov	 ecx, eax
  00dc1	e8 00 00 00 00	 call	 ?stbi__compute_y@@YAEHHH@Z ; stbi__compute_y
  00dc6	b9 01 00 00 00	 mov	 ecx, 1
  00dcb	48 6b c9 00	 imul	 rcx, rcx, 0
  00dcf	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$2[rsp]
  00dd4	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3991 :                             out[1] = 255;

  00dd7	b8 01 00 00 00	 mov	 eax, 1
  00ddc	48 6b c0 01	 imul	 rax, rax, 1
  00de0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  00de5	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 3992 :                         }

  00de9	e9 42 ff ff ff	 jmp	 $LN26@load_jpeg_
$LN27@load_jpeg_:
$LN74@load_jpeg_:

; 3993 :                     }

  00dee	e9 09 03 00 00	 jmp	 $LN72@load_jpeg_
$LN71@load_jpeg_:

; 3994 :                 } else if (z->s->img_n == 4 && z->app14_color_transform == 0) {

  00df3	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00dfb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00dfe	83 78 08 04	 cmp	 DWORD PTR [rax+8], 4
  00e02	0f 85 3d 01 00
	00		 jne	 $LN75@load_jpeg_
  00e08	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00e10	83 b8 4c 48 00
	00 00		 cmp	 DWORD PTR [rax+18508], 0
  00e17	0f 85 28 01 00
	00		 jne	 $LN75@load_jpeg_

; 3995 :                     for (i=0; i < z->s->img_x; ++i) {

  00e1d	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00e25	eb 0a		 jmp	 SHORT $LN31@load_jpeg_
$LN29@load_jpeg_:
  00e27	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  00e2b	ff c0		 inc	 eax
  00e2d	89 44 24 30	 mov	 DWORD PTR i$1[rsp], eax
$LN31@load_jpeg_:
  00e31	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00e39	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00e3c	8b 00		 mov	 eax, DWORD PTR [rax]
  00e3e	39 44 24 30	 cmp	 DWORD PTR i$1[rsp], eax
  00e42	0f 83 f8 00 00
	00		 jae	 $LN30@load_jpeg_

; 3996 :                         stbi_uc m = coutput[3][i];

  00e48	b8 08 00 00 00	 mov	 eax, 8
  00e4d	48 6b c0 03	 imul	 rax, rax, 3
  00e51	8b 4c 24 30	 mov	 ecx, DWORD PTR i$1[rsp]
  00e55	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  00e5d	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00e61	88 44 24 46	 mov	 BYTE PTR m$6[rsp], al

; 3997 :                         stbi_uc r = stbi__blinn_8x8(coutput[0][i], m);

  00e65	b8 08 00 00 00	 mov	 eax, 8
  00e6a	48 6b c0 00	 imul	 rax, rax, 0
  00e6e	8b 4c 24 30	 mov	 ecx, DWORD PTR i$1[rsp]
  00e72	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  00e7a	0f b6 54 24 46	 movzx	 edx, BYTE PTR m$6[rsp]
  00e7f	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00e83	e8 00 00 00 00	 call	 ?stbi__blinn_8x8@@YAEEE@Z ; stbi__blinn_8x8
  00e88	88 44 24 62	 mov	 BYTE PTR r$11[rsp], al

; 3998 :                         stbi_uc g = stbi__blinn_8x8(coutput[1][i], m);

  00e8c	b8 08 00 00 00	 mov	 eax, 8
  00e91	48 6b c0 01	 imul	 rax, rax, 1
  00e95	8b 4c 24 30	 mov	 ecx, DWORD PTR i$1[rsp]
  00e99	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  00ea1	0f b6 54 24 46	 movzx	 edx, BYTE PTR m$6[rsp]
  00ea6	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00eaa	e8 00 00 00 00	 call	 ?stbi__blinn_8x8@@YAEEE@Z ; stbi__blinn_8x8
  00eaf	88 44 24 61	 mov	 BYTE PTR g$10[rsp], al

; 3999 :                         stbi_uc b = stbi__blinn_8x8(coutput[2][i], m);

  00eb3	b8 08 00 00 00	 mov	 eax, 8
  00eb8	48 6b c0 02	 imul	 rax, rax, 2
  00ebc	8b 4c 24 30	 mov	 ecx, DWORD PTR i$1[rsp]
  00ec0	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  00ec8	0f b6 54 24 46	 movzx	 edx, BYTE PTR m$6[rsp]
  00ecd	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00ed1	e8 00 00 00 00	 call	 ?stbi__blinn_8x8@@YAEEE@Z ; stbi__blinn_8x8
  00ed6	88 44 24 60	 mov	 BYTE PTR b$9[rsp], al

; 4000 :                         out[0] = stbi__compute_y(r, g, b);

  00eda	0f b6 44 24 60	 movzx	 eax, BYTE PTR b$9[rsp]
  00edf	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR g$10[rsp]
  00ee4	0f b6 54 24 62	 movzx	 edx, BYTE PTR r$11[rsp]
  00ee9	89 94 24 b0 00
	00 00		 mov	 DWORD PTR tv629[rsp], edx
  00ef0	44 8b c0	 mov	 r8d, eax
  00ef3	8b d1		 mov	 edx, ecx
  00ef5	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv629[rsp]
  00efc	8b c8		 mov	 ecx, eax
  00efe	e8 00 00 00 00	 call	 ?stbi__compute_y@@YAEHHH@Z ; stbi__compute_y
  00f03	b9 01 00 00 00	 mov	 ecx, 1
  00f08	48 6b c9 00	 imul	 rcx, rcx, 0
  00f0c	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$2[rsp]
  00f11	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4001 :                         out[1] = 255;

  00f14	b8 01 00 00 00	 mov	 eax, 1
  00f19	48 6b c0 01	 imul	 rax, rax, 1
  00f1d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  00f22	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 4002 :                         out += n;

  00f26	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$[rsp]
  00f2b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  00f30	48 03 c8	 add	 rcx, rax
  00f33	48 8b c1	 mov	 rax, rcx
  00f36	48 89 44 24 38	 mov	 QWORD PTR out$2[rsp], rax

; 4003 :                     }

  00f3b	e9 e7 fe ff ff	 jmp	 $LN29@load_jpeg_
$LN30@load_jpeg_:

; 4004 :                 } else if (z->s->img_n == 4 && z->app14_color_transform == 2) {

  00f40	e9 b7 01 00 00	 jmp	 $LN76@load_jpeg_
$LN75@load_jpeg_:
  00f45	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00f4d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00f50	83 78 08 04	 cmp	 DWORD PTR [rax+8], 4
  00f54	0f 85 d8 00 00
	00		 jne	 $LN77@load_jpeg_
  00f5a	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00f62	83 b8 4c 48 00
	00 02		 cmp	 DWORD PTR [rax+18508], 2
  00f69	0f 85 c3 00 00
	00		 jne	 $LN77@load_jpeg_

; 4005 :                     for (i=0; i < z->s->img_x; ++i) {

  00f6f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00f77	eb 0a		 jmp	 SHORT $LN34@load_jpeg_
$LN32@load_jpeg_:
  00f79	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  00f7d	ff c0		 inc	 eax
  00f7f	89 44 24 30	 mov	 DWORD PTR i$1[rsp], eax
$LN34@load_jpeg_:
  00f83	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00f8b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00f8e	8b 00		 mov	 eax, DWORD PTR [rax]
  00f90	39 44 24 30	 cmp	 DWORD PTR i$1[rsp], eax
  00f94	0f 83 93 00 00
	00		 jae	 $LN33@load_jpeg_

; 4006 :                         out[0] = stbi__blinn_8x8(255 - coutput[0][i], coutput[3][i]);

  00f9a	b8 08 00 00 00	 mov	 eax, 8
  00f9f	48 6b c0 03	 imul	 rax, rax, 3
  00fa3	8b 4c 24 30	 mov	 ecx, DWORD PTR i$1[rsp]
  00fa7	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  00faf	ba 08 00 00 00	 mov	 edx, 8
  00fb4	48 6b d2 00	 imul	 rdx, rdx, 0
  00fb8	44 8b 44 24 30	 mov	 r8d, DWORD PTR i$1[rsp]
  00fbd	48 8b 94 14 e8
	00 00 00	 mov	 rdx, QWORD PTR coutput$17[rsp+rdx]
  00fc5	42 0f b6 14 02	 movzx	 edx, BYTE PTR [rdx+r8]
  00fca	41 b8 ff 00 00
	00		 mov	 r8d, 255		; 000000ffH
  00fd0	44 2b c2	 sub	 r8d, edx
  00fd3	41 8b d0	 mov	 edx, r8d
  00fd6	89 94 24 b4 00
	00 00		 mov	 DWORD PTR tv659[rsp], edx
  00fdd	0f b6 14 08	 movzx	 edx, BYTE PTR [rax+rcx]
  00fe1	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR tv659[rsp]
  00fe8	0f b6 c8	 movzx	 ecx, al
  00feb	e8 00 00 00 00	 call	 ?stbi__blinn_8x8@@YAEEE@Z ; stbi__blinn_8x8
  00ff0	b9 01 00 00 00	 mov	 ecx, 1
  00ff5	48 6b c9 00	 imul	 rcx, rcx, 0
  00ff9	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$2[rsp]
  00ffe	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 4007 :                         out[1] = 255;

  01001	b8 01 00 00 00	 mov	 eax, 1
  01006	48 6b c0 01	 imul	 rax, rax, 1
  0100a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  0100f	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 4008 :                         out += n;

  01013	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$[rsp]
  01018	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  0101d	48 03 c8	 add	 rcx, rax
  01020	48 8b c1	 mov	 rax, rcx
  01023	48 89 44 24 38	 mov	 QWORD PTR out$2[rsp], rax

; 4009 :                     }

  01028	e9 4c ff ff ff	 jmp	 $LN32@load_jpeg_
$LN33@load_jpeg_:

; 4010 :                 } else {

  0102d	e9 ca 00 00 00	 jmp	 $LN78@load_jpeg_
$LN77@load_jpeg_:

; 4011 :                     stbi_uc *y = coutput[0];

  01032	b8 08 00 00 00	 mov	 eax, 8
  01037	48 6b c0 00	 imul	 rax, rax, 0
  0103b	48 8b 84 04 e8
	00 00 00	 mov	 rax, QWORD PTR coutput$17[rsp+rax]
  01043	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR y$16[rsp], rax

; 4012 :                     if (n == 1)

  0104b	83 7c 24 48 01	 cmp	 DWORD PTR n$[rsp], 1
  01050	75 48		 jne	 SHORT $LN79@load_jpeg_

; 4013 :                         for (i=0; i < z->s->img_x; ++i) out[i] = y[i];

  01052	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  0105a	eb 0a		 jmp	 SHORT $LN37@load_jpeg_
$LN35@load_jpeg_:
  0105c	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  01060	ff c0		 inc	 eax
  01062	89 44 24 30	 mov	 DWORD PTR i$1[rsp], eax
$LN37@load_jpeg_:
  01066	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0106e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01071	8b 00		 mov	 eax, DWORD PTR [rax]
  01073	39 44 24 30	 cmp	 DWORD PTR i$1[rsp], eax
  01077	73 1f		 jae	 SHORT $LN36@load_jpeg_
  01079	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  0107d	8b 4c 24 30	 mov	 ecx, DWORD PTR i$1[rsp]
  01081	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$2[rsp]
  01086	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR y$16[rsp]
  0108e	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  01093	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  01096	eb c4		 jmp	 SHORT $LN35@load_jpeg_
$LN36@load_jpeg_:
  01098	eb 62		 jmp	 SHORT $LN80@load_jpeg_
$LN79@load_jpeg_:

; 4014 :                     else
; 4015 :                         for (i=0; i < z->s->img_x; ++i) { *out++ = y[i]; *out++ = 255; }

  0109a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  010a2	eb 0a		 jmp	 SHORT $LN40@load_jpeg_
$LN38@load_jpeg_:
  010a4	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  010a8	ff c0		 inc	 eax
  010aa	89 44 24 30	 mov	 DWORD PTR i$1[rsp], eax
$LN40@load_jpeg_:
  010ae	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  010b6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  010b9	8b 00		 mov	 eax, DWORD PTR [rax]
  010bb	39 44 24 30	 cmp	 DWORD PTR i$1[rsp], eax
  010bf	73 3b		 jae	 SHORT $LN39@load_jpeg_
  010c1	8b 44 24 30	 mov	 eax, DWORD PTR i$1[rsp]
  010c5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$2[rsp]
  010ca	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR y$16[rsp]
  010d2	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  010d6	88 01		 mov	 BYTE PTR [rcx], al
  010d8	48 8b 44 24 38	 mov	 rax, QWORD PTR out$2[rsp]
  010dd	48 ff c0	 inc	 rax
  010e0	48 89 44 24 38	 mov	 QWORD PTR out$2[rsp], rax
  010e5	48 8b 44 24 38	 mov	 rax, QWORD PTR out$2[rsp]
  010ea	c6 00 ff	 mov	 BYTE PTR [rax], 255	; 000000ffH
  010ed	48 8b 44 24 38	 mov	 rax, QWORD PTR out$2[rsp]
  010f2	48 ff c0	 inc	 rax
  010f5	48 89 44 24 38	 mov	 QWORD PTR out$2[rsp], rax
  010fa	eb a8		 jmp	 SHORT $LN38@load_jpeg_
$LN39@load_jpeg_:
$LN80@load_jpeg_:
$LN78@load_jpeg_:
$LN76@load_jpeg_:
$LN72@load_jpeg_:
$LN60@load_jpeg_:

; 4016 :                 }
; 4017 :             }
; 4018 :         }

  010fc	e9 e4 f3 ff ff	 jmp	 $LN5@load_jpeg_
$LN6@load_jpeg_:

; 4019 :         stbi__cleanup_jpeg(z);

  01101	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  01109	e8 00 00 00 00	 call	 ?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z ; stbi__cleanup_jpeg

; 4020 :         *out_x = z->s->img_x;

  0110e	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  01116	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01119	48 8b 8c 24 f8
	01 00 00	 mov	 rcx, QWORD PTR out_x$[rsp]
  01121	8b 00		 mov	 eax, DWORD PTR [rax]
  01123	89 01		 mov	 DWORD PTR [rcx], eax

; 4021 :         *out_y = z->s->img_y;

  01125	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0112d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01130	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR out_y$[rsp]
  01138	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0113b	89 01		 mov	 DWORD PTR [rcx], eax

; 4022 :         if (comp) *comp = z->s->img_n >= 3 ? 3 : 1; // report original components, not output

  0113d	48 83 bc 24 08
	02 00 00 00	 cmp	 QWORD PTR comp$[rsp], 0
  01146	74 3a		 je	 SHORT $LN81@load_jpeg_
  01148	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  01150	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01153	83 78 08 03	 cmp	 DWORD PTR [rax+8], 3
  01157	7c 0d		 jl	 SHORT $LN103@load_jpeg_
  01159	c7 84 24 8c 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv697[rsp], 3
  01164	eb 0b		 jmp	 SHORT $LN104@load_jpeg_
$LN103@load_jpeg_:
  01166	c7 84 24 8c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv697[rsp], 1
$LN104@load_jpeg_:
  01171	48 8b 84 24 08
	02 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  01179	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv697[rsp]
  01180	89 08		 mov	 DWORD PTR [rax], ecx
$LN81@load_jpeg_:

; 4023 :         return output;

  01182	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR output$15[rsp]
$LN1@load_jpeg_:

; 4024 :     }
; 4025 : }

  0118a	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01192	48 33 cc	 xor	 rcx, rsp
  01195	e8 00 00 00 00	 call	 __security_check_cookie
  0119a	48 81 c4 e8 01
	00 00		 add	 rsp, 488		; 000001e8H
  011a1	c3		 ret	 0
?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z ENDP	; load_jpeg_image
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
t$ = 0
x$ = 32
y$ = 40
?stbi__blinn_8x8@@YAEEE@Z PROC				; stbi__blinn_8x8

; 3859 : {

  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00008	48 83 ec 18	 sub	 rsp, 24

; 3860 :     unsigned int t = x*y + 128;

  0000c	0f b6 44 24 20	 movzx	 eax, BYTE PTR x$[rsp]
  00011	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR y$[rsp]
  00016	0f af c1	 imul	 eax, ecx
  00019	05 80 00 00 00	 add	 eax, 128		; 00000080H
  0001e	89 04 24	 mov	 DWORD PTR t$[rsp], eax

; 3861 :     return (stbi_uc) ((t + (t >>8)) >> 8);

  00021	8b 04 24	 mov	 eax, DWORD PTR t$[rsp]
  00024	c1 e8 08	 shr	 eax, 8
  00027	8b 0c 24	 mov	 ecx, DWORD PTR t$[rsp]
  0002a	03 c8		 add	 ecx, eax
  0002c	8b c1		 mov	 eax, ecx
  0002e	c1 e8 08	 shr	 eax, 8

; 3862 : }

  00031	48 83 c4 18	 add	 rsp, 24
  00035	c3		 ret	 0
?stbi__blinn_8x8@@YAEEE@Z ENDP				; stbi__blinn_8x8
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
j$ = 48
?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z PROC		; stbi__cleanup_jpeg

; 3843 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3844 :     stbi__free_jpeg_components(j, j->s->img_n, 0);

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR j$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	45 33 c0	 xor	 r8d, r8d
  00014	8b 50 08	 mov	 edx, DWORD PTR [rax+8]
  00017	48 8b 4c 24 30	 mov	 rcx, QWORD PTR j$[rsp]
  0001c	e8 00 00 00 00	 call	 ?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z ; stbi__free_jpeg_components

; 3845 : }

  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	c3		 ret	 0
?stbi__cleanup_jpeg@@YAXPEAUstbi__jpeg@@@Z ENDP		; stbi__cleanup_jpeg
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
j$ = 48
?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z PROC		; stbi__setup_jpeg

; 3821 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3822 :     j->idct_block_kernel = stbi__idct_block;

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR j$[rsp]
  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__idct_block@@YAXPEAEHQEAF@Z ; stbi__idct_block
  00015	48 89 88 70 48
	00 00		 mov	 QWORD PTR [rax+18544], rcx

; 3823 :     j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_row;

  0001c	48 8b 44 24 30	 mov	 rax, QWORD PTR j$[rsp]
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z ; stbi__YCbCr_to_RGB_row
  00028	48 89 88 78 48
	00 00		 mov	 QWORD PTR [rax+18552], rcx

; 3824 :     j->resample_row_hv_2_kernel = stbi__resample_row_hv_2;

  0002f	48 8b 44 24 30	 mov	 rax, QWORD PTR j$[rsp]
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z ; stbi__resample_row_hv_2
  0003b	48 89 88 80 48
	00 00		 mov	 QWORD PTR [rax+18560], rcx

; 3825 :     
; 3826 : #ifdef STBI_SSE2
; 3827 :     if (stbi__sse2_available()) {

  00042	e8 00 00 00 00	 call	 ?stbi__sse2_available@@YAHXZ ; stbi__sse2_available
  00047	85 c0		 test	 eax, eax
  00049	74 39		 je	 SHORT $LN2@stbi__setu

; 3828 :         j->idct_block_kernel = stbi__idct_simd;

  0004b	48 8b 44 24 30	 mov	 rax, QWORD PTR j$[rsp]
  00050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__idct_simd@@YAXPEAEHQEAF@Z ; stbi__idct_simd
  00057	48 89 88 70 48
	00 00		 mov	 QWORD PTR [rax+18544], rcx

; 3829 :         j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;

  0005e	48 8b 44 24 30	 mov	 rax, QWORD PTR j$[rsp]
  00063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z ; stbi__YCbCr_to_RGB_simd
  0006a	48 89 88 78 48
	00 00		 mov	 QWORD PTR [rax+18552], rcx

; 3830 :         j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;

  00071	48 8b 44 24 30	 mov	 rax, QWORD PTR j$[rsp]
  00076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z ; stbi__resample_row_hv_2_simd
  0007d	48 89 88 80 48
	00 00		 mov	 QWORD PTR [rax+18560], rcx
$LN2@stbi__setu:

; 3831 :     }
; 3832 : #endif
; 3833 :     
; 3834 : #ifdef STBI_NEON
; 3835 :     j->idct_block_kernel = stbi__idct_simd;
; 3836 :     j->YCbCr_to_RGB_kernel = stbi__YCbCr_to_RGB_simd;
; 3837 :     j->resample_row_hv_2_kernel = stbi__resample_row_hv_2_simd;
; 3838 : #endif
; 3839 : }

  00084	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00088	c3		 ret	 0
?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z ENDP		; stbi__setup_jpeg
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
i$ = 0
r$1 = 4
g$2 = 8
b$3 = 12
y_fixed$4 = 16
cr$5 = 20
cb$6 = 24
yws$7 = 32
signflip$8 = 48
cbw$9 = 64
crw$10 = 80
brb$11 = 96
gxb$12 = 112
t0$13 = 128
t1$14 = 144
$T15 = 160
$T16 = 176
$T17 = 192
$T18 = 208
$T19 = 224
$T20 = 240
$T21 = 256
$T22 = 272
$T23 = 288
$T24 = 304
cr_bytes$25 = 320
$T26 = 336
cb_bytes$27 = 352
$T28 = 368
y_bias$29 = 384
y_bytes$30 = 400
$T31 = 416
$T32 = 432
cr_biased$33 = 448
$T34 = 464
$T35 = 480
cb_biased$36 = 496
$T37 = 512
yw$38 = 528
$T39 = 544
cr_const0$40 = 560
$T41 = 576
cb_const0$42 = 592
$T43 = 608
cb_const1$44 = 624
$T45 = 640
cr_const1$46 = 656
$T47 = 672
cr0$48 = 688
$T49 = 704
cb0$50 = 720
$T51 = 736
cb1$52 = 752
$T53 = 768
gwt$54 = 784
cr1$55 = 800
$T56 = 816
rws$57 = 832
$T58 = 848
bws$59 = 864
$T60 = 880
gws$61 = 896
$T62 = 912
rw$63 = 928
bw$64 = 944
$T65 = 960
gw$66 = 976
xw$67 = 992
$T68 = 1008
$T69 = 1024
$T70 = 1040
$T71 = 1056
$T72 = 1072
o0$73 = 1088
o1$74 = 1104
out$ = 1136
y$ = 1144
pcb$ = 1152
pcr$ = 1160
count$ = 1168
step$ = 1176
?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z PROC	; stbi__YCbCr_to_RGB_simd

; 3686 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 68 04
	00 00		 sub	 rsp, 1128		; 00000468H

; 3687 :     int i = 0;

  0001b	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0

; 3688 :     
; 3689 : #ifdef STBI_SSE2
; 3690 :     // step == 3 is pretty ugly on the final interleave, and i'm not convinced
; 3691 :     // it's useful in practice (you wouldn't use it for textures, for example).
; 3692 :     // so just accelerate step == 4 case.
; 3693 :     if (step == 4) {

  00022	83 bc 24 98 04
	00 00 04	 cmp	 DWORD PTR step$[rsp], 4
  0002a	0f 85 c9 05 00
	00		 jne	 $LN8@stbi__YCbC

; 3694 :         // this is a fairly straightforward implementation and not super-optimized.
; 3695 :         __m128i signflip  = _mm_set1_epi8(-0x80);

  00030	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@80808080808080808080808080808080
  00038	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR $T15[rsp], xmm0
  00041	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR $T15[rsp]
  0004a	66 0f 7f 44 24
	30		 movdqa	 XMMWORD PTR signflip$8[rsp], xmm0

; 3696 :         __m128i cr_const0 = _mm_set1_epi16(   (short) ( 1.40200f*4096.0f+0.5f));

  00050	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@166f166f166f166f166f166f166f166f
  00058	66 0f 7f 84 24
	b0 00 00 00	 movdqa	 XMMWORD PTR $T16[rsp], xmm0
  00061	66 0f 6f 84 24
	b0 00 00 00	 movdqa	 xmm0, XMMWORD PTR $T16[rsp]
  0006a	66 0f 7f 84 24
	30 02 00 00	 movdqa	 XMMWORD PTR cr_const0$40[rsp], xmm0

; 3697 :         __m128i cr_const1 = _mm_set1_epi16( - (short) ( 0.71414f*4096.0f+0.5f));

  00073	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@f493f493f493f493f493f493f493f493
  0007b	66 0f 7f 84 24
	c0 00 00 00	 movdqa	 XMMWORD PTR $T17[rsp], xmm0
  00084	66 0f 6f 84 24
	c0 00 00 00	 movdqa	 xmm0, XMMWORD PTR $T17[rsp]
  0008d	66 0f 7f 84 24
	90 02 00 00	 movdqa	 XMMWORD PTR cr_const1$46[rsp], xmm0

; 3698 :         __m128i cb_const0 = _mm_set1_epi16( - (short) ( 0.34414f*4096.0f+0.5f));

  00096	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@fa7efa7efa7efa7efa7efa7efa7efa7e
  0009e	66 0f 7f 84 24
	d0 00 00 00	 movdqa	 XMMWORD PTR $T18[rsp], xmm0
  000a7	66 0f 6f 84 24
	d0 00 00 00	 movdqa	 xmm0, XMMWORD PTR $T18[rsp]
  000b0	66 0f 7f 84 24
	50 02 00 00	 movdqa	 XMMWORD PTR cb_const0$42[rsp], xmm0

; 3699 :         __m128i cb_const1 = _mm_set1_epi16(   (short) ( 1.77200f*4096.0f+0.5f));

  000b9	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@1c5a1c5a1c5a1c5a1c5a1c5a1c5a1c5a
  000c1	66 0f 7f 84 24
	e0 00 00 00	 movdqa	 XMMWORD PTR $T19[rsp], xmm0
  000ca	66 0f 6f 84 24
	e0 00 00 00	 movdqa	 xmm0, XMMWORD PTR $T19[rsp]
  000d3	66 0f 7f 84 24
	70 02 00 00	 movdqa	 XMMWORD PTR cb_const1$44[rsp], xmm0

; 3700 :         __m128i y_bias = _mm_set1_epi8((char) (unsigned char) 128);

  000dc	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@80808080808080808080808080808080
  000e4	66 0f 7f 84 24
	f0 00 00 00	 movdqa	 XMMWORD PTR $T20[rsp], xmm0
  000ed	66 0f 6f 84 24
	f0 00 00 00	 movdqa	 xmm0, XMMWORD PTR $T20[rsp]
  000f6	66 0f 7f 84 24
	80 01 00 00	 movdqa	 XMMWORD PTR y_bias$29[rsp], xmm0

; 3701 :         __m128i xw = _mm_set1_epi16(255); // alpha channel

  000ff	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@00ff00ff00ff00ff00ff00ff00ff00ff
  00107	66 0f 7f 84 24
	00 01 00 00	 movdqa	 XMMWORD PTR $T21[rsp], xmm0
  00110	66 0f 6f 84 24
	00 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T21[rsp]
  00119	66 0f 7f 84 24
	e0 03 00 00	 movdqa	 XMMWORD PTR xw$67[rsp], xmm0

; 3702 :         
; 3703 :         for (; i+7 < count; i += 8) {

  00122	eb 09		 jmp	 SHORT $LN4@stbi__YCbC
$LN2@stbi__YCbC:
  00124	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00127	83 c0 08	 add	 eax, 8
  0012a	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__YCbC:
  0012d	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00130	83 c0 07	 add	 eax, 7
  00133	3b 84 24 90 04
	00 00		 cmp	 eax, DWORD PTR count$[rsp]
  0013a	0f 8d b9 04 00
	00		 jge	 $LN3@stbi__YCbC

; 3704 :             // load
; 3705 :             __m128i y_bytes = _mm_loadl_epi64((__m128i *) (y+i));

  00140	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00144	48 8b 8c 24 78
	04 00 00	 mov	 rcx, QWORD PTR y$[rsp]
  0014c	48 03 c8	 add	 rcx, rax
  0014f	48 8b c1	 mov	 rax, rcx
  00152	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [rax]
  00156	66 0f 7f 84 24
	10 01 00 00	 movdqa	 XMMWORD PTR $T22[rsp], xmm0
  0015f	66 0f 6f 84 24
	10 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T22[rsp]
  00168	66 0f 7f 84 24
	90 01 00 00	 movdqa	 XMMWORD PTR y_bytes$30[rsp], xmm0

; 3706 :             __m128i cr_bytes = _mm_loadl_epi64((__m128i *) (pcr+i));

  00171	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00175	48 8b 8c 24 88
	04 00 00	 mov	 rcx, QWORD PTR pcr$[rsp]
  0017d	48 03 c8	 add	 rcx, rax
  00180	48 8b c1	 mov	 rax, rcx
  00183	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [rax]
  00187	66 0f 7f 84 24
	20 01 00 00	 movdqa	 XMMWORD PTR $T23[rsp], xmm0
  00190	66 0f 6f 84 24
	20 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T23[rsp]
  00199	66 0f 7f 84 24
	40 01 00 00	 movdqa	 XMMWORD PTR cr_bytes$25[rsp], xmm0

; 3707 :             __m128i cb_bytes = _mm_loadl_epi64((__m128i *) (pcb+i));

  001a2	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  001a6	48 8b 8c 24 80
	04 00 00	 mov	 rcx, QWORD PTR pcb$[rsp]
  001ae	48 03 c8	 add	 rcx, rax
  001b1	48 8b c1	 mov	 rax, rcx
  001b4	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [rax]
  001b8	66 0f 7f 84 24
	30 01 00 00	 movdqa	 XMMWORD PTR $T24[rsp], xmm0
  001c1	66 0f 6f 84 24
	30 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T24[rsp]
  001ca	66 0f 7f 84 24
	60 01 00 00	 movdqa	 XMMWORD PTR cb_bytes$27[rsp], xmm0

; 3708 :             __m128i cr_biased = _mm_xor_si128(cr_bytes, signflip); // -128

  001d3	66 0f 6f 84 24
	40 01 00 00	 movdqa	 xmm0, XMMWORD PTR cr_bytes$25[rsp]
  001dc	66 0f ef 44 24
	30		 pxor	 xmm0, XMMWORD PTR signflip$8[rsp]
  001e2	66 0f 7f 84 24
	50 01 00 00	 movdqa	 XMMWORD PTR $T26[rsp], xmm0
  001eb	66 0f 6f 84 24
	50 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T26[rsp]
  001f4	66 0f 7f 84 24
	c0 01 00 00	 movdqa	 XMMWORD PTR cr_biased$33[rsp], xmm0

; 3709 :             __m128i cb_biased = _mm_xor_si128(cb_bytes, signflip); // -128

  001fd	66 0f 6f 84 24
	60 01 00 00	 movdqa	 xmm0, XMMWORD PTR cb_bytes$27[rsp]
  00206	66 0f ef 44 24
	30		 pxor	 xmm0, XMMWORD PTR signflip$8[rsp]
  0020c	66 0f 7f 84 24
	70 01 00 00	 movdqa	 XMMWORD PTR $T28[rsp], xmm0
  00215	66 0f 6f 84 24
	70 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T28[rsp]
  0021e	66 0f 7f 84 24
	f0 01 00 00	 movdqa	 XMMWORD PTR cb_biased$36[rsp], xmm0

; 3710 :             
; 3711 :             // unpack to short (and left-shift cr, cb by 8)
; 3712 :             __m128i yw  = _mm_unpacklo_epi8(y_bias, y_bytes);

  00227	66 0f 6f 84 24
	80 01 00 00	 movdqa	 xmm0, XMMWORD PTR y_bias$29[rsp]
  00230	66 0f 60 84 24
	90 01 00 00	 punpcklbw xmm0, XMMWORD PTR y_bytes$30[rsp]
  00239	66 0f 7f 84 24
	a0 01 00 00	 movdqa	 XMMWORD PTR $T31[rsp], xmm0
  00242	66 0f 6f 84 24
	a0 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T31[rsp]
  0024b	66 0f 7f 84 24
	10 02 00 00	 movdqa	 XMMWORD PTR yw$38[rsp], xmm0

; 3713 :             __m128i crw = _mm_unpacklo_epi8(_mm_setzero_si128(), cr_biased);

  00254	66 0f ef c0	 pxor	 xmm0, xmm0
  00258	66 0f 7f 84 24
	b0 01 00 00	 movdqa	 XMMWORD PTR $T32[rsp], xmm0
  00261	66 0f 6f 84 24
	b0 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T32[rsp]
  0026a	66 0f 60 84 24
	c0 01 00 00	 punpcklbw xmm0, XMMWORD PTR cr_biased$33[rsp]
  00273	66 0f 7f 84 24
	d0 01 00 00	 movdqa	 XMMWORD PTR $T34[rsp], xmm0
  0027c	66 0f 6f 84 24
	d0 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T34[rsp]
  00285	66 0f 7f 44 24
	50		 movdqa	 XMMWORD PTR crw$10[rsp], xmm0

; 3714 :             __m128i cbw = _mm_unpacklo_epi8(_mm_setzero_si128(), cb_biased);

  0028b	66 0f ef c0	 pxor	 xmm0, xmm0
  0028f	66 0f 7f 84 24
	e0 01 00 00	 movdqa	 XMMWORD PTR $T35[rsp], xmm0
  00298	66 0f 6f 84 24
	e0 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T35[rsp]
  002a1	66 0f 60 84 24
	f0 01 00 00	 punpcklbw xmm0, XMMWORD PTR cb_biased$36[rsp]
  002aa	66 0f 7f 84 24
	00 02 00 00	 movdqa	 XMMWORD PTR $T37[rsp], xmm0
  002b3	66 0f 6f 84 24
	00 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T37[rsp]
  002bc	66 0f 7f 44 24
	40		 movdqa	 XMMWORD PTR cbw$9[rsp], xmm0

; 3715 :             
; 3716 :             // color transform
; 3717 :             __m128i yws = _mm_srli_epi16(yw, 4);

  002c2	66 0f 6f 84 24
	10 02 00 00	 movdqa	 xmm0, XMMWORD PTR yw$38[rsp]
  002cb	66 0f 71 d0 04	 psrlw	 xmm0, 4
  002d0	66 0f 7f 84 24
	20 02 00 00	 movdqa	 XMMWORD PTR $T39[rsp], xmm0
  002d9	66 0f 6f 84 24
	20 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T39[rsp]
  002e2	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR yws$7[rsp], xmm0

; 3718 :             __m128i cr0 = _mm_mulhi_epi16(cr_const0, crw);

  002e8	66 0f 6f 84 24
	30 02 00 00	 movdqa	 xmm0, XMMWORD PTR cr_const0$40[rsp]
  002f1	66 0f e5 44 24
	50		 pmulhw	 xmm0, XMMWORD PTR crw$10[rsp]
  002f7	66 0f 7f 84 24
	40 02 00 00	 movdqa	 XMMWORD PTR $T41[rsp], xmm0
  00300	66 0f 6f 84 24
	40 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T41[rsp]
  00309	66 0f 7f 84 24
	b0 02 00 00	 movdqa	 XMMWORD PTR cr0$48[rsp], xmm0

; 3719 :             __m128i cb0 = _mm_mulhi_epi16(cb_const0, cbw);

  00312	66 0f 6f 84 24
	50 02 00 00	 movdqa	 xmm0, XMMWORD PTR cb_const0$42[rsp]
  0031b	66 0f e5 44 24
	40		 pmulhw	 xmm0, XMMWORD PTR cbw$9[rsp]
  00321	66 0f 7f 84 24
	60 02 00 00	 movdqa	 XMMWORD PTR $T43[rsp], xmm0
  0032a	66 0f 6f 84 24
	60 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T43[rsp]
  00333	66 0f 7f 84 24
	d0 02 00 00	 movdqa	 XMMWORD PTR cb0$50[rsp], xmm0

; 3720 :             __m128i cb1 = _mm_mulhi_epi16(cbw, cb_const1);

  0033c	66 0f 6f 44 24
	40		 movdqa	 xmm0, XMMWORD PTR cbw$9[rsp]
  00342	66 0f e5 84 24
	70 02 00 00	 pmulhw	 xmm0, XMMWORD PTR cb_const1$44[rsp]
  0034b	66 0f 7f 84 24
	80 02 00 00	 movdqa	 XMMWORD PTR $T45[rsp], xmm0
  00354	66 0f 6f 84 24
	80 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T45[rsp]
  0035d	66 0f 7f 84 24
	f0 02 00 00	 movdqa	 XMMWORD PTR cb1$52[rsp], xmm0

; 3721 :             __m128i cr1 = _mm_mulhi_epi16(crw, cr_const1);

  00366	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR crw$10[rsp]
  0036c	66 0f e5 84 24
	90 02 00 00	 pmulhw	 xmm0, XMMWORD PTR cr_const1$46[rsp]
  00375	66 0f 7f 84 24
	a0 02 00 00	 movdqa	 XMMWORD PTR $T47[rsp], xmm0
  0037e	66 0f 6f 84 24
	a0 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T47[rsp]
  00387	66 0f 7f 84 24
	20 03 00 00	 movdqa	 XMMWORD PTR cr1$55[rsp], xmm0

; 3722 :             __m128i rws = _mm_add_epi16(cr0, yws);

  00390	66 0f 6f 84 24
	b0 02 00 00	 movdqa	 xmm0, XMMWORD PTR cr0$48[rsp]
  00399	66 0f fd 44 24
	20		 paddw	 xmm0, XMMWORD PTR yws$7[rsp]
  0039f	66 0f 7f 84 24
	c0 02 00 00	 movdqa	 XMMWORD PTR $T49[rsp], xmm0
  003a8	66 0f 6f 84 24
	c0 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T49[rsp]
  003b1	66 0f 7f 84 24
	40 03 00 00	 movdqa	 XMMWORD PTR rws$57[rsp], xmm0

; 3723 :             __m128i gwt = _mm_add_epi16(cb0, yws);

  003ba	66 0f 6f 84 24
	d0 02 00 00	 movdqa	 xmm0, XMMWORD PTR cb0$50[rsp]
  003c3	66 0f fd 44 24
	20		 paddw	 xmm0, XMMWORD PTR yws$7[rsp]
  003c9	66 0f 7f 84 24
	e0 02 00 00	 movdqa	 XMMWORD PTR $T51[rsp], xmm0
  003d2	66 0f 6f 84 24
	e0 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T51[rsp]
  003db	66 0f 7f 84 24
	10 03 00 00	 movdqa	 XMMWORD PTR gwt$54[rsp], xmm0

; 3724 :             __m128i bws = _mm_add_epi16(yws, cb1);

  003e4	66 0f 6f 44 24
	20		 movdqa	 xmm0, XMMWORD PTR yws$7[rsp]
  003ea	66 0f fd 84 24
	f0 02 00 00	 paddw	 xmm0, XMMWORD PTR cb1$52[rsp]
  003f3	66 0f 7f 84 24
	00 03 00 00	 movdqa	 XMMWORD PTR $T53[rsp], xmm0
  003fc	66 0f 6f 84 24
	00 03 00 00	 movdqa	 xmm0, XMMWORD PTR $T53[rsp]
  00405	66 0f 7f 84 24
	60 03 00 00	 movdqa	 XMMWORD PTR bws$59[rsp], xmm0

; 3725 :             __m128i gws = _mm_add_epi16(gwt, cr1);

  0040e	66 0f 6f 84 24
	10 03 00 00	 movdqa	 xmm0, XMMWORD PTR gwt$54[rsp]
  00417	66 0f fd 84 24
	20 03 00 00	 paddw	 xmm0, XMMWORD PTR cr1$55[rsp]
  00420	66 0f 7f 84 24
	30 03 00 00	 movdqa	 XMMWORD PTR $T56[rsp], xmm0
  00429	66 0f 6f 84 24
	30 03 00 00	 movdqa	 xmm0, XMMWORD PTR $T56[rsp]
  00432	66 0f 7f 84 24
	80 03 00 00	 movdqa	 XMMWORD PTR gws$61[rsp], xmm0

; 3726 :             
; 3727 :             // descale
; 3728 :             __m128i rw = _mm_srai_epi16(rws, 4);

  0043b	66 0f 6f 84 24
	40 03 00 00	 movdqa	 xmm0, XMMWORD PTR rws$57[rsp]
  00444	66 0f 71 e0 04	 psraw	 xmm0, 4
  00449	66 0f 7f 84 24
	50 03 00 00	 movdqa	 XMMWORD PTR $T58[rsp], xmm0
  00452	66 0f 6f 84 24
	50 03 00 00	 movdqa	 xmm0, XMMWORD PTR $T58[rsp]
  0045b	66 0f 7f 84 24
	a0 03 00 00	 movdqa	 XMMWORD PTR rw$63[rsp], xmm0

; 3729 :             __m128i bw = _mm_srai_epi16(bws, 4);

  00464	66 0f 6f 84 24
	60 03 00 00	 movdqa	 xmm0, XMMWORD PTR bws$59[rsp]
  0046d	66 0f 71 e0 04	 psraw	 xmm0, 4
  00472	66 0f 7f 84 24
	70 03 00 00	 movdqa	 XMMWORD PTR $T60[rsp], xmm0
  0047b	66 0f 6f 84 24
	70 03 00 00	 movdqa	 xmm0, XMMWORD PTR $T60[rsp]
  00484	66 0f 7f 84 24
	b0 03 00 00	 movdqa	 XMMWORD PTR bw$64[rsp], xmm0

; 3730 :             __m128i gw = _mm_srai_epi16(gws, 4);

  0048d	66 0f 6f 84 24
	80 03 00 00	 movdqa	 xmm0, XMMWORD PTR gws$61[rsp]
  00496	66 0f 71 e0 04	 psraw	 xmm0, 4
  0049b	66 0f 7f 84 24
	90 03 00 00	 movdqa	 XMMWORD PTR $T62[rsp], xmm0
  004a4	66 0f 6f 84 24
	90 03 00 00	 movdqa	 xmm0, XMMWORD PTR $T62[rsp]
  004ad	66 0f 7f 84 24
	d0 03 00 00	 movdqa	 XMMWORD PTR gw$66[rsp], xmm0

; 3731 :             
; 3732 :             // back to byte, set up for transpose
; 3733 :             __m128i brb = _mm_packus_epi16(rw, bw);

  004b6	66 0f 6f 84 24
	a0 03 00 00	 movdqa	 xmm0, XMMWORD PTR rw$63[rsp]
  004bf	66 0f 67 84 24
	b0 03 00 00	 packuswb xmm0, XMMWORD PTR bw$64[rsp]
  004c8	66 0f 7f 84 24
	c0 03 00 00	 movdqa	 XMMWORD PTR $T65[rsp], xmm0
  004d1	66 0f 6f 84 24
	c0 03 00 00	 movdqa	 xmm0, XMMWORD PTR $T65[rsp]
  004da	66 0f 7f 44 24
	60		 movdqa	 XMMWORD PTR brb$11[rsp], xmm0

; 3734 :             __m128i gxb = _mm_packus_epi16(gw, xw);

  004e0	66 0f 6f 84 24
	d0 03 00 00	 movdqa	 xmm0, XMMWORD PTR gw$66[rsp]
  004e9	66 0f 67 84 24
	e0 03 00 00	 packuswb xmm0, XMMWORD PTR xw$67[rsp]
  004f2	66 0f 7f 84 24
	f0 03 00 00	 movdqa	 XMMWORD PTR $T68[rsp], xmm0
  004fb	66 0f 6f 84 24
	f0 03 00 00	 movdqa	 xmm0, XMMWORD PTR $T68[rsp]
  00504	66 0f 7f 44 24
	70		 movdqa	 XMMWORD PTR gxb$12[rsp], xmm0

; 3735 :             
; 3736 :             // transpose to interleave channels
; 3737 :             __m128i t0 = _mm_unpacklo_epi8(brb, gxb);

  0050a	66 0f 6f 44 24
	60		 movdqa	 xmm0, XMMWORD PTR brb$11[rsp]
  00510	66 0f 60 44 24
	70		 punpcklbw xmm0, XMMWORD PTR gxb$12[rsp]
  00516	66 0f 7f 84 24
	00 04 00 00	 movdqa	 XMMWORD PTR $T69[rsp], xmm0
  0051f	66 0f 6f 84 24
	00 04 00 00	 movdqa	 xmm0, XMMWORD PTR $T69[rsp]
  00528	66 0f 7f 84 24
	80 00 00 00	 movdqa	 XMMWORD PTR t0$13[rsp], xmm0

; 3738 :             __m128i t1 = _mm_unpackhi_epi8(brb, gxb);

  00531	66 0f 6f 44 24
	60		 movdqa	 xmm0, XMMWORD PTR brb$11[rsp]
  00537	66 0f 68 44 24
	70		 punpckhbw xmm0, XMMWORD PTR gxb$12[rsp]
  0053d	66 0f 7f 84 24
	10 04 00 00	 movdqa	 XMMWORD PTR $T70[rsp], xmm0
  00546	66 0f 6f 84 24
	10 04 00 00	 movdqa	 xmm0, XMMWORD PTR $T70[rsp]
  0054f	66 0f 7f 84 24
	90 00 00 00	 movdqa	 XMMWORD PTR t1$14[rsp], xmm0

; 3739 :             __m128i o0 = _mm_unpacklo_epi16(t0, t1);

  00558	66 0f 6f 84 24
	80 00 00 00	 movdqa	 xmm0, XMMWORD PTR t0$13[rsp]
  00561	66 0f 61 84 24
	90 00 00 00	 punpcklwd xmm0, XMMWORD PTR t1$14[rsp]
  0056a	66 0f 7f 84 24
	20 04 00 00	 movdqa	 XMMWORD PTR $T71[rsp], xmm0
  00573	66 0f 6f 84 24
	20 04 00 00	 movdqa	 xmm0, XMMWORD PTR $T71[rsp]
  0057c	66 0f 7f 84 24
	40 04 00 00	 movdqa	 XMMWORD PTR o0$73[rsp], xmm0

; 3740 :             __m128i o1 = _mm_unpackhi_epi16(t0, t1);

  00585	66 0f 6f 84 24
	80 00 00 00	 movdqa	 xmm0, XMMWORD PTR t0$13[rsp]
  0058e	66 0f 69 84 24
	90 00 00 00	 punpckhwd xmm0, XMMWORD PTR t1$14[rsp]
  00597	66 0f 7f 84 24
	30 04 00 00	 movdqa	 XMMWORD PTR $T72[rsp], xmm0
  005a0	66 0f 6f 84 24
	30 04 00 00	 movdqa	 xmm0, XMMWORD PTR $T72[rsp]
  005a9	66 0f 7f 84 24
	50 04 00 00	 movdqa	 XMMWORD PTR o1$74[rsp], xmm0

; 3741 :             
; 3742 :             // store
; 3743 :             _mm_storeu_si128((__m128i *) (out + 0), o0);

  005b2	48 8b 84 24 70
	04 00 00	 mov	 rax, QWORD PTR out$[rsp]
  005ba	66 0f 6f 84 24
	40 04 00 00	 movdqa	 xmm0, XMMWORD PTR o0$73[rsp]
  005c3	f3 0f 7f 00	 movdqu	 XMMWORD PTR [rax], xmm0

; 3744 :             _mm_storeu_si128((__m128i *) (out + 16), o1);

  005c7	48 8b 84 24 70
	04 00 00	 mov	 rax, QWORD PTR out$[rsp]
  005cf	48 83 c0 10	 add	 rax, 16
  005d3	66 0f 6f 84 24
	50 04 00 00	 movdqa	 xmm0, XMMWORD PTR o1$74[rsp]
  005dc	f3 0f 7f 00	 movdqu	 XMMWORD PTR [rax], xmm0

; 3745 :             out += 32;

  005e0	48 8b 84 24 70
	04 00 00	 mov	 rax, QWORD PTR out$[rsp]
  005e8	48 83 c0 20	 add	 rax, 32			; 00000020H
  005ec	48 89 84 24 70
	04 00 00	 mov	 QWORD PTR out$[rsp], rax

; 3746 :         }

  005f4	e9 2b fb ff ff	 jmp	 $LN2@stbi__YCbC
$LN3@stbi__YCbC:
$LN8@stbi__YCbC:

; 3747 :     }
; 3748 : #endif
; 3749 :     
; 3750 : #ifdef STBI_NEON
; 3751 :     // in this version, step=3 support would be easy to add. but is there demand?
; 3752 :     if (step == 4) {
; 3753 :         // this is a fairly straightforward implementation and not super-optimized.
; 3754 :         uint8x8_t signflip = vdup_n_u8(0x80);
; 3755 :         int16x8_t cr_const0 = vdupq_n_s16(   (short) ( 1.40200f*4096.0f+0.5f));
; 3756 :         int16x8_t cr_const1 = vdupq_n_s16( - (short) ( 0.71414f*4096.0f+0.5f));
; 3757 :         int16x8_t cb_const0 = vdupq_n_s16( - (short) ( 0.34414f*4096.0f+0.5f));
; 3758 :         int16x8_t cb_const1 = vdupq_n_s16(   (short) ( 1.77200f*4096.0f+0.5f));
; 3759 :         
; 3760 :         for (; i+7 < count; i += 8) {
; 3761 :             // load
; 3762 :             uint8x8_t y_bytes  = vld1_u8(y + i);
; 3763 :             uint8x8_t cr_bytes = vld1_u8(pcr + i);
; 3764 :             uint8x8_t cb_bytes = vld1_u8(pcb + i);
; 3765 :             int8x8_t cr_biased = vreinterpret_s8_u8(vsub_u8(cr_bytes, signflip));
; 3766 :             int8x8_t cb_biased = vreinterpret_s8_u8(vsub_u8(cb_bytes, signflip));
; 3767 :             
; 3768 :             // expand to s16
; 3769 :             int16x8_t yws = vreinterpretq_s16_u16(vshll_n_u8(y_bytes, 4));
; 3770 :             int16x8_t crw = vshll_n_s8(cr_biased, 7);
; 3771 :             int16x8_t cbw = vshll_n_s8(cb_biased, 7);
; 3772 :             
; 3773 :             // color transform
; 3774 :             int16x8_t cr0 = vqdmulhq_s16(crw, cr_const0);
; 3775 :             int16x8_t cb0 = vqdmulhq_s16(cbw, cb_const0);
; 3776 :             int16x8_t cr1 = vqdmulhq_s16(crw, cr_const1);
; 3777 :             int16x8_t cb1 = vqdmulhq_s16(cbw, cb_const1);
; 3778 :             int16x8_t rws = vaddq_s16(yws, cr0);
; 3779 :             int16x8_t gws = vaddq_s16(vaddq_s16(yws, cb0), cr1);
; 3780 :             int16x8_t bws = vaddq_s16(yws, cb1);
; 3781 :             
; 3782 :             // undo scaling, round, convert to byte
; 3783 :             uint8x8x4_t o;
; 3784 :             o.val[0] = vqrshrun_n_s16(rws, 4);
; 3785 :             o.val[1] = vqrshrun_n_s16(gws, 4);
; 3786 :             o.val[2] = vqrshrun_n_s16(bws, 4);
; 3787 :             o.val[3] = vdup_n_u8(255);
; 3788 :             
; 3789 :             // store, interleaving r/g/b/a
; 3790 :             vst4_u8(out, o);
; 3791 :             out += 8*4;
; 3792 :         }
; 3793 :     }
; 3794 : #endif
; 3795 :     
; 3796 :     for (; i < count; ++i) {

  005f9	eb 08		 jmp	 SHORT $LN7@stbi__YCbC
$LN5@stbi__YCbC:
  005fb	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  005fe	ff c0		 inc	 eax
  00600	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN7@stbi__YCbC:
  00603	8b 84 24 90 04
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  0060a	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  0060d	0f 8d a7 01 00
	00		 jge	 $LN6@stbi__YCbC

; 3797 :         int y_fixed = (y[i] << 20) + (1<<19); // rounding

  00613	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00617	48 8b 8c 24 78
	04 00 00	 mov	 rcx, QWORD PTR y$[rsp]
  0061f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00623	c1 e0 14	 shl	 eax, 20
  00626	05 00 00 08 00	 add	 eax, 524288		; 00080000H
  0062b	89 44 24 10	 mov	 DWORD PTR y_fixed$4[rsp], eax

; 3798 :         int r,g,b;
; 3799 :         int cr = pcr[i] - 128;

  0062f	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00633	48 8b 8c 24 88
	04 00 00	 mov	 rcx, QWORD PTR pcr$[rsp]
  0063b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0063f	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
  00644	89 44 24 14	 mov	 DWORD PTR cr$5[rsp], eax

; 3800 :         int cb = pcb[i] - 128;

  00648	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  0064c	48 8b 8c 24 80
	04 00 00	 mov	 rcx, QWORD PTR pcb$[rsp]
  00654	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00658	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
  0065d	89 44 24 18	 mov	 DWORD PTR cb$6[rsp], eax

; 3801 :         r = y_fixed + cr* stbi__float2fixed(1.40200f);

  00661	69 44 24 14 00
	6f 16 00	 imul	 eax, DWORD PTR cr$5[rsp], 1470208 ; 00166f00H
  00669	8b 4c 24 10	 mov	 ecx, DWORD PTR y_fixed$4[rsp]
  0066d	03 c8		 add	 ecx, eax
  0066f	8b c1		 mov	 eax, ecx
  00671	89 44 24 04	 mov	 DWORD PTR r$1[rsp], eax

; 3802 :         g = y_fixed + cr*-stbi__float2fixed(0.71414f) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);

  00675	69 44 24 14 00
	93 f4 ff	 imul	 eax, DWORD PTR cr$5[rsp], -748800 ; fffffffffff49300H
  0067d	8b 4c 24 10	 mov	 ecx, DWORD PTR y_fixed$4[rsp]
  00681	03 c8		 add	 ecx, eax
  00683	8b c1		 mov	 eax, ecx
  00685	69 4c 24 18 00
	7e fa ff	 imul	 ecx, DWORD PTR cb$6[rsp], -360960 ; fffffffffffa7e00H
  0068d	81 e1 00 00 ff
	ff		 and	 ecx, -65536		; ffff0000H
  00693	03 c1		 add	 eax, ecx
  00695	89 44 24 08	 mov	 DWORD PTR g$2[rsp], eax

; 3803 :         b = y_fixed                                   +   cb* stbi__float2fixed(1.77200f);

  00699	69 44 24 18 00
	5a 1c 00	 imul	 eax, DWORD PTR cb$6[rsp], 1858048 ; 001c5a00H
  006a1	8b 4c 24 10	 mov	 ecx, DWORD PTR y_fixed$4[rsp]
  006a5	03 c8		 add	 ecx, eax
  006a7	8b c1		 mov	 eax, ecx
  006a9	89 44 24 0c	 mov	 DWORD PTR b$3[rsp], eax

; 3804 :         r >>= 20;

  006ad	8b 44 24 04	 mov	 eax, DWORD PTR r$1[rsp]
  006b1	c1 f8 14	 sar	 eax, 20
  006b4	89 44 24 04	 mov	 DWORD PTR r$1[rsp], eax

; 3805 :         g >>= 20;

  006b8	8b 44 24 08	 mov	 eax, DWORD PTR g$2[rsp]
  006bc	c1 f8 14	 sar	 eax, 20
  006bf	89 44 24 08	 mov	 DWORD PTR g$2[rsp], eax

; 3806 :         b >>= 20;

  006c3	8b 44 24 0c	 mov	 eax, DWORD PTR b$3[rsp]
  006c7	c1 f8 14	 sar	 eax, 20
  006ca	89 44 24 0c	 mov	 DWORD PTR b$3[rsp], eax

; 3807 :         if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }

  006ce	81 7c 24 04 ff
	00 00 00	 cmp	 DWORD PTR r$1[rsp], 255	; 000000ffH
  006d6	76 19		 jbe	 SHORT $LN9@stbi__YCbC
  006d8	83 7c 24 04 00	 cmp	 DWORD PTR r$1[rsp], 0
  006dd	7d 0a		 jge	 SHORT $LN10@stbi__YCbC
  006df	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR r$1[rsp], 0
  006e7	eb 08		 jmp	 SHORT $LN11@stbi__YCbC
$LN10@stbi__YCbC:
  006e9	c7 44 24 04 ff
	00 00 00	 mov	 DWORD PTR r$1[rsp], 255	; 000000ffH
$LN11@stbi__YCbC:
$LN9@stbi__YCbC:

; 3808 :         if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }

  006f1	81 7c 24 08 ff
	00 00 00	 cmp	 DWORD PTR g$2[rsp], 255	; 000000ffH
  006f9	76 19		 jbe	 SHORT $LN12@stbi__YCbC
  006fb	83 7c 24 08 00	 cmp	 DWORD PTR g$2[rsp], 0
  00700	7d 0a		 jge	 SHORT $LN13@stbi__YCbC
  00702	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR g$2[rsp], 0
  0070a	eb 08		 jmp	 SHORT $LN14@stbi__YCbC
$LN13@stbi__YCbC:
  0070c	c7 44 24 08 ff
	00 00 00	 mov	 DWORD PTR g$2[rsp], 255	; 000000ffH
$LN14@stbi__YCbC:
$LN12@stbi__YCbC:

; 3809 :         if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }

  00714	81 7c 24 0c ff
	00 00 00	 cmp	 DWORD PTR b$3[rsp], 255	; 000000ffH
  0071c	76 19		 jbe	 SHORT $LN15@stbi__YCbC
  0071e	83 7c 24 0c 00	 cmp	 DWORD PTR b$3[rsp], 0
  00723	7d 0a		 jge	 SHORT $LN16@stbi__YCbC
  00725	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR b$3[rsp], 0
  0072d	eb 08		 jmp	 SHORT $LN17@stbi__YCbC
$LN16@stbi__YCbC:
  0072f	c7 44 24 0c ff
	00 00 00	 mov	 DWORD PTR b$3[rsp], 255	; 000000ffH
$LN17@stbi__YCbC:
$LN15@stbi__YCbC:

; 3810 :         out[0] = (stbi_uc)r;

  00737	b8 01 00 00 00	 mov	 eax, 1
  0073c	48 6b c0 00	 imul	 rax, rax, 0
  00740	48 8b 8c 24 70
	04 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  00748	0f b6 54 24 04	 movzx	 edx, BYTE PTR r$1[rsp]
  0074d	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3811 :         out[1] = (stbi_uc)g;

  00750	b8 01 00 00 00	 mov	 eax, 1
  00755	48 6b c0 01	 imul	 rax, rax, 1
  00759	48 8b 8c 24 70
	04 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  00761	0f b6 54 24 08	 movzx	 edx, BYTE PTR g$2[rsp]
  00766	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3812 :         out[2] = (stbi_uc)b;

  00769	b8 01 00 00 00	 mov	 eax, 1
  0076e	48 6b c0 02	 imul	 rax, rax, 2
  00772	48 8b 8c 24 70
	04 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  0077a	0f b6 54 24 0c	 movzx	 edx, BYTE PTR b$3[rsp]
  0077f	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3813 :         out[3] = 255;

  00782	b8 01 00 00 00	 mov	 eax, 1
  00787	48 6b c0 03	 imul	 rax, rax, 3
  0078b	48 8b 8c 24 70
	04 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  00793	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 3814 :         out += step;

  00797	48 63 84 24 98
	04 00 00	 movsxd	 rax, DWORD PTR step$[rsp]
  0079f	48 8b 8c 24 70
	04 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  007a7	48 03 c8	 add	 rcx, rax
  007aa	48 8b c1	 mov	 rax, rcx
  007ad	48 89 84 24 70
	04 00 00	 mov	 QWORD PTR out$[rsp], rax

; 3815 :     }

  007b5	e9 41 fe ff ff	 jmp	 $LN5@stbi__YCbC
$LN6@stbi__YCbC:

; 3816 : }

  007ba	48 81 c4 68 04
	00 00		 add	 rsp, 1128		; 00000468H
  007c1	c3		 ret	 0
?stbi__YCbCr_to_RGB_simd@@YAXPEAEPEBE11HH@Z ENDP	; stbi__YCbCr_to_RGB_simd
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
r$1 = 0
g$2 = 4
b$3 = 8
i$ = 12
y_fixed$4 = 16
cr$5 = 20
cb$6 = 24
out$ = 48
y$ = 56
pcb$ = 64
pcr$ = 72
count$ = 80
step$ = 88
?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z PROC		; stbi__YCbCr_to_RGB_row

; 3660 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3661 :     int i;
; 3662 :     for (i=0; i < count; ++i) {

  00018	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00020	eb 0a		 jmp	 SHORT $LN4@stbi__YCbC
$LN2@stbi__YCbC:
  00022	8b 44 24 0c	 mov	 eax, DWORD PTR i$[rsp]
  00026	ff c0		 inc	 eax
  00028	89 44 24 0c	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__YCbC:
  0002c	8b 44 24 50	 mov	 eax, DWORD PTR count$[rsp]
  00030	39 44 24 0c	 cmp	 DWORD PTR i$[rsp], eax
  00034	0f 8d 84 01 00
	00		 jge	 $LN3@stbi__YCbC

; 3663 :         int y_fixed = (y[i] << 20) + (1<<19); // rounding

  0003a	48 63 44 24 0c	 movsxd	 rax, DWORD PTR i$[rsp]
  0003f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR y$[rsp]
  00044	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00048	c1 e0 14	 shl	 eax, 20
  0004b	05 00 00 08 00	 add	 eax, 524288		; 00080000H
  00050	89 44 24 10	 mov	 DWORD PTR y_fixed$4[rsp], eax

; 3664 :         int r,g,b;
; 3665 :         int cr = pcr[i] - 128;

  00054	48 63 44 24 0c	 movsxd	 rax, DWORD PTR i$[rsp]
  00059	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pcr$[rsp]
  0005e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00062	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
  00067	89 44 24 14	 mov	 DWORD PTR cr$5[rsp], eax

; 3666 :         int cb = pcb[i] - 128;

  0006b	48 63 44 24 0c	 movsxd	 rax, DWORD PTR i$[rsp]
  00070	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pcb$[rsp]
  00075	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00079	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
  0007e	89 44 24 18	 mov	 DWORD PTR cb$6[rsp], eax

; 3667 :         r = y_fixed +  cr* stbi__float2fixed(1.40200f);

  00082	69 44 24 14 00
	6f 16 00	 imul	 eax, DWORD PTR cr$5[rsp], 1470208 ; 00166f00H
  0008a	8b 4c 24 10	 mov	 ecx, DWORD PTR y_fixed$4[rsp]
  0008e	03 c8		 add	 ecx, eax
  00090	8b c1		 mov	 eax, ecx
  00092	89 04 24	 mov	 DWORD PTR r$1[rsp], eax

; 3668 :         g = y_fixed + (cr*-stbi__float2fixed(0.71414f)) + ((cb*-stbi__float2fixed(0.34414f)) & 0xffff0000);

  00095	69 44 24 14 00
	93 f4 ff	 imul	 eax, DWORD PTR cr$5[rsp], -748800 ; fffffffffff49300H
  0009d	8b 4c 24 10	 mov	 ecx, DWORD PTR y_fixed$4[rsp]
  000a1	03 c8		 add	 ecx, eax
  000a3	8b c1		 mov	 eax, ecx
  000a5	69 4c 24 18 00
	7e fa ff	 imul	 ecx, DWORD PTR cb$6[rsp], -360960 ; fffffffffffa7e00H
  000ad	81 e1 00 00 ff
	ff		 and	 ecx, -65536		; ffff0000H
  000b3	03 c1		 add	 eax, ecx
  000b5	89 44 24 04	 mov	 DWORD PTR g$2[rsp], eax

; 3669 :         b = y_fixed                                     +   cb* stbi__float2fixed(1.77200f);

  000b9	69 44 24 18 00
	5a 1c 00	 imul	 eax, DWORD PTR cb$6[rsp], 1858048 ; 001c5a00H
  000c1	8b 4c 24 10	 mov	 ecx, DWORD PTR y_fixed$4[rsp]
  000c5	03 c8		 add	 ecx, eax
  000c7	8b c1		 mov	 eax, ecx
  000c9	89 44 24 08	 mov	 DWORD PTR b$3[rsp], eax

; 3670 :         r >>= 20;

  000cd	8b 04 24	 mov	 eax, DWORD PTR r$1[rsp]
  000d0	c1 f8 14	 sar	 eax, 20
  000d3	89 04 24	 mov	 DWORD PTR r$1[rsp], eax

; 3671 :         g >>= 20;

  000d6	8b 44 24 04	 mov	 eax, DWORD PTR g$2[rsp]
  000da	c1 f8 14	 sar	 eax, 20
  000dd	89 44 24 04	 mov	 DWORD PTR g$2[rsp], eax

; 3672 :         b >>= 20;

  000e1	8b 44 24 08	 mov	 eax, DWORD PTR b$3[rsp]
  000e5	c1 f8 14	 sar	 eax, 20
  000e8	89 44 24 08	 mov	 DWORD PTR b$3[rsp], eax

; 3673 :         if ((unsigned) r > 255) { if (r < 0) r = 0; else r = 255; }

  000ec	81 3c 24 ff 00
	00 00		 cmp	 DWORD PTR r$1[rsp], 255	; 000000ffH
  000f3	76 16		 jbe	 SHORT $LN5@stbi__YCbC
  000f5	83 3c 24 00	 cmp	 DWORD PTR r$1[rsp], 0
  000f9	7d 09		 jge	 SHORT $LN6@stbi__YCbC
  000fb	c7 04 24 00 00
	00 00		 mov	 DWORD PTR r$1[rsp], 0
  00102	eb 07		 jmp	 SHORT $LN7@stbi__YCbC
$LN6@stbi__YCbC:
  00104	c7 04 24 ff 00
	00 00		 mov	 DWORD PTR r$1[rsp], 255	; 000000ffH
$LN7@stbi__YCbC:
$LN5@stbi__YCbC:

; 3674 :         if ((unsigned) g > 255) { if (g < 0) g = 0; else g = 255; }

  0010b	81 7c 24 04 ff
	00 00 00	 cmp	 DWORD PTR g$2[rsp], 255	; 000000ffH
  00113	76 19		 jbe	 SHORT $LN8@stbi__YCbC
  00115	83 7c 24 04 00	 cmp	 DWORD PTR g$2[rsp], 0
  0011a	7d 0a		 jge	 SHORT $LN9@stbi__YCbC
  0011c	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR g$2[rsp], 0
  00124	eb 08		 jmp	 SHORT $LN10@stbi__YCbC
$LN9@stbi__YCbC:
  00126	c7 44 24 04 ff
	00 00 00	 mov	 DWORD PTR g$2[rsp], 255	; 000000ffH
$LN10@stbi__YCbC:
$LN8@stbi__YCbC:

; 3675 :         if ((unsigned) b > 255) { if (b < 0) b = 0; else b = 255; }

  0012e	81 7c 24 08 ff
	00 00 00	 cmp	 DWORD PTR b$3[rsp], 255	; 000000ffH
  00136	76 19		 jbe	 SHORT $LN11@stbi__YCbC
  00138	83 7c 24 08 00	 cmp	 DWORD PTR b$3[rsp], 0
  0013d	7d 0a		 jge	 SHORT $LN12@stbi__YCbC
  0013f	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR b$3[rsp], 0
  00147	eb 08		 jmp	 SHORT $LN13@stbi__YCbC
$LN12@stbi__YCbC:
  00149	c7 44 24 08 ff
	00 00 00	 mov	 DWORD PTR b$3[rsp], 255	; 000000ffH
$LN13@stbi__YCbC:
$LN11@stbi__YCbC:

; 3676 :         out[0] = (stbi_uc)r;

  00151	b8 01 00 00 00	 mov	 eax, 1
  00156	48 6b c0 00	 imul	 rax, rax, 0
  0015a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  0015f	0f b6 14 24	 movzx	 edx, BYTE PTR r$1[rsp]
  00163	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3677 :         out[1] = (stbi_uc)g;

  00166	b8 01 00 00 00	 mov	 eax, 1
  0016b	48 6b c0 01	 imul	 rax, rax, 1
  0016f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  00174	0f b6 54 24 04	 movzx	 edx, BYTE PTR g$2[rsp]
  00179	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3678 :         out[2] = (stbi_uc)b;

  0017c	b8 01 00 00 00	 mov	 eax, 1
  00181	48 6b c0 02	 imul	 rax, rax, 2
  00185	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  0018a	0f b6 54 24 08	 movzx	 edx, BYTE PTR b$3[rsp]
  0018f	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3679 :         out[3] = 255;

  00192	b8 01 00 00 00	 mov	 eax, 1
  00197	48 6b c0 03	 imul	 rax, rax, 3
  0019b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  001a0	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 3680 :         out += step;

  001a4	48 63 44 24 58	 movsxd	 rax, DWORD PTR step$[rsp]
  001a9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR out$[rsp]
  001ae	48 03 c8	 add	 rcx, rax
  001b1	48 8b c1	 mov	 rax, rcx
  001b4	48 89 44 24 30	 mov	 QWORD PTR out$[rsp], rax

; 3681 :     }

  001b9	e9 64 fe ff ff	 jmp	 $LN2@stbi__YCbC
$LN3@stbi__YCbC:

; 3682 : }

  001be	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001c2	c3		 ret	 0
?stbi__YCbCr_to_RGB_row@@YAXPEAEPEBE11HH@Z ENDP		; stbi__YCbCr_to_RGB_row
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
i$ = 0
j$ = 4
out$ = 32
in_near$ = 40
in_far$ = 48
w$ = 56
hs$ = 64
?stbi__resample_row_generic@@YAPEAEPEAE00HH@Z PROC	; stbi__resample_row_generic

; 3646 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 18	 sub	 rsp, 24

; 3647 :     // resample with nearest-neighbor
; 3648 :     int i,j;
; 3649 :     STBI_NOTUSED(in_far);
; 3650 :     for (i=0; i < w; ++i)

  00018	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  0001f	eb 08		 jmp	 SHORT $LN4@stbi__resa
$LN2@stbi__resa:
  00021	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00024	ff c0		 inc	 eax
  00026	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__resa:
  00029	8b 44 24 38	 mov	 eax, DWORD PTR w$[rsp]
  0002d	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  00030	7d 47		 jge	 SHORT $LN3@stbi__resa

; 3651 :         for (j=0; j < hs; ++j)

  00032	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  0003a	eb 0a		 jmp	 SHORT $LN7@stbi__resa
$LN5@stbi__resa:
  0003c	8b 44 24 04	 mov	 eax, DWORD PTR j$[rsp]
  00040	ff c0		 inc	 eax
  00042	89 44 24 04	 mov	 DWORD PTR j$[rsp], eax
$LN7@stbi__resa:
  00046	8b 44 24 40	 mov	 eax, DWORD PTR hs$[rsp]
  0004a	39 44 24 04	 cmp	 DWORD PTR j$[rsp], eax
  0004e	7d 27		 jge	 SHORT $LN6@stbi__resa

; 3652 :         out[i*hs+j] = in_near[i];

  00050	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00054	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  00057	0f af 4c 24 40	 imul	 ecx, DWORD PTR hs$[rsp]
  0005c	03 4c 24 04	 add	 ecx, DWORD PTR j$[rsp]
  00060	48 63 c9	 movsxd	 rcx, ecx
  00063	48 8b 54 24 20	 mov	 rdx, QWORD PTR out$[rsp]
  00068	4c 8b 44 24 28	 mov	 r8, QWORD PTR in_near$[rsp]
  0006d	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00072	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00075	eb c5		 jmp	 SHORT $LN5@stbi__resa
$LN6@stbi__resa:
  00077	eb a8		 jmp	 SHORT $LN2@stbi__resa
$LN3@stbi__resa:

; 3653 :     return out;

  00079	48 8b 44 24 20	 mov	 rax, QWORD PTR out$[rsp]

; 3654 : }

  0007e	48 83 c4 18	 add	 rsp, 24
  00082	c3		 ret	 0
?stbi__resample_row_generic@@YAPEAEPEAE00HH@Z ENDP	; stbi__resample_row_generic
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
i$ = 0
t1$ = 4
t0$ = 8
tv78 = 12
curr$1 = 16
zero$2 = 32
nearw$3 = 48
curb$4 = 64
even$5 = 80
odd$6 = 96
$T7 = 112
$T8 = 128
$T9 = 144
farb$10 = 160
$T11 = 176
nearb$12 = 192
$T13 = 208
farw$14 = 224
$T15 = 240
$T16 = 256
nears$17 = 272
diff$18 = 288
$T19 = 304
$T20 = 320
$T21 = 336
prv0$22 = 352
$T23 = 368
nxt0$24 = 384
$T25 = 400
$T26 = 416
$T27 = 432
prev$28 = 448
$T29 = 464
next$30 = 480
$T31 = 496
curs$32 = 512
bias$33 = 528
$T34 = 544
prvd$35 = 560
$T36 = 576
nxtd$37 = 592
$T38 = 608
$T39 = 624
$T40 = 640
int0$41 = 656
$T42 = 672
int1$43 = 688
$T44 = 704
de0$45 = 720
de1$46 = 736
$T47 = 752
outv$48 = 768
out$ = 800
in_near$ = 808
in_far$ = 816
w$ = 824
hs$ = 832
?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z PROC	; stbi__resample_row_hv_2_simd

; 3530 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 18 03
	00 00		 sub	 rsp, 792		; 00000318H

; 3531 :     // need to generate 2x2 samples for every one in input
; 3532 :     int i=0,t0,t1;

  0001b	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0

; 3533 :     
; 3534 :     if (w == 1) {

  00022	83 bc 24 38 03
	00 00 01	 cmp	 DWORD PTR w$[rsp], 1
  0002a	75 77		 jne	 SHORT $LN8@stbi__resa

; 3535 :         out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);

  0002c	b8 01 00 00 00	 mov	 eax, 1
  00031	48 6b c0 00	 imul	 rax, rax, 0
  00035	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR in_near$[rsp]
  0003d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00041	6b c0 03	 imul	 eax, eax, 3
  00044	b9 01 00 00 00	 mov	 ecx, 1
  00049	48 6b c9 00	 imul	 rcx, rcx, 0
  0004d	48 8b 94 24 30
	03 00 00	 mov	 rdx, QWORD PTR in_far$[rsp]
  00055	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00059	8d 44 08 02	 lea	 eax, DWORD PTR [rax+rcx+2]
  0005d	c1 f8 02	 sar	 eax, 2
  00060	89 44 24 0c	 mov	 DWORD PTR tv78[rsp], eax
  00064	b8 01 00 00 00	 mov	 eax, 1
  00069	48 6b c0 01	 imul	 rax, rax, 1
  0006d	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  00075	0f b6 54 24 0c	 movzx	 edx, BYTE PTR tv78[rsp]
  0007a	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  0007d	b8 01 00 00 00	 mov	 eax, 1
  00082	48 6b c0 00	 imul	 rax, rax, 0
  00086	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  0008e	0f b6 54 24 0c	 movzx	 edx, BYTE PTR tv78[rsp]
  00093	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3536 :         return out;

  00096	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR out$[rsp]
  0009e	e9 ba 05 00 00	 jmp	 $LN1@stbi__resa
$LN8@stbi__resa:

; 3537 :     }
; 3538 :     
; 3539 :     t1 = 3*in_near[0] + in_far[0];

  000a3	b8 01 00 00 00	 mov	 eax, 1
  000a8	48 6b c0 00	 imul	 rax, rax, 0
  000ac	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR in_near$[rsp]
  000b4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000b8	6b c0 03	 imul	 eax, eax, 3
  000bb	b9 01 00 00 00	 mov	 ecx, 1
  000c0	48 6b c9 00	 imul	 rcx, rcx, 0
  000c4	48 8b 94 24 30
	03 00 00	 mov	 rdx, QWORD PTR in_far$[rsp]
  000cc	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000d0	03 c1		 add	 eax, ecx
  000d2	89 44 24 04	 mov	 DWORD PTR t1$[rsp], eax

; 3540 :     // process groups of 8 pixels for as long as we can.
; 3541 :     // note we can't handle the last pixel in a row in this loop
; 3542 :     // because we need to handle the filter boundary conditions.
; 3543 :     for (; i < ((w-1) & ~7); i += 8) {

  000d6	eb 09		 jmp	 SHORT $LN4@stbi__resa
$LN2@stbi__resa:
  000d8	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  000db	83 c0 08	 add	 eax, 8
  000de	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__resa:
  000e1	8b 84 24 38 03
	00 00		 mov	 eax, DWORD PTR w$[rsp]
  000e8	ff c8		 dec	 eax
  000ea	83 e0 f8	 and	 eax, -8
  000ed	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  000f0	0f 8d 4c 04 00
	00		 jge	 $LN3@stbi__resa

; 3544 : #if defined(STBI_SSE2)
; 3545 :         // load and perform the vertical filtering pass
; 3546 :         // this uses 3*x + y = 4*x + (y - x)
; 3547 :         __m128i zero  = _mm_setzero_si128();

  000f6	66 0f ef c0	 pxor	 xmm0, xmm0
  000fa	66 0f 7f 44 24
	70		 movdqa	 XMMWORD PTR $T7[rsp], xmm0
  00100	66 0f 6f 44 24
	70		 movdqa	 xmm0, XMMWORD PTR $T7[rsp]
  00106	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR zero$2[rsp], xmm0

; 3548 :         __m128i farb  = _mm_loadl_epi64((__m128i *) (in_far + i));

  0010c	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00110	48 8b 8c 24 30
	03 00 00	 mov	 rcx, QWORD PTR in_far$[rsp]
  00118	48 03 c8	 add	 rcx, rax
  0011b	48 8b c1	 mov	 rax, rcx
  0011e	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [rax]
  00122	66 0f 7f 84 24
	80 00 00 00	 movdqa	 XMMWORD PTR $T8[rsp], xmm0
  0012b	66 0f 6f 84 24
	80 00 00 00	 movdqa	 xmm0, XMMWORD PTR $T8[rsp]
  00134	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR farb$10[rsp], xmm0

; 3549 :         __m128i nearb = _mm_loadl_epi64((__m128i *) (in_near + i));

  0013d	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00141	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR in_near$[rsp]
  00149	48 03 c8	 add	 rcx, rax
  0014c	48 8b c1	 mov	 rax, rcx
  0014f	f3 0f 7e 00	 movq	 xmm0, QWORD PTR [rax]
  00153	66 0f 7f 84 24
	90 00 00 00	 movdqa	 XMMWORD PTR $T9[rsp], xmm0
  0015c	66 0f 6f 84 24
	90 00 00 00	 movdqa	 xmm0, XMMWORD PTR $T9[rsp]
  00165	66 0f 7f 84 24
	c0 00 00 00	 movdqa	 XMMWORD PTR nearb$12[rsp], xmm0

; 3550 :         __m128i farw  = _mm_unpacklo_epi8(farb, zero);

  0016e	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR farb$10[rsp]
  00177	66 0f 60 44 24
	20		 punpcklbw xmm0, XMMWORD PTR zero$2[rsp]
  0017d	66 0f 7f 84 24
	b0 00 00 00	 movdqa	 XMMWORD PTR $T11[rsp], xmm0
  00186	66 0f 6f 84 24
	b0 00 00 00	 movdqa	 xmm0, XMMWORD PTR $T11[rsp]
  0018f	66 0f 7f 84 24
	e0 00 00 00	 movdqa	 XMMWORD PTR farw$14[rsp], xmm0

; 3551 :         __m128i nearw = _mm_unpacklo_epi8(nearb, zero);

  00198	66 0f 6f 84 24
	c0 00 00 00	 movdqa	 xmm0, XMMWORD PTR nearb$12[rsp]
  001a1	66 0f 60 44 24
	20		 punpcklbw xmm0, XMMWORD PTR zero$2[rsp]
  001a7	66 0f 7f 84 24
	d0 00 00 00	 movdqa	 XMMWORD PTR $T13[rsp], xmm0
  001b0	66 0f 6f 84 24
	d0 00 00 00	 movdqa	 xmm0, XMMWORD PTR $T13[rsp]
  001b9	66 0f 7f 44 24
	30		 movdqa	 XMMWORD PTR nearw$3[rsp], xmm0

; 3552 :         __m128i diff  = _mm_sub_epi16(farw, nearw);

  001bf	66 0f 6f 84 24
	e0 00 00 00	 movdqa	 xmm0, XMMWORD PTR farw$14[rsp]
  001c8	66 0f f9 44 24
	30		 psubw	 xmm0, XMMWORD PTR nearw$3[rsp]
  001ce	66 0f 7f 84 24
	f0 00 00 00	 movdqa	 XMMWORD PTR $T15[rsp], xmm0
  001d7	66 0f 6f 84 24
	f0 00 00 00	 movdqa	 xmm0, XMMWORD PTR $T15[rsp]
  001e0	66 0f 7f 84 24
	20 01 00 00	 movdqa	 XMMWORD PTR diff$18[rsp], xmm0

; 3553 :         __m128i nears = _mm_slli_epi16(nearw, 2);

  001e9	66 0f 6f 44 24
	30		 movdqa	 xmm0, XMMWORD PTR nearw$3[rsp]
  001ef	66 0f 71 f0 02	 psllw	 xmm0, 2
  001f4	66 0f 7f 84 24
	00 01 00 00	 movdqa	 XMMWORD PTR $T16[rsp], xmm0
  001fd	66 0f 6f 84 24
	00 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T16[rsp]
  00206	66 0f 7f 84 24
	10 01 00 00	 movdqa	 XMMWORD PTR nears$17[rsp], xmm0

; 3554 :         __m128i curr  = _mm_add_epi16(nears, diff); // current row

  0020f	66 0f 6f 84 24
	10 01 00 00	 movdqa	 xmm0, XMMWORD PTR nears$17[rsp]
  00218	66 0f fd 84 24
	20 01 00 00	 paddw	 xmm0, XMMWORD PTR diff$18[rsp]
  00221	66 0f 7f 84 24
	30 01 00 00	 movdqa	 XMMWORD PTR $T19[rsp], xmm0
  0022a	66 0f 6f 84 24
	30 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T19[rsp]
  00233	66 0f 7f 44 24
	10		 movdqa	 XMMWORD PTR curr$1[rsp], xmm0

; 3555 :         
; 3556 :         // horizontal filter works the same based on shifted vers of current
; 3557 :         // row. "prev" is current row shifted right by 1 pixel; we need to
; 3558 :         // insert the previous pixel value (from t1).
; 3559 :         // "next" is current row shifted left by 1 pixel, with first pixel
; 3560 :         // of next block of 8 pixels added in.
; 3561 :         __m128i prv0 = _mm_slli_si128(curr, 2);

  00239	66 0f 6f 44 24
	10		 movdqa	 xmm0, XMMWORD PTR curr$1[rsp]
  0023f	66 0f 73 f8 02	 pslldq	 xmm0, 2
  00244	66 0f 7f 84 24
	40 01 00 00	 movdqa	 XMMWORD PTR $T20[rsp], xmm0
  0024d	66 0f 6f 84 24
	40 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T20[rsp]
  00256	66 0f 7f 84 24
	60 01 00 00	 movdqa	 XMMWORD PTR prv0$22[rsp], xmm0

; 3562 :         __m128i nxt0 = _mm_srli_si128(curr, 2);

  0025f	66 0f 6f 44 24
	10		 movdqa	 xmm0, XMMWORD PTR curr$1[rsp]
  00265	66 0f 73 d8 02	 psrldq	 xmm0, 2
  0026a	66 0f 7f 84 24
	50 01 00 00	 movdqa	 XMMWORD PTR $T21[rsp], xmm0
  00273	66 0f 6f 84 24
	50 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T21[rsp]
  0027c	66 0f 7f 84 24
	80 01 00 00	 movdqa	 XMMWORD PTR nxt0$24[rsp], xmm0

; 3563 :         __m128i prev = _mm_insert_epi16(prv0, t1, 0);

  00285	66 0f 6f 84 24
	60 01 00 00	 movdqa	 xmm0, XMMWORD PTR prv0$22[rsp]
  0028e	66 0f c4 44 24
	04 00		 pinsrw	 xmm0, DWORD PTR t1$[rsp], 0
  00295	66 0f 7f 84 24
	70 01 00 00	 movdqa	 XMMWORD PTR $T23[rsp], xmm0
  0029e	66 0f 6f 84 24
	70 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T23[rsp]
  002a7	66 0f 7f 84 24
	c0 01 00 00	 movdqa	 XMMWORD PTR prev$28[rsp], xmm0

; 3564 :         __m128i next = _mm_insert_epi16(nxt0, 3*in_near[i+8] + in_far[i+8], 7);

  002b0	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  002b3	83 c0 08	 add	 eax, 8
  002b6	48 98		 cdqe
  002b8	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR in_near$[rsp]
  002c0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002c4	6b c0 03	 imul	 eax, eax, 3
  002c7	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  002ca	83 c1 08	 add	 ecx, 8
  002cd	48 63 c9	 movsxd	 rcx, ecx
  002d0	48 8b 94 24 30
	03 00 00	 mov	 rdx, QWORD PTR in_far$[rsp]
  002d8	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  002dc	03 c1		 add	 eax, ecx
  002de	66 0f 6f 84 24
	80 01 00 00	 movdqa	 xmm0, XMMWORD PTR nxt0$24[rsp]
  002e7	66 0f c4 c0 07	 pinsrw	 xmm0, eax, 7
  002ec	66 0f 7f 84 24
	90 01 00 00	 movdqa	 XMMWORD PTR $T25[rsp], xmm0
  002f5	66 0f 6f 84 24
	90 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T25[rsp]
  002fe	66 0f 7f 84 24
	e0 01 00 00	 movdqa	 XMMWORD PTR next$30[rsp], xmm0

; 3565 :         
; 3566 :         // horizontal filter, polyphase implementation since it's convenient:
; 3567 :         // even pixels = 3*cur + prev = cur*4 + (prev - cur)
; 3568 :         // odd  pixels = 3*cur + next = cur*4 + (next - cur)
; 3569 :         // note the shared term.
; 3570 :         __m128i bias  = _mm_set1_epi16(8);

  00307	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@00080008000800080008000800080008
  0030f	66 0f 7f 84 24
	a0 01 00 00	 movdqa	 XMMWORD PTR $T26[rsp], xmm0
  00318	66 0f 6f 84 24
	a0 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T26[rsp]
  00321	66 0f 7f 84 24
	10 02 00 00	 movdqa	 XMMWORD PTR bias$33[rsp], xmm0

; 3571 :         __m128i curs = _mm_slli_epi16(curr, 2);

  0032a	66 0f 6f 44 24
	10		 movdqa	 xmm0, XMMWORD PTR curr$1[rsp]
  00330	66 0f 71 f0 02	 psllw	 xmm0, 2
  00335	66 0f 7f 84 24
	b0 01 00 00	 movdqa	 XMMWORD PTR $T27[rsp], xmm0
  0033e	66 0f 6f 84 24
	b0 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T27[rsp]
  00347	66 0f 7f 84 24
	00 02 00 00	 movdqa	 XMMWORD PTR curs$32[rsp], xmm0

; 3572 :         __m128i prvd = _mm_sub_epi16(prev, curr);

  00350	66 0f 6f 84 24
	c0 01 00 00	 movdqa	 xmm0, XMMWORD PTR prev$28[rsp]
  00359	66 0f f9 44 24
	10		 psubw	 xmm0, XMMWORD PTR curr$1[rsp]
  0035f	66 0f 7f 84 24
	d0 01 00 00	 movdqa	 XMMWORD PTR $T29[rsp], xmm0
  00368	66 0f 6f 84 24
	d0 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T29[rsp]
  00371	66 0f 7f 84 24
	30 02 00 00	 movdqa	 XMMWORD PTR prvd$35[rsp], xmm0

; 3573 :         __m128i nxtd = _mm_sub_epi16(next, curr);

  0037a	66 0f 6f 84 24
	e0 01 00 00	 movdqa	 xmm0, XMMWORD PTR next$30[rsp]
  00383	66 0f f9 44 24
	10		 psubw	 xmm0, XMMWORD PTR curr$1[rsp]
  00389	66 0f 7f 84 24
	f0 01 00 00	 movdqa	 XMMWORD PTR $T31[rsp], xmm0
  00392	66 0f 6f 84 24
	f0 01 00 00	 movdqa	 xmm0, XMMWORD PTR $T31[rsp]
  0039b	66 0f 7f 84 24
	50 02 00 00	 movdqa	 XMMWORD PTR nxtd$37[rsp], xmm0

; 3574 :         __m128i curb = _mm_add_epi16(curs, bias);

  003a4	66 0f 6f 84 24
	00 02 00 00	 movdqa	 xmm0, XMMWORD PTR curs$32[rsp]
  003ad	66 0f fd 84 24
	10 02 00 00	 paddw	 xmm0, XMMWORD PTR bias$33[rsp]
  003b6	66 0f 7f 84 24
	20 02 00 00	 movdqa	 XMMWORD PTR $T34[rsp], xmm0
  003bf	66 0f 6f 84 24
	20 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T34[rsp]
  003c8	66 0f 7f 44 24
	40		 movdqa	 XMMWORD PTR curb$4[rsp], xmm0

; 3575 :         __m128i even = _mm_add_epi16(prvd, curb);

  003ce	66 0f 6f 84 24
	30 02 00 00	 movdqa	 xmm0, XMMWORD PTR prvd$35[rsp]
  003d7	66 0f fd 44 24
	40		 paddw	 xmm0, XMMWORD PTR curb$4[rsp]
  003dd	66 0f 7f 84 24
	40 02 00 00	 movdqa	 XMMWORD PTR $T36[rsp], xmm0
  003e6	66 0f 6f 84 24
	40 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T36[rsp]
  003ef	66 0f 7f 44 24
	50		 movdqa	 XMMWORD PTR even$5[rsp], xmm0

; 3576 :         __m128i odd  = _mm_add_epi16(nxtd, curb);

  003f5	66 0f 6f 84 24
	50 02 00 00	 movdqa	 xmm0, XMMWORD PTR nxtd$37[rsp]
  003fe	66 0f fd 44 24
	40		 paddw	 xmm0, XMMWORD PTR curb$4[rsp]
  00404	66 0f 7f 84 24
	60 02 00 00	 movdqa	 XMMWORD PTR $T38[rsp], xmm0
  0040d	66 0f 6f 84 24
	60 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T38[rsp]
  00416	66 0f 7f 44 24
	60		 movdqa	 XMMWORD PTR odd$6[rsp], xmm0

; 3577 :         
; 3578 :         // interleave even and odd pixels, then undo scaling.
; 3579 :         __m128i int0 = _mm_unpacklo_epi16(even, odd);

  0041c	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR even$5[rsp]
  00422	66 0f 61 44 24
	60		 punpcklwd xmm0, XMMWORD PTR odd$6[rsp]
  00428	66 0f 7f 84 24
	70 02 00 00	 movdqa	 XMMWORD PTR $T39[rsp], xmm0
  00431	66 0f 6f 84 24
	70 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T39[rsp]
  0043a	66 0f 7f 84 24
	90 02 00 00	 movdqa	 XMMWORD PTR int0$41[rsp], xmm0

; 3580 :         __m128i int1 = _mm_unpackhi_epi16(even, odd);

  00443	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR even$5[rsp]
  00449	66 0f 69 44 24
	60		 punpckhwd xmm0, XMMWORD PTR odd$6[rsp]
  0044f	66 0f 7f 84 24
	80 02 00 00	 movdqa	 XMMWORD PTR $T40[rsp], xmm0
  00458	66 0f 6f 84 24
	80 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T40[rsp]
  00461	66 0f 7f 84 24
	b0 02 00 00	 movdqa	 XMMWORD PTR int1$43[rsp], xmm0

; 3581 :         __m128i de0  = _mm_srli_epi16(int0, 4);

  0046a	66 0f 6f 84 24
	90 02 00 00	 movdqa	 xmm0, XMMWORD PTR int0$41[rsp]
  00473	66 0f 71 d0 04	 psrlw	 xmm0, 4
  00478	66 0f 7f 84 24
	a0 02 00 00	 movdqa	 XMMWORD PTR $T42[rsp], xmm0
  00481	66 0f 6f 84 24
	a0 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T42[rsp]
  0048a	66 0f 7f 84 24
	d0 02 00 00	 movdqa	 XMMWORD PTR de0$45[rsp], xmm0

; 3582 :         __m128i de1  = _mm_srli_epi16(int1, 4);

  00493	66 0f 6f 84 24
	b0 02 00 00	 movdqa	 xmm0, XMMWORD PTR int1$43[rsp]
  0049c	66 0f 71 d0 04	 psrlw	 xmm0, 4
  004a1	66 0f 7f 84 24
	c0 02 00 00	 movdqa	 XMMWORD PTR $T44[rsp], xmm0
  004aa	66 0f 6f 84 24
	c0 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T44[rsp]
  004b3	66 0f 7f 84 24
	e0 02 00 00	 movdqa	 XMMWORD PTR de1$46[rsp], xmm0

; 3583 :         
; 3584 :         // pack and write output
; 3585 :         __m128i outv = _mm_packus_epi16(de0, de1);

  004bc	66 0f 6f 84 24
	d0 02 00 00	 movdqa	 xmm0, XMMWORD PTR de0$45[rsp]
  004c5	66 0f 67 84 24
	e0 02 00 00	 packuswb xmm0, XMMWORD PTR de1$46[rsp]
  004ce	66 0f 7f 84 24
	f0 02 00 00	 movdqa	 XMMWORD PTR $T47[rsp], xmm0
  004d7	66 0f 6f 84 24
	f0 02 00 00	 movdqa	 xmm0, XMMWORD PTR $T47[rsp]
  004e0	66 0f 7f 84 24
	00 03 00 00	 movdqa	 XMMWORD PTR outv$48[rsp], xmm0

; 3586 :         _mm_storeu_si128((__m128i *) (out + i*2), outv);

  004e9	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  004ec	03 c0		 add	 eax, eax
  004ee	48 98		 cdqe
  004f0	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  004f8	48 03 c8	 add	 rcx, rax
  004fb	48 8b c1	 mov	 rax, rcx
  004fe	66 0f 6f 84 24
	00 03 00 00	 movdqa	 xmm0, XMMWORD PTR outv$48[rsp]
  00507	f3 0f 7f 00	 movdqu	 XMMWORD PTR [rax], xmm0

; 3587 : #elif defined(STBI_NEON)
; 3588 :         // load and perform the vertical filtering pass
; 3589 :         // this uses 3*x + y = 4*x + (y - x)
; 3590 :         uint8x8_t farb  = vld1_u8(in_far + i);
; 3591 :         uint8x8_t nearb = vld1_u8(in_near + i);
; 3592 :         int16x8_t diff  = vreinterpretq_s16_u16(vsubl_u8(farb, nearb));
; 3593 :         int16x8_t nears = vreinterpretq_s16_u16(vshll_n_u8(nearb, 2));
; 3594 :         int16x8_t curr  = vaddq_s16(nears, diff); // current row
; 3595 :         
; 3596 :         // horizontal filter works the same based on shifted vers of current
; 3597 :         // row. "prev" is current row shifted right by 1 pixel; we need to
; 3598 :         // insert the previous pixel value (from t1).
; 3599 :         // "next" is current row shifted left by 1 pixel, with first pixel
; 3600 :         // of next block of 8 pixels added in.
; 3601 :         int16x8_t prv0 = vextq_s16(curr, curr, 7);
; 3602 :         int16x8_t nxt0 = vextq_s16(curr, curr, 1);
; 3603 :         int16x8_t prev = vsetq_lane_s16(t1, prv0, 0);
; 3604 :         int16x8_t next = vsetq_lane_s16(3*in_near[i+8] + in_far[i+8], nxt0, 7);
; 3605 :         
; 3606 :         // horizontal filter, polyphase implementation since it's convenient:
; 3607 :         // even pixels = 3*cur + prev = cur*4 + (prev - cur)
; 3608 :         // odd  pixels = 3*cur + next = cur*4 + (next - cur)
; 3609 :         // note the shared term.
; 3610 :         int16x8_t curs = vshlq_n_s16(curr, 2);
; 3611 :         int16x8_t prvd = vsubq_s16(prev, curr);
; 3612 :         int16x8_t nxtd = vsubq_s16(next, curr);
; 3613 :         int16x8_t even = vaddq_s16(curs, prvd);
; 3614 :         int16x8_t odd  = vaddq_s16(curs, nxtd);
; 3615 :         
; 3616 :         // undo scaling and round, then store with even/odd phases interleaved
; 3617 :         uint8x8x2_t o;
; 3618 :         o.val[0] = vqrshrun_n_s16(even, 4);
; 3619 :         o.val[1] = vqrshrun_n_s16(odd,  4);
; 3620 :         vst2_u8(out + i*2, o);
; 3621 : #endif
; 3622 :         
; 3623 :         // "previous" value for next iter
; 3624 :         t1 = 3*in_near[i+7] + in_far[i+7];

  0050b	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0050e	83 c0 07	 add	 eax, 7
  00511	48 98		 cdqe
  00513	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR in_near$[rsp]
  0051b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0051f	6b c0 03	 imul	 eax, eax, 3
  00522	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  00525	83 c1 07	 add	 ecx, 7
  00528	48 63 c9	 movsxd	 rcx, ecx
  0052b	48 8b 94 24 30
	03 00 00	 mov	 rdx, QWORD PTR in_far$[rsp]
  00533	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00537	03 c1		 add	 eax, ecx
  00539	89 44 24 04	 mov	 DWORD PTR t1$[rsp], eax

; 3625 :     }

  0053d	e9 96 fb ff ff	 jmp	 $LN2@stbi__resa
$LN3@stbi__resa:

; 3626 :     
; 3627 :     t0 = t1;

  00542	8b 44 24 04	 mov	 eax, DWORD PTR t1$[rsp]
  00546	89 44 24 08	 mov	 DWORD PTR t0$[rsp], eax

; 3628 :     t1 = 3*in_near[i] + in_far[i];

  0054a	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  0054e	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR in_near$[rsp]
  00556	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0055a	6b c0 03	 imul	 eax, eax, 3
  0055d	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  00561	48 8b 94 24 30
	03 00 00	 mov	 rdx, QWORD PTR in_far$[rsp]
  00569	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0056d	03 c1		 add	 eax, ecx
  0056f	89 44 24 04	 mov	 DWORD PTR t1$[rsp], eax

; 3629 :     out[i*2] = stbi__div16(3*t1 + t0 + 8);

  00573	6b 44 24 04 03	 imul	 eax, DWORD PTR t1$[rsp], 3
  00578	8b 4c 24 08	 mov	 ecx, DWORD PTR t0$[rsp]
  0057c	8d 44 08 08	 lea	 eax, DWORD PTR [rax+rcx+8]
  00580	c1 f8 04	 sar	 eax, 4
  00583	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  00586	03 c9		 add	 ecx, ecx
  00588	48 63 c9	 movsxd	 rcx, ecx
  0058b	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  00593	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3630 :     
; 3631 :     for (++i; i < w; ++i) {

  00596	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00599	ff c0		 inc	 eax
  0059b	89 04 24	 mov	 DWORD PTR i$[rsp], eax
  0059e	eb 08		 jmp	 SHORT $LN7@stbi__resa
$LN5@stbi__resa:
  005a0	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  005a3	ff c0		 inc	 eax
  005a5	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN7@stbi__resa:
  005a8	8b 84 24 38 03
	00 00		 mov	 eax, DWORD PTR w$[rsp]
  005af	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  005b2	7d 7e		 jge	 SHORT $LN6@stbi__resa

; 3632 :         t0 = t1;

  005b4	8b 44 24 04	 mov	 eax, DWORD PTR t1$[rsp]
  005b8	89 44 24 08	 mov	 DWORD PTR t0$[rsp], eax

; 3633 :         t1 = 3*in_near[i]+in_far[i];

  005bc	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  005c0	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR in_near$[rsp]
  005c8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  005cc	6b c0 03	 imul	 eax, eax, 3
  005cf	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  005d3	48 8b 94 24 30
	03 00 00	 mov	 rdx, QWORD PTR in_far$[rsp]
  005db	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  005df	03 c1		 add	 eax, ecx
  005e1	89 44 24 04	 mov	 DWORD PTR t1$[rsp], eax

; 3634 :         out[i*2-1] = stbi__div16(3*t0 + t1 + 8);

  005e5	6b 44 24 08 03	 imul	 eax, DWORD PTR t0$[rsp], 3
  005ea	8b 4c 24 04	 mov	 ecx, DWORD PTR t1$[rsp]
  005ee	8d 44 08 08	 lea	 eax, DWORD PTR [rax+rcx+8]
  005f2	c1 f8 04	 sar	 eax, 4
  005f5	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  005f8	8d 4c 09 ff	 lea	 ecx, DWORD PTR [rcx+rcx-1]
  005fc	48 63 c9	 movsxd	 rcx, ecx
  005ff	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  00607	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3635 :         out[i*2  ] = stbi__div16(3*t1 + t0 + 8);

  0060a	6b 44 24 04 03	 imul	 eax, DWORD PTR t1$[rsp], 3
  0060f	8b 4c 24 08	 mov	 ecx, DWORD PTR t0$[rsp]
  00613	8d 44 08 08	 lea	 eax, DWORD PTR [rax+rcx+8]
  00617	c1 f8 04	 sar	 eax, 4
  0061a	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  0061d	d1 e1		 shl	 ecx, 1
  0061f	48 63 c9	 movsxd	 rcx, ecx
  00622	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  0062a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3636 :     }

  0062d	e9 6e ff ff ff	 jmp	 $LN5@stbi__resa
$LN6@stbi__resa:

; 3637 :     out[w*2-1] = stbi__div4(t1+2);

  00632	8b 44 24 04	 mov	 eax, DWORD PTR t1$[rsp]
  00636	83 c0 02	 add	 eax, 2
  00639	c1 f8 02	 sar	 eax, 2
  0063c	8b 8c 24 38 03
	00 00		 mov	 ecx, DWORD PTR w$[rsp]
  00643	8d 4c 09 ff	 lea	 ecx, DWORD PTR [rcx+rcx-1]
  00647	48 63 c9	 movsxd	 rcx, ecx
  0064a	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR out$[rsp]
  00652	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3638 :     
; 3639 :     STBI_NOTUSED(hs);
; 3640 :     
; 3641 :     return out;

  00655	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR out$[rsp]
$LN1@stbi__resa:

; 3642 : }

  0065d	48 81 c4 18 03
	00 00		 add	 rsp, 792		; 00000318H
  00664	c3		 ret	 0
?stbi__resample_row_hv_2_simd@@YAPEAEPEAE00HH@Z ENDP	; stbi__resample_row_hv_2_simd
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
i$ = 0
t1$ = 4
tv78 = 8
t0$ = 12
out$ = 32
in_near$ = 40
in_far$ = 48
w$ = 56
hs$ = 64
?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z PROC		; stbi__resample_row_hv_2

; 3505 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 18	 sub	 rsp, 24

; 3506 :     // need to generate 2x2 samples for every one in input
; 3507 :     int i,t0,t1;
; 3508 :     if (w == 1) {

  00018	83 7c 24 38 01	 cmp	 DWORD PTR w$[rsp], 1
  0001d	75 68		 jne	 SHORT $LN5@stbi__resa

; 3509 :         out[0] = out[1] = stbi__div4(3*in_near[0] + in_far[0] + 2);

  0001f	b8 01 00 00 00	 mov	 eax, 1
  00024	48 6b c0 00	 imul	 rax, rax, 0
  00028	48 8b 4c 24 28	 mov	 rcx, QWORD PTR in_near$[rsp]
  0002d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00031	6b c0 03	 imul	 eax, eax, 3
  00034	b9 01 00 00 00	 mov	 ecx, 1
  00039	48 6b c9 00	 imul	 rcx, rcx, 0
  0003d	48 8b 54 24 30	 mov	 rdx, QWORD PTR in_far$[rsp]
  00042	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00046	8d 44 08 02	 lea	 eax, DWORD PTR [rax+rcx+2]
  0004a	c1 f8 02	 sar	 eax, 2
  0004d	89 44 24 08	 mov	 DWORD PTR tv78[rsp], eax
  00051	b8 01 00 00 00	 mov	 eax, 1
  00056	48 6b c0 01	 imul	 rax, rax, 1
  0005a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR out$[rsp]
  0005f	0f b6 54 24 08	 movzx	 edx, BYTE PTR tv78[rsp]
  00064	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00067	b8 01 00 00 00	 mov	 eax, 1
  0006c	48 6b c0 00	 imul	 rax, rax, 0
  00070	48 8b 4c 24 20	 mov	 rcx, QWORD PTR out$[rsp]
  00075	0f b6 54 24 08	 movzx	 edx, BYTE PTR tv78[rsp]
  0007a	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 3510 :         return out;

  0007d	48 8b 44 24 20	 mov	 rax, QWORD PTR out$[rsp]
  00082	e9 f3 00 00 00	 jmp	 $LN1@stbi__resa
$LN5@stbi__resa:

; 3511 :     }
; 3512 :     
; 3513 :     t1 = 3*in_near[0] + in_far[0];

  00087	b8 01 00 00 00	 mov	 eax, 1
  0008c	48 6b c0 00	 imul	 rax, rax, 0
  00090	48 8b 4c 24 28	 mov	 rcx, QWORD PTR in_near$[rsp]
  00095	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00099	6b c0 03	 imul	 eax, eax, 3
  0009c	b9 01 00 00 00	 mov	 ecx, 1
  000a1	48 6b c9 00	 imul	 rcx, rcx, 0
  000a5	48 8b 54 24 30	 mov	 rdx, QWORD PTR in_far$[rsp]
  000aa	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000ae	03 c1		 add	 eax, ecx
  000b0	89 44 24 04	 mov	 DWORD PTR t1$[rsp], eax

; 3514 :     out[0] = stbi__div4(t1+2);

  000b4	8b 44 24 04	 mov	 eax, DWORD PTR t1$[rsp]
  000b8	83 c0 02	 add	 eax, 2
  000bb	c1 f8 02	 sar	 eax, 2
  000be	b9 01 00 00 00	 mov	 ecx, 1
  000c3	48 6b c9 00	 imul	 rcx, rcx, 0
  000c7	48 8b 54 24 20	 mov	 rdx, QWORD PTR out$[rsp]
  000cc	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3515 :     for (i=1; i < w; ++i) {

  000cf	c7 04 24 01 00
	00 00		 mov	 DWORD PTR i$[rsp], 1
  000d6	eb 08		 jmp	 SHORT $LN4@stbi__resa
$LN2@stbi__resa:
  000d8	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  000db	ff c0		 inc	 eax
  000dd	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__resa:
  000e0	8b 44 24 38	 mov	 eax, DWORD PTR w$[rsp]
  000e4	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  000e7	7d 6f		 jge	 SHORT $LN3@stbi__resa

; 3516 :         t0 = t1;

  000e9	8b 44 24 04	 mov	 eax, DWORD PTR t1$[rsp]
  000ed	89 44 24 0c	 mov	 DWORD PTR t0$[rsp], eax

; 3517 :         t1 = 3*in_near[i]+in_far[i];

  000f1	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000f5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR in_near$[rsp]
  000fa	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000fe	6b c0 03	 imul	 eax, eax, 3
  00101	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  00105	48 8b 54 24 30	 mov	 rdx, QWORD PTR in_far$[rsp]
  0010a	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0010e	03 c1		 add	 eax, ecx
  00110	89 44 24 04	 mov	 DWORD PTR t1$[rsp], eax

; 3518 :         out[i*2-1] = stbi__div16(3*t0 + t1 + 8);

  00114	6b 44 24 0c 03	 imul	 eax, DWORD PTR t0$[rsp], 3
  00119	8b 4c 24 04	 mov	 ecx, DWORD PTR t1$[rsp]
  0011d	8d 44 08 08	 lea	 eax, DWORD PTR [rax+rcx+8]
  00121	c1 f8 04	 sar	 eax, 4
  00124	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  00127	8d 4c 09 ff	 lea	 ecx, DWORD PTR [rcx+rcx-1]
  0012b	48 63 c9	 movsxd	 rcx, ecx
  0012e	48 8b 54 24 20	 mov	 rdx, QWORD PTR out$[rsp]
  00133	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3519 :         out[i*2  ] = stbi__div16(3*t1 + t0 + 8);

  00136	6b 44 24 04 03	 imul	 eax, DWORD PTR t1$[rsp], 3
  0013b	8b 4c 24 0c	 mov	 ecx, DWORD PTR t0$[rsp]
  0013f	8d 44 08 08	 lea	 eax, DWORD PTR [rax+rcx+8]
  00143	c1 f8 04	 sar	 eax, 4
  00146	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  00149	d1 e1		 shl	 ecx, 1
  0014b	48 63 c9	 movsxd	 rcx, ecx
  0014e	48 8b 54 24 20	 mov	 rdx, QWORD PTR out$[rsp]
  00153	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3520 :     }

  00156	eb 80		 jmp	 SHORT $LN2@stbi__resa
$LN3@stbi__resa:

; 3521 :     out[w*2-1] = stbi__div4(t1+2);

  00158	8b 44 24 04	 mov	 eax, DWORD PTR t1$[rsp]
  0015c	83 c0 02	 add	 eax, 2
  0015f	c1 f8 02	 sar	 eax, 2
  00162	8b 4c 24 38	 mov	 ecx, DWORD PTR w$[rsp]
  00166	8d 4c 09 ff	 lea	 ecx, DWORD PTR [rcx+rcx-1]
  0016a	48 63 c9	 movsxd	 rcx, ecx
  0016d	48 8b 54 24 20	 mov	 rdx, QWORD PTR out$[rsp]
  00172	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3522 :     
; 3523 :     STBI_NOTUSED(hs);
; 3524 :     
; 3525 :     return out;

  00175	48 8b 44 24 20	 mov	 rax, QWORD PTR out$[rsp]
$LN1@stbi__resa:

; 3526 : }

  0017a	48 83 c4 18	 add	 rsp, 24
  0017e	c3		 ret	 0
?stbi__resample_row_hv_2@@YAPEAEPEAE00HH@Z ENDP		; stbi__resample_row_hv_2
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
i$ = 0
n$1 = 4
input$ = 8
out$ = 32
in_near$ = 40
in_far$ = 48
w$ = 56
hs$ = 64
?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z PROC		; stbi__resample_row_h_2

; 3475 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 18	 sub	 rsp, 24

; 3476 :     // need to generate two samples horizontally for every one in input
; 3477 :     int i;
; 3478 :     stbi_uc *input = in_near;

  00018	48 8b 44 24 28	 mov	 rax, QWORD PTR in_near$[rsp]
  0001d	48 89 44 24 08	 mov	 QWORD PTR input$[rsp], rax

; 3479 :     
; 3480 :     if (w == 1) {

  00022	83 7c 24 38 01	 cmp	 DWORD PTR w$[rsp], 1
  00027	75 52		 jne	 SHORT $LN5@stbi__resa

; 3481 :         // if only one sample, can't do any interpolation
; 3482 :         out[0] = out[1] = input[0];

  00029	b8 01 00 00 00	 mov	 eax, 1
  0002e	48 6b c0 00	 imul	 rax, rax, 0
  00032	b9 01 00 00 00	 mov	 ecx, 1
  00037	48 6b c9 01	 imul	 rcx, rcx, 1
  0003b	48 8b 54 24 20	 mov	 rdx, QWORD PTR out$[rsp]
  00040	4c 8b 44 24 08	 mov	 r8, QWORD PTR input$[rsp]
  00045	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0004a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0004d	b8 01 00 00 00	 mov	 eax, 1
  00052	48 6b c0 01	 imul	 rax, rax, 1
  00056	b9 01 00 00 00	 mov	 ecx, 1
  0005b	48 6b c9 00	 imul	 rcx, rcx, 0
  0005f	48 8b 54 24 20	 mov	 rdx, QWORD PTR out$[rsp]
  00064	4c 8b 44 24 20	 mov	 r8, QWORD PTR out$[rsp]
  00069	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0006e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3483 :         return out;

  00071	48 8b 44 24 20	 mov	 rax, QWORD PTR out$[rsp]
  00076	e9 5a 01 00 00	 jmp	 $LN1@stbi__resa
$LN5@stbi__resa:

; 3484 :     }
; 3485 :     
; 3486 :     out[0] = input[0];

  0007b	b8 01 00 00 00	 mov	 eax, 1
  00080	48 6b c0 00	 imul	 rax, rax, 0
  00084	b9 01 00 00 00	 mov	 ecx, 1
  00089	48 6b c9 00	 imul	 rcx, rcx, 0
  0008d	48 8b 54 24 20	 mov	 rdx, QWORD PTR out$[rsp]
  00092	4c 8b 44 24 08	 mov	 r8, QWORD PTR input$[rsp]
  00097	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0009c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3487 :     out[1] = stbi__div4(input[0]*3 + input[1] + 2);

  0009f	b8 01 00 00 00	 mov	 eax, 1
  000a4	48 6b c0 00	 imul	 rax, rax, 0
  000a8	48 8b 4c 24 08	 mov	 rcx, QWORD PTR input$[rsp]
  000ad	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000b1	6b c0 03	 imul	 eax, eax, 3
  000b4	b9 01 00 00 00	 mov	 ecx, 1
  000b9	48 6b c9 01	 imul	 rcx, rcx, 1
  000bd	48 8b 54 24 08	 mov	 rdx, QWORD PTR input$[rsp]
  000c2	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000c6	8d 44 08 02	 lea	 eax, DWORD PTR [rax+rcx+2]
  000ca	c1 f8 02	 sar	 eax, 2
  000cd	b9 01 00 00 00	 mov	 ecx, 1
  000d2	48 6b c9 01	 imul	 rcx, rcx, 1
  000d6	48 8b 54 24 20	 mov	 rdx, QWORD PTR out$[rsp]
  000db	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3488 :     for (i=1; i < w-1; ++i) {

  000de	c7 04 24 01 00
	00 00		 mov	 DWORD PTR i$[rsp], 1
  000e5	eb 08		 jmp	 SHORT $LN4@stbi__resa
$LN2@stbi__resa:
  000e7	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  000ea	ff c0		 inc	 eax
  000ec	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__resa:
  000ef	8b 44 24 38	 mov	 eax, DWORD PTR w$[rsp]
  000f3	ff c8		 dec	 eax
  000f5	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  000f8	7d 74		 jge	 SHORT $LN3@stbi__resa

; 3489 :         int n = 3*input[i]+2;

  000fa	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000fe	48 8b 4c 24 08	 mov	 rcx, QWORD PTR input$[rsp]
  00103	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00107	6b c0 03	 imul	 eax, eax, 3
  0010a	83 c0 02	 add	 eax, 2
  0010d	89 44 24 04	 mov	 DWORD PTR n$1[rsp], eax

; 3490 :         out[i*2+0] = stbi__div4(n+input[i-1]);

  00111	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00114	ff c8		 dec	 eax
  00116	48 98		 cdqe
  00118	48 8b 4c 24 08	 mov	 rcx, QWORD PTR input$[rsp]
  0011d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00121	8b 4c 24 04	 mov	 ecx, DWORD PTR n$1[rsp]
  00125	03 c8		 add	 ecx, eax
  00127	8b c1		 mov	 eax, ecx
  00129	c1 f8 02	 sar	 eax, 2
  0012c	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  0012f	03 c9		 add	 ecx, ecx
  00131	48 63 c9	 movsxd	 rcx, ecx
  00134	48 8b 54 24 20	 mov	 rdx, QWORD PTR out$[rsp]
  00139	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3491 :         out[i*2+1] = stbi__div4(n+input[i+1]);

  0013c	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0013f	ff c0		 inc	 eax
  00141	48 98		 cdqe
  00143	48 8b 4c 24 08	 mov	 rcx, QWORD PTR input$[rsp]
  00148	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0014c	8b 4c 24 04	 mov	 ecx, DWORD PTR n$1[rsp]
  00150	03 c8		 add	 ecx, eax
  00152	8b c1		 mov	 eax, ecx
  00154	c1 f8 02	 sar	 eax, 2
  00157	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  0015a	8d 4c 09 01	 lea	 ecx, DWORD PTR [rcx+rcx+1]
  0015e	48 63 c9	 movsxd	 rcx, ecx
  00161	48 8b 54 24 20	 mov	 rdx, QWORD PTR out$[rsp]
  00166	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3492 :     }

  00169	e9 79 ff ff ff	 jmp	 $LN2@stbi__resa
$LN3@stbi__resa:

; 3493 :     out[i*2+0] = stbi__div4(input[w-2]*3 + input[w-1] + 2);

  0016e	8b 44 24 38	 mov	 eax, DWORD PTR w$[rsp]
  00172	83 e8 02	 sub	 eax, 2
  00175	48 98		 cdqe
  00177	48 8b 4c 24 08	 mov	 rcx, QWORD PTR input$[rsp]
  0017c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00180	6b c0 03	 imul	 eax, eax, 3
  00183	8b 4c 24 38	 mov	 ecx, DWORD PTR w$[rsp]
  00187	ff c9		 dec	 ecx
  00189	48 63 c9	 movsxd	 rcx, ecx
  0018c	48 8b 54 24 08	 mov	 rdx, QWORD PTR input$[rsp]
  00191	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00195	8d 44 08 02	 lea	 eax, DWORD PTR [rax+rcx+2]
  00199	c1 f8 02	 sar	 eax, 2
  0019c	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  0019f	03 c9		 add	 ecx, ecx
  001a1	48 63 c9	 movsxd	 rcx, ecx
  001a4	48 8b 54 24 20	 mov	 rdx, QWORD PTR out$[rsp]
  001a9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3494 :     out[i*2+1] = input[w-1];

  001ac	8b 44 24 38	 mov	 eax, DWORD PTR w$[rsp]
  001b0	ff c8		 dec	 eax
  001b2	48 98		 cdqe
  001b4	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  001b7	8d 4c 09 01	 lea	 ecx, DWORD PTR [rcx+rcx+1]
  001bb	48 63 c9	 movsxd	 rcx, ecx
  001be	48 8b 54 24 20	 mov	 rdx, QWORD PTR out$[rsp]
  001c3	4c 8b 44 24 08	 mov	 r8, QWORD PTR input$[rsp]
  001c8	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  001cd	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3495 :     
; 3496 :     STBI_NOTUSED(in_far);
; 3497 :     STBI_NOTUSED(hs);
; 3498 :     
; 3499 :     return out;

  001d0	48 8b 44 24 20	 mov	 rax, QWORD PTR out$[rsp]
$LN1@stbi__resa:

; 3500 : }

  001d5	48 83 c4 18	 add	 rsp, 24
  001d9	c3		 ret	 0
?stbi__resample_row_h_2@@YAPEAEPEAE00HH@Z ENDP		; stbi__resample_row_h_2
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
i$ = 0
out$ = 32
in_near$ = 40
in_far$ = 48
w$ = 56
hs$ = 64
?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z PROC		; stbi__resample_row_v_2

; 3465 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 18	 sub	 rsp, 24

; 3466 :     // need to generate two samples vertically for every one in input
; 3467 :     int i;
; 3468 :     STBI_NOTUSED(hs);
; 3469 :     for (i=0; i < w; ++i)

  00018	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  0001f	eb 08		 jmp	 SHORT $LN4@stbi__resa
$LN2@stbi__resa:
  00021	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00024	ff c0		 inc	 eax
  00026	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__resa:
  00029	8b 44 24 38	 mov	 eax, DWORD PTR w$[rsp]
  0002d	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  00030	7d 32		 jge	 SHORT $LN3@stbi__resa

; 3470 :         out[i] = stbi__div4(3*in_near[i] + in_far[i] + 2);

  00032	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00036	48 8b 4c 24 28	 mov	 rcx, QWORD PTR in_near$[rsp]
  0003b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0003f	6b c0 03	 imul	 eax, eax, 3
  00042	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  00046	48 8b 54 24 30	 mov	 rdx, QWORD PTR in_far$[rsp]
  0004b	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0004f	8d 44 08 02	 lea	 eax, DWORD PTR [rax+rcx+2]
  00053	c1 f8 02	 sar	 eax, 2
  00056	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  0005a	48 8b 54 24 20	 mov	 rdx, QWORD PTR out$[rsp]
  0005f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00062	eb bd		 jmp	 SHORT $LN2@stbi__resa
$LN3@stbi__resa:

; 3471 :     return out;

  00064	48 8b 44 24 20	 mov	 rax, QWORD PTR out$[rsp]

; 3472 : }

  00069	48 83 c4 18	 add	 rsp, 24
  0006d	c3		 ret	 0
?stbi__resample_row_v_2@@YAPEAEPEAE00HH@Z ENDP		; stbi__resample_row_v_2
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
out$ = 8
in_near$ = 16
in_far$ = 24
w$ = 32
hs$ = 40
?resample_row_1@@YAPEAEPEAE00HH@Z PROC			; resample_row_1

; 3456 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 3457 :     STBI_NOTUSED(out);
; 3458 :     STBI_NOTUSED(in_far);
; 3459 :     STBI_NOTUSED(w);
; 3460 :     STBI_NOTUSED(hs);
; 3461 :     return in_near;

  00014	48 8b 44 24 10	 mov	 rax, QWORD PTR in_near$[rsp]

; 3462 : }

  00019	c3		 ret	 0
?resample_row_1@@YAPEAEPEAE00HH@Z ENDP			; resample_row_1
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
m$ = 32
Ld$1 = 36
NL$2 = 40
j$ = 64
?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z PROC	; stbi__decode_jpeg_image

; 3412 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3413 :     int m;
; 3414 :     for (m = 0; m < 4; m++) {

  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR m$[rsp], 0
  00011	eb 0a		 jmp	 SHORT $LN4@stbi__deco
$LN2@stbi__deco:
  00013	8b 44 24 20	 mov	 eax, DWORD PTR m$[rsp]
  00017	ff c0		 inc	 eax
  00019	89 44 24 20	 mov	 DWORD PTR m$[rsp], eax
$LN4@stbi__deco:
  0001d	83 7c 24 20 04	 cmp	 DWORD PTR m$[rsp], 4
  00022	7d 36		 jge	 SHORT $LN3@stbi__deco

; 3415 :         j->img_comp[m].raw_data = NULL;

  00024	48 63 44 24 20	 movsxd	 rax, DWORD PTR m$[rsp]
  00029	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0002d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00032	48 c7 84 01 d8
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18136], 0

; 3416 :         j->img_comp[m].raw_coeff = NULL;

  0003e	48 63 44 24 20	 movsxd	 rax, DWORD PTR m$[rsp]
  00043	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00047	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  0004c	48 c7 84 01 e0
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18144], 0

; 3417 :     }

  00058	eb b9		 jmp	 SHORT $LN2@stbi__deco
$LN3@stbi__deco:

; 3418 :     j->restart_interval = 0;

  0005a	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0005f	c7 80 68 48 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+18536], 0

; 3419 :     if (!stbi__decode_jpeg_header(j, STBI__SCAN_load)) return 0;

  00069	33 d2		 xor	 edx, edx
  0006b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00070	e8 00 00 00 00	 call	 ?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z ; stbi__decode_jpeg_header
  00075	85 c0		 test	 eax, eax
  00077	75 07		 jne	 SHORT $LN7@stbi__deco
  00079	33 c0		 xor	 eax, eax
  0007b	e9 79 01 00 00	 jmp	 $LN1@stbi__deco
$LN7@stbi__deco:

; 3420 :     m = stbi__get_marker(j);

  00080	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00085	e8 00 00 00 00	 call	 ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ; stbi__get_marker
  0008a	0f b6 c0	 movzx	 eax, al
  0008d	89 44 24 20	 mov	 DWORD PTR m$[rsp], eax
$LN5@stbi__deco:

; 3421 :     while (!stbi__EOI(m)) {

  00091	81 7c 24 20 d9
	00 00 00	 cmp	 DWORD PTR m$[rsp], 217	; 000000d9H
  00099	0f 84 3d 01 00
	00		 je	 $LN6@stbi__deco

; 3422 :         if (stbi__SOS(m)) {

  0009f	81 7c 24 20 da
	00 00 00	 cmp	 DWORD PTR m$[rsp], 218	; 000000daH
  000a7	0f 85 8d 00 00
	00		 jne	 $LN8@stbi__deco

; 3423 :             if (!stbi__process_scan_header(j)) return 0;

  000ad	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  000b2	e8 00 00 00 00	 call	 ?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z ; stbi__process_scan_header
  000b7	85 c0		 test	 eax, eax
  000b9	75 07		 jne	 SHORT $LN10@stbi__deco
  000bb	33 c0		 xor	 eax, eax
  000bd	e9 37 01 00 00	 jmp	 $LN1@stbi__deco
$LN10@stbi__deco:

; 3424 :             if (!stbi__parse_entropy_coded_data(j)) return 0;

  000c2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  000c7	e8 00 00 00 00	 call	 ?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z ; stbi__parse_entropy_coded_data
  000cc	85 c0		 test	 eax, eax
  000ce	75 07		 jne	 SHORT $LN11@stbi__deco
  000d0	33 c0		 xor	 eax, eax
  000d2	e9 22 01 00 00	 jmp	 $LN1@stbi__deco
$LN11@stbi__deco:

; 3425 :             if (j->marker == STBI__MARKER_none ) {

  000d7	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  000dc	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  000e3	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000e8	75 15		 jne	 SHORT $LN12@stbi__deco

; 3426 :                 j->marker = stbi__skip_jpeg_junk_at_end(j);

  000ea	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  000ef	e8 00 00 00 00	 call	 ?stbi__skip_jpeg_junk_at_end@@YAEPEAUstbi__jpeg@@@Z ; stbi__skip_jpeg_junk_at_end
  000f4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  000f9	88 81 28 48 00
	00		 mov	 BYTE PTR [rcx+18472], al
$LN12@stbi__deco:

; 3427 :                 // if we reach eof without hitting a marker, stbi__get_marker() below will fail and we'll eventually return 0
; 3428 :             }
; 3429 :             m = stbi__get_marker(j);

  000ff	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00104	e8 00 00 00 00	 call	 ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ; stbi__get_marker
  00109	0f b6 c0	 movzx	 eax, al
  0010c	89 44 24 20	 mov	 DWORD PTR m$[rsp], eax

; 3430 :             if (STBI__RESTART(m))

  00110	81 7c 24 20 d0
	00 00 00	 cmp	 DWORD PTR m$[rsp], 208	; 000000d0H
  00118	7c 1b		 jl	 SHORT $LN13@stbi__deco
  0011a	81 7c 24 20 d7
	00 00 00	 cmp	 DWORD PTR m$[rsp], 215	; 000000d7H
  00122	7f 11		 jg	 SHORT $LN13@stbi__deco

; 3431 :                 m = stbi__get_marker(j);

  00124	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00129	e8 00 00 00 00	 call	 ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ; stbi__get_marker
  0012e	0f b6 c0	 movzx	 eax, al
  00131	89 44 24 20	 mov	 DWORD PTR m$[rsp], eax
$LN13@stbi__deco:
  00135	e9 9d 00 00 00	 jmp	 $LN9@stbi__deco
$LN8@stbi__deco:

; 3432 :         } else if (stbi__DNL(m)) {

  0013a	81 7c 24 20 dc
	00 00 00	 cmp	 DWORD PTR m$[rsp], 220	; 000000dcH
  00142	75 69		 jne	 SHORT $LN14@stbi__deco

; 3433 :             int Ld = stbi__get16be(j->s);

  00144	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00149	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0014c	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  00151	89 44 24 24	 mov	 DWORD PTR Ld$1[rsp], eax

; 3434 :             stbi__uint32 NL = stbi__get16be(j->s);

  00155	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0015a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0015d	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  00162	89 44 24 28	 mov	 DWORD PTR NL$2[rsp], eax

; 3435 :             if (Ld != 4) return stbi__err("bad DNL len", "Corrupt JPEG");

  00166	83 7c 24 24 04	 cmp	 DWORD PTR Ld$1[rsp], 4
  0016b	74 0e		 je	 SHORT $LN16@stbi__deco
  0016d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79072
  00174	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00179	eb 7e		 jmp	 SHORT $LN1@stbi__deco
$LN16@stbi__deco:

; 3436 :             if (NL != j->s->img_y) return stbi__err("bad DNL height", "Corrupt JPEG");

  0017b	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00180	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00183	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00186	39 44 24 28	 cmp	 DWORD PTR NL$2[rsp], eax
  0018a	74 0e		 je	 SHORT $LN17@stbi__deco
  0018c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79074
  00193	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00198	eb 5f		 jmp	 SHORT $LN1@stbi__deco
$LN17@stbi__deco:

; 3437 :             m = stbi__get_marker(j);

  0019a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  0019f	e8 00 00 00 00	 call	 ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ; stbi__get_marker
  001a4	0f b6 c0	 movzx	 eax, al
  001a7	89 44 24 20	 mov	 DWORD PTR m$[rsp], eax

; 3438 :         } else {

  001ab	eb 2a		 jmp	 SHORT $LN15@stbi__deco
$LN14@stbi__deco:

; 3439 :             if (!stbi__process_marker(j, m)) return 1;

  001ad	8b 54 24 20	 mov	 edx, DWORD PTR m$[rsp]
  001b1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  001b6	e8 00 00 00 00	 call	 ?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z ; stbi__process_marker
  001bb	85 c0		 test	 eax, eax
  001bd	75 07		 jne	 SHORT $LN18@stbi__deco
  001bf	b8 01 00 00 00	 mov	 eax, 1
  001c4	eb 33		 jmp	 SHORT $LN1@stbi__deco
$LN18@stbi__deco:

; 3440 :             m = stbi__get_marker(j);

  001c6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  001cb	e8 00 00 00 00	 call	 ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ; stbi__get_marker
  001d0	0f b6 c0	 movzx	 eax, al
  001d3	89 44 24 20	 mov	 DWORD PTR m$[rsp], eax
$LN15@stbi__deco:
$LN9@stbi__deco:

; 3441 :         }
; 3442 :     }

  001d7	e9 b5 fe ff ff	 jmp	 $LN5@stbi__deco
$LN6@stbi__deco:

; 3443 :     if (j->progressive)

  001dc	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  001e1	83 b8 30 48 00
	00 00		 cmp	 DWORD PTR [rax+18480], 0
  001e8	74 0a		 je	 SHORT $LN19@stbi__deco

; 3444 :         stbi__jpeg_finish(j);

  001ea	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  001ef	e8 00 00 00 00	 call	 ?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z ; stbi__jpeg_finish
$LN19@stbi__deco:

; 3445 :     return 1;

  001f4	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__deco:

; 3446 : }

  001f9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001fd	c3		 ret	 0
?stbi__decode_jpeg_image@@YAHPEAUstbi__jpeg@@@Z ENDP	; stbi__decode_jpeg_image
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
x$1 = 32
j$ = 64
?stbi__skip_jpeg_junk_at_end@@YAEPEAUstbi__jpeg@@@Z PROC ; stbi__skip_jpeg_junk_at_end

; 3389 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN2@stbi__skip:

; 3390 :     // some JPEGs have junk at end, skip over it but if we find what looks
; 3391 :     // like a valid marker, resume there
; 3392 :     while (!stbi__at_eof(j->s)) {

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0000e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00011	e8 00 00 00 00	 call	 ?stbi__at_eof@@YAHPEAUstbi__context@@@Z ; stbi__at_eof
  00016	85 c0		 test	 eax, eax
  00018	75 63		 jne	 SHORT $LN3@stbi__skip

; 3393 :         stbi_uc x = stbi__get8(j->s);

  0001a	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0001f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00022	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00027	88 44 24 20	 mov	 BYTE PTR x$1[rsp], al
$LN4@stbi__skip:

; 3394 :         while (x == 0xff) { // might be a marker

  0002b	0f b6 44 24 20	 movzx	 eax, BYTE PTR x$1[rsp]
  00030	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00035	75 44		 jne	 SHORT $LN5@stbi__skip

; 3395 :             if (stbi__at_eof(j->s)) return STBI__MARKER_none;

  00037	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0003c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003f	e8 00 00 00 00	 call	 ?stbi__at_eof@@YAHPEAUstbi__context@@@Z ; stbi__at_eof
  00044	85 c0		 test	 eax, eax
  00046	74 04		 je	 SHORT $LN6@stbi__skip
  00048	b0 ff		 mov	 al, 255			; 000000ffH
  0004a	eb 33		 jmp	 SHORT $LN1@stbi__skip
$LN6@stbi__skip:

; 3396 :             x = stbi__get8(j->s);

  0004c	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00051	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00054	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00059	88 44 24 20	 mov	 BYTE PTR x$1[rsp], al

; 3397 :             if (x != 0x00 && x != 0xff) {

  0005d	0f b6 44 24 20	 movzx	 eax, BYTE PTR x$1[rsp]
  00062	85 c0		 test	 eax, eax
  00064	74 13		 je	 SHORT $LN7@stbi__skip
  00066	0f b6 44 24 20	 movzx	 eax, BYTE PTR x$1[rsp]
  0006b	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00070	74 07		 je	 SHORT $LN7@stbi__skip

; 3398 :                 // not a stuffed zero or lead-in to another marker, looks
; 3399 :                 // like an actual marker, return it
; 3400 :                 return x;

  00072	0f b6 44 24 20	 movzx	 eax, BYTE PTR x$1[rsp]
  00077	eb 06		 jmp	 SHORT $LN1@stbi__skip
$LN7@stbi__skip:

; 3401 :             }
; 3402 :             // stuffed zero has x=0 now which ends the loop, meaning we go
; 3403 :             // back to regular scan loop.
; 3404 :             // repeated 0xff keeps trying to read the next byte of the marker.
; 3405 :         }

  00079	eb b0		 jmp	 SHORT $LN4@stbi__skip
$LN5@stbi__skip:

; 3406 :     }

  0007b	eb 8c		 jmp	 SHORT $LN2@stbi__skip
$LN3@stbi__skip:

; 3407 :     return STBI__MARKER_none;

  0007d	b0 ff		 mov	 al, 255			; 000000ffH
$LN1@stbi__skip:

; 3408 : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
?stbi__skip_jpeg_junk_at_end@@YAEPEAUstbi__jpeg@@@Z ENDP ; stbi__skip_jpeg_junk_at_end
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
m$ = 32
tv131 = 36
z$ = 64
scan$ = 72
?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z PROC	; stbi__decode_jpeg_header

; 3365 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3366 :     int m;
; 3367 :     z->jfif = 0;

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  00012	c7 80 48 48 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+18504], 0

; 3368 :     z->app14_color_transform = -1; // valid values are 0,1,2

  0001c	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  00021	c7 80 4c 48 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+18508], -1

; 3369 :     z->marker = STBI__MARKER_none; // initialize cached marker to empty

  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  00030	c6 80 28 48 00
	00 ff		 mov	 BYTE PTR [rax+18472], 255 ; 000000ffH

; 3370 :     m = stbi__get_marker(z);

  00037	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  0003c	e8 00 00 00 00	 call	 ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ; stbi__get_marker
  00041	0f b6 c0	 movzx	 eax, al
  00044	89 44 24 20	 mov	 DWORD PTR m$[rsp], eax

; 3371 :     if (!stbi__SOI(m)) return stbi__err("no SOI","Corrupt JPEG");

  00048	81 7c 24 20 d8
	00 00 00	 cmp	 DWORD PTR m$[rsp], 216	; 000000d8H
  00050	74 11		 je	 SHORT $LN6@stbi__deco
  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79035
  00059	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0005e	e9 f1 00 00 00	 jmp	 $LN1@stbi__deco
$LN6@stbi__deco:

; 3372 :     if (scan == STBI__SCAN_type) return 1;

  00063	83 7c 24 48 01	 cmp	 DWORD PTR scan$[rsp], 1
  00068	75 0a		 jne	 SHORT $LN7@stbi__deco
  0006a	b8 01 00 00 00	 mov	 eax, 1
  0006f	e9 e0 00 00 00	 jmp	 $LN1@stbi__deco
$LN7@stbi__deco:

; 3373 :     m = stbi__get_marker(z);

  00074	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00079	e8 00 00 00 00	 call	 ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ; stbi__get_marker
  0007e	0f b6 c0	 movzx	 eax, al
  00081	89 44 24 20	 mov	 DWORD PTR m$[rsp], eax
$LN2@stbi__deco:

; 3374 :     while (!stbi__SOF(m)) {

  00085	81 7c 24 20 c0
	00 00 00	 cmp	 DWORD PTR m$[rsp], 192	; 000000c0H
  0008d	74 7f		 je	 SHORT $LN3@stbi__deco
  0008f	81 7c 24 20 c1
	00 00 00	 cmp	 DWORD PTR m$[rsp], 193	; 000000c1H
  00097	74 75		 je	 SHORT $LN3@stbi__deco
  00099	81 7c 24 20 c2
	00 00 00	 cmp	 DWORD PTR m$[rsp], 194	; 000000c2H
  000a1	74 6b		 je	 SHORT $LN3@stbi__deco

; 3375 :         if (!stbi__process_marker(z,m)) return 0;

  000a3	8b 54 24 20	 mov	 edx, DWORD PTR m$[rsp]
  000a7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  000ac	e8 00 00 00 00	 call	 ?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z ; stbi__process_marker
  000b1	85 c0		 test	 eax, eax
  000b3	75 07		 jne	 SHORT $LN8@stbi__deco
  000b5	33 c0		 xor	 eax, eax
  000b7	e9 98 00 00 00	 jmp	 $LN1@stbi__deco
$LN8@stbi__deco:

; 3376 :         m = stbi__get_marker(z);

  000bc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  000c1	e8 00 00 00 00	 call	 ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ; stbi__get_marker
  000c6	0f b6 c0	 movzx	 eax, al
  000c9	89 44 24 20	 mov	 DWORD PTR m$[rsp], eax
$LN4@stbi__deco:

; 3377 :         while (m == STBI__MARKER_none) {

  000cd	81 7c 24 20 ff
	00 00 00	 cmp	 DWORD PTR m$[rsp], 255	; 000000ffH
  000d5	75 32		 jne	 SHORT $LN5@stbi__deco

; 3378 :             // some files have extra padding after their blocks, so ok, we'll scan
; 3379 :             if (stbi__at_eof(z->s)) return stbi__err("no SOF", "Corrupt JPEG");

  000d7	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  000dc	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000df	e8 00 00 00 00	 call	 ?stbi__at_eof@@YAHPEAUstbi__context@@@Z ; stbi__at_eof
  000e4	85 c0		 test	 eax, eax
  000e6	74 0e		 je	 SHORT $LN9@stbi__deco
  000e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79039
  000ef	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000f4	eb 5e		 jmp	 SHORT $LN1@stbi__deco
$LN9@stbi__deco:

; 3380 :             m = stbi__get_marker(z);

  000f6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  000fb	e8 00 00 00 00	 call	 ?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ; stbi__get_marker
  00100	0f b6 c0	 movzx	 eax, al
  00103	89 44 24 20	 mov	 DWORD PTR m$[rsp], eax

; 3381 :         }

  00107	eb c4		 jmp	 SHORT $LN4@stbi__deco
$LN5@stbi__deco:

; 3382 :     }

  00109	e9 77 ff ff ff	 jmp	 $LN2@stbi__deco
$LN3@stbi__deco:

; 3383 :     z->progressive = stbi__SOF_progressive(m);

  0010e	81 7c 24 20 c2
	00 00 00	 cmp	 DWORD PTR m$[rsp], 194	; 000000c2H
  00116	75 0a		 jne	 SHORT $LN12@stbi__deco
  00118	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  00120	eb 08		 jmp	 SHORT $LN13@stbi__deco
$LN12@stbi__deco:
  00122	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN13@stbi__deco:
  0012a	48 8b 44 24 40	 mov	 rax, QWORD PTR z$[rsp]
  0012f	8b 4c 24 24	 mov	 ecx, DWORD PTR tv131[rsp]
  00133	89 88 30 48 00
	00		 mov	 DWORD PTR [rax+18480], ecx

; 3384 :     if (!stbi__process_frame_header(z, scan)) return 0;

  00139	8b 54 24 48	 mov	 edx, DWORD PTR scan$[rsp]
  0013d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00142	e8 00 00 00 00	 call	 ?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z ; stbi__process_frame_header
  00147	85 c0		 test	 eax, eax
  00149	75 04		 jne	 SHORT $LN10@stbi__deco
  0014b	33 c0		 xor	 eax, eax
  0014d	eb 05		 jmp	 SHORT $LN1@stbi__deco
$LN10@stbi__deco:

; 3385 :     return 1;

  0014f	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__deco:

; 3386 : }

  00154	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00158	c3		 ret	 0
?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z ENDP	; stbi__decode_jpeg_header
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
i$ = 32
s$ = 40
h_max$ = 48
v_max$ = 52
c$ = 56
Lf$ = 60
q$ = 64
p$ = 68
tv285 = 72
tv294 = 80
z$ = 112
scan$ = 120
?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z PROC ; stbi__process_frame_header

; 3264 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3265 :     stbi__context *s = z->s;

  0000d	48 8b 44 24 70	 mov	 rax, QWORD PTR z$[rsp]
  00012	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00015	48 89 44 24 28	 mov	 QWORD PTR s$[rsp], rax

; 3266 :     int Lf,p,i,q, h_max=1,v_max=1,c;

  0001a	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR h_max$[rsp], 1
  00022	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR v_max$[rsp], 1

; 3267 :     Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err("bad SOF len","Corrupt JPEG"); // JPEG

  0002a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0002f	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  00034	89 44 24 3c	 mov	 DWORD PTR Lf$[rsp], eax
  00038	83 7c 24 3c 0b	 cmp	 DWORD PTR Lf$[rsp], 11
  0003d	7d 11		 jge	 SHORT $LN17@stbi__proc
  0003f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG78987
  00046	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0004b	e9 b9 08 00 00	 jmp	 $LN1@stbi__proc
$LN17@stbi__proc:

; 3268 :     p  = stbi__get8(s);            if (p != 8) return stbi__err("only 8-bit","JPEG format not supported: 8-bit only"); // JPEG baseline

  00050	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00055	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0005a	0f b6 c0	 movzx	 eax, al
  0005d	89 44 24 44	 mov	 DWORD PTR p$[rsp], eax
  00061	83 7c 24 44 08	 cmp	 DWORD PTR p$[rsp], 8
  00066	74 11		 je	 SHORT $LN18@stbi__proc
  00068	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG78989
  0006f	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00074	e9 90 08 00 00	 jmp	 $LN1@stbi__proc
$LN18@stbi__proc:

; 3269 :     s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err("no header height", "JPEG format not supported: delayed height"); // Legal, but we don't handle it--but neither does IJG

  00079	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0007e	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  00083	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00088	89 41 04	 mov	 DWORD PTR [rcx+4], eax
  0008b	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00090	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00094	75 11		 jne	 SHORT $LN19@stbi__proc
  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG78991
  0009d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000a2	e9 62 08 00 00	 jmp	 $LN1@stbi__proc
$LN19@stbi__proc:

; 3270 :     s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err("0 width","Corrupt JPEG"); // JPEG requires

  000a7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  000ac	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  000b1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  000b6	89 01		 mov	 DWORD PTR [rcx], eax
  000b8	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  000bd	83 38 00	 cmp	 DWORD PTR [rax], 0
  000c0	75 11		 jne	 SHORT $LN20@stbi__proc
  000c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG78993
  000c9	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000ce	e9 36 08 00 00	 jmp	 $LN1@stbi__proc
$LN20@stbi__proc:

; 3271 :     if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");

  000d3	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  000d8	81 78 04 00 00
	00 01		 cmp	 DWORD PTR [rax+4], 16777216 ; 01000000H
  000df	76 11		 jbe	 SHORT $LN21@stbi__proc
  000e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG78995
  000e8	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000ed	e9 17 08 00 00	 jmp	 $LN1@stbi__proc
$LN21@stbi__proc:

; 3272 :     if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err("too large","Very large image (corrupt?)");

  000f2	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  000f7	81 38 00 00 00
	01		 cmp	 DWORD PTR [rax], 16777216 ; 01000000H
  000fd	76 11		 jbe	 SHORT $LN22@stbi__proc
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG78997
  00106	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0010b	e9 f9 07 00 00	 jmp	 $LN1@stbi__proc
$LN22@stbi__proc:

; 3273 :     c = stbi__get8(s);

  00110	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00115	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0011a	0f b6 c0	 movzx	 eax, al
  0011d	89 44 24 38	 mov	 DWORD PTR c$[rsp], eax

; 3274 :     if (c != 3 && c != 1 && c != 4) return stbi__err("bad component count","Corrupt JPEG");

  00121	83 7c 24 38 03	 cmp	 DWORD PTR c$[rsp], 3
  00126	74 1f		 je	 SHORT $LN23@stbi__proc
  00128	83 7c 24 38 01	 cmp	 DWORD PTR c$[rsp], 1
  0012d	74 18		 je	 SHORT $LN23@stbi__proc
  0012f	83 7c 24 38 04	 cmp	 DWORD PTR c$[rsp], 4
  00134	74 11		 je	 SHORT $LN23@stbi__proc
  00136	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG78999
  0013d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00142	e9 c2 07 00 00	 jmp	 $LN1@stbi__proc
$LN23@stbi__proc:

; 3275 :     s->img_n = c;

  00147	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0014c	8b 4c 24 38	 mov	 ecx, DWORD PTR c$[rsp]
  00150	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 3276 :     for (i=0; i < c; ++i) {

  00153	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0015b	eb 0a		 jmp	 SHORT $LN4@stbi__proc
$LN2@stbi__proc:
  0015d	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00161	ff c0		 inc	 eax
  00163	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__proc:
  00167	8b 44 24 38	 mov	 eax, DWORD PTR c$[rsp]
  0016b	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0016f	7d 36		 jge	 SHORT $LN3@stbi__proc

; 3277 :         z->img_comp[i].data = NULL;

  00171	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00176	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0017a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  0017f	48 c7 84 01 d0
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18128], 0

; 3278 :         z->img_comp[i].linebuf = NULL;

  0018b	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00190	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00194	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00199	48 c7 84 01 e8
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18152], 0

; 3279 :     }

  001a5	eb b6		 jmp	 SHORT $LN2@stbi__proc
$LN3@stbi__proc:

; 3280 :     
; 3281 :     if (Lf != 8+3*s->img_n) return stbi__err("bad SOF len","Corrupt JPEG");

  001a7	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  001ac	6b 40 08 03	 imul	 eax, DWORD PTR [rax+8], 3
  001b0	83 c0 08	 add	 eax, 8
  001b3	39 44 24 3c	 cmp	 DWORD PTR Lf$[rsp], eax
  001b7	74 11		 je	 SHORT $LN24@stbi__proc
  001b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79001
  001c0	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  001c5	e9 3f 07 00 00	 jmp	 $LN1@stbi__proc
$LN24@stbi__proc:

; 3282 :     
; 3283 :     z->rgb = 0;

  001ca	48 8b 44 24 70	 mov	 rax, QWORD PTR z$[rsp]
  001cf	c7 80 50 48 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+18512], 0

; 3284 :     for (i=0; i < s->img_n; ++i) {

  001d9	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001e1	eb 0a		 jmp	 SHORT $LN7@stbi__proc
$LN5@stbi__proc:
  001e3	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001e7	ff c0		 inc	 eax
  001e9	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@stbi__proc:
  001ed	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  001f2	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  001f5	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  001f9	0f 8d 87 01 00
	00		 jge	 $LN6@stbi__proc

; 3285 :         static const unsigned char rgb[3] = { 'R', 'G', 'B' };
; 3286 :         z->img_comp[i].id = stbi__get8(s);

  001ff	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00204	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00209	0f b6 c0	 movzx	 eax, al
  0020c	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00211	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00215	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  0021a	89 84 0a a0 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18080], eax

; 3287 :         if (s->img_n == 3 && z->img_comp[i].id == rgb[i])

  00221	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00226	83 78 08 03	 cmp	 DWORD PTR [rax+8], 3
  0022a	75 3f		 jne	 SHORT $LN25@stbi__proc
  0022c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00231	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00235	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0023a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?rgb@?BG@??stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z@4QBEB
  00241	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00245	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  0024a	39 8c 02 a0 46
	00 00		 cmp	 DWORD PTR [rdx+rax+18080], ecx
  00251	75 18		 jne	 SHORT $LN25@stbi__proc

; 3288 :             ++z->rgb;

  00253	48 8b 44 24 70	 mov	 rax, QWORD PTR z$[rsp]
  00258	8b 80 50 48 00
	00		 mov	 eax, DWORD PTR [rax+18512]
  0025e	ff c0		 inc	 eax
  00260	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00265	89 81 50 48 00
	00		 mov	 DWORD PTR [rcx+18512], eax
$LN25@stbi__proc:

; 3289 :         q = stbi__get8(s);

  0026b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00270	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00275	0f b6 c0	 movzx	 eax, al
  00278	89 44 24 40	 mov	 DWORD PTR q$[rsp], eax

; 3290 :         z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err("bad H","Corrupt JPEG");

  0027c	8b 44 24 40	 mov	 eax, DWORD PTR q$[rsp]
  00280	c1 f8 04	 sar	 eax, 4
  00283	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00288	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  0028c	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  00291	89 84 0a a4 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18084], eax
  00298	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0029d	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  002a1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  002a6	83 bc 01 a4 46
	00 00 00	 cmp	 DWORD PTR [rcx+rax+18084], 0
  002ae	74 18		 je	 SHORT $LN27@stbi__proc
  002b0	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  002b5	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  002b9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  002be	83 bc 01 a4 46
	00 00 04	 cmp	 DWORD PTR [rcx+rax+18084], 4
  002c6	7e 11		 jle	 SHORT $LN26@stbi__proc
$LN27@stbi__proc:
  002c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79005
  002cf	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  002d4	e9 30 06 00 00	 jmp	 $LN1@stbi__proc
$LN26@stbi__proc:

; 3291 :         z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err("bad V","Corrupt JPEG");

  002d9	8b 44 24 40	 mov	 eax, DWORD PTR q$[rsp]
  002dd	83 e0 0f	 and	 eax, 15
  002e0	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  002e5	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  002e9	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  002ee	89 84 0a a8 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18088], eax
  002f5	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  002fa	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  002fe	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00303	83 bc 01 a8 46
	00 00 00	 cmp	 DWORD PTR [rcx+rax+18088], 0
  0030b	74 18		 je	 SHORT $LN29@stbi__proc
  0030d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00312	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00316	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  0031b	83 bc 01 a8 46
	00 00 04	 cmp	 DWORD PTR [rcx+rax+18088], 4
  00323	7e 11		 jle	 SHORT $LN28@stbi__proc
$LN29@stbi__proc:
  00325	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79008
  0032c	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00331	e9 d3 05 00 00	 jmp	 $LN1@stbi__proc
$LN28@stbi__proc:

; 3292 :         z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err("bad TQ","Corrupt JPEG");

  00336	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0033b	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00340	0f b6 c0	 movzx	 eax, al
  00343	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00348	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  0034c	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  00351	89 84 0a ac 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18092], eax
  00358	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0035d	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00361	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00366	83 bc 01 ac 46
	00 00 03	 cmp	 DWORD PTR [rcx+rax+18092], 3
  0036e	7e 11		 jle	 SHORT $LN30@stbi__proc
  00370	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79010
  00377	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0037c	e9 88 05 00 00	 jmp	 $LN1@stbi__proc
$LN30@stbi__proc:

; 3293 :     }

  00381	e9 5d fe ff ff	 jmp	 $LN5@stbi__proc
$LN6@stbi__proc:

; 3294 :     
; 3295 :     if (scan != STBI__SCAN_load) return 1;

  00386	83 7c 24 78 00	 cmp	 DWORD PTR scan$[rsp], 0
  0038b	74 0a		 je	 SHORT $LN31@stbi__proc
  0038d	b8 01 00 00 00	 mov	 eax, 1
  00392	e9 72 05 00 00	 jmp	 $LN1@stbi__proc
$LN31@stbi__proc:

; 3296 :     
; 3297 :     if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err("too large", "Image too large to decode");

  00397	45 33 c9	 xor	 r9d, r9d
  0039a	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0039f	44 8b 40 08	 mov	 r8d, DWORD PTR [rax+8]
  003a3	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  003a8	8b 50 04	 mov	 edx, DWORD PTR [rax+4]
  003ab	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  003b0	8b 08		 mov	 ecx, DWORD PTR [rax]
  003b2	e8 00 00 00 00	 call	 ?stbi__mad3sizes_valid@@YAHHHHH@Z ; stbi__mad3sizes_valid
  003b7	85 c0		 test	 eax, eax
  003b9	75 11		 jne	 SHORT $LN32@stbi__proc
  003bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79013
  003c2	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  003c7	e9 3d 05 00 00	 jmp	 $LN1@stbi__proc
$LN32@stbi__proc:

; 3298 :     
; 3299 :     for (i=0; i < s->img_n; ++i) {

  003cc	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  003d4	eb 0a		 jmp	 SHORT $LN10@stbi__proc
$LN8@stbi__proc:
  003d6	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  003da	ff c0		 inc	 eax
  003dc	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN10@stbi__proc:
  003e0	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  003e5	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  003e8	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  003ec	7d 6d		 jge	 SHORT $LN9@stbi__proc

; 3300 :         if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h;

  003ee	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  003f3	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  003f7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  003fc	8b 54 24 30	 mov	 edx, DWORD PTR h_max$[rsp]
  00400	39 94 01 a4 46
	00 00		 cmp	 DWORD PTR [rcx+rax+18084], edx
  00407	7e 19		 jle	 SHORT $LN33@stbi__proc
  00409	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0040e	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00412	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00417	8b 84 01 a4 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18084]
  0041e	89 44 24 30	 mov	 DWORD PTR h_max$[rsp], eax
$LN33@stbi__proc:

; 3301 :         if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v;

  00422	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00427	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0042b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00430	8b 54 24 34	 mov	 edx, DWORD PTR v_max$[rsp]
  00434	39 94 01 a8 46
	00 00		 cmp	 DWORD PTR [rcx+rax+18088], edx
  0043b	7e 19		 jle	 SHORT $LN34@stbi__proc
  0043d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00442	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00446	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  0044b	8b 84 01 a8 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18088]
  00452	89 44 24 34	 mov	 DWORD PTR v_max$[rsp], eax
$LN34@stbi__proc:

; 3302 :     }

  00456	e9 7b ff ff ff	 jmp	 $LN8@stbi__proc
$LN9@stbi__proc:

; 3303 :     
; 3304 :     // check that plane subsampling factors are integer ratios; our resamplers can't deal with fractional ratios
; 3305 :     // and I've never seen a non-corrupted JPEG file actually use them
; 3306 :     for (i=0; i < s->img_n; ++i) {

  0045b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00463	eb 0a		 jmp	 SHORT $LN13@stbi__proc
$LN11@stbi__proc:
  00465	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00469	ff c0		 inc	 eax
  0046b	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN13@stbi__proc:
  0046f	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00474	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00477	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0047b	7d 7d		 jge	 SHORT $LN12@stbi__proc

; 3307 :         if (h_max % z->img_comp[i].h != 0) return stbi__err("bad H","Corrupt JPEG");

  0047d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00482	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00486	48 89 44 24 48	 mov	 QWORD PTR tv285[rsp], rax
  0048b	8b 44 24 30	 mov	 eax, DWORD PTR h_max$[rsp]
  0048f	99		 cdq
  00490	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00495	4c 8b 44 24 48	 mov	 r8, QWORD PTR tv285[rsp]
  0049a	42 f7 bc 01 a4
	46 00 00	 idiv	 DWORD PTR [rcx+r8+18084]
  004a2	8b c2		 mov	 eax, edx
  004a4	85 c0		 test	 eax, eax
  004a6	74 11		 je	 SHORT $LN35@stbi__proc
  004a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79017
  004af	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  004b4	e9 50 04 00 00	 jmp	 $LN1@stbi__proc
$LN35@stbi__proc:

; 3308 :         if (v_max % z->img_comp[i].v != 0) return stbi__err("bad V","Corrupt JPEG");

  004b9	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  004be	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  004c2	48 89 44 24 50	 mov	 QWORD PTR tv294[rsp], rax
  004c7	8b 44 24 34	 mov	 eax, DWORD PTR v_max$[rsp]
  004cb	99		 cdq
  004cc	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  004d1	4c 8b 44 24 50	 mov	 r8, QWORD PTR tv294[rsp]
  004d6	42 f7 bc 01 a8
	46 00 00	 idiv	 DWORD PTR [rcx+r8+18088]
  004de	8b c2		 mov	 eax, edx
  004e0	85 c0		 test	 eax, eax
  004e2	74 11		 je	 SHORT $LN36@stbi__proc
  004e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79019
  004eb	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  004f0	e9 14 04 00 00	 jmp	 $LN1@stbi__proc
$LN36@stbi__proc:

; 3309 :     }

  004f5	e9 6b ff ff ff	 jmp	 $LN11@stbi__proc
$LN12@stbi__proc:

; 3310 :     
; 3311 :     // compute interleaved mcu info
; 3312 :     z->img_h_max = h_max;

  004fa	48 8b 44 24 70	 mov	 rax, QWORD PTR z$[rsp]
  004ff	8b 4c 24 30	 mov	 ecx, DWORD PTR h_max$[rsp]
  00503	89 88 88 46 00
	00		 mov	 DWORD PTR [rax+18056], ecx

; 3313 :     z->img_v_max = v_max;

  00509	48 8b 44 24 70	 mov	 rax, QWORD PTR z$[rsp]
  0050e	8b 4c 24 34	 mov	 ecx, DWORD PTR v_max$[rsp]
  00512	89 88 8c 46 00
	00		 mov	 DWORD PTR [rax+18060], ecx

; 3314 :     z->img_mcu_w = h_max * 8;

  00518	8b 44 24 30	 mov	 eax, DWORD PTR h_max$[rsp]
  0051c	c1 e0 03	 shl	 eax, 3
  0051f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00524	89 81 98 46 00
	00		 mov	 DWORD PTR [rcx+18072], eax

; 3315 :     z->img_mcu_h = v_max * 8;

  0052a	8b 44 24 34	 mov	 eax, DWORD PTR v_max$[rsp]
  0052e	c1 e0 03	 shl	 eax, 3
  00531	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00536	89 81 9c 46 00
	00		 mov	 DWORD PTR [rcx+18076], eax

; 3316 :     // these sizes can't be more than 17 bits
; 3317 :     z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w;

  0053c	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00541	8b 00		 mov	 eax, DWORD PTR [rax]
  00543	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00548	8b 89 98 46 00
	00		 mov	 ecx, DWORD PTR [rcx+18072]
  0054e	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00552	33 d2		 xor	 edx, edx
  00554	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00559	f7 b1 98 46 00
	00		 div	 DWORD PTR [rcx+18072]
  0055f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00564	89 81 90 46 00
	00		 mov	 DWORD PTR [rcx+18064], eax

; 3318 :     z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h;

  0056a	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0056f	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00572	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00577	8b 89 9c 46 00
	00		 mov	 ecx, DWORD PTR [rcx+18076]
  0057d	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00581	33 d2		 xor	 edx, edx
  00583	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00588	f7 b1 9c 46 00
	00		 div	 DWORD PTR [rcx+18076]
  0058e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00593	89 81 94 46 00
	00		 mov	 DWORD PTR [rcx+18068], eax

; 3319 :     
; 3320 :     for (i=0; i < s->img_n; ++i) {

  00599	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  005a1	eb 0a		 jmp	 SHORT $LN16@stbi__proc
$LN14@stbi__proc:
  005a3	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  005a7	ff c0		 inc	 eax
  005a9	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN16@stbi__proc:
  005ad	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  005b2	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  005b5	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  005b9	0f 8d 45 03 00
	00		 jge	 $LN15@stbi__proc

; 3321 :         // number of effective pixels (e.g. for non-interleaved MCU)
; 3322 :         z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max;

  005bf	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  005c4	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  005c8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  005cd	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  005d2	8b 09		 mov	 ecx, DWORD PTR [rcx]
  005d4	0f af 8c 02 a4
	46 00 00	 imul	 ecx, DWORD PTR [rdx+rax+18084]
  005dc	8b c1		 mov	 eax, ecx
  005de	8b 4c 24 30	 mov	 ecx, DWORD PTR h_max$[rsp]
  005e2	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  005e6	33 d2		 xor	 edx, edx
  005e8	f7 74 24 30	 div	 DWORD PTR h_max$[rsp]
  005ec	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  005f1	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  005f5	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  005fa	89 84 0a bc 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18108], eax

; 3323 :         z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max;

  00601	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00606	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0060a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0060f	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  00614	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00617	0f af 8c 02 a8
	46 00 00	 imul	 ecx, DWORD PTR [rdx+rax+18088]
  0061f	8b c1		 mov	 eax, ecx
  00621	8b 4c 24 34	 mov	 ecx, DWORD PTR v_max$[rsp]
  00625	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00629	33 d2		 xor	 edx, edx
  0062b	f7 74 24 34	 div	 DWORD PTR v_max$[rsp]
  0062f	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00634	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00638	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  0063d	89 84 0a c0 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18112], eax

; 3324 :         // to simplify generation, we'll allocate enough memory to decode
; 3325 :         // the bogus oversized data from using interleaved MCUs and their
; 3326 :         // big blocks (e.g. a 16x16 iMCU on an image of width 33); we won't
; 3327 :         // discard the extra data until colorspace conversion
; 3328 :         //
; 3329 :         // img_mcu_x, img_mcu_y: <=17 bits; comp[i].h and .v are <=4 (checked earlier)
; 3330 :         // so these muls can't overflow with 32-bit ints (which we require)
; 3331 :         z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8;

  00644	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00649	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0064d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00652	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  00657	8b 89 90 46 00
	00		 mov	 ecx, DWORD PTR [rcx+18064]
  0065d	0f af 8c 02 a4
	46 00 00	 imul	 ecx, DWORD PTR [rdx+rax+18084]
  00665	8b c1		 mov	 eax, ecx
  00667	c1 e0 03	 shl	 eax, 3
  0066a	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0066f	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00673	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  00678	89 84 0a c4 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18116], eax

; 3332 :         z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8;

  0067f	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00684	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00688	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  0068d	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  00692	8b 89 94 46 00
	00		 mov	 ecx, DWORD PTR [rcx+18068]
  00698	0f af 8c 02 a8
	46 00 00	 imul	 ecx, DWORD PTR [rdx+rax+18088]
  006a0	8b c1		 mov	 eax, ecx
  006a2	c1 e0 03	 shl	 eax, 3
  006a5	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  006aa	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  006ae	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  006b3	89 84 0a c8 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18120], eax

; 3333 :         z->img_comp[i].coeff = 0;

  006ba	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  006bf	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  006c3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  006c8	48 c7 84 01 f0
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18160], 0

; 3334 :         z->img_comp[i].raw_coeff = 0;

  006d4	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  006d9	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  006dd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  006e2	48 c7 84 01 e0
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18144], 0

; 3335 :         z->img_comp[i].linebuf = NULL;

  006ee	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  006f3	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  006f7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  006fc	48 c7 84 01 e8
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18152], 0

; 3336 :         z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15);

  00708	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0070d	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00711	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00716	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  0071a	41 b8 0f 00 00
	00		 mov	 r8d, 15
  00720	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  00725	8b 94 02 c8 46
	00 00		 mov	 edx, DWORD PTR [rdx+rax+18120]
  0072c	48 8b 44 24 70	 mov	 rax, QWORD PTR z$[rsp]
  00731	8b 8c 08 c4 46
	00 00		 mov	 ecx, DWORD PTR [rax+rcx+18116]
  00738	e8 00 00 00 00	 call	 ?stbi__malloc_mad2@@YAPEAXHHH@Z ; stbi__malloc_mad2
  0073d	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00742	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00746	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  0074b	48 89 84 0a d8
	46 00 00	 mov	 QWORD PTR [rdx+rcx+18136], rax

; 3337 :         if (z->img_comp[i].raw_data == NULL)

  00753	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00758	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0075c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00761	48 83 bc 01 d8
	46 00 00 00	 cmp	 QWORD PTR [rcx+rax+18136], 0
  0076a	75 26		 jne	 SHORT $LN37@stbi__proc

; 3338 :             return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));

  0076c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79021
  00773	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00778	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0077c	ff c1		 inc	 ecx
  0077e	44 8b c0	 mov	 r8d, eax
  00781	8b d1		 mov	 edx, ecx
  00783	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00788	e8 00 00 00 00	 call	 ?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z ; stbi__free_jpeg_components
  0078d	e9 77 01 00 00	 jmp	 $LN1@stbi__proc
$LN37@stbi__proc:

; 3339 :         // align blocks for idct using mmx/sse
; 3340 :         z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15);

  00792	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00797	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0079b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  007a0	48 8b 84 01 d8
	46 00 00	 mov	 rax, QWORD PTR [rcx+rax+18136]
  007a8	48 83 c0 0f	 add	 rax, 15
  007ac	48 83 e0 f0	 and	 rax, -16
  007b0	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  007b5	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  007b9	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  007be	48 89 84 0a d0
	46 00 00	 mov	 QWORD PTR [rdx+rcx+18128], rax

; 3341 :         if (z->progressive) {

  007c6	48 8b 44 24 70	 mov	 rax, QWORD PTR z$[rsp]
  007cb	83 b8 30 48 00
	00 00		 cmp	 DWORD PTR [rax+18480], 0
  007d2	0f 84 27 01 00
	00		 je	 $LN38@stbi__proc

; 3342 :             // w2, h2 are multiples of 8 (see above)
; 3343 :             z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8;

  007d8	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  007dd	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  007e1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  007e6	8b 84 01 c4 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18116]
  007ed	99		 cdq
  007ee	83 e2 07	 and	 edx, 7
  007f1	03 c2		 add	 eax, edx
  007f3	c1 f8 03	 sar	 eax, 3
  007f6	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  007fb	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  007ff	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  00804	89 84 0a f8 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18168], eax

; 3344 :             z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8;

  0080b	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00810	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00814	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  00819	8b 84 01 c8 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18120]
  00820	99		 cdq
  00821	83 e2 07	 and	 edx, 7
  00824	03 c2		 add	 eax, edx
  00826	c1 f8 03	 sar	 eax, 3
  00829	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0082e	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00832	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  00837	89 84 0a fc 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18172], eax

; 3345 :             z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15);

  0083e	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00843	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00847	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0084c	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00850	41 b9 0f 00 00
	00		 mov	 r9d, 15
  00856	41 b8 02 00 00
	00		 mov	 r8d, 2
  0085c	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  00861	8b 94 02 c8 46
	00 00		 mov	 edx, DWORD PTR [rdx+rax+18120]
  00868	48 8b 44 24 70	 mov	 rax, QWORD PTR z$[rsp]
  0086d	8b 8c 08 c4 46
	00 00		 mov	 ecx, DWORD PTR [rax+rcx+18116]
  00874	e8 00 00 00 00	 call	 ?stbi__malloc_mad3@@YAPEAXHHHH@Z ; stbi__malloc_mad3
  00879	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0087e	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00882	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  00887	48 89 84 0a e0
	46 00 00	 mov	 QWORD PTR [rdx+rcx+18144], rax

; 3346 :             if (z->img_comp[i].raw_coeff == NULL)

  0088f	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00894	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00898	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  0089d	48 83 bc 01 e0
	46 00 00 00	 cmp	 QWORD PTR [rcx+rax+18144], 0
  008a6	75 23		 jne	 SHORT $LN39@stbi__proc

; 3347 :                 return stbi__free_jpeg_components(z, i+1, stbi__err("outofmem", "Out of memory"));

  008a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79024
  008af	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  008b4	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  008b8	ff c1		 inc	 ecx
  008ba	44 8b c0	 mov	 r8d, eax
  008bd	8b d1		 mov	 edx, ecx
  008bf	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  008c4	e8 00 00 00 00	 call	 ?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z ; stbi__free_jpeg_components
  008c9	eb 3e		 jmp	 SHORT $LN1@stbi__proc
$LN39@stbi__proc:

; 3348 :             z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15);

  008cb	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  008d0	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  008d4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR z$[rsp]
  008d9	48 8b 84 01 e0
	46 00 00	 mov	 rax, QWORD PTR [rcx+rax+18144]
  008e1	48 83 c0 0f	 add	 rax, 15
  008e5	48 83 e0 f0	 and	 rax, -16
  008e9	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  008ee	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  008f2	48 8b 54 24 70	 mov	 rdx, QWORD PTR z$[rsp]
  008f7	48 89 84 0a f0
	46 00 00	 mov	 QWORD PTR [rdx+rcx+18160], rax
$LN38@stbi__proc:

; 3349 :         }
; 3350 :     }

  008ff	e9 9f fc ff ff	 jmp	 $LN14@stbi__proc
$LN15@stbi__proc:

; 3351 :     
; 3352 :     return 1;

  00904	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__proc:

; 3353 : }

  00909	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0090d	c3		 ret	 0
?stbi__process_frame_header@@YAHPEAUstbi__jpeg@@H@Z ENDP ; stbi__process_frame_header
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
i$ = 32
z$ = 64
ncomp$ = 72
why$ = 80
?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z PROC ; stbi__free_jpeg_components

; 3242 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3243 :     int i;
; 3244 :     for (i=0; i < ncomp; ++i) {

  00012	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0001a	eb 0a		 jmp	 SHORT $LN4@stbi__free
$LN2@stbi__free:
  0001c	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00020	ff c0		 inc	 eax
  00022	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__free:
  00026	8b 44 24 48	 mov	 eax, DWORD PTR ncomp$[rsp]
  0002a	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0002e	0f 8d 23 01 00
	00		 jge	 $LN3@stbi__free

; 3245 :         if (z->img_comp[i].raw_data) {

  00034	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00039	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0003d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00042	48 83 bc 01 d8
	46 00 00 00	 cmp	 QWORD PTR [rcx+rax+18136], 0
  0004b	74 4f		 je	 SHORT $LN5@stbi__free

; 3246 :             STBI_FREE(z->img_comp[i].raw_data);

  0004d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00052	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00056	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  0005b	48 8b 8c 01 d8
	46 00 00	 mov	 rcx, QWORD PTR [rcx+rax+18136]
  00063	e8 00 00 00 00	 call	 free

; 3247 :             z->img_comp[i].raw_data = NULL;

  00068	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0006d	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00071	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00076	48 c7 84 01 d8
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18136], 0

; 3248 :             z->img_comp[i].data = NULL;

  00082	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00087	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0008b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00090	48 c7 84 01 d0
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18128], 0
$LN5@stbi__free:

; 3249 :         }
; 3250 :         if (z->img_comp[i].raw_coeff) {

  0009c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000a1	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000a5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  000aa	48 83 bc 01 e0
	46 00 00 00	 cmp	 QWORD PTR [rcx+rax+18144], 0
  000b3	74 4f		 je	 SHORT $LN6@stbi__free

; 3251 :             STBI_FREE(z->img_comp[i].raw_coeff);

  000b5	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000ba	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000be	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  000c3	48 8b 8c 01 e0
	46 00 00	 mov	 rcx, QWORD PTR [rcx+rax+18144]
  000cb	e8 00 00 00 00	 call	 free

; 3252 :             z->img_comp[i].raw_coeff = 0;

  000d0	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000d5	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000d9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  000de	48 c7 84 01 e0
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18144], 0

; 3253 :             z->img_comp[i].coeff = 0;

  000ea	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000ef	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000f3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  000f8	48 c7 84 01 f0
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18160], 0
$LN6@stbi__free:

; 3254 :         }
; 3255 :         if (z->img_comp[i].linebuf) {

  00104	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00109	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0010d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00112	48 83 bc 01 e8
	46 00 00 00	 cmp	 QWORD PTR [rcx+rax+18152], 0
  0011b	74 35		 je	 SHORT $LN7@stbi__free

; 3256 :             STBI_FREE(z->img_comp[i].linebuf);

  0011d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00122	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00126	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  0012b	48 8b 8c 01 e8
	46 00 00	 mov	 rcx, QWORD PTR [rcx+rax+18152]
  00133	e8 00 00 00 00	 call	 free

; 3257 :             z->img_comp[i].linebuf = NULL;

  00138	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0013d	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00141	48 8b 4c 24 40	 mov	 rcx, QWORD PTR z$[rsp]
  00146	48 c7 84 01 e8
	46 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+18152], 0
$LN7@stbi__free:

; 3258 :         }
; 3259 :     }

  00152	e9 c5 fe ff ff	 jmp	 $LN2@stbi__free
$LN3@stbi__free:

; 3260 :     return why;

  00157	8b 44 24 50	 mov	 eax, DWORD PTR why$[rsp]

; 3261 : }

  0015b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0015f	c3		 ret	 0
?stbi__free_jpeg_components@@YAHPEAUstbi__jpeg@@HH@Z ENDP ; stbi__free_jpeg_components
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
which$1 = 32
i$ = 36
q$2 = 40
aa$3 = 44
Ls$ = 48
id$4 = 52
z$ = 80
?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z PROC	; stbi__process_scan_header

; 3203 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3204 :     int i;
; 3205 :     int Ls = stbi__get16be(z->s);

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0000e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00011	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  00016	89 44 24 30	 mov	 DWORD PTR Ls$[rsp], eax

; 3206 :     z->scan_n = stbi__get8(z->s);

  0001a	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0001f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00022	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00027	0f b6 c0	 movzx	 eax, al
  0002a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  0002f	89 81 54 48 00
	00		 mov	 DWORD PTR [rcx+18516], eax

; 3207 :     if (z->scan_n < 1 || z->scan_n > 4 || z->scan_n > (int) z->s->img_n) return stbi__err("bad SOS component count","Corrupt JPEG");

  00035	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0003a	83 b8 54 48 00
	00 01		 cmp	 DWORD PTR [rax+18516], 1
  00041	7c 26		 jl	 SHORT $LN9@stbi__proc
  00043	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00048	83 b8 54 48 00
	00 04		 cmp	 DWORD PTR [rax+18516], 4
  0004f	7f 18		 jg	 SHORT $LN9@stbi__proc
  00051	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00056	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00059	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  0005e	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00061	39 81 54 48 00
	00		 cmp	 DWORD PTR [rcx+18516], eax
  00067	7e 11		 jle	 SHORT $LN8@stbi__proc
$LN9@stbi__proc:
  00069	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG78921
  00070	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00075	e9 ad 02 00 00	 jmp	 $LN1@stbi__proc
$LN8@stbi__proc:

; 3208 :     if (Ls != 6+2*z->scan_n) return stbi__err("bad SOS len","Corrupt JPEG");

  0007a	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0007f	8b 80 54 48 00
	00		 mov	 eax, DWORD PTR [rax+18516]
  00085	8d 44 00 06	 lea	 eax, DWORD PTR [rax+rax+6]
  00089	39 44 24 30	 cmp	 DWORD PTR Ls$[rsp], eax
  0008d	74 11		 je	 SHORT $LN10@stbi__proc
  0008f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG78923
  00096	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0009b	e9 87 02 00 00	 jmp	 $LN1@stbi__proc
$LN10@stbi__proc:

; 3209 :     for (i=0; i < z->scan_n; ++i) {

  000a0	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000a8	eb 0a		 jmp	 SHORT $LN4@stbi__proc
$LN2@stbi__proc:
  000aa	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  000ae	ff c0		 inc	 eax
  000b0	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__proc:
  000b4	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  000b9	8b 80 54 48 00
	00		 mov	 eax, DWORD PTR [rax+18516]
  000bf	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  000c3	0f 8d 28 01 00
	00		 jge	 $LN3@stbi__proc

; 3210 :         int id = stbi__get8(z->s), which;

  000c9	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  000ce	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000d1	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  000d6	0f b6 c0	 movzx	 eax, al
  000d9	89 44 24 34	 mov	 DWORD PTR id$4[rsp], eax

; 3211 :         int q = stbi__get8(z->s);

  000dd	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  000e2	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000e5	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  000ea	0f b6 c0	 movzx	 eax, al
  000ed	89 44 24 28	 mov	 DWORD PTR q$2[rsp], eax

; 3212 :         for (which = 0; which < z->s->img_n; ++which)

  000f1	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR which$1[rsp], 0
  000f9	eb 0a		 jmp	 SHORT $LN7@stbi__proc
$LN5@stbi__proc:
  000fb	8b 44 24 20	 mov	 eax, DWORD PTR which$1[rsp]
  000ff	ff c0		 inc	 eax
  00101	89 44 24 20	 mov	 DWORD PTR which$1[rsp], eax
$LN7@stbi__proc:
  00105	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0010a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0010d	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00110	39 44 24 20	 cmp	 DWORD PTR which$1[rsp], eax
  00114	7d 1f		 jge	 SHORT $LN6@stbi__proc

; 3213 :             if (z->img_comp[which].id == id)

  00116	48 63 44 24 20	 movsxd	 rax, DWORD PTR which$1[rsp]
  0011b	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0011f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00124	8b 54 24 34	 mov	 edx, DWORD PTR id$4[rsp]
  00128	39 94 01 a0 46
	00 00		 cmp	 DWORD PTR [rcx+rax+18080], edx
  0012f	75 02		 jne	 SHORT $LN11@stbi__proc

; 3214 :             break;

  00131	eb 02		 jmp	 SHORT $LN6@stbi__proc
$LN11@stbi__proc:
  00133	eb c6		 jmp	 SHORT $LN5@stbi__proc
$LN6@stbi__proc:

; 3215 :         if (which == z->s->img_n) return 0; // no match

  00135	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0013a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0013d	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00140	39 44 24 20	 cmp	 DWORD PTR which$1[rsp], eax
  00144	75 07		 jne	 SHORT $LN12@stbi__proc
  00146	33 c0		 xor	 eax, eax
  00148	e9 da 01 00 00	 jmp	 $LN1@stbi__proc
$LN12@stbi__proc:

; 3216 :         z->img_comp[which].hd = q >> 4;   if (z->img_comp[which].hd > 3) return stbi__err("bad DC huff","Corrupt JPEG");

  0014d	8b 44 24 28	 mov	 eax, DWORD PTR q$2[rsp]
  00151	c1 f8 04	 sar	 eax, 4
  00154	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR which$1[rsp]
  00159	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  0015d	48 8b 54 24 50	 mov	 rdx, QWORD PTR z$[rsp]
  00162	89 84 0a b0 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18096], eax
  00169	48 63 44 24 20	 movsxd	 rax, DWORD PTR which$1[rsp]
  0016e	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00172	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00177	83 bc 01 b0 46
	00 00 03	 cmp	 DWORD PTR [rcx+rax+18096], 3
  0017f	7e 11		 jle	 SHORT $LN13@stbi__proc
  00181	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG78927
  00188	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0018d	e9 95 01 00 00	 jmp	 $LN1@stbi__proc
$LN13@stbi__proc:

; 3217 :         z->img_comp[which].ha = q & 15;   if (z->img_comp[which].ha > 3) return stbi__err("bad AC huff","Corrupt JPEG");

  00192	8b 44 24 28	 mov	 eax, DWORD PTR q$2[rsp]
  00196	83 e0 0f	 and	 eax, 15
  00199	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR which$1[rsp]
  0019e	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  001a2	48 8b 54 24 50	 mov	 rdx, QWORD PTR z$[rsp]
  001a7	89 84 0a b4 46
	00 00		 mov	 DWORD PTR [rdx+rcx+18100], eax
  001ae	48 63 44 24 20	 movsxd	 rax, DWORD PTR which$1[rsp]
  001b3	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  001b7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  001bc	83 bc 01 b4 46
	00 00 03	 cmp	 DWORD PTR [rcx+rax+18100], 3
  001c4	7e 11		 jle	 SHORT $LN14@stbi__proc
  001c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG78929
  001cd	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  001d2	e9 50 01 00 00	 jmp	 $LN1@stbi__proc
$LN14@stbi__proc:

; 3218 :         z->order[i] = which;

  001d7	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$[rsp]
  001dc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  001e1	8b 54 24 20	 mov	 edx, DWORD PTR which$1[rsp]
  001e5	89 94 81 58 48
	00 00		 mov	 DWORD PTR [rcx+rax*4+18520], edx

; 3219 :     }

  001ec	e9 b9 fe ff ff	 jmp	 $LN2@stbi__proc
$LN3@stbi__proc:

; 3220 :     
; 3221 :     {
; 3222 :         int aa;
; 3223 :         z->spec_start = stbi__get8(z->s);

  001f1	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  001f6	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001f9	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  001fe	0f b6 c0	 movzx	 eax, al
  00201	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00206	89 81 34 48 00
	00		 mov	 DWORD PTR [rcx+18484], eax

; 3224 :         z->spec_end   = stbi__get8(z->s); // should be 63, but might be 0

  0020c	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00211	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00214	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00219	0f b6 c0	 movzx	 eax, al
  0021c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00221	89 81 38 48 00
	00		 mov	 DWORD PTR [rcx+18488], eax

; 3225 :         aa = stbi__get8(z->s);

  00227	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0022c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0022f	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00234	0f b6 c0	 movzx	 eax, al
  00237	89 44 24 2c	 mov	 DWORD PTR aa$3[rsp], eax

; 3226 :         z->succ_high = (aa >> 4);

  0023b	8b 44 24 2c	 mov	 eax, DWORD PTR aa$3[rsp]
  0023f	c1 f8 04	 sar	 eax, 4
  00242	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00247	89 81 3c 48 00
	00		 mov	 DWORD PTR [rcx+18492], eax

; 3227 :         z->succ_low  = (aa & 15);

  0024d	8b 44 24 2c	 mov	 eax, DWORD PTR aa$3[rsp]
  00251	83 e0 0f	 and	 eax, 15
  00254	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00259	89 81 40 48 00
	00		 mov	 DWORD PTR [rcx+18496], eax

; 3228 :         if (z->progressive) {

  0025f	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00264	83 b8 30 48 00
	00 00		 cmp	 DWORD PTR [rax+18480], 0
  0026b	74 60		 je	 SHORT $LN15@stbi__proc

; 3229 :             if (z->spec_start > 63 || z->spec_end > 63  || z->spec_start > z->spec_end || z->succ_high > 13 || z->succ_low > 13)

  0026d	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00272	83 b8 34 48 00
	00 3f		 cmp	 DWORD PTR [rax+18484], 63 ; 0000003fH
  00279	7f 42		 jg	 SHORT $LN18@stbi__proc
  0027b	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00280	83 b8 38 48 00
	00 3f		 cmp	 DWORD PTR [rax+18488], 63 ; 0000003fH
  00287	7f 34		 jg	 SHORT $LN18@stbi__proc
  00289	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0028e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00293	8b 89 38 48 00
	00		 mov	 ecx, DWORD PTR [rcx+18488]
  00299	39 88 34 48 00
	00		 cmp	 DWORD PTR [rax+18484], ecx
  0029f	7f 1c		 jg	 SHORT $LN18@stbi__proc
  002a1	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  002a6	83 b8 3c 48 00
	00 0d		 cmp	 DWORD PTR [rax+18492], 13
  002ad	7f 0e		 jg	 SHORT $LN18@stbi__proc
  002af	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  002b4	83 b8 40 48 00
	00 0d		 cmp	 DWORD PTR [rax+18496], 13
  002bb	7e 0e		 jle	 SHORT $LN17@stbi__proc
$LN18@stbi__proc:

; 3230 :                 return stbi__err("bad SOS", "Corrupt JPEG");

  002bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG78934
  002c4	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  002c9	eb 5c		 jmp	 SHORT $LN1@stbi__proc
$LN17@stbi__proc:

; 3231 :         } else {

  002cb	eb 55		 jmp	 SHORT $LN16@stbi__proc
$LN15@stbi__proc:

; 3232 :             if (z->spec_start != 0) return stbi__err("bad SOS","Corrupt JPEG");

  002cd	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  002d2	83 b8 34 48 00
	00 00		 cmp	 DWORD PTR [rax+18484], 0
  002d9	74 0e		 je	 SHORT $LN19@stbi__proc
  002db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG78936
  002e2	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  002e7	eb 3e		 jmp	 SHORT $LN1@stbi__proc
$LN19@stbi__proc:

; 3233 :             if (z->succ_high != 0 || z->succ_low != 0) return stbi__err("bad SOS","Corrupt JPEG");

  002e9	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  002ee	83 b8 3c 48 00
	00 00		 cmp	 DWORD PTR [rax+18492], 0
  002f5	75 0e		 jne	 SHORT $LN21@stbi__proc
  002f7	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  002fc	83 b8 40 48 00
	00 00		 cmp	 DWORD PTR [rax+18496], 0
  00303	74 0e		 je	 SHORT $LN20@stbi__proc
$LN21@stbi__proc:
  00305	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG78939
  0030c	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00311	eb 14		 jmp	 SHORT $LN1@stbi__proc
$LN20@stbi__proc:

; 3234 :             z->spec_end = 63;

  00313	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00318	c7 80 38 48 00
	00 3f 00 00 00	 mov	 DWORD PTR [rax+18488], 63 ; 0000003fH
$LN16@stbi__proc:

; 3235 :         }
; 3236 :     }
; 3237 :     
; 3238 :     return 1;

  00322	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__proc:

; 3239 : }

  00327	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0032b	c3		 ret	 0
?stbi__process_scan_header@@YAHPEAUstbi__jpeg@@@Z ENDP	; stbi__process_scan_header
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
L$ = 32
i$1 = 36
th$2 = 40
n$3 = 44
tv64 = 48
i$4 = 52
i$5 = 56
i$6 = 60
p$7 = 64
tc$8 = 68
tv88 = 72
q$9 = 76
t$10 = 80
tv149 = 84
sixteen$11 = 88
tv152 = 92
tv155 = 96
q$12 = 100
tv236 = 104
ok$13 = 108
ok$14 = 112
v$15 = 120
sizes$16 = 128
__$ArrayPad$ = 192
z$ = 224
m$ = 232
?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z PROC	; stbi__process_marker

; 3099 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3100 :     int L;
; 3101 :     switch (m) {

  00022	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR m$[rsp]
  00029	89 44 24 30	 mov	 DWORD PTR tv64[rsp], eax
  0002d	81 7c 24 30 c4
	00 00 00	 cmp	 DWORD PTR tv64[rsp], 196 ; 000000c4H
  00035	0f 84 ff 01 00
	00		 je	 $LN29@stbi__proc
  0003b	81 7c 24 30 db
	00 00 00	 cmp	 DWORD PTR tv64[rsp], 219 ; 000000dbH
  00043	74 78		 je	 SHORT $LN26@stbi__proc
  00045	81 7c 24 30 dd
	00 00 00	 cmp	 DWORD PTR tv64[rsp], 221 ; 000000ddH
  0004d	74 20		 je	 SHORT $LN24@stbi__proc
  0004f	81 7c 24 30 ff
	00 00 00	 cmp	 DWORD PTR tv64[rsp], 255 ; 000000ffH
  00057	74 05		 je	 SHORT $LN23@stbi__proc
  00059	e9 3d 04 00 00	 jmp	 $LN2@stbi__proc
$LN23@stbi__proc:

; 3102 :         case STBI__MARKER_none: // no marker found
; 3103 :         return stbi__err("expected marker","Corrupt JPEG");

  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG78867
  00065	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0006a	e9 48 06 00 00	 jmp	 $LN1@stbi__proc
$LN24@stbi__proc:

; 3104 :         
; 3105 :         case 0xDD: // DRI - specify restart interval
; 3106 :         if (stbi__get16be(z->s) != 4) return stbi__err("bad DRI len","Corrupt JPEG");

  0006f	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00077	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0007a	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  0007f	83 f8 04	 cmp	 eax, 4
  00082	74 11		 je	 SHORT $LN25@stbi__proc
  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG78870
  0008b	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00090	e9 22 06 00 00	 jmp	 $LN1@stbi__proc
$LN25@stbi__proc:

; 3107 :         z->restart_interval = stbi__get16be(z->s);

  00095	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0009d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000a0	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  000a5	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  000ad	89 81 68 48 00
	00		 mov	 DWORD PTR [rcx+18536], eax

; 3108 :         return 1;

  000b3	b8 01 00 00 00	 mov	 eax, 1
  000b8	e9 fa 05 00 00	 jmp	 $LN1@stbi__proc
$LN26@stbi__proc:

; 3109 :         
; 3110 :         case 0xDB: // DQT - define quantization table
; 3111 :         L = stbi__get16be(z->s)-2;

  000bd	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  000c5	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000c8	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  000cd	83 e8 02	 sub	 eax, 2
  000d0	89 44 24 20	 mov	 DWORD PTR L$[rsp], eax
$LN4@stbi__proc:

; 3112 :         while (L > 0) {

  000d4	83 7c 24 20 00	 cmp	 DWORD PTR L$[rsp], 0
  000d9	0f 8e 39 01 00
	00		 jle	 $LN5@stbi__proc

; 3113 :             int q = stbi__get8(z->s);

  000df	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  000e7	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000ea	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  000ef	0f b6 c0	 movzx	 eax, al
  000f2	89 44 24 4c	 mov	 DWORD PTR q$9[rsp], eax

; 3114 :             int p = q >> 4, sixteen = (p != 0);

  000f6	8b 44 24 4c	 mov	 eax, DWORD PTR q$9[rsp]
  000fa	c1 f8 04	 sar	 eax, 4
  000fd	89 44 24 40	 mov	 DWORD PTR p$7[rsp], eax
  00101	83 7c 24 40 00	 cmp	 DWORD PTR p$7[rsp], 0
  00106	74 0a		 je	 SHORT $LN52@stbi__proc
  00108	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv88[rsp], 1
  00110	eb 08		 jmp	 SHORT $LN53@stbi__proc
$LN52@stbi__proc:
  00112	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv88[rsp], 0
$LN53@stbi__proc:
  0011a	8b 44 24 48	 mov	 eax, DWORD PTR tv88[rsp]
  0011e	89 44 24 58	 mov	 DWORD PTR sixteen$11[rsp], eax

; 3115 :             int t = q & 15,i;

  00122	8b 44 24 4c	 mov	 eax, DWORD PTR q$9[rsp]
  00126	83 e0 0f	 and	 eax, 15
  00129	89 44 24 50	 mov	 DWORD PTR t$10[rsp], eax

; 3116 :             if (p != 0 && p != 1) return stbi__err("bad DQT type","Corrupt JPEG");

  0012d	83 7c 24 40 00	 cmp	 DWORD PTR p$7[rsp], 0
  00132	74 18		 je	 SHORT $LN27@stbi__proc
  00134	83 7c 24 40 01	 cmp	 DWORD PTR p$7[rsp], 1
  00139	74 11		 je	 SHORT $LN27@stbi__proc
  0013b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG78873
  00142	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00147	e9 6b 05 00 00	 jmp	 $LN1@stbi__proc
$LN27@stbi__proc:

; 3117 :             if (t > 3) return stbi__err("bad DQT table","Corrupt JPEG");

  0014c	83 7c 24 50 03	 cmp	 DWORD PTR t$10[rsp], 3
  00151	7e 11		 jle	 SHORT $LN28@stbi__proc
  00153	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG78875
  0015a	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0015f	e9 53 05 00 00	 jmp	 $LN1@stbi__proc
$LN28@stbi__proc:

; 3118 :             
; 3119 :             for (i=0; i < 64; ++i)

  00164	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$4[rsp], 0
  0016c	eb 0a		 jmp	 SHORT $LN8@stbi__proc
$LN6@stbi__proc:
  0016e	8b 44 24 34	 mov	 eax, DWORD PTR i$4[rsp]
  00172	ff c0		 inc	 eax
  00174	89 44 24 34	 mov	 DWORD PTR i$4[rsp], eax
$LN8@stbi__proc:
  00178	83 7c 24 34 40	 cmp	 DWORD PTR i$4[rsp], 64	; 00000040H
  0017d	7d 6b		 jge	 SHORT $LN7@stbi__proc

; 3120 :                 z->dequant[t][stbi__jpeg_dezigzag[i]] = (stbi__uint16)(sixteen ? stbi__get16be(z->s) : stbi__get8(z->s));

  0017f	83 7c 24 58 00	 cmp	 DWORD PTR sixteen$11[rsp], 0
  00184	74 16		 je	 SHORT $LN54@stbi__proc
  00186	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0018e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00191	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  00196	89 44 24 54	 mov	 DWORD PTR tv149[rsp], eax
  0019a	eb 17		 jmp	 SHORT $LN55@stbi__proc
$LN54@stbi__proc:
  0019c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  001a4	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001a7	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  001ac	0f b6 c0	 movzx	 eax, al
  001af	89 44 24 54	 mov	 DWORD PTR tv149[rsp], eax
$LN55@stbi__proc:
  001b3	48 63 44 24 50	 movsxd	 rax, DWORD PTR t$10[rsp]
  001b8	48 69 c0 80 00
	00 00		 imul	 rax, rax, 128		; 00000080H
  001bf	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  001c7	48 8d 84 01 88
	34 00 00	 lea	 rax, QWORD PTR [rcx+rax+13448]
  001cf	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR i$4[rsp]
  001d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?stbi__jpeg_dezigzag@@3QBEB
  001db	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  001df	0f b7 54 24 54	 movzx	 edx, WORD PTR tv149[rsp]
  001e4	66 89 14 48	 mov	 WORD PTR [rax+rcx*2], dx
  001e8	eb 84		 jmp	 SHORT $LN6@stbi__proc
$LN7@stbi__proc:

; 3121 :             L -= (sixteen ? 129 : 65);

  001ea	83 7c 24 58 00	 cmp	 DWORD PTR sixteen$11[rsp], 0
  001ef	74 0a		 je	 SHORT $LN56@stbi__proc
  001f1	c7 44 24 5c 81
	00 00 00	 mov	 DWORD PTR tv152[rsp], 129 ; 00000081H
  001f9	eb 08		 jmp	 SHORT $LN57@stbi__proc
$LN56@stbi__proc:
  001fb	c7 44 24 5c 41
	00 00 00	 mov	 DWORD PTR tv152[rsp], 65 ; 00000041H
$LN57@stbi__proc:
  00203	8b 44 24 5c	 mov	 eax, DWORD PTR tv152[rsp]
  00207	8b 4c 24 20	 mov	 ecx, DWORD PTR L$[rsp]
  0020b	2b c8		 sub	 ecx, eax
  0020d	8b c1		 mov	 eax, ecx
  0020f	89 44 24 20	 mov	 DWORD PTR L$[rsp], eax

; 3122 :         }

  00213	e9 bc fe ff ff	 jmp	 $LN4@stbi__proc
$LN5@stbi__proc:

; 3123 :         return L==0;

  00218	83 7c 24 20 00	 cmp	 DWORD PTR L$[rsp], 0
  0021d	75 0a		 jne	 SHORT $LN58@stbi__proc
  0021f	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv155[rsp], 1
  00227	eb 08		 jmp	 SHORT $LN59@stbi__proc
$LN58@stbi__proc:
  00229	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv155[rsp], 0
$LN59@stbi__proc:
  00231	8b 44 24 60	 mov	 eax, DWORD PTR tv155[rsp]
  00235	e9 7d 04 00 00	 jmp	 $LN1@stbi__proc
$LN29@stbi__proc:

; 3124 :         
; 3125 :         case 0xC4: // DHT - define huffman table
; 3126 :         L = stbi__get16be(z->s)-2;

  0023a	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00242	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00245	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  0024a	83 e8 02	 sub	 eax, 2
  0024d	89 44 24 20	 mov	 DWORD PTR L$[rsp], eax
$LN9@stbi__proc:

; 3127 :         while (L > 0) {

  00251	83 7c 24 20 00	 cmp	 DWORD PTR L$[rsp], 0
  00256	0f 8e 1d 02 00
	00		 jle	 $LN10@stbi__proc

; 3128 :             stbi_uc *v;
; 3129 :             int sizes[16],i,n=0;

  0025c	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR n$3[rsp], 0

; 3130 :             int q = stbi__get8(z->s);

  00264	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0026c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0026f	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00274	0f b6 c0	 movzx	 eax, al
  00277	89 44 24 64	 mov	 DWORD PTR q$12[rsp], eax

; 3131 :             int tc = q >> 4;

  0027b	8b 44 24 64	 mov	 eax, DWORD PTR q$12[rsp]
  0027f	c1 f8 04	 sar	 eax, 4
  00282	89 44 24 44	 mov	 DWORD PTR tc$8[rsp], eax

; 3132 :             int th = q & 15;

  00286	8b 44 24 64	 mov	 eax, DWORD PTR q$12[rsp]
  0028a	83 e0 0f	 and	 eax, 15
  0028d	89 44 24 28	 mov	 DWORD PTR th$2[rsp], eax

; 3133 :             if (tc > 1 || th > 3) return stbi__err("bad DHT header","Corrupt JPEG");

  00291	83 7c 24 44 01	 cmp	 DWORD PTR tc$8[rsp], 1
  00296	7f 07		 jg	 SHORT $LN31@stbi__proc
  00298	83 7c 24 28 03	 cmp	 DWORD PTR th$2[rsp], 3
  0029d	7e 11		 jle	 SHORT $LN30@stbi__proc
$LN31@stbi__proc:
  0029f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG78879
  002a6	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  002ab	e9 07 04 00 00	 jmp	 $LN1@stbi__proc
$LN30@stbi__proc:

; 3134 :             for (i=0; i < 16; ++i) {

  002b0	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  002b8	eb 0a		 jmp	 SHORT $LN13@stbi__proc
$LN11@stbi__proc:
  002ba	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  002be	ff c0		 inc	 eax
  002c0	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
$LN13@stbi__proc:
  002c4	83 7c 24 24 10	 cmp	 DWORD PTR i$1[rsp], 16
  002c9	7d 39		 jge	 SHORT $LN12@stbi__proc

; 3135 :                 sizes[i] = stbi__get8(z->s);

  002cb	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  002d3	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  002d6	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  002db	0f b6 c0	 movzx	 eax, al
  002de	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR i$1[rsp]
  002e3	89 84 8c 80 00
	00 00		 mov	 DWORD PTR sizes$16[rsp+rcx*4], eax

; 3136 :                 n += sizes[i];

  002ea	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$1[rsp]
  002ef	8b 84 84 80 00
	00 00		 mov	 eax, DWORD PTR sizes$16[rsp+rax*4]
  002f6	8b 4c 24 2c	 mov	 ecx, DWORD PTR n$3[rsp]
  002fa	03 c8		 add	 ecx, eax
  002fc	8b c1		 mov	 eax, ecx
  002fe	89 44 24 2c	 mov	 DWORD PTR n$3[rsp], eax

; 3137 :             }

  00302	eb b6		 jmp	 SHORT $LN11@stbi__proc
$LN12@stbi__proc:

; 3138 :             if(n > 256) return stbi__err("bad DHT header","Corrupt JPEG"); // Loop over i < n would write past end of values!

  00304	81 7c 24 2c 00
	01 00 00	 cmp	 DWORD PTR n$3[rsp], 256	; 00000100H
  0030c	7e 11		 jle	 SHORT $LN32@stbi__proc
  0030e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG78881
  00315	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0031a	e9 98 03 00 00	 jmp	 $LN1@stbi__proc
$LN32@stbi__proc:

; 3139 :             L -= 17;

  0031f	8b 44 24 20	 mov	 eax, DWORD PTR L$[rsp]
  00323	83 e8 11	 sub	 eax, 17
  00326	89 44 24 20	 mov	 DWORD PTR L$[rsp], eax

; 3140 :             if (tc == 0) {

  0032a	83 7c 24 44 00	 cmp	 DWORD PTR tc$8[rsp], 0
  0032f	75 57		 jne	 SHORT $LN33@stbi__proc

; 3141 :                 if (!stbi__build_huffman(z->huff_dc+th, sizes)) return 0;

  00331	48 63 44 24 28	 movsxd	 rax, DWORD PTR th$2[rsp]
  00336	48 69 c0 90 06
	00 00		 imul	 rax, rax, 1680		; 00000690H
  0033d	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00345	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  0034a	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR sizes$16[rsp]
  00352	48 8b c8	 mov	 rcx, rax
  00355	e8 00 00 00 00	 call	 ?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z ; stbi__build_huffman
  0035a	85 c0		 test	 eax, eax
  0035c	75 07		 jne	 SHORT $LN35@stbi__proc
  0035e	33 c0		 xor	 eax, eax
  00360	e9 52 03 00 00	 jmp	 $LN1@stbi__proc
$LN35@stbi__proc:

; 3142 :                 v = z->huff_dc[th].values;

  00365	48 63 44 24 28	 movsxd	 rax, DWORD PTR th$2[rsp]
  0036a	48 69 c0 90 06
	00 00		 imul	 rax, rax, 1680		; 00000690H
  00371	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00379	48 8d 84 01 08
	04 00 00	 lea	 rax, QWORD PTR [rcx+rax+1032]
  00381	48 89 44 24 78	 mov	 QWORD PTR v$15[rsp], rax

; 3143 :             } else {

  00386	eb 58		 jmp	 SHORT $LN34@stbi__proc
$LN33@stbi__proc:

; 3144 :                 if (!stbi__build_huffman(z->huff_ac+th, sizes)) return 0;

  00388	48 63 44 24 28	 movsxd	 rax, DWORD PTR th$2[rsp]
  0038d	48 69 c0 90 06
	00 00		 imul	 rax, rax, 1680		; 00000690H
  00394	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0039c	48 8d 84 01 48
	1a 00 00	 lea	 rax, QWORD PTR [rcx+rax+6728]
  003a4	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR sizes$16[rsp]
  003ac	48 8b c8	 mov	 rcx, rax
  003af	e8 00 00 00 00	 call	 ?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z ; stbi__build_huffman
  003b4	85 c0		 test	 eax, eax
  003b6	75 07		 jne	 SHORT $LN36@stbi__proc
  003b8	33 c0		 xor	 eax, eax
  003ba	e9 f8 02 00 00	 jmp	 $LN1@stbi__proc
$LN36@stbi__proc:

; 3145 :                 v = z->huff_ac[th].values;

  003bf	48 63 44 24 28	 movsxd	 rax, DWORD PTR th$2[rsp]
  003c4	48 69 c0 90 06
	00 00		 imul	 rax, rax, 1680		; 00000690H
  003cb	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  003d3	48 8d 84 01 48
	1e 00 00	 lea	 rax, QWORD PTR [rcx+rax+7752]
  003db	48 89 44 24 78	 mov	 QWORD PTR v$15[rsp], rax
$LN34@stbi__proc:

; 3146 :             }
; 3147 :             for (i=0; i < n; ++i)

  003e0	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  003e8	eb 0a		 jmp	 SHORT $LN16@stbi__proc
$LN14@stbi__proc:
  003ea	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  003ee	ff c0		 inc	 eax
  003f0	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
$LN16@stbi__proc:
  003f4	8b 44 24 2c	 mov	 eax, DWORD PTR n$3[rsp]
  003f8	39 44 24 24	 cmp	 DWORD PTR i$1[rsp], eax
  003fc	7d 1f		 jge	 SHORT $LN15@stbi__proc

; 3148 :                 v[i] = stbi__get8(z->s);

  003fe	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00406	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00409	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0040e	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00413	48 8b 54 24 78	 mov	 rdx, QWORD PTR v$15[rsp]
  00418	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0041b	eb cd		 jmp	 SHORT $LN14@stbi__proc
$LN15@stbi__proc:

; 3149 :             if (tc != 0)

  0041d	83 7c 24 44 00	 cmp	 DWORD PTR tc$8[rsp], 0
  00422	74 40		 je	 SHORT $LN37@stbi__proc

; 3150 :                 stbi__build_fast_ac(z->fast_ac[th], z->huff_ac + th);

  00424	48 63 44 24 28	 movsxd	 rax, DWORD PTR th$2[rsp]
  00429	48 69 c0 90 06
	00 00		 imul	 rax, rax, 1680		; 00000690H
  00430	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00438	48 8d 84 01 48
	1a 00 00	 lea	 rax, QWORD PTR [rcx+rax+6728]
  00440	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR th$2[rsp]
  00445	48 69 c9 00 04
	00 00		 imul	 rcx, rcx, 1024		; 00000400H
  0044c	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00454	48 8d 8c 0a 88
	36 00 00	 lea	 rcx, QWORD PTR [rdx+rcx+13960]
  0045c	48 8b d0	 mov	 rdx, rax
  0045f	e8 00 00 00 00	 call	 ?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z ; stbi__build_fast_ac
$LN37@stbi__proc:

; 3151 :             L -= n;

  00464	8b 44 24 2c	 mov	 eax, DWORD PTR n$3[rsp]
  00468	8b 4c 24 20	 mov	 ecx, DWORD PTR L$[rsp]
  0046c	2b c8		 sub	 ecx, eax
  0046e	8b c1		 mov	 eax, ecx
  00470	89 44 24 20	 mov	 DWORD PTR L$[rsp], eax

; 3152 :         }

  00474	e9 d8 fd ff ff	 jmp	 $LN9@stbi__proc
$LN10@stbi__proc:

; 3153 :         return L==0;

  00479	83 7c 24 20 00	 cmp	 DWORD PTR L$[rsp], 0
  0047e	75 0a		 jne	 SHORT $LN60@stbi__proc
  00480	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv236[rsp], 1
  00488	eb 08		 jmp	 SHORT $LN61@stbi__proc
$LN60@stbi__proc:
  0048a	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv236[rsp], 0
$LN61@stbi__proc:
  00492	8b 44 24 68	 mov	 eax, DWORD PTR tv236[rsp]
  00496	e9 1c 02 00 00	 jmp	 $LN1@stbi__proc
$LN2@stbi__proc:

; 3154 :     }
; 3155 :     
; 3156 :     // check for comment block or APP blocks
; 3157 :     if ((m >= 0xE0 && m <= 0xEF) || m == 0xFE) {

  0049b	81 bc 24 e8 00
	00 00 e0 00 00
	00		 cmp	 DWORD PTR m$[rsp], 224	; 000000e0H
  004a6	7c 0d		 jl	 SHORT $LN40@stbi__proc
  004a8	81 bc 24 e8 00
	00 00 ef 00 00
	00		 cmp	 DWORD PTR m$[rsp], 239	; 000000efH
  004b3	7e 11		 jle	 SHORT $LN39@stbi__proc
$LN40@stbi__proc:
  004b5	81 bc 24 e8 00
	00 00 fe 00 00
	00		 cmp	 DWORD PTR m$[rsp], 254	; 000000feH
  004c0	0f 85 e5 01 00
	00		 jne	 $LN38@stbi__proc
$LN39@stbi__proc:

; 3158 :         L = stbi__get16be(z->s);

  004c6	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  004ce	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  004d1	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  004d6	89 44 24 20	 mov	 DWORD PTR L$[rsp], eax

; 3159 :         if (L < 2) {

  004da	83 7c 24 20 02	 cmp	 DWORD PTR L$[rsp], 2
  004df	7d 31		 jge	 SHORT $LN41@stbi__proc

; 3160 :             if (m == 0xFE)

  004e1	81 bc 24 e8 00
	00 00 fe 00 00
	00		 cmp	 DWORD PTR m$[rsp], 254	; 000000feH
  004ec	75 13		 jne	 SHORT $LN42@stbi__proc

; 3161 :                 return stbi__err("bad COM len","Corrupt JPEG");

  004ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG78893
  004f5	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  004fa	e9 b8 01 00 00	 jmp	 $LN1@stbi__proc
  004ff	eb 11		 jmp	 SHORT $LN43@stbi__proc
$LN42@stbi__proc:

; 3162 :             else
; 3163 :                 return stbi__err("bad APP len","Corrupt JPEG");

  00501	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG78894
  00508	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0050d	e9 a5 01 00 00	 jmp	 $LN1@stbi__proc
$LN43@stbi__proc:
$LN41@stbi__proc:

; 3164 :         }
; 3165 :         L -= 2;

  00512	8b 44 24 20	 mov	 eax, DWORD PTR L$[rsp]
  00516	83 e8 02	 sub	 eax, 2
  00519	89 44 24 20	 mov	 DWORD PTR L$[rsp], eax

; 3166 :         
; 3167 :         if (m == 0xE0 && L >= 5) { // JFIF APP0 segment

  0051d	81 bc 24 e8 00
	00 00 e0 00 00
	00		 cmp	 DWORD PTR m$[rsp], 224	; 000000e0H
  00528	0f 85 84 00 00
	00		 jne	 $LN44@stbi__proc
  0052e	83 7c 24 20 05	 cmp	 DWORD PTR L$[rsp], 5
  00533	7c 7d		 jl	 SHORT $LN44@stbi__proc

; 3168 :             static const unsigned char tag[5] = {'J','F','I','F','\0'};
; 3169 :             int ok = 1;

  00535	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR ok$13[rsp], 1

; 3170 :             int i;
; 3171 :             for (i=0; i < 5; ++i)

  0053d	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR i$5[rsp], 0
  00545	eb 0a		 jmp	 SHORT $LN19@stbi__proc
$LN17@stbi__proc:
  00547	8b 44 24 38	 mov	 eax, DWORD PTR i$5[rsp]
  0054b	ff c0		 inc	 eax
  0054d	89 44 24 38	 mov	 DWORD PTR i$5[rsp], eax
$LN19@stbi__proc:
  00551	83 7c 24 38 05	 cmp	 DWORD PTR i$5[rsp], 5
  00556	7d 31		 jge	 SHORT $LN18@stbi__proc

; 3172 :                 if (stbi__get8(z->s) != tag[i])

  00558	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00560	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00563	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00568	0f b6 c0	 movzx	 eax, al
  0056b	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR i$5[rsp]
  00570	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?tag@?CN@??stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z@4QBEB
  00577	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0057b	3b c1		 cmp	 eax, ecx
  0057d	74 08		 je	 SHORT $LN46@stbi__proc

; 3173 :                 ok = 0;

  0057f	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR ok$13[rsp], 0
$LN46@stbi__proc:
  00587	eb be		 jmp	 SHORT $LN17@stbi__proc
$LN18@stbi__proc:

; 3174 :             L -= 5;

  00589	8b 44 24 20	 mov	 eax, DWORD PTR L$[rsp]
  0058d	83 e8 05	 sub	 eax, 5
  00590	89 44 24 20	 mov	 DWORD PTR L$[rsp], eax

; 3175 :             if (ok)

  00594	83 7c 24 6c 00	 cmp	 DWORD PTR ok$13[rsp], 0
  00599	74 12		 je	 SHORT $LN47@stbi__proc

; 3176 :                 z->jfif = 1;

  0059b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  005a3	c7 80 48 48 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+18504], 1
$LN47@stbi__proc:
  005ad	e9 de 00 00 00	 jmp	 $LN45@stbi__proc
$LN44@stbi__proc:

; 3177 :         } else if (m == 0xEE && L >= 12) { // Adobe APP14 segment

  005b2	81 bc 24 e8 00
	00 00 ee 00 00
	00		 cmp	 DWORD PTR m$[rsp], 238	; 000000eeH
  005bd	0f 85 cd 00 00
	00		 jne	 $LN48@stbi__proc
  005c3	83 7c 24 20 0c	 cmp	 DWORD PTR L$[rsp], 12
  005c8	0f 8c c2 00 00
	00		 jl	 $LN48@stbi__proc

; 3178 :             static const unsigned char tag[6] = {'A','d','o','b','e','\0'};
; 3179 :             int ok = 1;

  005ce	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR ok$14[rsp], 1

; 3180 :             int i;
; 3181 :             for (i=0; i < 6; ++i)

  005d6	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR i$6[rsp], 0
  005de	eb 0a		 jmp	 SHORT $LN22@stbi__proc
$LN20@stbi__proc:
  005e0	8b 44 24 3c	 mov	 eax, DWORD PTR i$6[rsp]
  005e4	ff c0		 inc	 eax
  005e6	89 44 24 3c	 mov	 DWORD PTR i$6[rsp], eax
$LN22@stbi__proc:
  005ea	83 7c 24 3c 06	 cmp	 DWORD PTR i$6[rsp], 6
  005ef	7d 31		 jge	 SHORT $LN21@stbi__proc

; 3182 :                 if (stbi__get8(z->s) != tag[i])

  005f1	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  005f9	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  005fc	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00601	0f b6 c0	 movzx	 eax, al
  00604	48 63 4c 24 3c	 movsxd	 rcx, DWORD PTR i$6[rsp]
  00609	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?tag@?DG@??stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z@4QBEB
  00610	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00614	3b c1		 cmp	 eax, ecx
  00616	74 08		 je	 SHORT $LN49@stbi__proc

; 3183 :                 ok = 0;

  00618	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR ok$14[rsp], 0
$LN49@stbi__proc:
  00620	eb be		 jmp	 SHORT $LN20@stbi__proc
$LN21@stbi__proc:

; 3184 :             L -= 6;

  00622	8b 44 24 20	 mov	 eax, DWORD PTR L$[rsp]
  00626	83 e8 06	 sub	 eax, 6
  00629	89 44 24 20	 mov	 DWORD PTR L$[rsp], eax

; 3185 :             if (ok) {

  0062d	83 7c 24 70 00	 cmp	 DWORD PTR ok$14[rsp], 0
  00632	74 5c		 je	 SHORT $LN50@stbi__proc

; 3186 :                 stbi__get8(z->s); // version

  00634	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0063c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0063f	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8

; 3187 :                 stbi__get16be(z->s); // flags0

  00644	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0064c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0064f	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 3188 :                 stbi__get16be(z->s); // flags1

  00654	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0065c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0065f	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 3189 :                 z->app14_color_transform = stbi__get8(z->s); // color transform

  00664	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0066c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0066f	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00674	0f b6 c0	 movzx	 eax, al
  00677	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0067f	89 81 4c 48 00
	00		 mov	 DWORD PTR [rcx+18508], eax

; 3190 :                 L -= 6;

  00685	8b 44 24 20	 mov	 eax, DWORD PTR L$[rsp]
  00689	83 e8 06	 sub	 eax, 6
  0068c	89 44 24 20	 mov	 DWORD PTR L$[rsp], eax
$LN50@stbi__proc:
$LN48@stbi__proc:
$LN45@stbi__proc:

; 3191 :             }
; 3192 :         }
; 3193 :         
; 3194 :         stbi__skip(z->s, L);

  00690	8b 54 24 20	 mov	 edx, DWORD PTR L$[rsp]
  00694	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0069c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0069f	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 3195 :         return 1;

  006a4	b8 01 00 00 00	 mov	 eax, 1
  006a9	eb 0c		 jmp	 SHORT $LN1@stbi__proc
$LN38@stbi__proc:

; 3196 :     }
; 3197 :     
; 3198 :     return stbi__err("unknown marker","Corrupt JPEG");

  006ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG78902
  006b2	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
$LN1@stbi__proc:

; 3199 : }

  006b7	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  006bf	48 33 cc	 xor	 rcx, rsp
  006c2	e8 00 00 00 00	 call	 __security_check_cookie
  006c7	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  006ce	c3		 ret	 0
?stbi__process_marker@@YAHPEAUstbi__jpeg@@H@Z ENDP	; stbi__process_marker
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
n$1 = 32
j$2 = 36
i$3 = 40
h$4 = 44
w$5 = 48
data$6 = 56
z$ = 80
?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z PROC		; stbi__jpeg_finish

; 3080 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3081 :     if (z->progressive) {

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  0000e	83 b8 30 48 00
	00 00		 cmp	 DWORD PTR [rax+18480], 0
  00015	0f 84 a9 01 00
	00		 je	 $LN11@stbi__jpeg

; 3082 :         // dequantize and idct the data
; 3083 :         int i,j,n;
; 3084 :         for (n=0; n < z->s->img_n; ++n) {

  0001b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR n$1[rsp], 0
  00023	eb 0a		 jmp	 SHORT $LN4@stbi__jpeg
$LN2@stbi__jpeg:
  00025	8b 44 24 20	 mov	 eax, DWORD PTR n$1[rsp]
  00029	ff c0		 inc	 eax
  0002b	89 44 24 20	 mov	 DWORD PTR n$1[rsp], eax
$LN4@stbi__jpeg:
  0002f	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  00034	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00037	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0003a	39 44 24 20	 cmp	 DWORD PTR n$1[rsp], eax
  0003e	0f 8d 80 01 00
	00		 jge	 $LN3@stbi__jpeg

; 3085 :             int w = (z->img_comp[n].x+7) >> 3;

  00044	48 63 44 24 20	 movsxd	 rax, DWORD PTR n$1[rsp]
  00049	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0004d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00052	8b 84 01 bc 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18108]
  00059	83 c0 07	 add	 eax, 7
  0005c	c1 f8 03	 sar	 eax, 3
  0005f	89 44 24 30	 mov	 DWORD PTR w$5[rsp], eax

; 3086 :             int h = (z->img_comp[n].y+7) >> 3;

  00063	48 63 44 24 20	 movsxd	 rax, DWORD PTR n$1[rsp]
  00068	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0006c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00071	8b 84 01 c0 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18112]
  00078	83 c0 07	 add	 eax, 7
  0007b	c1 f8 03	 sar	 eax, 3
  0007e	89 44 24 2c	 mov	 DWORD PTR h$4[rsp], eax

; 3087 :             for (j=0; j < h; ++j) {

  00082	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$2[rsp], 0
  0008a	eb 0a		 jmp	 SHORT $LN7@stbi__jpeg
$LN5@stbi__jpeg:
  0008c	8b 44 24 24	 mov	 eax, DWORD PTR j$2[rsp]
  00090	ff c0		 inc	 eax
  00092	89 44 24 24	 mov	 DWORD PTR j$2[rsp], eax
$LN7@stbi__jpeg:
  00096	8b 44 24 2c	 mov	 eax, DWORD PTR h$4[rsp]
  0009a	39 44 24 24	 cmp	 DWORD PTR j$2[rsp], eax
  0009e	0f 8d 1b 01 00
	00		 jge	 $LN6@stbi__jpeg

; 3088 :                 for (i=0; i < w; ++i) {

  000a4	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$3[rsp], 0
  000ac	eb 0a		 jmp	 SHORT $LN10@stbi__jpeg
$LN8@stbi__jpeg:
  000ae	8b 44 24 28	 mov	 eax, DWORD PTR i$3[rsp]
  000b2	ff c0		 inc	 eax
  000b4	89 44 24 28	 mov	 DWORD PTR i$3[rsp], eax
$LN10@stbi__jpeg:
  000b8	8b 44 24 30	 mov	 eax, DWORD PTR w$5[rsp]
  000bc	39 44 24 28	 cmp	 DWORD PTR i$3[rsp], eax
  000c0	0f 8d f4 00 00
	00		 jge	 $LN9@stbi__jpeg

; 3089 :                     short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);

  000c6	48 63 44 24 20	 movsxd	 rax, DWORD PTR n$1[rsp]
  000cb	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000cf	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR n$1[rsp]
  000d4	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  000d8	48 8b 54 24 50	 mov	 rdx, QWORD PTR z$[rsp]
  000dd	44 8b 44 24 24	 mov	 r8d, DWORD PTR j$2[rsp]
  000e2	44 0f af 84 0a
	f8 46 00 00	 imul	 r8d, DWORD PTR [rdx+rcx+18168]
  000eb	41 8b c8	 mov	 ecx, r8d
  000ee	8b 54 24 28	 mov	 edx, DWORD PTR i$3[rsp]
  000f2	03 d1		 add	 edx, ecx
  000f4	8b ca		 mov	 ecx, edx
  000f6	6b c9 40	 imul	 ecx, ecx, 64		; 00000040H
  000f9	48 63 c9	 movsxd	 rcx, ecx
  000fc	48 8b 54 24 50	 mov	 rdx, QWORD PTR z$[rsp]
  00101	48 8b 84 02 f0
	46 00 00	 mov	 rax, QWORD PTR [rdx+rax+18160]
  00109	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  0010d	48 89 44 24 38	 mov	 QWORD PTR data$6[rsp], rax

; 3090 :                     stbi__jpeg_dequantize(data, z->dequant[z->img_comp[n].tq]);

  00112	48 63 44 24 20	 movsxd	 rax, DWORD PTR n$1[rsp]
  00117	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0011b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00120	48 63 84 01 ac
	46 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+18092]
  00128	48 69 c0 80 00
	00 00		 imul	 rax, rax, 128		; 00000080H
  0012f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR z$[rsp]
  00134	48 8d 84 01 88
	34 00 00	 lea	 rax, QWORD PTR [rcx+rax+13448]
  0013c	48 8b d0	 mov	 rdx, rax
  0013f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR data$6[rsp]
  00144	e8 00 00 00 00	 call	 ?stbi__jpeg_dequantize@@YAXPEAFPEAG@Z ; stbi__jpeg_dequantize

; 3091 :                     z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);

  00149	48 63 44 24 20	 movsxd	 rax, DWORD PTR n$1[rsp]
  0014e	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00152	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR n$1[rsp]
  00157	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  0015b	48 63 54 24 20	 movsxd	 rdx, DWORD PTR n$1[rsp]
  00160	48 6b d2 60	 imul	 rdx, rdx, 96		; 00000060H
  00164	4c 8b 44 24 50	 mov	 r8, QWORD PTR z$[rsp]
  00169	41 8b 94 10 c4
	46 00 00	 mov	 edx, DWORD PTR [r8+rdx+18116]
  00171	0f af 54 24 24	 imul	 edx, DWORD PTR j$2[rsp]
  00176	c1 e2 03	 shl	 edx, 3
  00179	48 63 d2	 movsxd	 rdx, edx
  0017c	4c 8b 44 24 50	 mov	 r8, QWORD PTR z$[rsp]
  00181	49 8b 8c 08 d0
	46 00 00	 mov	 rcx, QWORD PTR [r8+rcx+18128]
  00189	48 03 ca	 add	 rcx, rdx
  0018c	8b 54 24 28	 mov	 edx, DWORD PTR i$3[rsp]
  00190	c1 e2 03	 shl	 edx, 3
  00193	48 63 d2	 movsxd	 rdx, edx
  00196	48 03 ca	 add	 rcx, rdx
  00199	4c 8b 44 24 38	 mov	 r8, QWORD PTR data$6[rsp]
  0019e	48 8b 54 24 50	 mov	 rdx, QWORD PTR z$[rsp]
  001a3	8b 94 02 c4 46
	00 00		 mov	 edx, DWORD PTR [rdx+rax+18116]
  001aa	48 8b 44 24 50	 mov	 rax, QWORD PTR z$[rsp]
  001af	ff 90 70 48 00
	00		 call	 QWORD PTR [rax+18544]

; 3092 :                 }

  001b5	e9 f4 fe ff ff	 jmp	 $LN8@stbi__jpeg
$LN9@stbi__jpeg:

; 3093 :             }

  001ba	e9 cd fe ff ff	 jmp	 $LN5@stbi__jpeg
$LN6@stbi__jpeg:

; 3094 :         }

  001bf	e9 61 fe ff ff	 jmp	 $LN2@stbi__jpeg
$LN3@stbi__jpeg:
$LN11@stbi__jpeg:

; 3095 :     }
; 3096 : }

  001c4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001c8	c3		 ret	 0
?stbi__jpeg_finish@@YAXPEAUstbi__jpeg@@@Z ENDP		; stbi__jpeg_finish
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
i$ = 0
data$ = 32
dequant$ = 40
?stbi__jpeg_dequantize@@YAXPEAFPEAG@Z PROC		; stbi__jpeg_dequantize

; 3073 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 3074 :     int i;
; 3075 :     for (i=0; i < 64; ++i)

  0000e	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  00015	eb 08		 jmp	 SHORT $LN4@stbi__jpeg
$LN2@stbi__jpeg:
  00017	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0001a	ff c0		 inc	 eax
  0001c	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__jpeg:
  0001f	83 3c 24 40	 cmp	 DWORD PTR i$[rsp], 64	; 00000040H
  00023	7d 2c		 jge	 SHORT $LN3@stbi__jpeg

; 3076 :         data[i] *= dequant[i];

  00025	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00029	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  0002d	48 8b 54 24 28	 mov	 rdx, QWORD PTR dequant$[rsp]
  00032	0f b7 0c 4a	 movzx	 ecx, WORD PTR [rdx+rcx*2]
  00036	48 8b 54 24 20	 mov	 rdx, QWORD PTR data$[rsp]
  0003b	0f bf 04 42	 movsx	 eax, WORD PTR [rdx+rax*2]
  0003f	0f af c1	 imul	 eax, ecx
  00042	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  00046	48 8b 54 24 20	 mov	 rdx, QWORD PTR data$[rsp]
  0004b	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax
  0004f	eb c6		 jmp	 SHORT $LN2@stbi__jpeg
$LN3@stbi__jpeg:

; 3077 : }

  00051	48 83 c4 18	 add	 rsp, 24
  00055	c3		 ret	 0
?stbi__jpeg_dequantize@@YAXPEAFPEAG@Z ENDP		; stbi__jpeg_dequantize
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
n$1 = 64
n$2 = 68
n$3 = 72
n$4 = 76
j$5 = 80
i$6 = 84
k$7 = 88
i$8 = 92
x$9 = 96
j$10 = 100
y$11 = 104
j$12 = 108
i$13 = 112
k$14 = 116
i$15 = 120
x$16 = 124
j$17 = 128
y$18 = 132
ha$19 = 136
tv190 = 140
ha$20 = 144
tv311 = 148
ha$21 = 152
tv400 = 156
tv518 = 160
h$22 = 164
w$23 = 168
y2$24 = 172
x2$25 = 176
h$26 = 180
w$27 = 184
y2$28 = 188
x2$29 = 192
data$30 = 200
data$31 = 208
data$32 = 224
data$33 = 352
__$ArrayPad$ = 480
z$ = 512
?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z PROC ; stbi__parse_entropy_coded_data

; 2949 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec f8 01
	00 00		 sub	 rsp, 504		; 000001f8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 e0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2950 :     stbi__jpeg_reset(z);

  0001e	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00026	e8 00 00 00 00	 call	 ?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z ; stbi__jpeg_reset

; 2951 :     if (!z->progressive) {

  0002b	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00033	83 b8 30 48 00
	00 00		 cmp	 DWORD PTR [rax+18480], 0
  0003a	0f 85 68 06 00
	00		 jne	 $LN44@stbi__pars

; 2952 :         if (z->scan_n == 1) {

  00040	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00048	83 b8 54 48 00
	00 01		 cmp	 DWORD PTR [rax+18516], 1
  0004f	0f 85 ca 02 00
	00		 jne	 $LN46@stbi__pars

; 2953 :             int i,j;
; 2954 :             STBI_SIMD_ALIGN(short, data[64]);
; 2955 :             int n = z->order[0];

  00055	b8 04 00 00 00	 mov	 eax, 4
  0005a	48 6b c0 00	 imul	 rax, rax, 0
  0005e	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00066	8b 84 01 58 48
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18520]
  0006d	89 44 24 44	 mov	 DWORD PTR n$2[rsp], eax

; 2956 :             // non-interleaved data, we just need to process one block at a time,
; 2957 :             // in trivial scanline order
; 2958 :             // number of blocks to do just depends on how many actual "pixels" this
; 2959 :             // component has, independent of interleaved MCU blocking and such
; 2960 :             int w = (z->img_comp[n].x+7) >> 3;

  00071	48 63 44 24 44	 movsxd	 rax, DWORD PTR n$2[rsp]
  00076	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0007a	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00082	8b 84 01 bc 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18108]
  00089	83 c0 07	 add	 eax, 7
  0008c	c1 f8 03	 sar	 eax, 3
  0008f	89 84 24 a8 00
	00 00		 mov	 DWORD PTR w$23[rsp], eax

; 2961 :             int h = (z->img_comp[n].y+7) >> 3;

  00096	48 63 44 24 44	 movsxd	 rax, DWORD PTR n$2[rsp]
  0009b	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0009f	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  000a7	8b 84 01 c0 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18112]
  000ae	83 c0 07	 add	 eax, 7
  000b1	c1 f8 03	 sar	 eax, 3
  000b4	89 84 24 a4 00
	00 00		 mov	 DWORD PTR h$22[rsp], eax

; 2962 :             for (j=0; j < h; ++j) {

  000bb	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR j$5[rsp], 0
  000c3	eb 0a		 jmp	 SHORT $LN4@stbi__pars
$LN2@stbi__pars:
  000c5	8b 44 24 50	 mov	 eax, DWORD PTR j$5[rsp]
  000c9	ff c0		 inc	 eax
  000cb	89 44 24 50	 mov	 DWORD PTR j$5[rsp], eax
$LN4@stbi__pars:
  000cf	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR h$22[rsp]
  000d6	39 44 24 50	 cmp	 DWORD PTR j$5[rsp], eax
  000da	0f 8d 30 02 00
	00		 jge	 $LN3@stbi__pars

; 2963 :                 for (i=0; i < w; ++i) {

  000e0	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$6[rsp], 0
  000e8	eb 0a		 jmp	 SHORT $LN7@stbi__pars
$LN5@stbi__pars:
  000ea	8b 44 24 54	 mov	 eax, DWORD PTR i$6[rsp]
  000ee	ff c0		 inc	 eax
  000f0	89 44 24 54	 mov	 DWORD PTR i$6[rsp], eax
$LN7@stbi__pars:
  000f4	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR w$23[rsp]
  000fb	39 44 24 54	 cmp	 DWORD PTR i$6[rsp], eax
  000ff	0f 8d 06 02 00
	00		 jge	 $LN6@stbi__pars

; 2964 :                     int ha = z->img_comp[n].ha;

  00105	48 63 44 24 44	 movsxd	 rax, DWORD PTR n$2[rsp]
  0010a	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0010e	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00116	8b 84 01 b4 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18100]
  0011d	89 84 24 88 00
	00 00		 mov	 DWORD PTR ha$19[rsp], eax

; 2965 :                     if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;

  00124	48 63 44 24 44	 movsxd	 rax, DWORD PTR n$2[rsp]
  00129	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0012d	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00135	48 63 84 01 ac
	46 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+18092]
  0013d	48 69 c0 80 00
	00 00		 imul	 rax, rax, 128		; 00000080H
  00144	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0014c	48 8d 84 01 88
	34 00 00	 lea	 rax, QWORD PTR [rcx+rax+13448]
  00154	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR ha$19[rsp]
  0015c	48 69 c9 00 04
	00 00		 imul	 rcx, rcx, 1024		; 00000400H
  00163	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  0016b	48 8d 8c 0a 88
	36 00 00	 lea	 rcx, QWORD PTR [rdx+rcx+13960]
  00173	48 63 94 24 88
	00 00 00	 movsxd	 rdx, DWORD PTR ha$19[rsp]
  0017b	48 69 d2 90 06
	00 00		 imul	 rdx, rdx, 1680		; 00000690H
  00182	4c 8b 84 24 00
	02 00 00	 mov	 r8, QWORD PTR z$[rsp]
  0018a	49 8d 94 10 48
	1a 00 00	 lea	 rdx, QWORD PTR [r8+rdx+6728]
  00192	4c 63 44 24 44	 movsxd	 r8, DWORD PTR n$2[rsp]
  00197	4d 6b c0 60	 imul	 r8, r8, 96		; 00000060H
  0019b	4c 8b 8c 24 00
	02 00 00	 mov	 r9, QWORD PTR z$[rsp]
  001a3	4f 63 84 01 b0
	46 00 00	 movsxd	 r8, DWORD PTR [r9+r8+18096]
  001ab	4d 69 c0 90 06
	00 00		 imul	 r8, r8, 1680		; 00000690H
  001b2	4c 8b 8c 24 00
	02 00 00	 mov	 r9, QWORD PTR z$[rsp]
  001ba	4f 8d 44 01 08	 lea	 r8, QWORD PTR [r9+r8+8]
  001bf	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001c4	8b 44 24 44	 mov	 eax, DWORD PTR n$2[rsp]
  001c8	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  001cc	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001d1	4c 8b ca	 mov	 r9, rdx
  001d4	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR data$32[rsp]
  001dc	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  001e4	e8 00 00 00 00	 call	 ?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z ; stbi__jpeg_decode_block
  001e9	85 c0		 test	 eax, eax
  001eb	75 07		 jne	 SHORT $LN48@stbi__pars
  001ed	33 c0		 xor	 eax, eax
  001ef	e9 48 0a 00 00	 jmp	 $LN1@stbi__pars
$LN48@stbi__pars:

; 2966 :                     z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*j*8+i*8, z->img_comp[n].w2, data);

  001f4	48 63 44 24 44	 movsxd	 rax, DWORD PTR n$2[rsp]
  001f9	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  001fd	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR n$2[rsp]
  00202	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00206	48 63 54 24 44	 movsxd	 rdx, DWORD PTR n$2[rsp]
  0020b	48 6b d2 60	 imul	 rdx, rdx, 96		; 00000060H
  0020f	4c 8b 84 24 00
	02 00 00	 mov	 r8, QWORD PTR z$[rsp]
  00217	41 8b 94 10 c4
	46 00 00	 mov	 edx, DWORD PTR [r8+rdx+18116]
  0021f	0f af 54 24 50	 imul	 edx, DWORD PTR j$5[rsp]
  00224	c1 e2 03	 shl	 edx, 3
  00227	48 63 d2	 movsxd	 rdx, edx
  0022a	4c 8b 84 24 00
	02 00 00	 mov	 r8, QWORD PTR z$[rsp]
  00232	49 8b 8c 08 d0
	46 00 00	 mov	 rcx, QWORD PTR [r8+rcx+18128]
  0023a	48 03 ca	 add	 rcx, rdx
  0023d	8b 54 24 54	 mov	 edx, DWORD PTR i$6[rsp]
  00241	c1 e2 03	 shl	 edx, 3
  00244	48 63 d2	 movsxd	 rdx, edx
  00247	48 03 ca	 add	 rcx, rdx
  0024a	4c 8d 84 24 e0
	00 00 00	 lea	 r8, QWORD PTR data$32[rsp]
  00252	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  0025a	8b 94 02 c4 46
	00 00		 mov	 edx, DWORD PTR [rdx+rax+18116]
  00261	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00269	ff 90 70 48 00
	00		 call	 QWORD PTR [rax+18544]

; 2967 :                     // every data block is an MCU, so countdown the restart interval
; 2968 :                     if (--z->todo <= 0) {

  0026f	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00277	8b 80 6c 48 00
	00		 mov	 eax, DWORD PTR [rax+18540]
  0027d	ff c8		 dec	 eax
  0027f	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv190[rsp], eax
  00286	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0028e	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv190[rsp]
  00295	89 88 6c 48 00
	00		 mov	 DWORD PTR [rax+18540], ecx
  0029b	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR tv190[rsp], 0
  002a3	7f 61		 jg	 SHORT $LN49@stbi__pars

; 2969 :                         if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

  002a5	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  002ad	83 b8 24 48 00
	00 18		 cmp	 DWORD PTR [rax+18468], 24
  002b4	7d 0d		 jge	 SHORT $LN50@stbi__pars
  002b6	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  002be	e8 00 00 00 00	 call	 ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN50@stbi__pars:

; 2970 :                         // if it's NOT a restart, then just bail, so we get corrupt data
; 2971 :                         // rather than no data
; 2972 :                         if (!STBI__RESTART(z->marker)) return 1;

  002c3	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  002cb	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  002d2	3d d0 00 00 00	 cmp	 eax, 208		; 000000d0H
  002d7	7c 16		 jl	 SHORT $LN52@stbi__pars
  002d9	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  002e1	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  002e8	3d d7 00 00 00	 cmp	 eax, 215		; 000000d7H
  002ed	7e 0a		 jle	 SHORT $LN51@stbi__pars
$LN52@stbi__pars:
  002ef	b8 01 00 00 00	 mov	 eax, 1
  002f4	e9 43 09 00 00	 jmp	 $LN1@stbi__pars
$LN51@stbi__pars:

; 2973 :                         stbi__jpeg_reset(z);

  002f9	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00301	e8 00 00 00 00	 call	 ?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z ; stbi__jpeg_reset
$LN49@stbi__pars:

; 2974 :                     }
; 2975 :                 }

  00306	e9 df fd ff ff	 jmp	 $LN5@stbi__pars
$LN6@stbi__pars:

; 2976 :             }

  0030b	e9 b5 fd ff ff	 jmp	 $LN2@stbi__pars
$LN3@stbi__pars:

; 2977 :             return 1;

  00310	b8 01 00 00 00	 mov	 eax, 1
  00315	e9 22 09 00 00	 jmp	 $LN1@stbi__pars

; 2978 :         } else { // interleaved

  0031a	e9 84 03 00 00	 jmp	 $LN47@stbi__pars
$LN46@stbi__pars:

; 2979 :             int i,j,k,x,y;
; 2980 :             STBI_SIMD_ALIGN(short, data[64]);
; 2981 :             for (j=0; j < z->img_mcu_y; ++j) {

  0031f	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR j$10[rsp], 0
  00327	eb 0a		 jmp	 SHORT $LN10@stbi__pars
$LN8@stbi__pars:
  00329	8b 44 24 64	 mov	 eax, DWORD PTR j$10[rsp]
  0032d	ff c0		 inc	 eax
  0032f	89 44 24 64	 mov	 DWORD PTR j$10[rsp], eax
$LN10@stbi__pars:
  00333	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0033b	8b 80 94 46 00
	00		 mov	 eax, DWORD PTR [rax+18068]
  00341	39 44 24 64	 cmp	 DWORD PTR j$10[rsp], eax
  00345	0f 8d 4e 03 00
	00		 jge	 $LN9@stbi__pars

; 2982 :                 for (i=0; i < z->img_mcu_x; ++i) {

  0034b	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR i$8[rsp], 0
  00353	eb 0a		 jmp	 SHORT $LN13@stbi__pars
$LN11@stbi__pars:
  00355	8b 44 24 5c	 mov	 eax, DWORD PTR i$8[rsp]
  00359	ff c0		 inc	 eax
  0035b	89 44 24 5c	 mov	 DWORD PTR i$8[rsp], eax
$LN13@stbi__pars:
  0035f	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00367	8b 80 90 46 00
	00		 mov	 eax, DWORD PTR [rax+18064]
  0036d	39 44 24 5c	 cmp	 DWORD PTR i$8[rsp], eax
  00371	0f 8d 1d 03 00
	00		 jge	 $LN12@stbi__pars

; 2983 :                     // scan an interleaved mcu... process scan_n components in order
; 2984 :                     for (k=0; k < z->scan_n; ++k) {

  00377	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR k$7[rsp], 0
  0037f	eb 0a		 jmp	 SHORT $LN16@stbi__pars
$LN14@stbi__pars:
  00381	8b 44 24 58	 mov	 eax, DWORD PTR k$7[rsp]
  00385	ff c0		 inc	 eax
  00387	89 44 24 58	 mov	 DWORD PTR k$7[rsp], eax
$LN16@stbi__pars:
  0038b	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00393	8b 80 54 48 00
	00		 mov	 eax, DWORD PTR [rax+18516]
  00399	39 44 24 58	 cmp	 DWORD PTR k$7[rsp], eax
  0039d	0f 8d 55 02 00
	00		 jge	 $LN15@stbi__pars

; 2985 :                         int n = z->order[k];

  003a3	48 63 44 24 58	 movsxd	 rax, DWORD PTR k$7[rsp]
  003a8	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  003b0	8b 84 81 58 48
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+18520]
  003b7	89 44 24 40	 mov	 DWORD PTR n$1[rsp], eax

; 2986 :                         // scan out an mcu's worth of this component; that's just determined
; 2987 :                         // by the basic H and V specified for the component
; 2988 :                         for (y=0; y < z->img_comp[n].v; ++y) {

  003bb	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR y$11[rsp], 0
  003c3	eb 0a		 jmp	 SHORT $LN19@stbi__pars
$LN17@stbi__pars:
  003c5	8b 44 24 68	 mov	 eax, DWORD PTR y$11[rsp]
  003c9	ff c0		 inc	 eax
  003cb	89 44 24 68	 mov	 DWORD PTR y$11[rsp], eax
$LN19@stbi__pars:
  003cf	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$1[rsp]
  003d4	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  003d8	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  003e0	8b 84 01 a8 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18088]
  003e7	39 44 24 68	 cmp	 DWORD PTR y$11[rsp], eax
  003eb	0f 8d 02 02 00
	00		 jge	 $LN18@stbi__pars

; 2989 :                             for (x=0; x < z->img_comp[n].h; ++x) {

  003f1	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR x$9[rsp], 0
  003f9	eb 0a		 jmp	 SHORT $LN22@stbi__pars
$LN20@stbi__pars:
  003fb	8b 44 24 60	 mov	 eax, DWORD PTR x$9[rsp]
  003ff	ff c0		 inc	 eax
  00401	89 44 24 60	 mov	 DWORD PTR x$9[rsp], eax
$LN22@stbi__pars:
  00405	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$1[rsp]
  0040a	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0040e	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00416	8b 84 01 a4 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18084]
  0041d	39 44 24 60	 cmp	 DWORD PTR x$9[rsp], eax
  00421	0f 8d c7 01 00
	00		 jge	 $LN21@stbi__pars

; 2990 :                                 int x2 = (i*z->img_comp[n].h + x)*8;

  00427	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$1[rsp]
  0042c	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00430	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00438	8b 54 24 5c	 mov	 edx, DWORD PTR i$8[rsp]
  0043c	0f af 94 01 a4
	46 00 00	 imul	 edx, DWORD PTR [rcx+rax+18084]
  00444	8b c2		 mov	 eax, edx
  00446	03 44 24 60	 add	 eax, DWORD PTR x$9[rsp]
  0044a	c1 e0 03	 shl	 eax, 3
  0044d	89 84 24 b0 00
	00 00		 mov	 DWORD PTR x2$25[rsp], eax

; 2991 :                                 int y2 = (j*z->img_comp[n].v + y)*8;

  00454	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$1[rsp]
  00459	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0045d	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00465	8b 54 24 64	 mov	 edx, DWORD PTR j$10[rsp]
  00469	0f af 94 01 a8
	46 00 00	 imul	 edx, DWORD PTR [rcx+rax+18088]
  00471	8b c2		 mov	 eax, edx
  00473	03 44 24 68	 add	 eax, DWORD PTR y$11[rsp]
  00477	c1 e0 03	 shl	 eax, 3
  0047a	89 84 24 ac 00
	00 00		 mov	 DWORD PTR y2$24[rsp], eax

; 2992 :                                 int ha = z->img_comp[n].ha;

  00481	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$1[rsp]
  00486	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0048a	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00492	8b 84 01 b4 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18100]
  00499	89 84 24 90 00
	00 00		 mov	 DWORD PTR ha$20[rsp], eax

; 2993 :                                 if (!stbi__jpeg_decode_block(z, data, z->huff_dc+z->img_comp[n].hd, z->huff_ac+ha, z->fast_ac[ha], n, z->dequant[z->img_comp[n].tq])) return 0;

  004a0	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$1[rsp]
  004a5	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  004a9	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  004b1	48 63 84 01 ac
	46 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+18092]
  004b9	48 69 c0 80 00
	00 00		 imul	 rax, rax, 128		; 00000080H
  004c0	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  004c8	48 8d 84 01 88
	34 00 00	 lea	 rax, QWORD PTR [rcx+rax+13448]
  004d0	48 63 8c 24 90
	00 00 00	 movsxd	 rcx, DWORD PTR ha$20[rsp]
  004d8	48 69 c9 00 04
	00 00		 imul	 rcx, rcx, 1024		; 00000400H
  004df	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  004e7	48 8d 8c 0a 88
	36 00 00	 lea	 rcx, QWORD PTR [rdx+rcx+13960]
  004ef	48 63 94 24 90
	00 00 00	 movsxd	 rdx, DWORD PTR ha$20[rsp]
  004f7	48 69 d2 90 06
	00 00		 imul	 rdx, rdx, 1680		; 00000690H
  004fe	4c 8b 84 24 00
	02 00 00	 mov	 r8, QWORD PTR z$[rsp]
  00506	49 8d 94 10 48
	1a 00 00	 lea	 rdx, QWORD PTR [r8+rdx+6728]
  0050e	4c 63 44 24 40	 movsxd	 r8, DWORD PTR n$1[rsp]
  00513	4d 6b c0 60	 imul	 r8, r8, 96		; 00000060H
  00517	4c 8b 8c 24 00
	02 00 00	 mov	 r9, QWORD PTR z$[rsp]
  0051f	4f 63 84 01 b0
	46 00 00	 movsxd	 r8, DWORD PTR [r9+r8+18096]
  00527	4d 69 c0 90 06
	00 00		 imul	 r8, r8, 1680		; 00000690H
  0052e	4c 8b 8c 24 00
	02 00 00	 mov	 r9, QWORD PTR z$[rsp]
  00536	4f 8d 44 01 08	 lea	 r8, QWORD PTR [r9+r8+8]
  0053b	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00540	8b 44 24 40	 mov	 eax, DWORD PTR n$1[rsp]
  00544	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00548	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0054d	4c 8b ca	 mov	 r9, rdx
  00550	48 8d 94 24 60
	01 00 00	 lea	 rdx, QWORD PTR data$33[rsp]
  00558	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00560	e8 00 00 00 00	 call	 ?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z ; stbi__jpeg_decode_block
  00565	85 c0		 test	 eax, eax
  00567	75 07		 jne	 SHORT $LN53@stbi__pars
  00569	33 c0		 xor	 eax, eax
  0056b	e9 cc 06 00 00	 jmp	 $LN1@stbi__pars
$LN53@stbi__pars:

; 2994 :                                 z->idct_block_kernel(z->img_comp[n].data+z->img_comp[n].w2*y2+x2, z->img_comp[n].w2, data);

  00570	48 63 44 24 40	 movsxd	 rax, DWORD PTR n$1[rsp]
  00575	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00579	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR n$1[rsp]
  0057e	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00582	48 63 54 24 40	 movsxd	 rdx, DWORD PTR n$1[rsp]
  00587	48 6b d2 60	 imul	 rdx, rdx, 96		; 00000060H
  0058b	4c 8b 84 24 00
	02 00 00	 mov	 r8, QWORD PTR z$[rsp]
  00593	41 8b 94 10 c4
	46 00 00	 mov	 edx, DWORD PTR [r8+rdx+18116]
  0059b	0f af 94 24 ac
	00 00 00	 imul	 edx, DWORD PTR y2$24[rsp]
  005a3	48 63 d2	 movsxd	 rdx, edx
  005a6	4c 8b 84 24 00
	02 00 00	 mov	 r8, QWORD PTR z$[rsp]
  005ae	49 8b 8c 08 d0
	46 00 00	 mov	 rcx, QWORD PTR [r8+rcx+18128]
  005b6	48 03 ca	 add	 rcx, rdx
  005b9	48 63 94 24 b0
	00 00 00	 movsxd	 rdx, DWORD PTR x2$25[rsp]
  005c1	48 03 ca	 add	 rcx, rdx
  005c4	4c 8d 84 24 60
	01 00 00	 lea	 r8, QWORD PTR data$33[rsp]
  005cc	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  005d4	8b 94 02 c4 46
	00 00		 mov	 edx, DWORD PTR [rdx+rax+18116]
  005db	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  005e3	ff 90 70 48 00
	00		 call	 QWORD PTR [rax+18544]

; 2995 :                             }

  005e9	e9 0d fe ff ff	 jmp	 $LN20@stbi__pars
$LN21@stbi__pars:

; 2996 :                         }

  005ee	e9 d2 fd ff ff	 jmp	 $LN17@stbi__pars
$LN18@stbi__pars:

; 2997 :                     }

  005f3	e9 89 fd ff ff	 jmp	 $LN14@stbi__pars
$LN15@stbi__pars:

; 2998 :                     // after all interleaved components, that's an interleaved MCU,
; 2999 :                     // so now count down the restart interval
; 3000 :                     if (--z->todo <= 0) {

  005f8	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00600	8b 80 6c 48 00
	00		 mov	 eax, DWORD PTR [rax+18540]
  00606	ff c8		 dec	 eax
  00608	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv311[rsp], eax
  0060f	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00617	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv311[rsp]
  0061e	89 88 6c 48 00
	00		 mov	 DWORD PTR [rax+18540], ecx
  00624	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR tv311[rsp], 0
  0062c	7f 61		 jg	 SHORT $LN54@stbi__pars

; 3001 :                         if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

  0062e	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00636	83 b8 24 48 00
	00 18		 cmp	 DWORD PTR [rax+18468], 24
  0063d	7d 0d		 jge	 SHORT $LN55@stbi__pars
  0063f	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00647	e8 00 00 00 00	 call	 ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN55@stbi__pars:

; 3002 :                         if (!STBI__RESTART(z->marker)) return 1;

  0064c	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00654	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  0065b	3d d0 00 00 00	 cmp	 eax, 208		; 000000d0H
  00660	7c 16		 jl	 SHORT $LN57@stbi__pars
  00662	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0066a	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  00671	3d d7 00 00 00	 cmp	 eax, 215		; 000000d7H
  00676	7e 0a		 jle	 SHORT $LN56@stbi__pars
$LN57@stbi__pars:
  00678	b8 01 00 00 00	 mov	 eax, 1
  0067d	e9 ba 05 00 00	 jmp	 $LN1@stbi__pars
$LN56@stbi__pars:

; 3003 :                         stbi__jpeg_reset(z);

  00682	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0068a	e8 00 00 00 00	 call	 ?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z ; stbi__jpeg_reset
$LN54@stbi__pars:

; 3004 :                     }
; 3005 :                 }

  0068f	e9 c1 fc ff ff	 jmp	 $LN11@stbi__pars
$LN12@stbi__pars:

; 3006 :             }

  00694	e9 90 fc ff ff	 jmp	 $LN8@stbi__pars
$LN9@stbi__pars:

; 3007 :             return 1;

  00699	b8 01 00 00 00	 mov	 eax, 1
  0069e	e9 99 05 00 00	 jmp	 $LN1@stbi__pars
$LN47@stbi__pars:

; 3008 :         }
; 3009 :     } else {

  006a3	e9 94 05 00 00	 jmp	 $LN45@stbi__pars
$LN44@stbi__pars:

; 3010 :         if (z->scan_n == 1) {

  006a8	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  006b0	83 b8 54 48 00
	00 01		 cmp	 DWORD PTR [rax+18516], 1
  006b7	0f 85 a3 02 00
	00		 jne	 $LN58@stbi__pars

; 3011 :             int i,j;
; 3012 :             int n = z->order[0];

  006bd	b8 04 00 00 00	 mov	 eax, 4
  006c2	48 6b c0 00	 imul	 rax, rax, 0
  006c6	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  006ce	8b 84 01 58 48
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18520]
  006d5	89 44 24 4c	 mov	 DWORD PTR n$4[rsp], eax

; 3013 :             // non-interleaved data, we just need to process one block at a time,
; 3014 :             // in trivial scanline order
; 3015 :             // number of blocks to do just depends on how many actual "pixels" this
; 3016 :             // component has, independent of interleaved MCU blocking and such
; 3017 :             int w = (z->img_comp[n].x+7) >> 3;

  006d9	48 63 44 24 4c	 movsxd	 rax, DWORD PTR n$4[rsp]
  006de	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  006e2	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  006ea	8b 84 01 bc 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18108]
  006f1	83 c0 07	 add	 eax, 7
  006f4	c1 f8 03	 sar	 eax, 3
  006f7	89 84 24 b8 00
	00 00		 mov	 DWORD PTR w$27[rsp], eax

; 3018 :             int h = (z->img_comp[n].y+7) >> 3;

  006fe	48 63 44 24 4c	 movsxd	 rax, DWORD PTR n$4[rsp]
  00703	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00707	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0070f	8b 84 01 c0 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18112]
  00716	83 c0 07	 add	 eax, 7
  00719	c1 f8 03	 sar	 eax, 3
  0071c	89 84 24 b4 00
	00 00		 mov	 DWORD PTR h$26[rsp], eax

; 3019 :             for (j=0; j < h; ++j) {

  00723	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR j$12[rsp], 0
  0072b	eb 0a		 jmp	 SHORT $LN25@stbi__pars
$LN23@stbi__pars:
  0072d	8b 44 24 6c	 mov	 eax, DWORD PTR j$12[rsp]
  00731	ff c0		 inc	 eax
  00733	89 44 24 6c	 mov	 DWORD PTR j$12[rsp], eax
$LN25@stbi__pars:
  00737	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR h$26[rsp]
  0073e	39 44 24 6c	 cmp	 DWORD PTR j$12[rsp], eax
  00742	0f 8d 09 02 00
	00		 jge	 $LN24@stbi__pars

; 3020 :                 for (i=0; i < w; ++i) {

  00748	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR i$13[rsp], 0
  00750	eb 0a		 jmp	 SHORT $LN28@stbi__pars
$LN26@stbi__pars:
  00752	8b 44 24 70	 mov	 eax, DWORD PTR i$13[rsp]
  00756	ff c0		 inc	 eax
  00758	89 44 24 70	 mov	 DWORD PTR i$13[rsp], eax
$LN28@stbi__pars:
  0075c	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR w$27[rsp]
  00763	39 44 24 70	 cmp	 DWORD PTR i$13[rsp], eax
  00767	0f 8d df 01 00
	00		 jge	 $LN27@stbi__pars

; 3021 :                     short *data = z->img_comp[n].coeff + 64 * (i + j * z->img_comp[n].coeff_w);

  0076d	48 63 44 24 4c	 movsxd	 rax, DWORD PTR n$4[rsp]
  00772	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00776	48 63 4c 24 4c	 movsxd	 rcx, DWORD PTR n$4[rsp]
  0077b	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  0077f	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00787	44 8b 44 24 6c	 mov	 r8d, DWORD PTR j$12[rsp]
  0078c	44 0f af 84 0a
	f8 46 00 00	 imul	 r8d, DWORD PTR [rdx+rcx+18168]
  00795	41 8b c8	 mov	 ecx, r8d
  00798	8b 54 24 70	 mov	 edx, DWORD PTR i$13[rsp]
  0079c	03 d1		 add	 edx, ecx
  0079e	8b ca		 mov	 ecx, edx
  007a0	6b c9 40	 imul	 ecx, ecx, 64		; 00000040H
  007a3	48 63 c9	 movsxd	 rcx, ecx
  007a6	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  007ae	48 8b 84 02 f0
	46 00 00	 mov	 rax, QWORD PTR [rdx+rax+18160]
  007b6	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  007ba	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR data$30[rsp], rax

; 3022 :                     if (z->spec_start == 0) {

  007c2	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  007ca	83 b8 34 48 00
	00 00		 cmp	 DWORD PTR [rax+18484], 0
  007d1	75 5a		 jne	 SHORT $LN60@stbi__pars

; 3023 :                         if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))

  007d3	48 63 44 24 4c	 movsxd	 rax, DWORD PTR n$4[rsp]
  007d8	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  007dc	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  007e4	48 63 84 01 b0
	46 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+18096]
  007ec	48 69 c0 90 06
	00 00		 imul	 rax, rax, 1680		; 00000690H
  007f3	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  007fb	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  00800	44 8b 4c 24 4c	 mov	 r9d, DWORD PTR n$4[rsp]
  00805	4c 8b c0	 mov	 r8, rax
  00808	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR data$30[rsp]
  00810	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00818	e8 00 00 00 00	 call	 ?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z ; stbi__jpeg_decode_block_prog_dc
  0081d	85 c0		 test	 eax, eax
  0081f	75 07		 jne	 SHORT $LN62@stbi__pars

; 3024 :                             return 0;

  00821	33 c0		 xor	 eax, eax
  00823	e9 14 04 00 00	 jmp	 $LN1@stbi__pars
$LN62@stbi__pars:

; 3025 :                     } else {

  00828	e9 83 00 00 00	 jmp	 $LN61@stbi__pars
$LN60@stbi__pars:

; 3026 :                         int ha = z->img_comp[n].ha;

  0082d	48 63 44 24 4c	 movsxd	 rax, DWORD PTR n$4[rsp]
  00832	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00836	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  0083e	8b 84 01 b4 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18100]
  00845	89 84 24 98 00
	00 00		 mov	 DWORD PTR ha$21[rsp], eax

; 3027 :                         if (!stbi__jpeg_decode_block_prog_ac(z, data, &z->huff_ac[ha], z->fast_ac[ha]))

  0084c	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR ha$21[rsp]
  00854	48 69 c0 00 04
	00 00		 imul	 rax, rax, 1024		; 00000400H
  0085b	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00863	48 8d 84 01 88
	36 00 00	 lea	 rax, QWORD PTR [rcx+rax+13960]
  0086b	48 63 8c 24 98
	00 00 00	 movsxd	 rcx, DWORD PTR ha$21[rsp]
  00873	48 69 c9 90 06
	00 00		 imul	 rcx, rcx, 1680		; 00000690H
  0087a	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00882	48 8d 8c 0a 48
	1a 00 00	 lea	 rcx, QWORD PTR [rdx+rcx+6728]
  0088a	4c 8b c8	 mov	 r9, rax
  0088d	4c 8b c1	 mov	 r8, rcx
  00890	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR data$30[rsp]
  00898	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  008a0	e8 00 00 00 00	 call	 ?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z ; stbi__jpeg_decode_block_prog_ac
  008a5	85 c0		 test	 eax, eax
  008a7	75 07		 jne	 SHORT $LN63@stbi__pars

; 3028 :                             return 0;

  008a9	33 c0		 xor	 eax, eax
  008ab	e9 8c 03 00 00	 jmp	 $LN1@stbi__pars
$LN63@stbi__pars:
$LN61@stbi__pars:

; 3029 :                     }
; 3030 :                     // every data block is an MCU, so countdown the restart interval
; 3031 :                     if (--z->todo <= 0) {

  008b0	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  008b8	8b 80 6c 48 00
	00		 mov	 eax, DWORD PTR [rax+18540]
  008be	ff c8		 dec	 eax
  008c0	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv400[rsp], eax
  008c7	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  008cf	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv400[rsp]
  008d6	89 88 6c 48 00
	00		 mov	 DWORD PTR [rax+18540], ecx
  008dc	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR tv400[rsp], 0
  008e4	7f 61		 jg	 SHORT $LN64@stbi__pars

; 3032 :                         if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

  008e6	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  008ee	83 b8 24 48 00
	00 18		 cmp	 DWORD PTR [rax+18468], 24
  008f5	7d 0d		 jge	 SHORT $LN65@stbi__pars
  008f7	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  008ff	e8 00 00 00 00	 call	 ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN65@stbi__pars:

; 3033 :                         if (!STBI__RESTART(z->marker)) return 1;

  00904	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0090c	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  00913	3d d0 00 00 00	 cmp	 eax, 208		; 000000d0H
  00918	7c 16		 jl	 SHORT $LN67@stbi__pars
  0091a	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00922	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  00929	3d d7 00 00 00	 cmp	 eax, 215		; 000000d7H
  0092e	7e 0a		 jle	 SHORT $LN66@stbi__pars
$LN67@stbi__pars:
  00930	b8 01 00 00 00	 mov	 eax, 1
  00935	e9 02 03 00 00	 jmp	 $LN1@stbi__pars
$LN66@stbi__pars:

; 3034 :                         stbi__jpeg_reset(z);

  0093a	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00942	e8 00 00 00 00	 call	 ?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z ; stbi__jpeg_reset
$LN64@stbi__pars:

; 3035 :                     }
; 3036 :                 }

  00947	e9 06 fe ff ff	 jmp	 $LN26@stbi__pars
$LN27@stbi__pars:

; 3037 :             }

  0094c	e9 dc fd ff ff	 jmp	 $LN23@stbi__pars
$LN24@stbi__pars:

; 3038 :             return 1;

  00951	b8 01 00 00 00	 mov	 eax, 1
  00956	e9 e1 02 00 00	 jmp	 $LN1@stbi__pars

; 3039 :         } else { // interleaved

  0095b	e9 dc 02 00 00	 jmp	 $LN59@stbi__pars
$LN58@stbi__pars:

; 3040 :             int i,j,k,x,y;
; 3041 :             for (j=0; j < z->img_mcu_y; ++j) {

  00960	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR j$17[rsp], 0
  0096b	eb 10		 jmp	 SHORT $LN31@stbi__pars
$LN29@stbi__pars:
  0096d	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR j$17[rsp]
  00974	ff c0		 inc	 eax
  00976	89 84 24 80 00
	00 00		 mov	 DWORD PTR j$17[rsp], eax
$LN31@stbi__pars:
  0097d	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00985	8b 80 94 46 00
	00		 mov	 eax, DWORD PTR [rax+18068]
  0098b	39 84 24 80 00
	00 00		 cmp	 DWORD PTR j$17[rsp], eax
  00992	0f 8d 9f 02 00
	00		 jge	 $LN30@stbi__pars

; 3042 :                 for (i=0; i < z->img_mcu_x; ++i) {

  00998	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR i$15[rsp], 0
  009a0	eb 0a		 jmp	 SHORT $LN34@stbi__pars
$LN32@stbi__pars:
  009a2	8b 44 24 78	 mov	 eax, DWORD PTR i$15[rsp]
  009a6	ff c0		 inc	 eax
  009a8	89 44 24 78	 mov	 DWORD PTR i$15[rsp], eax
$LN34@stbi__pars:
  009ac	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  009b4	8b 80 90 46 00
	00		 mov	 eax, DWORD PTR [rax+18064]
  009ba	39 44 24 78	 cmp	 DWORD PTR i$15[rsp], eax
  009be	0f 8d 6e 02 00
	00		 jge	 $LN33@stbi__pars

; 3043 :                     // scan an interleaved mcu... process scan_n components in order
; 3044 :                     for (k=0; k < z->scan_n; ++k) {

  009c4	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR k$14[rsp], 0
  009cc	eb 0a		 jmp	 SHORT $LN37@stbi__pars
$LN35@stbi__pars:
  009ce	8b 44 24 74	 mov	 eax, DWORD PTR k$14[rsp]
  009d2	ff c0		 inc	 eax
  009d4	89 44 24 74	 mov	 DWORD PTR k$14[rsp], eax
$LN37@stbi__pars:
  009d8	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  009e0	8b 80 54 48 00
	00		 mov	 eax, DWORD PTR [rax+18516]
  009e6	39 44 24 74	 cmp	 DWORD PTR k$14[rsp], eax
  009ea	0f 8d a9 01 00
	00		 jge	 $LN36@stbi__pars

; 3045 :                         int n = z->order[k];

  009f0	48 63 44 24 74	 movsxd	 rax, DWORD PTR k$14[rsp]
  009f5	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  009fd	8b 84 81 58 48
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+18520]
  00a04	89 44 24 48	 mov	 DWORD PTR n$3[rsp], eax

; 3046 :                         // scan out an mcu's worth of this component; that's just determined
; 3047 :                         // by the basic H and V specified for the component
; 3048 :                         for (y=0; y < z->img_comp[n].v; ++y) {

  00a08	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR y$18[rsp], 0
  00a13	eb 10		 jmp	 SHORT $LN40@stbi__pars
$LN38@stbi__pars:
  00a15	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR y$18[rsp]
  00a1c	ff c0		 inc	 eax
  00a1e	89 84 24 84 00
	00 00		 mov	 DWORD PTR y$18[rsp], eax
$LN40@stbi__pars:
  00a25	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$3[rsp]
  00a2a	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00a2e	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00a36	8b 84 01 a8 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18088]
  00a3d	39 84 24 84 00
	00 00		 cmp	 DWORD PTR y$18[rsp], eax
  00a44	0f 8d 4a 01 00
	00		 jge	 $LN39@stbi__pars

; 3049 :                             for (x=0; x < z->img_comp[n].h; ++x) {

  00a4a	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR x$16[rsp], 0
  00a52	eb 0a		 jmp	 SHORT $LN43@stbi__pars
$LN41@stbi__pars:
  00a54	8b 44 24 7c	 mov	 eax, DWORD PTR x$16[rsp]
  00a58	ff c0		 inc	 eax
  00a5a	89 44 24 7c	 mov	 DWORD PTR x$16[rsp], eax
$LN43@stbi__pars:
  00a5e	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$3[rsp]
  00a63	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00a67	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00a6f	8b 84 01 a4 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18084]
  00a76	39 44 24 7c	 cmp	 DWORD PTR x$16[rsp], eax
  00a7a	0f 8d 0f 01 00
	00		 jge	 $LN42@stbi__pars

; 3050 :                                 int x2 = (i*z->img_comp[n].h + x);

  00a80	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$3[rsp]
  00a85	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00a89	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00a91	8b 54 24 78	 mov	 edx, DWORD PTR i$15[rsp]
  00a95	0f af 94 01 a4
	46 00 00	 imul	 edx, DWORD PTR [rcx+rax+18084]
  00a9d	8b c2		 mov	 eax, edx
  00a9f	03 44 24 7c	 add	 eax, DWORD PTR x$16[rsp]
  00aa3	89 84 24 c0 00
	00 00		 mov	 DWORD PTR x2$29[rsp], eax

; 3051 :                                 int y2 = (j*z->img_comp[n].v + y);

  00aaa	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$3[rsp]
  00aaf	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00ab3	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00abb	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR j$17[rsp]
  00ac2	0f af 94 01 a8
	46 00 00	 imul	 edx, DWORD PTR [rcx+rax+18088]
  00aca	8b c2		 mov	 eax, edx
  00acc	03 84 24 84 00
	00 00		 add	 eax, DWORD PTR y$18[rsp]
  00ad3	89 84 24 bc 00
	00 00		 mov	 DWORD PTR y2$28[rsp], eax

; 3052 :                                 short *data = z->img_comp[n].coeff + 64 * (x2 + y2 * z->img_comp[n].coeff_w);

  00ada	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$3[rsp]
  00adf	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00ae3	48 63 4c 24 48	 movsxd	 rcx, DWORD PTR n$3[rsp]
  00ae8	48 6b c9 60	 imul	 rcx, rcx, 96		; 00000060H
  00aec	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00af4	44 8b 84 24 bc
	00 00 00	 mov	 r8d, DWORD PTR y2$28[rsp]
  00afc	44 0f af 84 0a
	f8 46 00 00	 imul	 r8d, DWORD PTR [rdx+rcx+18168]
  00b05	41 8b c8	 mov	 ecx, r8d
  00b08	8b 94 24 c0 00
	00 00		 mov	 edx, DWORD PTR x2$29[rsp]
  00b0f	03 d1		 add	 edx, ecx
  00b11	8b ca		 mov	 ecx, edx
  00b13	6b c9 40	 imul	 ecx, ecx, 64		; 00000040H
  00b16	48 63 c9	 movsxd	 rcx, ecx
  00b19	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR z$[rsp]
  00b21	48 8b 84 02 f0
	46 00 00	 mov	 rax, QWORD PTR [rdx+rax+18160]
  00b29	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  00b2d	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR data$31[rsp], rax

; 3053 :                                 if (!stbi__jpeg_decode_block_prog_dc(z, data, &z->huff_dc[z->img_comp[n].hd], n))

  00b35	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$3[rsp]
  00b3a	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00b3e	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00b46	48 63 84 01 b0
	46 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+18096]
  00b4e	48 69 c0 90 06
	00 00		 imul	 rax, rax, 1680		; 00000690H
  00b55	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00b5d	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  00b62	44 8b 4c 24 48	 mov	 r9d, DWORD PTR n$3[rsp]
  00b67	4c 8b c0	 mov	 r8, rax
  00b6a	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR data$31[rsp]
  00b72	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00b7a	e8 00 00 00 00	 call	 ?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z ; stbi__jpeg_decode_block_prog_dc
  00b7f	85 c0		 test	 eax, eax
  00b81	75 07		 jne	 SHORT $LN68@stbi__pars

; 3054 :                                     return 0;

  00b83	33 c0		 xor	 eax, eax
  00b85	e9 b2 00 00 00	 jmp	 $LN1@stbi__pars
$LN68@stbi__pars:

; 3055 :                             }

  00b8a	e9 c5 fe ff ff	 jmp	 $LN41@stbi__pars
$LN42@stbi__pars:

; 3056 :                         }

  00b8f	e9 81 fe ff ff	 jmp	 $LN38@stbi__pars
$LN39@stbi__pars:

; 3057 :                     }

  00b94	e9 35 fe ff ff	 jmp	 $LN35@stbi__pars
$LN36@stbi__pars:

; 3058 :                     // after all interleaved components, that's an interleaved MCU,
; 3059 :                     // so now count down the restart interval
; 3060 :                     if (--z->todo <= 0) {

  00b99	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00ba1	8b 80 6c 48 00
	00		 mov	 eax, DWORD PTR [rax+18540]
  00ba7	ff c8		 dec	 eax
  00ba9	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv518[rsp], eax
  00bb0	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00bb8	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv518[rsp]
  00bbf	89 88 6c 48 00
	00		 mov	 DWORD PTR [rax+18540], ecx
  00bc5	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR tv518[rsp], 0
  00bcd	7f 5e		 jg	 SHORT $LN69@stbi__pars

; 3061 :                         if (z->code_bits < 24) stbi__grow_buffer_unsafe(z);

  00bcf	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00bd7	83 b8 24 48 00
	00 18		 cmp	 DWORD PTR [rax+18468], 24
  00bde	7d 0d		 jge	 SHORT $LN70@stbi__pars
  00be0	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00be8	e8 00 00 00 00	 call	 ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN70@stbi__pars:

; 3062 :                         if (!STBI__RESTART(z->marker)) return 1;

  00bed	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00bf5	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  00bfc	3d d0 00 00 00	 cmp	 eax, 208		; 000000d0H
  00c01	7c 16		 jl	 SHORT $LN72@stbi__pars
  00c03	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00c0b	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  00c12	3d d7 00 00 00	 cmp	 eax, 215		; 000000d7H
  00c17	7e 07		 jle	 SHORT $LN71@stbi__pars
$LN72@stbi__pars:
  00c19	b8 01 00 00 00	 mov	 eax, 1
  00c1e	eb 1c		 jmp	 SHORT $LN1@stbi__pars
$LN71@stbi__pars:

; 3063 :                         stbi__jpeg_reset(z);

  00c20	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR z$[rsp]
  00c28	e8 00 00 00 00	 call	 ?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z ; stbi__jpeg_reset
$LN69@stbi__pars:

; 3064 :                     }
; 3065 :                 }

  00c2d	e9 70 fd ff ff	 jmp	 $LN32@stbi__pars
$LN33@stbi__pars:

; 3066 :             }

  00c32	e9 36 fd ff ff	 jmp	 $LN29@stbi__pars
$LN30@stbi__pars:

; 3067 :             return 1;

  00c37	b8 01 00 00 00	 mov	 eax, 1
$LN59@stbi__pars:
$LN45@stbi__pars:
$LN1@stbi__pars:

; 3068 :         }
; 3069 :     }
; 3070 : }

  00c3c	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00c44	48 33 cc	 xor	 rcx, rsp
  00c47	e8 00 00 00 00	 call	 __security_check_cookie
  00c4c	48 81 c4 f8 01
	00 00		 add	 rsp, 504		; 000001f8H
  00c53	c3		 ret	 0
?stbi__parse_entropy_coded_data@@YAHPEAUstbi__jpeg@@@Z ENDP ; stbi__parse_entropy_coded_data
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv88 = 0
j$ = 32
?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z PROC		; stbi__jpeg_reset

; 2936 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 2937 :     j->code_bits = 0;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR j$[rsp]
  0000e	c7 80 24 48 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+18468], 0

; 2938 :     j->code_buffer = 0;

  00018	48 8b 44 24 20	 mov	 rax, QWORD PTR j$[rsp]
  0001d	c7 80 20 48 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+18464], 0

; 2939 :     j->nomore = 0;

  00027	48 8b 44 24 20	 mov	 rax, QWORD PTR j$[rsp]
  0002c	c7 80 2c 48 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+18476], 0

; 2940 :     j->img_comp[0].dc_pred = j->img_comp[1].dc_pred = j->img_comp[2].dc_pred = j->img_comp[3].dc_pred = 0;

  00036	b8 60 00 00 00	 mov	 eax, 96			; 00000060H
  0003b	48 6b c0 03	 imul	 rax, rax, 3
  0003f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR j$[rsp]
  00044	c7 84 01 b8 46
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+18104], 0
  0004f	b8 60 00 00 00	 mov	 eax, 96			; 00000060H
  00054	48 6b c0 02	 imul	 rax, rax, 2
  00058	48 8b 4c 24 20	 mov	 rcx, QWORD PTR j$[rsp]
  0005d	c7 84 01 b8 46
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+18104], 0
  00068	b8 60 00 00 00	 mov	 eax, 96			; 00000060H
  0006d	48 6b c0 01	 imul	 rax, rax, 1
  00071	48 8b 4c 24 20	 mov	 rcx, QWORD PTR j$[rsp]
  00076	c7 84 01 b8 46
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+18104], 0
  00081	b8 60 00 00 00	 mov	 eax, 96			; 00000060H
  00086	48 6b c0 00	 imul	 rax, rax, 0
  0008a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR j$[rsp]
  0008f	c7 84 01 b8 46
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+18104], 0

; 2941 :     j->marker = STBI__MARKER_none;

  0009a	48 8b 44 24 20	 mov	 rax, QWORD PTR j$[rsp]
  0009f	c6 80 28 48 00
	00 ff		 mov	 BYTE PTR [rax+18472], 255 ; 000000ffH

; 2942 :     j->todo = j->restart_interval ? j->restart_interval : 0x7fffffff;

  000a6	48 8b 44 24 20	 mov	 rax, QWORD PTR j$[rsp]
  000ab	83 b8 68 48 00
	00 00		 cmp	 DWORD PTR [rax+18536], 0
  000b2	74 10		 je	 SHORT $LN3@stbi__jpeg
  000b4	48 8b 44 24 20	 mov	 rax, QWORD PTR j$[rsp]
  000b9	8b 80 68 48 00
	00		 mov	 eax, DWORD PTR [rax+18536]
  000bf	89 04 24	 mov	 DWORD PTR tv88[rsp], eax
  000c2	eb 07		 jmp	 SHORT $LN4@stbi__jpeg
$LN3@stbi__jpeg:
  000c4	c7 04 24 ff ff
	ff 7f		 mov	 DWORD PTR tv88[rsp], 2147483647 ; 7fffffffH
$LN4@stbi__jpeg:
  000cb	48 8b 44 24 20	 mov	 rax, QWORD PTR j$[rsp]
  000d0	8b 0c 24	 mov	 ecx, DWORD PTR tv88[rsp]
  000d3	89 88 6c 48 00
	00		 mov	 DWORD PTR [rax+18540], ecx

; 2943 :     j->eob_run = 0;

  000d9	48 8b 44 24 20	 mov	 rax, QWORD PTR j$[rsp]
  000de	c7 80 44 48 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+18500], 0

; 2944 :     // no more than 1<<31 MCUs if no restart_interal? that's plenty safe,
; 2945 :     // since we don't even allow 1<<30 pixels
; 2946 : }

  000e8	48 83 c4 18	 add	 rsp, 24
  000ec	c3		 ret	 0
?stbi__jpeg_reset@@YAXPEAUstbi__jpeg@@@Z ENDP		; stbi__jpeg_reset
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
x$ = 32
j$ = 64
?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z PROC		; stbi__get_marker

; 2919 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2920 :     stbi_uc x;
; 2921 :     if (j->marker != STBI__MARKER_none) { x = j->marker; j->marker = STBI__MARKER_none; return x; }

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0000e	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  00015	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0001a	74 23		 je	 SHORT $LN4@stbi__get_
  0001c	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00021	0f b6 80 28 48
	00 00		 movzx	 eax, BYTE PTR [rax+18472]
  00028	88 44 24 20	 mov	 BYTE PTR x$[rsp], al
  0002c	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00031	c6 80 28 48 00
	00 ff		 mov	 BYTE PTR [rax+18472], 255 ; 000000ffH
  00038	0f b6 44 24 20	 movzx	 eax, BYTE PTR x$[rsp]
  0003d	eb 45		 jmp	 SHORT $LN1@stbi__get_
$LN4@stbi__get_:

; 2922 :     x = stbi__get8(j->s);

  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00044	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00047	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0004c	88 44 24 20	 mov	 BYTE PTR x$[rsp], al

; 2923 :     if (x != 0xff) return STBI__MARKER_none;

  00050	0f b6 44 24 20	 movzx	 eax, BYTE PTR x$[rsp]
  00055	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0005a	74 04		 je	 SHORT $LN5@stbi__get_
  0005c	b0 ff		 mov	 al, 255			; 000000ffH
  0005e	eb 24		 jmp	 SHORT $LN1@stbi__get_
$LN5@stbi__get_:
$LN2@stbi__get_:

; 2924 :     while (x == 0xff)

  00060	0f b6 44 24 20	 movzx	 eax, BYTE PTR x$[rsp]
  00065	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0006a	75 13		 jne	 SHORT $LN3@stbi__get_

; 2925 :         x = stbi__get8(j->s); // consume repeated 0xff fill bytes

  0006c	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00071	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00074	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00079	88 44 24 20	 mov	 BYTE PTR x$[rsp], al
  0007d	eb e1		 jmp	 SHORT $LN2@stbi__get_
$LN3@stbi__get_:

; 2926 :     return x;

  0007f	0f b6 44 24 20	 movzx	 eax, BYTE PTR x$[rsp]
$LN1@stbi__get_:

; 2927 : }

  00084	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00088	c3		 ret	 0
?stbi__get_marker@@YAEPEAUstbi__jpeg@@@Z ENDP		; stbi__get_marker
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tmp$ = 0
row1$ = 16
row3$ = 32
row5$ = 48
row7$ = 64
row0$ = 80
row2$ = 96
row4$ = 112
row6$ = 128
p0$1 = 144
p2$2 = 160
p1$3 = 176
p3$4 = 192
bias_0$ = 208
bias_1$ = 224
rot0_0$ = 240
rot0_1$ = 256
rot2_0$ = 272
rot2_1$ = 288
rot3_0$ = 304
rot3_1$ = 320
rot1_0$ = 336
rot1_1$ = 352
rot0_0lo$5 = 368
rot0_0hi$6 = 384
sum04$7 = 400
dif04$8 = 416
t0e_l$9 = 432
t3e_l$10 = 448
t0e_h$11 = 464
t3e_h$12 = 480
t1e_l$13 = 496
t2e_l$14 = 512
t1e_h$15 = 528
t2e_h$16 = 544
rot2_0lo$17 = 560
rot2_0hi$18 = 576
rot3_0lo$19 = 592
rot3_0hi$20 = 608
sum17$21 = 624
sum35$22 = 640
rot1_0lo$23 = 656
rot1_0hi$24 = 672
y5o_l$25 = 688
y5o_h$26 = 704
y4o_l$27 = 720
y4o_h$28 = 736
abiased_l$29 = 752
x7_l$30 = 768
abiased_h$31 = 784
x7_h$32 = 800
abiased_l$33 = 816
x6_l$34 = 832
abiased_h$35 = 848
x6_h$36 = 864
abiased_l$37 = 880
x5_l$38 = 896
abiased_h$39 = 912
x5_h$40 = 928
abiased_l$41 = 944
x4_l$42 = 960
abiased_h$43 = 976
x4_h$44 = 992
rot0_0lo$45 = 1008
rot0_0hi$46 = 1024
sum04$47 = 1040
dif04$48 = 1056
t0e_l$49 = 1072
t3e_l$50 = 1088
t0e_h$51 = 1104
t3e_h$52 = 1120
t1e_l$53 = 1136
t2e_l$54 = 1152
t1e_h$55 = 1168
t2e_h$56 = 1184
rot2_0lo$57 = 1200
rot2_0hi$58 = 1216
rot3_0lo$59 = 1232
rot3_0hi$60 = 1248
sum17$61 = 1264
sum35$62 = 1280
rot1_0lo$63 = 1296
rot1_0hi$64 = 1312
y5o_l$65 = 1328
y5o_h$66 = 1344
y4o_l$67 = 1360
y4o_h$68 = 1376
abiased_l$69 = 1392
x7_l$70 = 1408
abiased_h$71 = 1424
x7_h$72 = 1440
abiased_l$73 = 1456
x6_l$74 = 1472
abiased_h$75 = 1488
x6_h$76 = 1504
abiased_l$77 = 1520
x5_l$78 = 1536
abiased_h$79 = 1552
x5_h$80 = 1568
abiased_l$81 = 1584
x4_l$82 = 1600
abiased_h$83 = 1616
x4_h$84 = 1632
$T85 = 1648
$T86 = 1664
$T87 = 1680
$T88 = 1696
$T89 = 1712
$T90 = 1728
$T91 = 1744
$T92 = 1760
$T93 = 1776
$T94 = 1792
$T95 = 1808
$T96 = 1824
$T97 = 1840
$T98 = 1856
$T99 = 1872
$T100 = 1888
$T101 = 1904
$T102 = 1920
$T103 = 1936
$T104 = 1952
$T105 = 1968
$T106 = 1984
$T107 = 2000
$T108 = 2016
$T109 = 2032
$T110 = 2048
$T111 = 2064
$T112 = 2080
$T113 = 2096
$T114 = 2112
$T115 = 2128
$T116 = 2144
$T117 = 2160
$T118 = 2176
$T119 = 2192
$T120 = 2208
$T121 = 2224
$T122 = 2240
$T123 = 2256
$T124 = 2272
$T125 = 2288
$T126 = 2304
$T127 = 2320
$T128 = 2336
$T129 = 2352
$T130 = 2368
$T131 = 2384
$T132 = 2400
$T133 = 2416
$T134 = 2432
$T135 = 2448
$T136 = 2464
$T137 = 2480
$T138 = 2496
$T139 = 2512
$T140 = 2528
$T141 = 2544
$T142 = 2560
$T143 = 2576
$T144 = 2592
$T145 = 2608
$T146 = 2624
$T147 = 2640
$T148 = 2656
$T149 = 2672
$T150 = 2688
y0o_l$151 = 2704
$T152 = 2720
y0o_h$153 = 2736
$T154 = 2752
y1o_l$155 = 2768
$T156 = 2784
y1o_h$157 = 2800
$T158 = 2816
y2o_l$159 = 2832
$T160 = 2848
y2o_h$161 = 2864
$T162 = 2880
y3o_l$163 = 2896
$T164 = 2912
y3o_h$165 = 2928
$T166 = 2944
x0_l$167 = 2960
$T168 = 2976
x0_h$169 = 2992
$T170 = 3008
$T171 = 3024
$T172 = 3040
$T173 = 3056
$T174 = 3072
sum_h$175 = 3088
sum_l$176 = 3104
$T177 = 3120
$T178 = 3136
$T179 = 3152
dif_h$180 = 3168
dif_l$181 = 3184
$T182 = 3200
$T183 = 3216
$T184 = 3232
x1_l$185 = 3248
$T186 = 3264
x1_h$187 = 3280
$T188 = 3296
$T189 = 3312
$T190 = 3328
$T191 = 3344
$T192 = 3360
sum_h$193 = 3376
sum_l$194 = 3392
$T195 = 3408
$T196 = 3424
$T197 = 3440
dif_h$198 = 3456
dif_l$199 = 3472
$T200 = 3488
$T201 = 3504
$T202 = 3520
x2_l$203 = 3536
$T204 = 3552
x2_h$205 = 3568
$T206 = 3584
$T207 = 3600
$T208 = 3616
$T209 = 3632
$T210 = 3648
sum_h$211 = 3664
sum_l$212 = 3680
$T213 = 3696
$T214 = 3712
$T215 = 3728
dif_h$216 = 3744
dif_l$217 = 3760
$T218 = 3776
$T219 = 3792
$T220 = 3808
x3_l$221 = 3824
$T222 = 3840
x3_h$223 = 3856
$T224 = 3872
$T225 = 3888
$T226 = 3904
$T227 = 3920
$T228 = 3936
sum_h$229 = 3952
sum_l$230 = 3968
$T231 = 3984
$T232 = 4000
$T233 = 4016
dif_h$234 = 4032
dif_l$235 = 4048
$T236 = 4064
$T237 = 4080
$T238 = 4096
$T239 = 4112
$T240 = 4128
$T241 = 4144
$T242 = 4160
$T243 = 4176
$T244 = 4192
$T245 = 4208
$T246 = 4224
$T247 = 4240
$T248 = 4256
$T249 = 4272
$T250 = 4288
$T251 = 4304
$T252 = 4320
$T253 = 4336
$T254 = 4352
$T255 = 4368
$T256 = 4384
$T257 = 4400
$T258 = 4416
$T259 = 4432
$T260 = 4448
$T261 = 4464
$T262 = 4480
$T263 = 4496
$T264 = 4512
$T265 = 4528
$T266 = 4544
$T267 = 4560
$T268 = 4576
$T269 = 4592
$T270 = 4608
$T271 = 4624
$T272 = 4640
$T273 = 4656
$T274 = 4672
$T275 = 4688
$T276 = 4704
$T277 = 4720
$T278 = 4736
$T279 = 4752
$T280 = 4768
$T281 = 4784
$T282 = 4800
$T283 = 4816
$T284 = 4832
$T285 = 4848
$T286 = 4864
$T287 = 4880
$T288 = 4896
$T289 = 4912
$T290 = 4928
$T291 = 4944
$T292 = 4960
$T293 = 4976
$T294 = 4992
$T295 = 5008
$T296 = 5024
$T297 = 5040
$T298 = 5056
$T299 = 5072
$T300 = 5088
$T301 = 5104
$T302 = 5120
$T303 = 5136
$T304 = 5152
$T305 = 5168
$T306 = 5184
$T307 = 5200
$T308 = 5216
$T309 = 5232
$T310 = 5248
y0o_l$311 = 5264
$T312 = 5280
y0o_h$313 = 5296
$T314 = 5312
y1o_l$315 = 5328
$T316 = 5344
y1o_h$317 = 5360
$T318 = 5376
y2o_l$319 = 5392
$T320 = 5408
y2o_h$321 = 5424
$T322 = 5440
y3o_l$323 = 5456
$T324 = 5472
y3o_h$325 = 5488
$T326 = 5504
x0_l$327 = 5520
$T328 = 5536
x0_h$329 = 5552
$T330 = 5568
$T331 = 5584
$T332 = 5600
$T333 = 5616
$T334 = 5632
sum_h$335 = 5648
sum_l$336 = 5664
$T337 = 5680
$T338 = 5696
$T339 = 5712
dif_h$340 = 5728
dif_l$341 = 5744
$T342 = 5760
$T343 = 5776
$T344 = 5792
x1_l$345 = 5808
$T346 = 5824
x1_h$347 = 5840
$T348 = 5856
$T349 = 5872
$T350 = 5888
$T351 = 5904
$T352 = 5920
sum_h$353 = 5936
sum_l$354 = 5952
$T355 = 5968
$T356 = 5984
$T357 = 6000
dif_h$358 = 6016
dif_l$359 = 6032
$T360 = 6048
$T361 = 6064
$T362 = 6080
x2_l$363 = 6096
$T364 = 6112
x2_h$365 = 6128
$T366 = 6144
$T367 = 6160
$T368 = 6176
$T369 = 6192
$T370 = 6208
sum_h$371 = 6224
sum_l$372 = 6240
$T373 = 6256
$T374 = 6272
$T375 = 6288
dif_h$376 = 6304
dif_l$377 = 6320
$T378 = 6336
$T379 = 6352
$T380 = 6368
x3_l$381 = 6384
$T382 = 6400
x3_h$383 = 6416
$T384 = 6432
$T385 = 6448
$T386 = 6464
$T387 = 6480
$T388 = 6496
sum_h$389 = 6512
sum_l$390 = 6528
$T391 = 6544
$T392 = 6560
$T393 = 6576
dif_h$394 = 6592
dif_l$395 = 6608
$T396 = 6624
$T397 = 6640
$T398 = 6656
$T399 = 6672
$T400 = 6688
$T401 = 6704
$T402 = 6720
$T403 = 6736
$T404 = 6752
$T405 = 6768
$T406 = 6784
$T407 = 6800
$T408 = 6816
$T409 = 6832
$T410 = 6848
$T411 = 6864
$T412 = 6880
$T413 = 6896
$T414 = 6912
$T415 = 6928
$T416 = 6944
$T417 = 6960
$T418 = 6976
out$ = 7008
out_stride$ = 7016
data$ = 7024
?stbi__idct_simd@@YAXPEAEHQEAF@Z PROC			; stbi__idct_simd

; 2530 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	b8 58 1b 00 00	 mov	 eax, 7000		; 00001b58H
  00013	e8 00 00 00 00	 call	 __chkstk
  00018	48 2b e0	 sub	 rsp, rax

; 2531 :     // This is constructed to match our regular (generic) integer IDCT exactly.
; 2532 :     __m128i row0, row1, row2, row3, row4, row5, row6, row7;
; 2533 :     __m128i tmp;
; 2534 :     
; 2535 :     // dot product constant: even elems=x, odd elems=y
; 2536 : #define dct_const(x,y)  _mm_setr_epi16((x),(y),(x),(y),(x),(y),(x),(y))
; 2537 :     
; 2538 :     // out(0) = c0[even]*x + c0[odd]*y   (c0, x, y 16-bit, out 32-bit)
; 2539 :     // out(1) = c1[even]*x + c1[odd]*y
; 2540 : #define dct_rot(out0,out1, x,y,c0,c1) \
; 2541 : __m128i c0##lo = _mm_unpacklo_epi16((x),(y)); \
; 2542 : __m128i c0##hi = _mm_unpackhi_epi16((x),(y)); \
; 2543 : __m128i out0##_l = _mm_madd_epi16(c0##lo, c0); \
; 2544 : __m128i out0##_h = _mm_madd_epi16(c0##hi, c0); \
; 2545 : __m128i out1##_l = _mm_madd_epi16(c0##lo, c1); \
; 2546 : __m128i out1##_h = _mm_madd_epi16(c0##hi, c1)
; 2547 :     
; 2548 :     // out = in << 12  (in 16-bit, out 32-bit)
; 2549 : #define dct_widen(out, in) \
; 2550 : __m128i out##_l = _mm_srai_epi32(_mm_unpacklo_epi16(_mm_setzero_si128(), (in)), 4); \
; 2551 : __m128i out##_h = _mm_srai_epi32(_mm_unpackhi_epi16(_mm_setzero_si128(), (in)), 4)
; 2552 :     
; 2553 :     // wide add
; 2554 : #define dct_wadd(out, a, b) \
; 2555 : __m128i out##_l = _mm_add_epi32(a##_l, b##_l); \
; 2556 : __m128i out##_h = _mm_add_epi32(a##_h, b##_h)
; 2557 :     
; 2558 :     // wide sub
; 2559 : #define dct_wsub(out, a, b) \
; 2560 : __m128i out##_l = _mm_sub_epi32(a##_l, b##_l); \
; 2561 : __m128i out##_h = _mm_sub_epi32(a##_h, b##_h)
; 2562 :     
; 2563 :     // butterfly a/b, add bias, then shift by "s" and pack
; 2564 : #define dct_bfly32o(out0, out1, a,b,bias,s) \
; 2565 : { \
; 2566 : __m128i abiased_l = _mm_add_epi32(a##_l, bias); \
; 2567 : __m128i abiased_h = _mm_add_epi32(a##_h, bias); \
; 2568 : dct_wadd(sum, abiased, b); \
; 2569 : dct_wsub(dif, abiased, b); \
; 2570 : out0 = _mm_packs_epi32(_mm_srai_epi32(sum_l, s), _mm_srai_epi32(sum_h, s)); \
; 2571 : out1 = _mm_packs_epi32(_mm_srai_epi32(dif_l, s), _mm_srai_epi32(dif_h, s)); \
; 2572 : }
; 2573 :     
; 2574 :     // 8-bit interleave step (for transposes)
; 2575 : #define dct_interleave8(a, b) \
; 2576 : tmp = a; \
; 2577 : a = _mm_unpacklo_epi8(a, b); \
; 2578 : b = _mm_unpackhi_epi8(tmp, b)
; 2579 :     
; 2580 :     // 16-bit interleave step (for transposes)
; 2581 : #define dct_interleave16(a, b) \
; 2582 : tmp = a; \
; 2583 : a = _mm_unpacklo_epi16(a, b); \
; 2584 : b = _mm_unpackhi_epi16(tmp, b)
; 2585 :     
; 2586 : #define dct_pass(bias,shift) \
; 2587 : { \
; 2588 : /* even part */ \
; 2589 : dct_rot(t2e,t3e, row2,row6, rot0_0,rot0_1); \
; 2590 : __m128i sum04 = _mm_add_epi16(row0, row4); \
; 2591 : __m128i dif04 = _mm_sub_epi16(row0, row4); \
; 2592 : dct_widen(t0e, sum04); \
; 2593 : dct_widen(t1e, dif04); \
; 2594 : dct_wadd(x0, t0e, t3e); \
; 2595 : dct_wsub(x3, t0e, t3e); \
; 2596 : dct_wadd(x1, t1e, t2e); \
; 2597 : dct_wsub(x2, t1e, t2e); \
; 2598 : /* odd part */ \
; 2599 : dct_rot(y0o,y2o, row7,row3, rot2_0,rot2_1); \
; 2600 : dct_rot(y1o,y3o, row5,row1, rot3_0,rot3_1); \
; 2601 : __m128i sum17 = _mm_add_epi16(row1, row7); \
; 2602 : __m128i sum35 = _mm_add_epi16(row3, row5); \
; 2603 : dct_rot(y4o,y5o, sum17,sum35, rot1_0,rot1_1); \
; 2604 : dct_wadd(x4, y0o, y4o); \
; 2605 : dct_wadd(x5, y1o, y5o); \
; 2606 : dct_wadd(x6, y2o, y5o); \
; 2607 : dct_wadd(x7, y3o, y4o); \
; 2608 : dct_bfly32o(row0,row7, x0,x7,bias,shift); \
; 2609 : dct_bfly32o(row1,row6, x1,x6,bias,shift); \
; 2610 : dct_bfly32o(row2,row5, x2,x5,bias,shift); \
; 2611 : dct_bfly32o(row3,row4, x3,x4,bias,shift); \
; 2612 : }
; 2613 :     
; 2614 :     __m128i rot0_0 = dct_const(stbi__f2f(0.5411961f), stbi__f2f(0.5411961f) + stbi__f2f(-1.847759065f));

  0001b	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@eb1a08a9eb1a08a9eb1a08a9eb1a08a9
  00023	66 0f 7f 84 24
	70 06 00 00	 movdqa	 XMMWORD PTR $T85[rsp], xmm0
  0002c	66 0f 6f 84 24
	70 06 00 00	 movdqa	 xmm0, XMMWORD PTR $T85[rsp]
  00035	66 0f 7f 84 24
	f0 00 00 00	 movdqa	 XMMWORD PTR rot0_0$[rsp], xmm0

; 2615 :     __m128i rot0_1 = dct_const(stbi__f2f(0.5411961f) + stbi__f2f( 0.765366865f), stbi__f2f(0.5411961f));

  0003e	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@08a914e808a914e808a914e808a914e8
  00046	66 0f 7f 84 24
	80 06 00 00	 movdqa	 XMMWORD PTR $T86[rsp], xmm0
  0004f	66 0f 6f 84 24
	80 06 00 00	 movdqa	 xmm0, XMMWORD PTR $T86[rsp]
  00058	66 0f 7f 84 24
	00 01 00 00	 movdqa	 XMMWORD PTR rot0_1$[rsp], xmm0

; 2616 :     __m128i rot1_0 = dct_const(stbi__f2f(1.175875602f) + stbi__f2f(-0.899976223f), stbi__f2f(1.175875602f));

  00061	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@12d0046b12d0046b12d0046b12d0046b
  00069	66 0f 7f 84 24
	90 06 00 00	 movdqa	 XMMWORD PTR $T87[rsp], xmm0
  00072	66 0f 6f 84 24
	90 06 00 00	 movdqa	 xmm0, XMMWORD PTR $T87[rsp]
  0007b	66 0f 7f 84 24
	50 01 00 00	 movdqa	 XMMWORD PTR rot1_0$[rsp], xmm0

; 2617 :     __m128i rot1_1 = dct_const(stbi__f2f(1.175875602f), stbi__f2f(1.175875602f) + stbi__f2f(-2.562915447f));

  00084	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@e9cf12d0e9cf12d0e9cf12d0e9cf12d0
  0008c	66 0f 7f 84 24
	a0 06 00 00	 movdqa	 XMMWORD PTR $T88[rsp], xmm0
  00095	66 0f 6f 84 24
	a0 06 00 00	 movdqa	 xmm0, XMMWORD PTR $T88[rsp]
  0009e	66 0f 7f 84 24
	60 01 00 00	 movdqa	 XMMWORD PTR rot1_1$[rsp], xmm0

; 2618 :     __m128i rot2_0 = dct_const(stbi__f2f(-1.961570560f) + stbi__f2f( 0.298631336f), stbi__f2f(-1.961570560f));

  000a7	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@e09ee565e09ee565e09ee565e09ee565
  000af	66 0f 7f 84 24
	b0 06 00 00	 movdqa	 XMMWORD PTR $T89[rsp], xmm0
  000b8	66 0f 6f 84 24
	b0 06 00 00	 movdqa	 xmm0, XMMWORD PTR $T89[rsp]
  000c1	66 0f 7f 84 24
	10 01 00 00	 movdqa	 XMMWORD PTR rot2_0$[rsp], xmm0

; 2619 :     __m128i rot2_1 = dct_const(stbi__f2f(-1.961570560f), stbi__f2f(-1.961570560f) + stbi__f2f( 3.072711026f));

  000ca	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@11c8e09e11c8e09e11c8e09e11c8e09e
  000d2	66 0f 7f 84 24
	c0 06 00 00	 movdqa	 XMMWORD PTR $T90[rsp], xmm0
  000db	66 0f 6f 84 24
	c0 06 00 00	 movdqa	 xmm0, XMMWORD PTR $T90[rsp]
  000e4	66 0f 7f 84 24
	20 01 00 00	 movdqa	 XMMWORD PTR rot2_1$[rsp], xmm0

; 2620 :     __m128i rot3_0 = dct_const(stbi__f2f(-0.390180644f) + stbi__f2f( 2.053119869f), stbi__f2f(-0.390180644f));

  000ed	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@f9c31a9df9c31a9df9c31a9df9c31a9d
  000f5	66 0f 7f 84 24
	d0 06 00 00	 movdqa	 XMMWORD PTR $T91[rsp], xmm0
  000fe	66 0f 6f 84 24
	d0 06 00 00	 movdqa	 xmm0, XMMWORD PTR $T91[rsp]
  00107	66 0f 7f 84 24
	30 01 00 00	 movdqa	 XMMWORD PTR rot3_0$[rsp], xmm0

; 2621 :     __m128i rot3_1 = dct_const(stbi__f2f(-0.390180644f), stbi__f2f(-0.390180644f) + stbi__f2f( 1.501321110f));

  00110	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@11c8f9c311c8f9c311c8f9c311c8f9c3
  00118	66 0f 7f 84 24
	e0 06 00 00	 movdqa	 XMMWORD PTR $T92[rsp], xmm0
  00121	66 0f 6f 84 24
	e0 06 00 00	 movdqa	 xmm0, XMMWORD PTR $T92[rsp]
  0012a	66 0f 7f 84 24
	40 01 00 00	 movdqa	 XMMWORD PTR rot3_1$[rsp], xmm0

; 2622 :     
; 2623 :     // rounding biases in column/row passes, see stbi__idct_block for explanation.
; 2624 :     __m128i bias_0 = _mm_set1_epi32(512);

  00133	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@00000200000002000000020000000200
  0013b	66 0f 7f 84 24
	f0 06 00 00	 movdqa	 XMMWORD PTR $T93[rsp], xmm0
  00144	66 0f 6f 84 24
	f0 06 00 00	 movdqa	 xmm0, XMMWORD PTR $T93[rsp]
  0014d	66 0f 7f 84 24
	d0 00 00 00	 movdqa	 XMMWORD PTR bias_0$[rsp], xmm0

; 2625 :     __m128i bias_1 = _mm_set1_epi32(65536 + (128<<17));

  00156	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@01010000010100000101000001010000
  0015e	66 0f 7f 84 24
	00 07 00 00	 movdqa	 XMMWORD PTR $T94[rsp], xmm0
  00167	66 0f 6f 84 24
	00 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T94[rsp]
  00170	66 0f 7f 84 24
	e0 00 00 00	 movdqa	 XMMWORD PTR bias_1$[rsp], xmm0

; 2626 :     
; 2627 :     // load
; 2628 :     row0 = _mm_load_si128((const __m128i *) (data + 0*8));

  00179	48 8b 84 24 70
	1b 00 00	 mov	 rax, QWORD PTR data$[rsp]
  00181	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  00185	66 0f 7f 84 24
	10 07 00 00	 movdqa	 XMMWORD PTR $T95[rsp], xmm0
  0018e	66 0f 6f 84 24
	10 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T95[rsp]
  00197	66 0f 7f 44 24
	50		 movdqa	 XMMWORD PTR row0$[rsp], xmm0

; 2629 :     row1 = _mm_load_si128((const __m128i *) (data + 1*8));

  0019d	48 8b 84 24 70
	1b 00 00	 mov	 rax, QWORD PTR data$[rsp]
  001a5	48 83 c0 10	 add	 rax, 16
  001a9	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  001ad	66 0f 7f 84 24
	20 07 00 00	 movdqa	 XMMWORD PTR $T96[rsp], xmm0
  001b6	66 0f 6f 84 24
	20 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T96[rsp]
  001bf	66 0f 7f 44 24
	10		 movdqa	 XMMWORD PTR row1$[rsp], xmm0

; 2630 :     row2 = _mm_load_si128((const __m128i *) (data + 2*8));

  001c5	48 8b 84 24 70
	1b 00 00	 mov	 rax, QWORD PTR data$[rsp]
  001cd	48 83 c0 20	 add	 rax, 32			; 00000020H
  001d1	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  001d5	66 0f 7f 84 24
	30 07 00 00	 movdqa	 XMMWORD PTR $T97[rsp], xmm0
  001de	66 0f 6f 84 24
	30 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T97[rsp]
  001e7	66 0f 7f 44 24
	60		 movdqa	 XMMWORD PTR row2$[rsp], xmm0

; 2631 :     row3 = _mm_load_si128((const __m128i *) (data + 3*8));

  001ed	48 8b 84 24 70
	1b 00 00	 mov	 rax, QWORD PTR data$[rsp]
  001f5	48 83 c0 30	 add	 rax, 48			; 00000030H
  001f9	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  001fd	66 0f 7f 84 24
	40 07 00 00	 movdqa	 XMMWORD PTR $T98[rsp], xmm0
  00206	66 0f 6f 84 24
	40 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T98[rsp]
  0020f	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR row3$[rsp], xmm0

; 2632 :     row4 = _mm_load_si128((const __m128i *) (data + 4*8));

  00215	48 8b 84 24 70
	1b 00 00	 mov	 rax, QWORD PTR data$[rsp]
  0021d	48 83 c0 40	 add	 rax, 64			; 00000040H
  00221	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  00225	66 0f 7f 84 24
	50 07 00 00	 movdqa	 XMMWORD PTR $T99[rsp], xmm0
  0022e	66 0f 6f 84 24
	50 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T99[rsp]
  00237	66 0f 7f 44 24
	70		 movdqa	 XMMWORD PTR row4$[rsp], xmm0

; 2633 :     row5 = _mm_load_si128((const __m128i *) (data + 5*8));

  0023d	48 8b 84 24 70
	1b 00 00	 mov	 rax, QWORD PTR data$[rsp]
  00245	48 83 c0 50	 add	 rax, 80			; 00000050H
  00249	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  0024d	66 0f 7f 84 24
	60 07 00 00	 movdqa	 XMMWORD PTR $T100[rsp], xmm0
  00256	66 0f 6f 84 24
	60 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T100[rsp]
  0025f	66 0f 7f 44 24
	30		 movdqa	 XMMWORD PTR row5$[rsp], xmm0

; 2634 :     row6 = _mm_load_si128((const __m128i *) (data + 6*8));

  00265	48 8b 84 24 70
	1b 00 00	 mov	 rax, QWORD PTR data$[rsp]
  0026d	48 83 c0 60	 add	 rax, 96			; 00000060H
  00271	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  00275	66 0f 7f 84 24
	70 07 00 00	 movdqa	 XMMWORD PTR $T101[rsp], xmm0
  0027e	66 0f 6f 84 24
	70 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T101[rsp]
  00287	66 0f 7f 84 24
	80 00 00 00	 movdqa	 XMMWORD PTR row6$[rsp], xmm0

; 2635 :     row7 = _mm_load_si128((const __m128i *) (data + 7*8));

  00290	48 8b 84 24 70
	1b 00 00	 mov	 rax, QWORD PTR data$[rsp]
  00298	48 83 c0 70	 add	 rax, 112		; 00000070H
  0029c	f3 0f 6f 00	 movdqu	 xmm0, XMMWORD PTR [rax]
  002a0	66 0f 7f 84 24
	80 07 00 00	 movdqa	 XMMWORD PTR $T102[rsp], xmm0
  002a9	66 0f 6f 84 24
	80 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T102[rsp]
  002b2	66 0f 7f 44 24
	40		 movdqa	 XMMWORD PTR row7$[rsp], xmm0

; 2636 :     
; 2637 :     // column pass
; 2638 :     dct_pass(bias_0, 10);

  002b8	66 0f 6f 44 24
	60		 movdqa	 xmm0, XMMWORD PTR row2$[rsp]
  002be	66 0f 61 84 24
	80 00 00 00	 punpcklwd xmm0, XMMWORD PTR row6$[rsp]
  002c7	66 0f 7f 84 24
	90 07 00 00	 movdqa	 XMMWORD PTR $T103[rsp], xmm0
  002d0	66 0f 6f 84 24
	90 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T103[rsp]
  002d9	66 0f 7f 84 24
	70 01 00 00	 movdqa	 XMMWORD PTR rot0_0lo$5[rsp], xmm0
  002e2	66 0f 6f 44 24
	60		 movdqa	 xmm0, XMMWORD PTR row2$[rsp]
  002e8	66 0f 69 84 24
	80 00 00 00	 punpckhwd xmm0, XMMWORD PTR row6$[rsp]
  002f1	66 0f 7f 84 24
	a0 07 00 00	 movdqa	 XMMWORD PTR $T104[rsp], xmm0
  002fa	66 0f 6f 84 24
	a0 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T104[rsp]
  00303	66 0f 7f 84 24
	80 01 00 00	 movdqa	 XMMWORD PTR rot0_0hi$6[rsp], xmm0
  0030c	66 0f 6f 84 24
	70 01 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0lo$5[rsp]
  00315	66 0f f5 84 24
	f0 00 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_0$[rsp]
  0031e	66 0f 7f 84 24
	b0 07 00 00	 movdqa	 XMMWORD PTR $T105[rsp], xmm0
  00327	66 0f 6f 84 24
	b0 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T105[rsp]
  00330	66 0f 7f 84 24
	00 02 00 00	 movdqa	 XMMWORD PTR t2e_l$14[rsp], xmm0
  00339	66 0f 6f 84 24
	80 01 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0hi$6[rsp]
  00342	66 0f f5 84 24
	f0 00 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_0$[rsp]
  0034b	66 0f 7f 84 24
	c0 07 00 00	 movdqa	 XMMWORD PTR $T106[rsp], xmm0
  00354	66 0f 6f 84 24
	c0 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T106[rsp]
  0035d	66 0f 7f 84 24
	20 02 00 00	 movdqa	 XMMWORD PTR t2e_h$16[rsp], xmm0
  00366	66 0f 6f 84 24
	70 01 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0lo$5[rsp]
  0036f	66 0f f5 84 24
	00 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_1$[rsp]
  00378	66 0f 7f 84 24
	d0 07 00 00	 movdqa	 XMMWORD PTR $T107[rsp], xmm0
  00381	66 0f 6f 84 24
	d0 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T107[rsp]
  0038a	66 0f 7f 84 24
	c0 01 00 00	 movdqa	 XMMWORD PTR t3e_l$10[rsp], xmm0
  00393	66 0f 6f 84 24
	80 01 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0hi$6[rsp]
  0039c	66 0f f5 84 24
	00 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_1$[rsp]
  003a5	66 0f 7f 84 24
	e0 07 00 00	 movdqa	 XMMWORD PTR $T108[rsp], xmm0
  003ae	66 0f 6f 84 24
	e0 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T108[rsp]
  003b7	66 0f 7f 84 24
	e0 01 00 00	 movdqa	 XMMWORD PTR t3e_h$12[rsp], xmm0
  003c0	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  003c6	66 0f fd 44 24
	70		 paddw	 xmm0, XMMWORD PTR row4$[rsp]
  003cc	66 0f 7f 84 24
	f0 07 00 00	 movdqa	 XMMWORD PTR $T109[rsp], xmm0
  003d5	66 0f 6f 84 24
	f0 07 00 00	 movdqa	 xmm0, XMMWORD PTR $T109[rsp]
  003de	66 0f 7f 84 24
	90 01 00 00	 movdqa	 XMMWORD PTR sum04$7[rsp], xmm0
  003e7	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  003ed	66 0f f9 44 24
	70		 psubw	 xmm0, XMMWORD PTR row4$[rsp]
  003f3	66 0f 7f 84 24
	00 08 00 00	 movdqa	 XMMWORD PTR $T110[rsp], xmm0
  003fc	66 0f 6f 84 24
	00 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T110[rsp]
  00405	66 0f 7f 84 24
	a0 01 00 00	 movdqa	 XMMWORD PTR dif04$8[rsp], xmm0
  0040e	66 0f ef c0	 pxor	 xmm0, xmm0
  00412	66 0f 7f 84 24
	10 08 00 00	 movdqa	 XMMWORD PTR $T111[rsp], xmm0
  0041b	66 0f 6f 84 24
	10 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T111[rsp]
  00424	66 0f 61 84 24
	90 01 00 00	 punpcklwd xmm0, XMMWORD PTR sum04$7[rsp]
  0042d	66 0f 7f 84 24
	20 08 00 00	 movdqa	 XMMWORD PTR $T112[rsp], xmm0
  00436	66 0f 6f 84 24
	20 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T112[rsp]
  0043f	66 0f 72 e0 04	 psrad	 xmm0, 4
  00444	66 0f 7f 84 24
	30 08 00 00	 movdqa	 XMMWORD PTR $T113[rsp], xmm0
  0044d	66 0f 6f 84 24
	30 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T113[rsp]
  00456	66 0f 7f 84 24
	b0 01 00 00	 movdqa	 XMMWORD PTR t0e_l$9[rsp], xmm0
  0045f	66 0f ef c0	 pxor	 xmm0, xmm0
  00463	66 0f 7f 84 24
	40 08 00 00	 movdqa	 XMMWORD PTR $T114[rsp], xmm0
  0046c	66 0f 6f 84 24
	40 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T114[rsp]
  00475	66 0f 69 84 24
	90 01 00 00	 punpckhwd xmm0, XMMWORD PTR sum04$7[rsp]
  0047e	66 0f 7f 84 24
	50 08 00 00	 movdqa	 XMMWORD PTR $T115[rsp], xmm0
  00487	66 0f 6f 84 24
	50 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T115[rsp]
  00490	66 0f 72 e0 04	 psrad	 xmm0, 4
  00495	66 0f 7f 84 24
	60 08 00 00	 movdqa	 XMMWORD PTR $T116[rsp], xmm0
  0049e	66 0f 6f 84 24
	60 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T116[rsp]
  004a7	66 0f 7f 84 24
	d0 01 00 00	 movdqa	 XMMWORD PTR t0e_h$11[rsp], xmm0
  004b0	66 0f ef c0	 pxor	 xmm0, xmm0
  004b4	66 0f 7f 84 24
	70 08 00 00	 movdqa	 XMMWORD PTR $T117[rsp], xmm0
  004bd	66 0f 6f 84 24
	70 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T117[rsp]
  004c6	66 0f 61 84 24
	a0 01 00 00	 punpcklwd xmm0, XMMWORD PTR dif04$8[rsp]
  004cf	66 0f 7f 84 24
	80 08 00 00	 movdqa	 XMMWORD PTR $T118[rsp], xmm0
  004d8	66 0f 6f 84 24
	80 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T118[rsp]
  004e1	66 0f 72 e0 04	 psrad	 xmm0, 4
  004e6	66 0f 7f 84 24
	90 08 00 00	 movdqa	 XMMWORD PTR $T119[rsp], xmm0
  004ef	66 0f 6f 84 24
	90 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T119[rsp]
  004f8	66 0f 7f 84 24
	f0 01 00 00	 movdqa	 XMMWORD PTR t1e_l$13[rsp], xmm0
  00501	66 0f ef c0	 pxor	 xmm0, xmm0
  00505	66 0f 7f 84 24
	a0 08 00 00	 movdqa	 XMMWORD PTR $T120[rsp], xmm0
  0050e	66 0f 6f 84 24
	a0 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T120[rsp]
  00517	66 0f 69 84 24
	a0 01 00 00	 punpckhwd xmm0, XMMWORD PTR dif04$8[rsp]
  00520	66 0f 7f 84 24
	b0 08 00 00	 movdqa	 XMMWORD PTR $T121[rsp], xmm0
  00529	66 0f 6f 84 24
	b0 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T121[rsp]
  00532	66 0f 72 e0 04	 psrad	 xmm0, 4
  00537	66 0f 7f 84 24
	c0 08 00 00	 movdqa	 XMMWORD PTR $T122[rsp], xmm0
  00540	66 0f 6f 84 24
	c0 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T122[rsp]
  00549	66 0f 7f 84 24
	10 02 00 00	 movdqa	 XMMWORD PTR t1e_h$15[rsp], xmm0
  00552	66 0f 6f 84 24
	b0 01 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_l$9[rsp]
  0055b	66 0f fe 84 24
	c0 01 00 00	 paddd	 xmm0, XMMWORD PTR t3e_l$10[rsp]
  00564	66 0f 7f 84 24
	d0 08 00 00	 movdqa	 XMMWORD PTR $T123[rsp], xmm0
  0056d	66 0f 6f 84 24
	d0 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T123[rsp]
  00576	66 0f 7f 84 24
	90 0b 00 00	 movdqa	 XMMWORD PTR x0_l$167[rsp], xmm0
  0057f	66 0f 6f 84 24
	d0 01 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_h$11[rsp]
  00588	66 0f fe 84 24
	e0 01 00 00	 paddd	 xmm0, XMMWORD PTR t3e_h$12[rsp]
  00591	66 0f 7f 84 24
	e0 08 00 00	 movdqa	 XMMWORD PTR $T124[rsp], xmm0
  0059a	66 0f 6f 84 24
	e0 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T124[rsp]
  005a3	66 0f 7f 84 24
	b0 0b 00 00	 movdqa	 XMMWORD PTR x0_h$169[rsp], xmm0
  005ac	66 0f 6f 84 24
	b0 01 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_l$9[rsp]
  005b5	66 0f fa 84 24
	c0 01 00 00	 psubd	 xmm0, XMMWORD PTR t3e_l$10[rsp]
  005be	66 0f 7f 84 24
	f0 08 00 00	 movdqa	 XMMWORD PTR $T125[rsp], xmm0
  005c7	66 0f 6f 84 24
	f0 08 00 00	 movdqa	 xmm0, XMMWORD PTR $T125[rsp]
  005d0	66 0f 7f 84 24
	f0 0e 00 00	 movdqa	 XMMWORD PTR x3_l$221[rsp], xmm0
  005d9	66 0f 6f 84 24
	d0 01 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_h$11[rsp]
  005e2	66 0f fa 84 24
	e0 01 00 00	 psubd	 xmm0, XMMWORD PTR t3e_h$12[rsp]
  005eb	66 0f 7f 84 24
	00 09 00 00	 movdqa	 XMMWORD PTR $T126[rsp], xmm0
  005f4	66 0f 6f 84 24
	00 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T126[rsp]
  005fd	66 0f 7f 84 24
	10 0f 00 00	 movdqa	 XMMWORD PTR x3_h$223[rsp], xmm0
  00606	66 0f 6f 84 24
	f0 01 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_l$13[rsp]
  0060f	66 0f fe 84 24
	00 02 00 00	 paddd	 xmm0, XMMWORD PTR t2e_l$14[rsp]
  00618	66 0f 7f 84 24
	10 09 00 00	 movdqa	 XMMWORD PTR $T127[rsp], xmm0
  00621	66 0f 6f 84 24
	10 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T127[rsp]
  0062a	66 0f 7f 84 24
	b0 0c 00 00	 movdqa	 XMMWORD PTR x1_l$185[rsp], xmm0
  00633	66 0f 6f 84 24
	10 02 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_h$15[rsp]
  0063c	66 0f fe 84 24
	20 02 00 00	 paddd	 xmm0, XMMWORD PTR t2e_h$16[rsp]
  00645	66 0f 7f 84 24
	20 09 00 00	 movdqa	 XMMWORD PTR $T128[rsp], xmm0
  0064e	66 0f 6f 84 24
	20 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T128[rsp]
  00657	66 0f 7f 84 24
	d0 0c 00 00	 movdqa	 XMMWORD PTR x1_h$187[rsp], xmm0
  00660	66 0f 6f 84 24
	f0 01 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_l$13[rsp]
  00669	66 0f fa 84 24
	00 02 00 00	 psubd	 xmm0, XMMWORD PTR t2e_l$14[rsp]
  00672	66 0f 7f 84 24
	30 09 00 00	 movdqa	 XMMWORD PTR $T129[rsp], xmm0
  0067b	66 0f 6f 84 24
	30 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T129[rsp]
  00684	66 0f 7f 84 24
	d0 0d 00 00	 movdqa	 XMMWORD PTR x2_l$203[rsp], xmm0
  0068d	66 0f 6f 84 24
	10 02 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_h$15[rsp]
  00696	66 0f fa 84 24
	20 02 00 00	 psubd	 xmm0, XMMWORD PTR t2e_h$16[rsp]
  0069f	66 0f 7f 84 24
	40 09 00 00	 movdqa	 XMMWORD PTR $T130[rsp], xmm0
  006a8	66 0f 6f 84 24
	40 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T130[rsp]
  006b1	66 0f 7f 84 24
	f0 0d 00 00	 movdqa	 XMMWORD PTR x2_h$205[rsp], xmm0
  006ba	66 0f 6f 44 24
	40		 movdqa	 xmm0, XMMWORD PTR row7$[rsp]
  006c0	66 0f 61 44 24
	20		 punpcklwd xmm0, XMMWORD PTR row3$[rsp]
  006c6	66 0f 7f 84 24
	50 09 00 00	 movdqa	 XMMWORD PTR $T131[rsp], xmm0
  006cf	66 0f 6f 84 24
	50 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T131[rsp]
  006d8	66 0f 7f 84 24
	30 02 00 00	 movdqa	 XMMWORD PTR rot2_0lo$17[rsp], xmm0
  006e1	66 0f 6f 44 24
	40		 movdqa	 xmm0, XMMWORD PTR row7$[rsp]
  006e7	66 0f 69 44 24
	20		 punpckhwd xmm0, XMMWORD PTR row3$[rsp]
  006ed	66 0f 7f 84 24
	60 09 00 00	 movdqa	 XMMWORD PTR $T132[rsp], xmm0
  006f6	66 0f 6f 84 24
	60 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T132[rsp]
  006ff	66 0f 7f 84 24
	40 02 00 00	 movdqa	 XMMWORD PTR rot2_0hi$18[rsp], xmm0
  00708	66 0f 6f 84 24
	30 02 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0lo$17[rsp]
  00711	66 0f f5 84 24
	10 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_0$[rsp]
  0071a	66 0f 7f 84 24
	70 09 00 00	 movdqa	 XMMWORD PTR $T133[rsp], xmm0
  00723	66 0f 6f 84 24
	70 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T133[rsp]
  0072c	66 0f 7f 84 24
	90 0a 00 00	 movdqa	 XMMWORD PTR y0o_l$151[rsp], xmm0
  00735	66 0f 6f 84 24
	40 02 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0hi$18[rsp]
  0073e	66 0f f5 84 24
	10 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_0$[rsp]
  00747	66 0f 7f 84 24
	80 09 00 00	 movdqa	 XMMWORD PTR $T134[rsp], xmm0
  00750	66 0f 6f 84 24
	80 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T134[rsp]
  00759	66 0f 7f 84 24
	b0 0a 00 00	 movdqa	 XMMWORD PTR y0o_h$153[rsp], xmm0
  00762	66 0f 6f 84 24
	30 02 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0lo$17[rsp]
  0076b	66 0f f5 84 24
	20 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_1$[rsp]
  00774	66 0f 7f 84 24
	90 09 00 00	 movdqa	 XMMWORD PTR $T135[rsp], xmm0
  0077d	66 0f 6f 84 24
	90 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T135[rsp]
  00786	66 0f 7f 84 24
	10 0b 00 00	 movdqa	 XMMWORD PTR y2o_l$159[rsp], xmm0
  0078f	66 0f 6f 84 24
	40 02 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0hi$18[rsp]
  00798	66 0f f5 84 24
	20 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_1$[rsp]
  007a1	66 0f 7f 84 24
	a0 09 00 00	 movdqa	 XMMWORD PTR $T136[rsp], xmm0
  007aa	66 0f 6f 84 24
	a0 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T136[rsp]
  007b3	66 0f 7f 84 24
	30 0b 00 00	 movdqa	 XMMWORD PTR y2o_h$161[rsp], xmm0
  007bc	66 0f 6f 44 24
	30		 movdqa	 xmm0, XMMWORD PTR row5$[rsp]
  007c2	66 0f 61 44 24
	10		 punpcklwd xmm0, XMMWORD PTR row1$[rsp]
  007c8	66 0f 7f 84 24
	b0 09 00 00	 movdqa	 XMMWORD PTR $T137[rsp], xmm0
  007d1	66 0f 6f 84 24
	b0 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T137[rsp]
  007da	66 0f 7f 84 24
	50 02 00 00	 movdqa	 XMMWORD PTR rot3_0lo$19[rsp], xmm0
  007e3	66 0f 6f 44 24
	30		 movdqa	 xmm0, XMMWORD PTR row5$[rsp]
  007e9	66 0f 69 44 24
	10		 punpckhwd xmm0, XMMWORD PTR row1$[rsp]
  007ef	66 0f 7f 84 24
	c0 09 00 00	 movdqa	 XMMWORD PTR $T138[rsp], xmm0
  007f8	66 0f 6f 84 24
	c0 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T138[rsp]
  00801	66 0f 7f 84 24
	60 02 00 00	 movdqa	 XMMWORD PTR rot3_0hi$20[rsp], xmm0
  0080a	66 0f 6f 84 24
	50 02 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0lo$19[rsp]
  00813	66 0f f5 84 24
	30 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_0$[rsp]
  0081c	66 0f 7f 84 24
	d0 09 00 00	 movdqa	 XMMWORD PTR $T139[rsp], xmm0
  00825	66 0f 6f 84 24
	d0 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T139[rsp]
  0082e	66 0f 7f 84 24
	d0 0a 00 00	 movdqa	 XMMWORD PTR y1o_l$155[rsp], xmm0
  00837	66 0f 6f 84 24
	60 02 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0hi$20[rsp]
  00840	66 0f f5 84 24
	30 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_0$[rsp]
  00849	66 0f 7f 84 24
	e0 09 00 00	 movdqa	 XMMWORD PTR $T140[rsp], xmm0
  00852	66 0f 6f 84 24
	e0 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T140[rsp]
  0085b	66 0f 7f 84 24
	f0 0a 00 00	 movdqa	 XMMWORD PTR y1o_h$157[rsp], xmm0
  00864	66 0f 6f 84 24
	50 02 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0lo$19[rsp]
  0086d	66 0f f5 84 24
	40 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_1$[rsp]
  00876	66 0f 7f 84 24
	f0 09 00 00	 movdqa	 XMMWORD PTR $T141[rsp], xmm0
  0087f	66 0f 6f 84 24
	f0 09 00 00	 movdqa	 xmm0, XMMWORD PTR $T141[rsp]
  00888	66 0f 7f 84 24
	50 0b 00 00	 movdqa	 XMMWORD PTR y3o_l$163[rsp], xmm0
  00891	66 0f 6f 84 24
	60 02 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0hi$20[rsp]
  0089a	66 0f f5 84 24
	40 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_1$[rsp]
  008a3	66 0f 7f 84 24
	00 0a 00 00	 movdqa	 XMMWORD PTR $T142[rsp], xmm0
  008ac	66 0f 6f 84 24
	00 0a 00 00	 movdqa	 xmm0, XMMWORD PTR $T142[rsp]
  008b5	66 0f 7f 84 24
	70 0b 00 00	 movdqa	 XMMWORD PTR y3o_h$165[rsp], xmm0
  008be	66 0f 6f 44 24
	10		 movdqa	 xmm0, XMMWORD PTR row1$[rsp]
  008c4	66 0f fd 44 24
	40		 paddw	 xmm0, XMMWORD PTR row7$[rsp]
  008ca	66 0f 7f 84 24
	10 0a 00 00	 movdqa	 XMMWORD PTR $T143[rsp], xmm0
  008d3	66 0f 6f 84 24
	10 0a 00 00	 movdqa	 xmm0, XMMWORD PTR $T143[rsp]
  008dc	66 0f 7f 84 24
	70 02 00 00	 movdqa	 XMMWORD PTR sum17$21[rsp], xmm0
  008e5	66 0f 6f 44 24
	20		 movdqa	 xmm0, XMMWORD PTR row3$[rsp]
  008eb	66 0f fd 44 24
	30		 paddw	 xmm0, XMMWORD PTR row5$[rsp]
  008f1	66 0f 7f 84 24
	20 0a 00 00	 movdqa	 XMMWORD PTR $T144[rsp], xmm0
  008fa	66 0f 6f 84 24
	20 0a 00 00	 movdqa	 xmm0, XMMWORD PTR $T144[rsp]
  00903	66 0f 7f 84 24
	80 02 00 00	 movdqa	 XMMWORD PTR sum35$22[rsp], xmm0
  0090c	66 0f 6f 84 24
	70 02 00 00	 movdqa	 xmm0, XMMWORD PTR sum17$21[rsp]
  00915	66 0f 61 84 24
	80 02 00 00	 punpcklwd xmm0, XMMWORD PTR sum35$22[rsp]
  0091e	66 0f 7f 84 24
	30 0a 00 00	 movdqa	 XMMWORD PTR $T145[rsp], xmm0
  00927	66 0f 6f 84 24
	30 0a 00 00	 movdqa	 xmm0, XMMWORD PTR $T145[rsp]
  00930	66 0f 7f 84 24
	90 02 00 00	 movdqa	 XMMWORD PTR rot1_0lo$23[rsp], xmm0
  00939	66 0f 6f 84 24
	70 02 00 00	 movdqa	 xmm0, XMMWORD PTR sum17$21[rsp]
  00942	66 0f 69 84 24
	80 02 00 00	 punpckhwd xmm0, XMMWORD PTR sum35$22[rsp]
  0094b	66 0f 7f 84 24
	40 0a 00 00	 movdqa	 XMMWORD PTR $T146[rsp], xmm0
  00954	66 0f 6f 84 24
	40 0a 00 00	 movdqa	 xmm0, XMMWORD PTR $T146[rsp]
  0095d	66 0f 7f 84 24
	a0 02 00 00	 movdqa	 XMMWORD PTR rot1_0hi$24[rsp], xmm0
  00966	66 0f 6f 84 24
	90 02 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0lo$23[rsp]
  0096f	66 0f f5 84 24
	50 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_0$[rsp]
  00978	66 0f 7f 84 24
	50 0a 00 00	 movdqa	 XMMWORD PTR $T147[rsp], xmm0
  00981	66 0f 6f 84 24
	50 0a 00 00	 movdqa	 xmm0, XMMWORD PTR $T147[rsp]
  0098a	66 0f 7f 84 24
	d0 02 00 00	 movdqa	 XMMWORD PTR y4o_l$27[rsp], xmm0
  00993	66 0f 6f 84 24
	a0 02 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0hi$24[rsp]
  0099c	66 0f f5 84 24
	50 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_0$[rsp]
  009a5	66 0f 7f 84 24
	60 0a 00 00	 movdqa	 XMMWORD PTR $T148[rsp], xmm0
  009ae	66 0f 6f 84 24
	60 0a 00 00	 movdqa	 xmm0, XMMWORD PTR $T148[rsp]
  009b7	66 0f 7f 84 24
	e0 02 00 00	 movdqa	 XMMWORD PTR y4o_h$28[rsp], xmm0
  009c0	66 0f 6f 84 24
	90 02 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0lo$23[rsp]
  009c9	66 0f f5 84 24
	60 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_1$[rsp]
  009d2	66 0f 7f 84 24
	70 0a 00 00	 movdqa	 XMMWORD PTR $T149[rsp], xmm0
  009db	66 0f 6f 84 24
	70 0a 00 00	 movdqa	 xmm0, XMMWORD PTR $T149[rsp]
  009e4	66 0f 7f 84 24
	b0 02 00 00	 movdqa	 XMMWORD PTR y5o_l$25[rsp], xmm0
  009ed	66 0f 6f 84 24
	a0 02 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0hi$24[rsp]
  009f6	66 0f f5 84 24
	60 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_1$[rsp]
  009ff	66 0f 7f 84 24
	80 0a 00 00	 movdqa	 XMMWORD PTR $T150[rsp], xmm0
  00a08	66 0f 6f 84 24
	80 0a 00 00	 movdqa	 xmm0, XMMWORD PTR $T150[rsp]
  00a11	66 0f 7f 84 24
	c0 02 00 00	 movdqa	 XMMWORD PTR y5o_h$26[rsp], xmm0
  00a1a	66 0f 6f 84 24
	90 0a 00 00	 movdqa	 xmm0, XMMWORD PTR y0o_l$151[rsp]
  00a23	66 0f fe 84 24
	d0 02 00 00	 paddd	 xmm0, XMMWORD PTR y4o_l$27[rsp]
  00a2c	66 0f 7f 84 24
	a0 0a 00 00	 movdqa	 XMMWORD PTR $T152[rsp], xmm0
  00a35	66 0f 6f 84 24
	a0 0a 00 00	 movdqa	 xmm0, XMMWORD PTR $T152[rsp]
  00a3e	66 0f 7f 84 24
	c0 03 00 00	 movdqa	 XMMWORD PTR x4_l$42[rsp], xmm0
  00a47	66 0f 6f 84 24
	b0 0a 00 00	 movdqa	 xmm0, XMMWORD PTR y0o_h$153[rsp]
  00a50	66 0f fe 84 24
	e0 02 00 00	 paddd	 xmm0, XMMWORD PTR y4o_h$28[rsp]
  00a59	66 0f 7f 84 24
	c0 0a 00 00	 movdqa	 XMMWORD PTR $T154[rsp], xmm0
  00a62	66 0f 6f 84 24
	c0 0a 00 00	 movdqa	 xmm0, XMMWORD PTR $T154[rsp]
  00a6b	66 0f 7f 84 24
	e0 03 00 00	 movdqa	 XMMWORD PTR x4_h$44[rsp], xmm0
  00a74	66 0f 6f 84 24
	d0 0a 00 00	 movdqa	 xmm0, XMMWORD PTR y1o_l$155[rsp]
  00a7d	66 0f fe 84 24
	b0 02 00 00	 paddd	 xmm0, XMMWORD PTR y5o_l$25[rsp]
  00a86	66 0f 7f 84 24
	e0 0a 00 00	 movdqa	 XMMWORD PTR $T156[rsp], xmm0
  00a8f	66 0f 6f 84 24
	e0 0a 00 00	 movdqa	 xmm0, XMMWORD PTR $T156[rsp]
  00a98	66 0f 7f 84 24
	80 03 00 00	 movdqa	 XMMWORD PTR x5_l$38[rsp], xmm0
  00aa1	66 0f 6f 84 24
	f0 0a 00 00	 movdqa	 xmm0, XMMWORD PTR y1o_h$157[rsp]
  00aaa	66 0f fe 84 24
	c0 02 00 00	 paddd	 xmm0, XMMWORD PTR y5o_h$26[rsp]
  00ab3	66 0f 7f 84 24
	00 0b 00 00	 movdqa	 XMMWORD PTR $T158[rsp], xmm0
  00abc	66 0f 6f 84 24
	00 0b 00 00	 movdqa	 xmm0, XMMWORD PTR $T158[rsp]
  00ac5	66 0f 7f 84 24
	a0 03 00 00	 movdqa	 XMMWORD PTR x5_h$40[rsp], xmm0
  00ace	66 0f 6f 84 24
	10 0b 00 00	 movdqa	 xmm0, XMMWORD PTR y2o_l$159[rsp]
  00ad7	66 0f fe 84 24
	b0 02 00 00	 paddd	 xmm0, XMMWORD PTR y5o_l$25[rsp]
  00ae0	66 0f 7f 84 24
	20 0b 00 00	 movdqa	 XMMWORD PTR $T160[rsp], xmm0
  00ae9	66 0f 6f 84 24
	20 0b 00 00	 movdqa	 xmm0, XMMWORD PTR $T160[rsp]
  00af2	66 0f 7f 84 24
	40 03 00 00	 movdqa	 XMMWORD PTR x6_l$34[rsp], xmm0
  00afb	66 0f 6f 84 24
	30 0b 00 00	 movdqa	 xmm0, XMMWORD PTR y2o_h$161[rsp]
  00b04	66 0f fe 84 24
	c0 02 00 00	 paddd	 xmm0, XMMWORD PTR y5o_h$26[rsp]
  00b0d	66 0f 7f 84 24
	40 0b 00 00	 movdqa	 XMMWORD PTR $T162[rsp], xmm0
  00b16	66 0f 6f 84 24
	40 0b 00 00	 movdqa	 xmm0, XMMWORD PTR $T162[rsp]
  00b1f	66 0f 7f 84 24
	60 03 00 00	 movdqa	 XMMWORD PTR x6_h$36[rsp], xmm0
  00b28	66 0f 6f 84 24
	50 0b 00 00	 movdqa	 xmm0, XMMWORD PTR y3o_l$163[rsp]
  00b31	66 0f fe 84 24
	d0 02 00 00	 paddd	 xmm0, XMMWORD PTR y4o_l$27[rsp]
  00b3a	66 0f 7f 84 24
	60 0b 00 00	 movdqa	 XMMWORD PTR $T164[rsp], xmm0
  00b43	66 0f 6f 84 24
	60 0b 00 00	 movdqa	 xmm0, XMMWORD PTR $T164[rsp]
  00b4c	66 0f 7f 84 24
	00 03 00 00	 movdqa	 XMMWORD PTR x7_l$30[rsp], xmm0
  00b55	66 0f 6f 84 24
	70 0b 00 00	 movdqa	 xmm0, XMMWORD PTR y3o_h$165[rsp]
  00b5e	66 0f fe 84 24
	e0 02 00 00	 paddd	 xmm0, XMMWORD PTR y4o_h$28[rsp]
  00b67	66 0f 7f 84 24
	80 0b 00 00	 movdqa	 XMMWORD PTR $T166[rsp], xmm0
  00b70	66 0f 6f 84 24
	80 0b 00 00	 movdqa	 xmm0, XMMWORD PTR $T166[rsp]
  00b79	66 0f 7f 84 24
	20 03 00 00	 movdqa	 XMMWORD PTR x7_h$32[rsp], xmm0
  00b82	66 0f 6f 84 24
	90 0b 00 00	 movdqa	 xmm0, XMMWORD PTR x0_l$167[rsp]
  00b8b	66 0f fe 84 24
	d0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rsp]
  00b94	66 0f 7f 84 24
	a0 0b 00 00	 movdqa	 XMMWORD PTR $T168[rsp], xmm0
  00b9d	66 0f 6f 84 24
	a0 0b 00 00	 movdqa	 xmm0, XMMWORD PTR $T168[rsp]
  00ba6	66 0f 7f 84 24
	f0 02 00 00	 movdqa	 XMMWORD PTR abiased_l$29[rsp], xmm0
  00baf	66 0f 6f 84 24
	b0 0b 00 00	 movdqa	 xmm0, XMMWORD PTR x0_h$169[rsp]
  00bb8	66 0f fe 84 24
	d0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rsp]
  00bc1	66 0f 7f 84 24
	c0 0b 00 00	 movdqa	 XMMWORD PTR $T170[rsp], xmm0
  00bca	66 0f 6f 84 24
	c0 0b 00 00	 movdqa	 xmm0, XMMWORD PTR $T170[rsp]
  00bd3	66 0f 7f 84 24
	10 03 00 00	 movdqa	 XMMWORD PTR abiased_h$31[rsp], xmm0
  00bdc	66 0f 6f 84 24
	f0 02 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$29[rsp]
  00be5	66 0f fe 84 24
	00 03 00 00	 paddd	 xmm0, XMMWORD PTR x7_l$30[rsp]
  00bee	66 0f 7f 84 24
	d0 0b 00 00	 movdqa	 XMMWORD PTR $T171[rsp], xmm0
  00bf7	66 0f 6f 84 24
	d0 0b 00 00	 movdqa	 xmm0, XMMWORD PTR $T171[rsp]
  00c00	66 0f 7f 84 24
	20 0c 00 00	 movdqa	 XMMWORD PTR sum_l$176[rsp], xmm0
  00c09	66 0f 6f 84 24
	10 03 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$31[rsp]
  00c12	66 0f fe 84 24
	20 03 00 00	 paddd	 xmm0, XMMWORD PTR x7_h$32[rsp]
  00c1b	66 0f 7f 84 24
	e0 0b 00 00	 movdqa	 XMMWORD PTR $T172[rsp], xmm0
  00c24	66 0f 6f 84 24
	e0 0b 00 00	 movdqa	 xmm0, XMMWORD PTR $T172[rsp]
  00c2d	66 0f 7f 84 24
	10 0c 00 00	 movdqa	 XMMWORD PTR sum_h$175[rsp], xmm0
  00c36	66 0f 6f 84 24
	f0 02 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$29[rsp]
  00c3f	66 0f fa 84 24
	00 03 00 00	 psubd	 xmm0, XMMWORD PTR x7_l$30[rsp]
  00c48	66 0f 7f 84 24
	f0 0b 00 00	 movdqa	 XMMWORD PTR $T173[rsp], xmm0
  00c51	66 0f 6f 84 24
	f0 0b 00 00	 movdqa	 xmm0, XMMWORD PTR $T173[rsp]
  00c5a	66 0f 7f 84 24
	70 0c 00 00	 movdqa	 XMMWORD PTR dif_l$181[rsp], xmm0
  00c63	66 0f 6f 84 24
	10 03 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$31[rsp]
  00c6c	66 0f fa 84 24
	20 03 00 00	 psubd	 xmm0, XMMWORD PTR x7_h$32[rsp]
  00c75	66 0f 7f 84 24
	00 0c 00 00	 movdqa	 XMMWORD PTR $T174[rsp], xmm0
  00c7e	66 0f 6f 84 24
	00 0c 00 00	 movdqa	 xmm0, XMMWORD PTR $T174[rsp]
  00c87	66 0f 7f 84 24
	60 0c 00 00	 movdqa	 XMMWORD PTR dif_h$180[rsp], xmm0
  00c90	66 0f 6f 84 24
	10 0c 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$175[rsp]
  00c99	66 0f 72 e0 0a	 psrad	 xmm0, 10
  00c9e	66 0f 7f 84 24
	40 0c 00 00	 movdqa	 XMMWORD PTR $T178[rsp], xmm0
  00ca7	66 0f 6f 84 24
	20 0c 00 00	 movdqa	 xmm0, XMMWORD PTR sum_l$176[rsp]
  00cb0	66 0f 72 e0 0a	 psrad	 xmm0, 10
  00cb5	66 0f 7f 84 24
	30 0c 00 00	 movdqa	 XMMWORD PTR $T177[rsp], xmm0
  00cbe	66 0f 6f 84 24
	30 0c 00 00	 movdqa	 xmm0, XMMWORD PTR $T177[rsp]
  00cc7	66 0f 6b 84 24
	40 0c 00 00	 packssdw xmm0, XMMWORD PTR $T178[rsp]
  00cd0	66 0f 7f 84 24
	50 0c 00 00	 movdqa	 XMMWORD PTR $T179[rsp], xmm0
  00cd9	66 0f 6f 84 24
	50 0c 00 00	 movdqa	 xmm0, XMMWORD PTR $T179[rsp]
  00ce2	66 0f 7f 44 24
	50		 movdqa	 XMMWORD PTR row0$[rsp], xmm0
  00ce8	66 0f 6f 84 24
	60 0c 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$180[rsp]
  00cf1	66 0f 72 e0 0a	 psrad	 xmm0, 10
  00cf6	66 0f 7f 84 24
	90 0c 00 00	 movdqa	 XMMWORD PTR $T183[rsp], xmm0
  00cff	66 0f 6f 84 24
	70 0c 00 00	 movdqa	 xmm0, XMMWORD PTR dif_l$181[rsp]
  00d08	66 0f 72 e0 0a	 psrad	 xmm0, 10
  00d0d	66 0f 7f 84 24
	80 0c 00 00	 movdqa	 XMMWORD PTR $T182[rsp], xmm0
  00d16	66 0f 6f 84 24
	80 0c 00 00	 movdqa	 xmm0, XMMWORD PTR $T182[rsp]
  00d1f	66 0f 6b 84 24
	90 0c 00 00	 packssdw xmm0, XMMWORD PTR $T183[rsp]
  00d28	66 0f 7f 84 24
	a0 0c 00 00	 movdqa	 XMMWORD PTR $T184[rsp], xmm0
  00d31	66 0f 6f 84 24
	a0 0c 00 00	 movdqa	 xmm0, XMMWORD PTR $T184[rsp]
  00d3a	66 0f 7f 44 24
	40		 movdqa	 XMMWORD PTR row7$[rsp], xmm0
  00d40	66 0f 6f 84 24
	b0 0c 00 00	 movdqa	 xmm0, XMMWORD PTR x1_l$185[rsp]
  00d49	66 0f fe 84 24
	d0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rsp]
  00d52	66 0f 7f 84 24
	c0 0c 00 00	 movdqa	 XMMWORD PTR $T186[rsp], xmm0
  00d5b	66 0f 6f 84 24
	c0 0c 00 00	 movdqa	 xmm0, XMMWORD PTR $T186[rsp]
  00d64	66 0f 7f 84 24
	30 03 00 00	 movdqa	 XMMWORD PTR abiased_l$33[rsp], xmm0
  00d6d	66 0f 6f 84 24
	d0 0c 00 00	 movdqa	 xmm0, XMMWORD PTR x1_h$187[rsp]
  00d76	66 0f fe 84 24
	d0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rsp]
  00d7f	66 0f 7f 84 24
	e0 0c 00 00	 movdqa	 XMMWORD PTR $T188[rsp], xmm0
  00d88	66 0f 6f 84 24
	e0 0c 00 00	 movdqa	 xmm0, XMMWORD PTR $T188[rsp]
  00d91	66 0f 7f 84 24
	50 03 00 00	 movdqa	 XMMWORD PTR abiased_h$35[rsp], xmm0
  00d9a	66 0f 6f 84 24
	30 03 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$33[rsp]
  00da3	66 0f fe 84 24
	40 03 00 00	 paddd	 xmm0, XMMWORD PTR x6_l$34[rsp]
  00dac	66 0f 7f 84 24
	f0 0c 00 00	 movdqa	 XMMWORD PTR $T189[rsp], xmm0
  00db5	66 0f 6f 84 24
	f0 0c 00 00	 movdqa	 xmm0, XMMWORD PTR $T189[rsp]
  00dbe	66 0f 7f 84 24
	40 0d 00 00	 movdqa	 XMMWORD PTR sum_l$194[rsp], xmm0
  00dc7	66 0f 6f 84 24
	50 03 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$35[rsp]
  00dd0	66 0f fe 84 24
	60 03 00 00	 paddd	 xmm0, XMMWORD PTR x6_h$36[rsp]
  00dd9	66 0f 7f 84 24
	00 0d 00 00	 movdqa	 XMMWORD PTR $T190[rsp], xmm0
  00de2	66 0f 6f 84 24
	00 0d 00 00	 movdqa	 xmm0, XMMWORD PTR $T190[rsp]
  00deb	66 0f 7f 84 24
	30 0d 00 00	 movdqa	 XMMWORD PTR sum_h$193[rsp], xmm0
  00df4	66 0f 6f 84 24
	30 03 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$33[rsp]
  00dfd	66 0f fa 84 24
	40 03 00 00	 psubd	 xmm0, XMMWORD PTR x6_l$34[rsp]
  00e06	66 0f 7f 84 24
	10 0d 00 00	 movdqa	 XMMWORD PTR $T191[rsp], xmm0
  00e0f	66 0f 6f 84 24
	10 0d 00 00	 movdqa	 xmm0, XMMWORD PTR $T191[rsp]
  00e18	66 0f 7f 84 24
	90 0d 00 00	 movdqa	 XMMWORD PTR dif_l$199[rsp], xmm0
  00e21	66 0f 6f 84 24
	50 03 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$35[rsp]
  00e2a	66 0f fa 84 24
	60 03 00 00	 psubd	 xmm0, XMMWORD PTR x6_h$36[rsp]
  00e33	66 0f 7f 84 24
	20 0d 00 00	 movdqa	 XMMWORD PTR $T192[rsp], xmm0
  00e3c	66 0f 6f 84 24
	20 0d 00 00	 movdqa	 xmm0, XMMWORD PTR $T192[rsp]
  00e45	66 0f 7f 84 24
	80 0d 00 00	 movdqa	 XMMWORD PTR dif_h$198[rsp], xmm0
  00e4e	66 0f 6f 84 24
	30 0d 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$193[rsp]
  00e57	66 0f 72 e0 0a	 psrad	 xmm0, 10
  00e5c	66 0f 7f 84 24
	60 0d 00 00	 movdqa	 XMMWORD PTR $T196[rsp], xmm0
  00e65	66 0f 6f 84 24
	40 0d 00 00	 movdqa	 xmm0, XMMWORD PTR sum_l$194[rsp]
  00e6e	66 0f 72 e0 0a	 psrad	 xmm0, 10
  00e73	66 0f 7f 84 24
	50 0d 00 00	 movdqa	 XMMWORD PTR $T195[rsp], xmm0
  00e7c	66 0f 6f 84 24
	50 0d 00 00	 movdqa	 xmm0, XMMWORD PTR $T195[rsp]
  00e85	66 0f 6b 84 24
	60 0d 00 00	 packssdw xmm0, XMMWORD PTR $T196[rsp]
  00e8e	66 0f 7f 84 24
	70 0d 00 00	 movdqa	 XMMWORD PTR $T197[rsp], xmm0
  00e97	66 0f 6f 84 24
	70 0d 00 00	 movdqa	 xmm0, XMMWORD PTR $T197[rsp]
  00ea0	66 0f 7f 44 24
	10		 movdqa	 XMMWORD PTR row1$[rsp], xmm0
  00ea6	66 0f 6f 84 24
	80 0d 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$198[rsp]
  00eaf	66 0f 72 e0 0a	 psrad	 xmm0, 10
  00eb4	66 0f 7f 84 24
	b0 0d 00 00	 movdqa	 XMMWORD PTR $T201[rsp], xmm0
  00ebd	66 0f 6f 84 24
	90 0d 00 00	 movdqa	 xmm0, XMMWORD PTR dif_l$199[rsp]
  00ec6	66 0f 72 e0 0a	 psrad	 xmm0, 10
  00ecb	66 0f 7f 84 24
	a0 0d 00 00	 movdqa	 XMMWORD PTR $T200[rsp], xmm0
  00ed4	66 0f 6f 84 24
	a0 0d 00 00	 movdqa	 xmm0, XMMWORD PTR $T200[rsp]
  00edd	66 0f 6b 84 24
	b0 0d 00 00	 packssdw xmm0, XMMWORD PTR $T201[rsp]
  00ee6	66 0f 7f 84 24
	c0 0d 00 00	 movdqa	 XMMWORD PTR $T202[rsp], xmm0
  00eef	66 0f 6f 84 24
	c0 0d 00 00	 movdqa	 xmm0, XMMWORD PTR $T202[rsp]
  00ef8	66 0f 7f 84 24
	80 00 00 00	 movdqa	 XMMWORD PTR row6$[rsp], xmm0
  00f01	66 0f 6f 84 24
	d0 0d 00 00	 movdqa	 xmm0, XMMWORD PTR x2_l$203[rsp]
  00f0a	66 0f fe 84 24
	d0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rsp]
  00f13	66 0f 7f 84 24
	e0 0d 00 00	 movdqa	 XMMWORD PTR $T204[rsp], xmm0
  00f1c	66 0f 6f 84 24
	e0 0d 00 00	 movdqa	 xmm0, XMMWORD PTR $T204[rsp]
  00f25	66 0f 7f 84 24
	70 03 00 00	 movdqa	 XMMWORD PTR abiased_l$37[rsp], xmm0
  00f2e	66 0f 6f 84 24
	f0 0d 00 00	 movdqa	 xmm0, XMMWORD PTR x2_h$205[rsp]
  00f37	66 0f fe 84 24
	d0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rsp]
  00f40	66 0f 7f 84 24
	00 0e 00 00	 movdqa	 XMMWORD PTR $T206[rsp], xmm0
  00f49	66 0f 6f 84 24
	00 0e 00 00	 movdqa	 xmm0, XMMWORD PTR $T206[rsp]
  00f52	66 0f 7f 84 24
	90 03 00 00	 movdqa	 XMMWORD PTR abiased_h$39[rsp], xmm0
  00f5b	66 0f 6f 84 24
	70 03 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$37[rsp]
  00f64	66 0f fe 84 24
	80 03 00 00	 paddd	 xmm0, XMMWORD PTR x5_l$38[rsp]
  00f6d	66 0f 7f 84 24
	10 0e 00 00	 movdqa	 XMMWORD PTR $T207[rsp], xmm0
  00f76	66 0f 6f 84 24
	10 0e 00 00	 movdqa	 xmm0, XMMWORD PTR $T207[rsp]
  00f7f	66 0f 7f 84 24
	60 0e 00 00	 movdqa	 XMMWORD PTR sum_l$212[rsp], xmm0
  00f88	66 0f 6f 84 24
	90 03 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$39[rsp]
  00f91	66 0f fe 84 24
	a0 03 00 00	 paddd	 xmm0, XMMWORD PTR x5_h$40[rsp]
  00f9a	66 0f 7f 84 24
	20 0e 00 00	 movdqa	 XMMWORD PTR $T208[rsp], xmm0
  00fa3	66 0f 6f 84 24
	20 0e 00 00	 movdqa	 xmm0, XMMWORD PTR $T208[rsp]
  00fac	66 0f 7f 84 24
	50 0e 00 00	 movdqa	 XMMWORD PTR sum_h$211[rsp], xmm0
  00fb5	66 0f 6f 84 24
	70 03 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$37[rsp]
  00fbe	66 0f fa 84 24
	80 03 00 00	 psubd	 xmm0, XMMWORD PTR x5_l$38[rsp]
  00fc7	66 0f 7f 84 24
	30 0e 00 00	 movdqa	 XMMWORD PTR $T209[rsp], xmm0
  00fd0	66 0f 6f 84 24
	30 0e 00 00	 movdqa	 xmm0, XMMWORD PTR $T209[rsp]
  00fd9	66 0f 7f 84 24
	b0 0e 00 00	 movdqa	 XMMWORD PTR dif_l$217[rsp], xmm0
  00fe2	66 0f 6f 84 24
	90 03 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$39[rsp]
  00feb	66 0f fa 84 24
	a0 03 00 00	 psubd	 xmm0, XMMWORD PTR x5_h$40[rsp]
  00ff4	66 0f 7f 84 24
	40 0e 00 00	 movdqa	 XMMWORD PTR $T210[rsp], xmm0
  00ffd	66 0f 6f 84 24
	40 0e 00 00	 movdqa	 xmm0, XMMWORD PTR $T210[rsp]
  01006	66 0f 7f 84 24
	a0 0e 00 00	 movdqa	 XMMWORD PTR dif_h$216[rsp], xmm0
  0100f	66 0f 6f 84 24
	50 0e 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$211[rsp]
  01018	66 0f 72 e0 0a	 psrad	 xmm0, 10
  0101d	66 0f 7f 84 24
	80 0e 00 00	 movdqa	 XMMWORD PTR $T214[rsp], xmm0
  01026	66 0f 6f 84 24
	60 0e 00 00	 movdqa	 xmm0, XMMWORD PTR sum_l$212[rsp]
  0102f	66 0f 72 e0 0a	 psrad	 xmm0, 10
  01034	66 0f 7f 84 24
	70 0e 00 00	 movdqa	 XMMWORD PTR $T213[rsp], xmm0
  0103d	66 0f 6f 84 24
	70 0e 00 00	 movdqa	 xmm0, XMMWORD PTR $T213[rsp]
  01046	66 0f 6b 84 24
	80 0e 00 00	 packssdw xmm0, XMMWORD PTR $T214[rsp]
  0104f	66 0f 7f 84 24
	90 0e 00 00	 movdqa	 XMMWORD PTR $T215[rsp], xmm0
  01058	66 0f 6f 84 24
	90 0e 00 00	 movdqa	 xmm0, XMMWORD PTR $T215[rsp]
  01061	66 0f 7f 44 24
	60		 movdqa	 XMMWORD PTR row2$[rsp], xmm0
  01067	66 0f 6f 84 24
	a0 0e 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$216[rsp]
  01070	66 0f 72 e0 0a	 psrad	 xmm0, 10
  01075	66 0f 7f 84 24
	d0 0e 00 00	 movdqa	 XMMWORD PTR $T219[rsp], xmm0
  0107e	66 0f 6f 84 24
	b0 0e 00 00	 movdqa	 xmm0, XMMWORD PTR dif_l$217[rsp]
  01087	66 0f 72 e0 0a	 psrad	 xmm0, 10
  0108c	66 0f 7f 84 24
	c0 0e 00 00	 movdqa	 XMMWORD PTR $T218[rsp], xmm0
  01095	66 0f 6f 84 24
	c0 0e 00 00	 movdqa	 xmm0, XMMWORD PTR $T218[rsp]
  0109e	66 0f 6b 84 24
	d0 0e 00 00	 packssdw xmm0, XMMWORD PTR $T219[rsp]
  010a7	66 0f 7f 84 24
	e0 0e 00 00	 movdqa	 XMMWORD PTR $T220[rsp], xmm0
  010b0	66 0f 6f 84 24
	e0 0e 00 00	 movdqa	 xmm0, XMMWORD PTR $T220[rsp]
  010b9	66 0f 7f 44 24
	30		 movdqa	 XMMWORD PTR row5$[rsp], xmm0
  010bf	66 0f 6f 84 24
	f0 0e 00 00	 movdqa	 xmm0, XMMWORD PTR x3_l$221[rsp]
  010c8	66 0f fe 84 24
	d0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rsp]
  010d1	66 0f 7f 84 24
	00 0f 00 00	 movdqa	 XMMWORD PTR $T222[rsp], xmm0
  010da	66 0f 6f 84 24
	00 0f 00 00	 movdqa	 xmm0, XMMWORD PTR $T222[rsp]
  010e3	66 0f 7f 84 24
	b0 03 00 00	 movdqa	 XMMWORD PTR abiased_l$41[rsp], xmm0
  010ec	66 0f 6f 84 24
	10 0f 00 00	 movdqa	 xmm0, XMMWORD PTR x3_h$223[rsp]
  010f5	66 0f fe 84 24
	d0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_0$[rsp]
  010fe	66 0f 7f 84 24
	20 0f 00 00	 movdqa	 XMMWORD PTR $T224[rsp], xmm0
  01107	66 0f 6f 84 24
	20 0f 00 00	 movdqa	 xmm0, XMMWORD PTR $T224[rsp]
  01110	66 0f 7f 84 24
	d0 03 00 00	 movdqa	 XMMWORD PTR abiased_h$43[rsp], xmm0
  01119	66 0f 6f 84 24
	b0 03 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$41[rsp]
  01122	66 0f fe 84 24
	c0 03 00 00	 paddd	 xmm0, XMMWORD PTR x4_l$42[rsp]
  0112b	66 0f 7f 84 24
	30 0f 00 00	 movdqa	 XMMWORD PTR $T225[rsp], xmm0
  01134	66 0f 6f 84 24
	30 0f 00 00	 movdqa	 xmm0, XMMWORD PTR $T225[rsp]
  0113d	66 0f 7f 84 24
	80 0f 00 00	 movdqa	 XMMWORD PTR sum_l$230[rsp], xmm0
  01146	66 0f 6f 84 24
	d0 03 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$43[rsp]
  0114f	66 0f fe 84 24
	e0 03 00 00	 paddd	 xmm0, XMMWORD PTR x4_h$44[rsp]
  01158	66 0f 7f 84 24
	40 0f 00 00	 movdqa	 XMMWORD PTR $T226[rsp], xmm0
  01161	66 0f 6f 84 24
	40 0f 00 00	 movdqa	 xmm0, XMMWORD PTR $T226[rsp]
  0116a	66 0f 7f 84 24
	70 0f 00 00	 movdqa	 XMMWORD PTR sum_h$229[rsp], xmm0
  01173	66 0f 6f 84 24
	b0 03 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$41[rsp]
  0117c	66 0f fa 84 24
	c0 03 00 00	 psubd	 xmm0, XMMWORD PTR x4_l$42[rsp]
  01185	66 0f 7f 84 24
	50 0f 00 00	 movdqa	 XMMWORD PTR $T227[rsp], xmm0
  0118e	66 0f 6f 84 24
	50 0f 00 00	 movdqa	 xmm0, XMMWORD PTR $T227[rsp]
  01197	66 0f 7f 84 24
	d0 0f 00 00	 movdqa	 XMMWORD PTR dif_l$235[rsp], xmm0
  011a0	66 0f 6f 84 24
	d0 03 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$43[rsp]
  011a9	66 0f fa 84 24
	e0 03 00 00	 psubd	 xmm0, XMMWORD PTR x4_h$44[rsp]
  011b2	66 0f 7f 84 24
	60 0f 00 00	 movdqa	 XMMWORD PTR $T228[rsp], xmm0
  011bb	66 0f 6f 84 24
	60 0f 00 00	 movdqa	 xmm0, XMMWORD PTR $T228[rsp]
  011c4	66 0f 7f 84 24
	c0 0f 00 00	 movdqa	 XMMWORD PTR dif_h$234[rsp], xmm0
  011cd	66 0f 6f 84 24
	70 0f 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$229[rsp]
  011d6	66 0f 72 e0 0a	 psrad	 xmm0, 10
  011db	66 0f 7f 84 24
	a0 0f 00 00	 movdqa	 XMMWORD PTR $T232[rsp], xmm0
  011e4	66 0f 6f 84 24
	80 0f 00 00	 movdqa	 xmm0, XMMWORD PTR sum_l$230[rsp]
  011ed	66 0f 72 e0 0a	 psrad	 xmm0, 10
  011f2	66 0f 7f 84 24
	90 0f 00 00	 movdqa	 XMMWORD PTR $T231[rsp], xmm0
  011fb	66 0f 6f 84 24
	90 0f 00 00	 movdqa	 xmm0, XMMWORD PTR $T231[rsp]
  01204	66 0f 6b 84 24
	a0 0f 00 00	 packssdw xmm0, XMMWORD PTR $T232[rsp]
  0120d	66 0f 7f 84 24
	b0 0f 00 00	 movdqa	 XMMWORD PTR $T233[rsp], xmm0
  01216	66 0f 6f 84 24
	b0 0f 00 00	 movdqa	 xmm0, XMMWORD PTR $T233[rsp]
  0121f	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR row3$[rsp], xmm0
  01225	66 0f 6f 84 24
	c0 0f 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$234[rsp]
  0122e	66 0f 72 e0 0a	 psrad	 xmm0, 10
  01233	66 0f 7f 84 24
	f0 0f 00 00	 movdqa	 XMMWORD PTR $T237[rsp], xmm0
  0123c	66 0f 6f 84 24
	d0 0f 00 00	 movdqa	 xmm0, XMMWORD PTR dif_l$235[rsp]
  01245	66 0f 72 e0 0a	 psrad	 xmm0, 10
  0124a	66 0f 7f 84 24
	e0 0f 00 00	 movdqa	 XMMWORD PTR $T236[rsp], xmm0
  01253	66 0f 6f 84 24
	e0 0f 00 00	 movdqa	 xmm0, XMMWORD PTR $T236[rsp]
  0125c	66 0f 6b 84 24
	f0 0f 00 00	 packssdw xmm0, XMMWORD PTR $T237[rsp]
  01265	66 0f 7f 84 24
	00 10 00 00	 movdqa	 XMMWORD PTR $T238[rsp], xmm0
  0126e	66 0f 6f 84 24
	00 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T238[rsp]
  01277	66 0f 7f 44 24
	70		 movdqa	 XMMWORD PTR row4$[rsp], xmm0

; 2639 :     
; 2640 :     {
; 2641 :         // 16bit 8x8 transpose pass 1
; 2642 :         dct_interleave16(row0, row4);

  0127d	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  01283	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  01288	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  0128e	66 0f 61 44 24
	70		 punpcklwd xmm0, XMMWORD PTR row4$[rsp]
  01294	66 0f 7f 84 24
	10 10 00 00	 movdqa	 XMMWORD PTR $T239[rsp], xmm0
  0129d	66 0f 6f 84 24
	10 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T239[rsp]
  012a6	66 0f 7f 44 24
	50		 movdqa	 XMMWORD PTR row0$[rsp], xmm0
  012ac	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  012b1	66 0f 69 44 24
	70		 punpckhwd xmm0, XMMWORD PTR row4$[rsp]
  012b7	66 0f 7f 84 24
	20 10 00 00	 movdqa	 XMMWORD PTR $T240[rsp], xmm0
  012c0	66 0f 6f 84 24
	20 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T240[rsp]
  012c9	66 0f 7f 44 24
	70		 movdqa	 XMMWORD PTR row4$[rsp], xmm0

; 2643 :         dct_interleave16(row1, row5);

  012cf	66 0f 6f 44 24
	10		 movdqa	 xmm0, XMMWORD PTR row1$[rsp]
  012d5	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  012da	66 0f 6f 44 24
	10		 movdqa	 xmm0, XMMWORD PTR row1$[rsp]
  012e0	66 0f 61 44 24
	30		 punpcklwd xmm0, XMMWORD PTR row5$[rsp]
  012e6	66 0f 7f 84 24
	30 10 00 00	 movdqa	 XMMWORD PTR $T241[rsp], xmm0
  012ef	66 0f 6f 84 24
	30 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T241[rsp]
  012f8	66 0f 7f 44 24
	10		 movdqa	 XMMWORD PTR row1$[rsp], xmm0
  012fe	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  01303	66 0f 69 44 24
	30		 punpckhwd xmm0, XMMWORD PTR row5$[rsp]
  01309	66 0f 7f 84 24
	40 10 00 00	 movdqa	 XMMWORD PTR $T242[rsp], xmm0
  01312	66 0f 6f 84 24
	40 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T242[rsp]
  0131b	66 0f 7f 44 24
	30		 movdqa	 XMMWORD PTR row5$[rsp], xmm0

; 2644 :         dct_interleave16(row2, row6);

  01321	66 0f 6f 44 24
	60		 movdqa	 xmm0, XMMWORD PTR row2$[rsp]
  01327	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  0132c	66 0f 6f 44 24
	60		 movdqa	 xmm0, XMMWORD PTR row2$[rsp]
  01332	66 0f 61 84 24
	80 00 00 00	 punpcklwd xmm0, XMMWORD PTR row6$[rsp]
  0133b	66 0f 7f 84 24
	50 10 00 00	 movdqa	 XMMWORD PTR $T243[rsp], xmm0
  01344	66 0f 6f 84 24
	50 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T243[rsp]
  0134d	66 0f 7f 44 24
	60		 movdqa	 XMMWORD PTR row2$[rsp], xmm0
  01353	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  01358	66 0f 69 84 24
	80 00 00 00	 punpckhwd xmm0, XMMWORD PTR row6$[rsp]
  01361	66 0f 7f 84 24
	60 10 00 00	 movdqa	 XMMWORD PTR $T244[rsp], xmm0
  0136a	66 0f 6f 84 24
	60 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T244[rsp]
  01373	66 0f 7f 84 24
	80 00 00 00	 movdqa	 XMMWORD PTR row6$[rsp], xmm0

; 2645 :         dct_interleave16(row3, row7);

  0137c	66 0f 6f 44 24
	20		 movdqa	 xmm0, XMMWORD PTR row3$[rsp]
  01382	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  01387	66 0f 6f 44 24
	20		 movdqa	 xmm0, XMMWORD PTR row3$[rsp]
  0138d	66 0f 61 44 24
	40		 punpcklwd xmm0, XMMWORD PTR row7$[rsp]
  01393	66 0f 7f 84 24
	70 10 00 00	 movdqa	 XMMWORD PTR $T245[rsp], xmm0
  0139c	66 0f 6f 84 24
	70 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T245[rsp]
  013a5	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR row3$[rsp], xmm0
  013ab	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  013b0	66 0f 69 44 24
	40		 punpckhwd xmm0, XMMWORD PTR row7$[rsp]
  013b6	66 0f 7f 84 24
	80 10 00 00	 movdqa	 XMMWORD PTR $T246[rsp], xmm0
  013bf	66 0f 6f 84 24
	80 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T246[rsp]
  013c8	66 0f 7f 44 24
	40		 movdqa	 XMMWORD PTR row7$[rsp], xmm0

; 2646 :         
; 2647 :         // transpose pass 2
; 2648 :         dct_interleave16(row0, row2);

  013ce	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  013d4	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  013d9	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  013df	66 0f 61 44 24
	60		 punpcklwd xmm0, XMMWORD PTR row2$[rsp]
  013e5	66 0f 7f 84 24
	90 10 00 00	 movdqa	 XMMWORD PTR $T247[rsp], xmm0
  013ee	66 0f 6f 84 24
	90 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T247[rsp]
  013f7	66 0f 7f 44 24
	50		 movdqa	 XMMWORD PTR row0$[rsp], xmm0
  013fd	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  01402	66 0f 69 44 24
	60		 punpckhwd xmm0, XMMWORD PTR row2$[rsp]
  01408	66 0f 7f 84 24
	a0 10 00 00	 movdqa	 XMMWORD PTR $T248[rsp], xmm0
  01411	66 0f 6f 84 24
	a0 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T248[rsp]
  0141a	66 0f 7f 44 24
	60		 movdqa	 XMMWORD PTR row2$[rsp], xmm0

; 2649 :         dct_interleave16(row1, row3);

  01420	66 0f 6f 44 24
	10		 movdqa	 xmm0, XMMWORD PTR row1$[rsp]
  01426	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  0142b	66 0f 6f 44 24
	10		 movdqa	 xmm0, XMMWORD PTR row1$[rsp]
  01431	66 0f 61 44 24
	20		 punpcklwd xmm0, XMMWORD PTR row3$[rsp]
  01437	66 0f 7f 84 24
	b0 10 00 00	 movdqa	 XMMWORD PTR $T249[rsp], xmm0
  01440	66 0f 6f 84 24
	b0 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T249[rsp]
  01449	66 0f 7f 44 24
	10		 movdqa	 XMMWORD PTR row1$[rsp], xmm0
  0144f	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  01454	66 0f 69 44 24
	20		 punpckhwd xmm0, XMMWORD PTR row3$[rsp]
  0145a	66 0f 7f 84 24
	c0 10 00 00	 movdqa	 XMMWORD PTR $T250[rsp], xmm0
  01463	66 0f 6f 84 24
	c0 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T250[rsp]
  0146c	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR row3$[rsp], xmm0

; 2650 :         dct_interleave16(row4, row6);

  01472	66 0f 6f 44 24
	70		 movdqa	 xmm0, XMMWORD PTR row4$[rsp]
  01478	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  0147d	66 0f 6f 44 24
	70		 movdqa	 xmm0, XMMWORD PTR row4$[rsp]
  01483	66 0f 61 84 24
	80 00 00 00	 punpcklwd xmm0, XMMWORD PTR row6$[rsp]
  0148c	66 0f 7f 84 24
	d0 10 00 00	 movdqa	 XMMWORD PTR $T251[rsp], xmm0
  01495	66 0f 6f 84 24
	d0 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T251[rsp]
  0149e	66 0f 7f 44 24
	70		 movdqa	 XMMWORD PTR row4$[rsp], xmm0
  014a4	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  014a9	66 0f 69 84 24
	80 00 00 00	 punpckhwd xmm0, XMMWORD PTR row6$[rsp]
  014b2	66 0f 7f 84 24
	e0 10 00 00	 movdqa	 XMMWORD PTR $T252[rsp], xmm0
  014bb	66 0f 6f 84 24
	e0 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T252[rsp]
  014c4	66 0f 7f 84 24
	80 00 00 00	 movdqa	 XMMWORD PTR row6$[rsp], xmm0

; 2651 :         dct_interleave16(row5, row7);

  014cd	66 0f 6f 44 24
	30		 movdqa	 xmm0, XMMWORD PTR row5$[rsp]
  014d3	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  014d8	66 0f 6f 44 24
	30		 movdqa	 xmm0, XMMWORD PTR row5$[rsp]
  014de	66 0f 61 44 24
	40		 punpcklwd xmm0, XMMWORD PTR row7$[rsp]
  014e4	66 0f 7f 84 24
	f0 10 00 00	 movdqa	 XMMWORD PTR $T253[rsp], xmm0
  014ed	66 0f 6f 84 24
	f0 10 00 00	 movdqa	 xmm0, XMMWORD PTR $T253[rsp]
  014f6	66 0f 7f 44 24
	30		 movdqa	 XMMWORD PTR row5$[rsp], xmm0
  014fc	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  01501	66 0f 69 44 24
	40		 punpckhwd xmm0, XMMWORD PTR row7$[rsp]
  01507	66 0f 7f 84 24
	00 11 00 00	 movdqa	 XMMWORD PTR $T254[rsp], xmm0
  01510	66 0f 6f 84 24
	00 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T254[rsp]
  01519	66 0f 7f 44 24
	40		 movdqa	 XMMWORD PTR row7$[rsp], xmm0

; 2652 :         
; 2653 :         // transpose pass 3
; 2654 :         dct_interleave16(row0, row1);

  0151f	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  01525	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  0152a	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  01530	66 0f 61 44 24
	10		 punpcklwd xmm0, XMMWORD PTR row1$[rsp]
  01536	66 0f 7f 84 24
	10 11 00 00	 movdqa	 XMMWORD PTR $T255[rsp], xmm0
  0153f	66 0f 6f 84 24
	10 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T255[rsp]
  01548	66 0f 7f 44 24
	50		 movdqa	 XMMWORD PTR row0$[rsp], xmm0
  0154e	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  01553	66 0f 69 44 24
	10		 punpckhwd xmm0, XMMWORD PTR row1$[rsp]
  01559	66 0f 7f 84 24
	20 11 00 00	 movdqa	 XMMWORD PTR $T256[rsp], xmm0
  01562	66 0f 6f 84 24
	20 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T256[rsp]
  0156b	66 0f 7f 44 24
	10		 movdqa	 XMMWORD PTR row1$[rsp], xmm0

; 2655 :         dct_interleave16(row2, row3);

  01571	66 0f 6f 44 24
	60		 movdqa	 xmm0, XMMWORD PTR row2$[rsp]
  01577	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  0157c	66 0f 6f 44 24
	60		 movdqa	 xmm0, XMMWORD PTR row2$[rsp]
  01582	66 0f 61 44 24
	20		 punpcklwd xmm0, XMMWORD PTR row3$[rsp]
  01588	66 0f 7f 84 24
	30 11 00 00	 movdqa	 XMMWORD PTR $T257[rsp], xmm0
  01591	66 0f 6f 84 24
	30 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T257[rsp]
  0159a	66 0f 7f 44 24
	60		 movdqa	 XMMWORD PTR row2$[rsp], xmm0
  015a0	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  015a5	66 0f 69 44 24
	20		 punpckhwd xmm0, XMMWORD PTR row3$[rsp]
  015ab	66 0f 7f 84 24
	40 11 00 00	 movdqa	 XMMWORD PTR $T258[rsp], xmm0
  015b4	66 0f 6f 84 24
	40 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T258[rsp]
  015bd	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR row3$[rsp], xmm0

; 2656 :         dct_interleave16(row4, row5);

  015c3	66 0f 6f 44 24
	70		 movdqa	 xmm0, XMMWORD PTR row4$[rsp]
  015c9	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  015ce	66 0f 6f 44 24
	70		 movdqa	 xmm0, XMMWORD PTR row4$[rsp]
  015d4	66 0f 61 44 24
	30		 punpcklwd xmm0, XMMWORD PTR row5$[rsp]
  015da	66 0f 7f 84 24
	50 11 00 00	 movdqa	 XMMWORD PTR $T259[rsp], xmm0
  015e3	66 0f 6f 84 24
	50 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T259[rsp]
  015ec	66 0f 7f 44 24
	70		 movdqa	 XMMWORD PTR row4$[rsp], xmm0
  015f2	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  015f7	66 0f 69 44 24
	30		 punpckhwd xmm0, XMMWORD PTR row5$[rsp]
  015fd	66 0f 7f 84 24
	60 11 00 00	 movdqa	 XMMWORD PTR $T260[rsp], xmm0
  01606	66 0f 6f 84 24
	60 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T260[rsp]
  0160f	66 0f 7f 44 24
	30		 movdqa	 XMMWORD PTR row5$[rsp], xmm0

; 2657 :         dct_interleave16(row6, row7);

  01615	66 0f 6f 84 24
	80 00 00 00	 movdqa	 xmm0, XMMWORD PTR row6$[rsp]
  0161e	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  01623	66 0f 6f 84 24
	80 00 00 00	 movdqa	 xmm0, XMMWORD PTR row6$[rsp]
  0162c	66 0f 61 44 24
	40		 punpcklwd xmm0, XMMWORD PTR row7$[rsp]
  01632	66 0f 7f 84 24
	70 11 00 00	 movdqa	 XMMWORD PTR $T261[rsp], xmm0
  0163b	66 0f 6f 84 24
	70 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T261[rsp]
  01644	66 0f 7f 84 24
	80 00 00 00	 movdqa	 XMMWORD PTR row6$[rsp], xmm0
  0164d	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  01652	66 0f 69 44 24
	40		 punpckhwd xmm0, XMMWORD PTR row7$[rsp]
  01658	66 0f 7f 84 24
	80 11 00 00	 movdqa	 XMMWORD PTR $T262[rsp], xmm0
  01661	66 0f 6f 84 24
	80 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T262[rsp]
  0166a	66 0f 7f 44 24
	40		 movdqa	 XMMWORD PTR row7$[rsp], xmm0

; 2658 :     }
; 2659 :     
; 2660 :     // row pass
; 2661 :     dct_pass(bias_1, 17);

  01670	66 0f 6f 44 24
	60		 movdqa	 xmm0, XMMWORD PTR row2$[rsp]
  01676	66 0f 61 84 24
	80 00 00 00	 punpcklwd xmm0, XMMWORD PTR row6$[rsp]
  0167f	66 0f 7f 84 24
	90 11 00 00	 movdqa	 XMMWORD PTR $T263[rsp], xmm0
  01688	66 0f 6f 84 24
	90 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T263[rsp]
  01691	66 0f 7f 84 24
	f0 03 00 00	 movdqa	 XMMWORD PTR rot0_0lo$45[rsp], xmm0
  0169a	66 0f 6f 44 24
	60		 movdqa	 xmm0, XMMWORD PTR row2$[rsp]
  016a0	66 0f 69 84 24
	80 00 00 00	 punpckhwd xmm0, XMMWORD PTR row6$[rsp]
  016a9	66 0f 7f 84 24
	a0 11 00 00	 movdqa	 XMMWORD PTR $T264[rsp], xmm0
  016b2	66 0f 6f 84 24
	a0 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T264[rsp]
  016bb	66 0f 7f 84 24
	00 04 00 00	 movdqa	 XMMWORD PTR rot0_0hi$46[rsp], xmm0
  016c4	66 0f 6f 84 24
	f0 03 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0lo$45[rsp]
  016cd	66 0f f5 84 24
	f0 00 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_0$[rsp]
  016d6	66 0f 7f 84 24
	b0 11 00 00	 movdqa	 XMMWORD PTR $T265[rsp], xmm0
  016df	66 0f 6f 84 24
	b0 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T265[rsp]
  016e8	66 0f 7f 84 24
	80 04 00 00	 movdqa	 XMMWORD PTR t2e_l$54[rsp], xmm0
  016f1	66 0f 6f 84 24
	00 04 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0hi$46[rsp]
  016fa	66 0f f5 84 24
	f0 00 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_0$[rsp]
  01703	66 0f 7f 84 24
	c0 11 00 00	 movdqa	 XMMWORD PTR $T266[rsp], xmm0
  0170c	66 0f 6f 84 24
	c0 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T266[rsp]
  01715	66 0f 7f 84 24
	a0 04 00 00	 movdqa	 XMMWORD PTR t2e_h$56[rsp], xmm0
  0171e	66 0f 6f 84 24
	f0 03 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0lo$45[rsp]
  01727	66 0f f5 84 24
	00 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_1$[rsp]
  01730	66 0f 7f 84 24
	d0 11 00 00	 movdqa	 XMMWORD PTR $T267[rsp], xmm0
  01739	66 0f 6f 84 24
	d0 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T267[rsp]
  01742	66 0f 7f 84 24
	40 04 00 00	 movdqa	 XMMWORD PTR t3e_l$50[rsp], xmm0
  0174b	66 0f 6f 84 24
	00 04 00 00	 movdqa	 xmm0, XMMWORD PTR rot0_0hi$46[rsp]
  01754	66 0f f5 84 24
	00 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot0_1$[rsp]
  0175d	66 0f 7f 84 24
	e0 11 00 00	 movdqa	 XMMWORD PTR $T268[rsp], xmm0
  01766	66 0f 6f 84 24
	e0 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T268[rsp]
  0176f	66 0f 7f 84 24
	60 04 00 00	 movdqa	 XMMWORD PTR t3e_h$52[rsp], xmm0
  01778	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  0177e	66 0f fd 44 24
	70		 paddw	 xmm0, XMMWORD PTR row4$[rsp]
  01784	66 0f 7f 84 24
	f0 11 00 00	 movdqa	 XMMWORD PTR $T269[rsp], xmm0
  0178d	66 0f 6f 84 24
	f0 11 00 00	 movdqa	 xmm0, XMMWORD PTR $T269[rsp]
  01796	66 0f 7f 84 24
	10 04 00 00	 movdqa	 XMMWORD PTR sum04$47[rsp], xmm0
  0179f	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  017a5	66 0f f9 44 24
	70		 psubw	 xmm0, XMMWORD PTR row4$[rsp]
  017ab	66 0f 7f 84 24
	00 12 00 00	 movdqa	 XMMWORD PTR $T270[rsp], xmm0
  017b4	66 0f 6f 84 24
	00 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T270[rsp]
  017bd	66 0f 7f 84 24
	20 04 00 00	 movdqa	 XMMWORD PTR dif04$48[rsp], xmm0
  017c6	66 0f ef c0	 pxor	 xmm0, xmm0
  017ca	66 0f 7f 84 24
	10 12 00 00	 movdqa	 XMMWORD PTR $T271[rsp], xmm0
  017d3	66 0f 6f 84 24
	10 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T271[rsp]
  017dc	66 0f 61 84 24
	10 04 00 00	 punpcklwd xmm0, XMMWORD PTR sum04$47[rsp]
  017e5	66 0f 7f 84 24
	20 12 00 00	 movdqa	 XMMWORD PTR $T272[rsp], xmm0
  017ee	66 0f 6f 84 24
	20 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T272[rsp]
  017f7	66 0f 72 e0 04	 psrad	 xmm0, 4
  017fc	66 0f 7f 84 24
	30 12 00 00	 movdqa	 XMMWORD PTR $T273[rsp], xmm0
  01805	66 0f 6f 84 24
	30 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T273[rsp]
  0180e	66 0f 7f 84 24
	30 04 00 00	 movdqa	 XMMWORD PTR t0e_l$49[rsp], xmm0
  01817	66 0f ef c0	 pxor	 xmm0, xmm0
  0181b	66 0f 7f 84 24
	40 12 00 00	 movdqa	 XMMWORD PTR $T274[rsp], xmm0
  01824	66 0f 6f 84 24
	40 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T274[rsp]
  0182d	66 0f 69 84 24
	10 04 00 00	 punpckhwd xmm0, XMMWORD PTR sum04$47[rsp]
  01836	66 0f 7f 84 24
	50 12 00 00	 movdqa	 XMMWORD PTR $T275[rsp], xmm0
  0183f	66 0f 6f 84 24
	50 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T275[rsp]
  01848	66 0f 72 e0 04	 psrad	 xmm0, 4
  0184d	66 0f 7f 84 24
	60 12 00 00	 movdqa	 XMMWORD PTR $T276[rsp], xmm0
  01856	66 0f 6f 84 24
	60 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T276[rsp]
  0185f	66 0f 7f 84 24
	50 04 00 00	 movdqa	 XMMWORD PTR t0e_h$51[rsp], xmm0
  01868	66 0f ef c0	 pxor	 xmm0, xmm0
  0186c	66 0f 7f 84 24
	70 12 00 00	 movdqa	 XMMWORD PTR $T277[rsp], xmm0
  01875	66 0f 6f 84 24
	70 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T277[rsp]
  0187e	66 0f 61 84 24
	20 04 00 00	 punpcklwd xmm0, XMMWORD PTR dif04$48[rsp]
  01887	66 0f 7f 84 24
	80 12 00 00	 movdqa	 XMMWORD PTR $T278[rsp], xmm0
  01890	66 0f 6f 84 24
	80 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T278[rsp]
  01899	66 0f 72 e0 04	 psrad	 xmm0, 4
  0189e	66 0f 7f 84 24
	90 12 00 00	 movdqa	 XMMWORD PTR $T279[rsp], xmm0
  018a7	66 0f 6f 84 24
	90 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T279[rsp]
  018b0	66 0f 7f 84 24
	70 04 00 00	 movdqa	 XMMWORD PTR t1e_l$53[rsp], xmm0
  018b9	66 0f ef c0	 pxor	 xmm0, xmm0
  018bd	66 0f 7f 84 24
	a0 12 00 00	 movdqa	 XMMWORD PTR $T280[rsp], xmm0
  018c6	66 0f 6f 84 24
	a0 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T280[rsp]
  018cf	66 0f 69 84 24
	20 04 00 00	 punpckhwd xmm0, XMMWORD PTR dif04$48[rsp]
  018d8	66 0f 7f 84 24
	b0 12 00 00	 movdqa	 XMMWORD PTR $T281[rsp], xmm0
  018e1	66 0f 6f 84 24
	b0 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T281[rsp]
  018ea	66 0f 72 e0 04	 psrad	 xmm0, 4
  018ef	66 0f 7f 84 24
	c0 12 00 00	 movdqa	 XMMWORD PTR $T282[rsp], xmm0
  018f8	66 0f 6f 84 24
	c0 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T282[rsp]
  01901	66 0f 7f 84 24
	90 04 00 00	 movdqa	 XMMWORD PTR t1e_h$55[rsp], xmm0
  0190a	66 0f 6f 84 24
	30 04 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_l$49[rsp]
  01913	66 0f fe 84 24
	40 04 00 00	 paddd	 xmm0, XMMWORD PTR t3e_l$50[rsp]
  0191c	66 0f 7f 84 24
	d0 12 00 00	 movdqa	 XMMWORD PTR $T283[rsp], xmm0
  01925	66 0f 6f 84 24
	d0 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T283[rsp]
  0192e	66 0f 7f 84 24
	90 15 00 00	 movdqa	 XMMWORD PTR x0_l$327[rsp], xmm0
  01937	66 0f 6f 84 24
	50 04 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_h$51[rsp]
  01940	66 0f fe 84 24
	60 04 00 00	 paddd	 xmm0, XMMWORD PTR t3e_h$52[rsp]
  01949	66 0f 7f 84 24
	e0 12 00 00	 movdqa	 XMMWORD PTR $T284[rsp], xmm0
  01952	66 0f 6f 84 24
	e0 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T284[rsp]
  0195b	66 0f 7f 84 24
	b0 15 00 00	 movdqa	 XMMWORD PTR x0_h$329[rsp], xmm0
  01964	66 0f 6f 84 24
	30 04 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_l$49[rsp]
  0196d	66 0f fa 84 24
	40 04 00 00	 psubd	 xmm0, XMMWORD PTR t3e_l$50[rsp]
  01976	66 0f 7f 84 24
	f0 12 00 00	 movdqa	 XMMWORD PTR $T285[rsp], xmm0
  0197f	66 0f 6f 84 24
	f0 12 00 00	 movdqa	 xmm0, XMMWORD PTR $T285[rsp]
  01988	66 0f 7f 84 24
	f0 18 00 00	 movdqa	 XMMWORD PTR x3_l$381[rsp], xmm0
  01991	66 0f 6f 84 24
	50 04 00 00	 movdqa	 xmm0, XMMWORD PTR t0e_h$51[rsp]
  0199a	66 0f fa 84 24
	60 04 00 00	 psubd	 xmm0, XMMWORD PTR t3e_h$52[rsp]
  019a3	66 0f 7f 84 24
	00 13 00 00	 movdqa	 XMMWORD PTR $T286[rsp], xmm0
  019ac	66 0f 6f 84 24
	00 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T286[rsp]
  019b5	66 0f 7f 84 24
	10 19 00 00	 movdqa	 XMMWORD PTR x3_h$383[rsp], xmm0
  019be	66 0f 6f 84 24
	70 04 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_l$53[rsp]
  019c7	66 0f fe 84 24
	80 04 00 00	 paddd	 xmm0, XMMWORD PTR t2e_l$54[rsp]
  019d0	66 0f 7f 84 24
	10 13 00 00	 movdqa	 XMMWORD PTR $T287[rsp], xmm0
  019d9	66 0f 6f 84 24
	10 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T287[rsp]
  019e2	66 0f 7f 84 24
	b0 16 00 00	 movdqa	 XMMWORD PTR x1_l$345[rsp], xmm0
  019eb	66 0f 6f 84 24
	90 04 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_h$55[rsp]
  019f4	66 0f fe 84 24
	a0 04 00 00	 paddd	 xmm0, XMMWORD PTR t2e_h$56[rsp]
  019fd	66 0f 7f 84 24
	20 13 00 00	 movdqa	 XMMWORD PTR $T288[rsp], xmm0
  01a06	66 0f 6f 84 24
	20 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T288[rsp]
  01a0f	66 0f 7f 84 24
	d0 16 00 00	 movdqa	 XMMWORD PTR x1_h$347[rsp], xmm0
  01a18	66 0f 6f 84 24
	70 04 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_l$53[rsp]
  01a21	66 0f fa 84 24
	80 04 00 00	 psubd	 xmm0, XMMWORD PTR t2e_l$54[rsp]
  01a2a	66 0f 7f 84 24
	30 13 00 00	 movdqa	 XMMWORD PTR $T289[rsp], xmm0
  01a33	66 0f 6f 84 24
	30 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T289[rsp]
  01a3c	66 0f 7f 84 24
	d0 17 00 00	 movdqa	 XMMWORD PTR x2_l$363[rsp], xmm0
  01a45	66 0f 6f 84 24
	90 04 00 00	 movdqa	 xmm0, XMMWORD PTR t1e_h$55[rsp]
  01a4e	66 0f fa 84 24
	a0 04 00 00	 psubd	 xmm0, XMMWORD PTR t2e_h$56[rsp]
  01a57	66 0f 7f 84 24
	40 13 00 00	 movdqa	 XMMWORD PTR $T290[rsp], xmm0
  01a60	66 0f 6f 84 24
	40 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T290[rsp]
  01a69	66 0f 7f 84 24
	f0 17 00 00	 movdqa	 XMMWORD PTR x2_h$365[rsp], xmm0
  01a72	66 0f 6f 44 24
	40		 movdqa	 xmm0, XMMWORD PTR row7$[rsp]
  01a78	66 0f 61 44 24
	20		 punpcklwd xmm0, XMMWORD PTR row3$[rsp]
  01a7e	66 0f 7f 84 24
	50 13 00 00	 movdqa	 XMMWORD PTR $T291[rsp], xmm0
  01a87	66 0f 6f 84 24
	50 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T291[rsp]
  01a90	66 0f 7f 84 24
	b0 04 00 00	 movdqa	 XMMWORD PTR rot2_0lo$57[rsp], xmm0
  01a99	66 0f 6f 44 24
	40		 movdqa	 xmm0, XMMWORD PTR row7$[rsp]
  01a9f	66 0f 69 44 24
	20		 punpckhwd xmm0, XMMWORD PTR row3$[rsp]
  01aa5	66 0f 7f 84 24
	60 13 00 00	 movdqa	 XMMWORD PTR $T292[rsp], xmm0
  01aae	66 0f 6f 84 24
	60 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T292[rsp]
  01ab7	66 0f 7f 84 24
	c0 04 00 00	 movdqa	 XMMWORD PTR rot2_0hi$58[rsp], xmm0
  01ac0	66 0f 6f 84 24
	b0 04 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0lo$57[rsp]
  01ac9	66 0f f5 84 24
	10 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_0$[rsp]
  01ad2	66 0f 7f 84 24
	70 13 00 00	 movdqa	 XMMWORD PTR $T293[rsp], xmm0
  01adb	66 0f 6f 84 24
	70 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T293[rsp]
  01ae4	66 0f 7f 84 24
	90 14 00 00	 movdqa	 XMMWORD PTR y0o_l$311[rsp], xmm0
  01aed	66 0f 6f 84 24
	c0 04 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0hi$58[rsp]
  01af6	66 0f f5 84 24
	10 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_0$[rsp]
  01aff	66 0f 7f 84 24
	80 13 00 00	 movdqa	 XMMWORD PTR $T294[rsp], xmm0
  01b08	66 0f 6f 84 24
	80 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T294[rsp]
  01b11	66 0f 7f 84 24
	b0 14 00 00	 movdqa	 XMMWORD PTR y0o_h$313[rsp], xmm0
  01b1a	66 0f 6f 84 24
	b0 04 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0lo$57[rsp]
  01b23	66 0f f5 84 24
	20 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_1$[rsp]
  01b2c	66 0f 7f 84 24
	90 13 00 00	 movdqa	 XMMWORD PTR $T295[rsp], xmm0
  01b35	66 0f 6f 84 24
	90 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T295[rsp]
  01b3e	66 0f 7f 84 24
	10 15 00 00	 movdqa	 XMMWORD PTR y2o_l$319[rsp], xmm0
  01b47	66 0f 6f 84 24
	c0 04 00 00	 movdqa	 xmm0, XMMWORD PTR rot2_0hi$58[rsp]
  01b50	66 0f f5 84 24
	20 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot2_1$[rsp]
  01b59	66 0f 7f 84 24
	a0 13 00 00	 movdqa	 XMMWORD PTR $T296[rsp], xmm0
  01b62	66 0f 6f 84 24
	a0 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T296[rsp]
  01b6b	66 0f 7f 84 24
	30 15 00 00	 movdqa	 XMMWORD PTR y2o_h$321[rsp], xmm0
  01b74	66 0f 6f 44 24
	30		 movdqa	 xmm0, XMMWORD PTR row5$[rsp]
  01b7a	66 0f 61 44 24
	10		 punpcklwd xmm0, XMMWORD PTR row1$[rsp]
  01b80	66 0f 7f 84 24
	b0 13 00 00	 movdqa	 XMMWORD PTR $T297[rsp], xmm0
  01b89	66 0f 6f 84 24
	b0 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T297[rsp]
  01b92	66 0f 7f 84 24
	d0 04 00 00	 movdqa	 XMMWORD PTR rot3_0lo$59[rsp], xmm0
  01b9b	66 0f 6f 44 24
	30		 movdqa	 xmm0, XMMWORD PTR row5$[rsp]
  01ba1	66 0f 69 44 24
	10		 punpckhwd xmm0, XMMWORD PTR row1$[rsp]
  01ba7	66 0f 7f 84 24
	c0 13 00 00	 movdqa	 XMMWORD PTR $T298[rsp], xmm0
  01bb0	66 0f 6f 84 24
	c0 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T298[rsp]
  01bb9	66 0f 7f 84 24
	e0 04 00 00	 movdqa	 XMMWORD PTR rot3_0hi$60[rsp], xmm0
  01bc2	66 0f 6f 84 24
	d0 04 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0lo$59[rsp]
  01bcb	66 0f f5 84 24
	30 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_0$[rsp]
  01bd4	66 0f 7f 84 24
	d0 13 00 00	 movdqa	 XMMWORD PTR $T299[rsp], xmm0
  01bdd	66 0f 6f 84 24
	d0 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T299[rsp]
  01be6	66 0f 7f 84 24
	d0 14 00 00	 movdqa	 XMMWORD PTR y1o_l$315[rsp], xmm0
  01bef	66 0f 6f 84 24
	e0 04 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0hi$60[rsp]
  01bf8	66 0f f5 84 24
	30 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_0$[rsp]
  01c01	66 0f 7f 84 24
	e0 13 00 00	 movdqa	 XMMWORD PTR $T300[rsp], xmm0
  01c0a	66 0f 6f 84 24
	e0 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T300[rsp]
  01c13	66 0f 7f 84 24
	f0 14 00 00	 movdqa	 XMMWORD PTR y1o_h$317[rsp], xmm0
  01c1c	66 0f 6f 84 24
	d0 04 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0lo$59[rsp]
  01c25	66 0f f5 84 24
	40 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_1$[rsp]
  01c2e	66 0f 7f 84 24
	f0 13 00 00	 movdqa	 XMMWORD PTR $T301[rsp], xmm0
  01c37	66 0f 6f 84 24
	f0 13 00 00	 movdqa	 xmm0, XMMWORD PTR $T301[rsp]
  01c40	66 0f 7f 84 24
	50 15 00 00	 movdqa	 XMMWORD PTR y3o_l$323[rsp], xmm0
  01c49	66 0f 6f 84 24
	e0 04 00 00	 movdqa	 xmm0, XMMWORD PTR rot3_0hi$60[rsp]
  01c52	66 0f f5 84 24
	40 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot3_1$[rsp]
  01c5b	66 0f 7f 84 24
	00 14 00 00	 movdqa	 XMMWORD PTR $T302[rsp], xmm0
  01c64	66 0f 6f 84 24
	00 14 00 00	 movdqa	 xmm0, XMMWORD PTR $T302[rsp]
  01c6d	66 0f 7f 84 24
	70 15 00 00	 movdqa	 XMMWORD PTR y3o_h$325[rsp], xmm0
  01c76	66 0f 6f 44 24
	10		 movdqa	 xmm0, XMMWORD PTR row1$[rsp]
  01c7c	66 0f fd 44 24
	40		 paddw	 xmm0, XMMWORD PTR row7$[rsp]
  01c82	66 0f 7f 84 24
	10 14 00 00	 movdqa	 XMMWORD PTR $T303[rsp], xmm0
  01c8b	66 0f 6f 84 24
	10 14 00 00	 movdqa	 xmm0, XMMWORD PTR $T303[rsp]
  01c94	66 0f 7f 84 24
	f0 04 00 00	 movdqa	 XMMWORD PTR sum17$61[rsp], xmm0
  01c9d	66 0f 6f 44 24
	20		 movdqa	 xmm0, XMMWORD PTR row3$[rsp]
  01ca3	66 0f fd 44 24
	30		 paddw	 xmm0, XMMWORD PTR row5$[rsp]
  01ca9	66 0f 7f 84 24
	20 14 00 00	 movdqa	 XMMWORD PTR $T304[rsp], xmm0
  01cb2	66 0f 6f 84 24
	20 14 00 00	 movdqa	 xmm0, XMMWORD PTR $T304[rsp]
  01cbb	66 0f 7f 84 24
	00 05 00 00	 movdqa	 XMMWORD PTR sum35$62[rsp], xmm0
  01cc4	66 0f 6f 84 24
	f0 04 00 00	 movdqa	 xmm0, XMMWORD PTR sum17$61[rsp]
  01ccd	66 0f 61 84 24
	00 05 00 00	 punpcklwd xmm0, XMMWORD PTR sum35$62[rsp]
  01cd6	66 0f 7f 84 24
	30 14 00 00	 movdqa	 XMMWORD PTR $T305[rsp], xmm0
  01cdf	66 0f 6f 84 24
	30 14 00 00	 movdqa	 xmm0, XMMWORD PTR $T305[rsp]
  01ce8	66 0f 7f 84 24
	10 05 00 00	 movdqa	 XMMWORD PTR rot1_0lo$63[rsp], xmm0
  01cf1	66 0f 6f 84 24
	f0 04 00 00	 movdqa	 xmm0, XMMWORD PTR sum17$61[rsp]
  01cfa	66 0f 69 84 24
	00 05 00 00	 punpckhwd xmm0, XMMWORD PTR sum35$62[rsp]
  01d03	66 0f 7f 84 24
	40 14 00 00	 movdqa	 XMMWORD PTR $T306[rsp], xmm0
  01d0c	66 0f 6f 84 24
	40 14 00 00	 movdqa	 xmm0, XMMWORD PTR $T306[rsp]
  01d15	66 0f 7f 84 24
	20 05 00 00	 movdqa	 XMMWORD PTR rot1_0hi$64[rsp], xmm0
  01d1e	66 0f 6f 84 24
	10 05 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0lo$63[rsp]
  01d27	66 0f f5 84 24
	50 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_0$[rsp]
  01d30	66 0f 7f 84 24
	50 14 00 00	 movdqa	 XMMWORD PTR $T307[rsp], xmm0
  01d39	66 0f 6f 84 24
	50 14 00 00	 movdqa	 xmm0, XMMWORD PTR $T307[rsp]
  01d42	66 0f 7f 84 24
	50 05 00 00	 movdqa	 XMMWORD PTR y4o_l$67[rsp], xmm0
  01d4b	66 0f 6f 84 24
	20 05 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0hi$64[rsp]
  01d54	66 0f f5 84 24
	50 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_0$[rsp]
  01d5d	66 0f 7f 84 24
	60 14 00 00	 movdqa	 XMMWORD PTR $T308[rsp], xmm0
  01d66	66 0f 6f 84 24
	60 14 00 00	 movdqa	 xmm0, XMMWORD PTR $T308[rsp]
  01d6f	66 0f 7f 84 24
	60 05 00 00	 movdqa	 XMMWORD PTR y4o_h$68[rsp], xmm0
  01d78	66 0f 6f 84 24
	10 05 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0lo$63[rsp]
  01d81	66 0f f5 84 24
	60 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_1$[rsp]
  01d8a	66 0f 7f 84 24
	70 14 00 00	 movdqa	 XMMWORD PTR $T309[rsp], xmm0
  01d93	66 0f 6f 84 24
	70 14 00 00	 movdqa	 xmm0, XMMWORD PTR $T309[rsp]
  01d9c	66 0f 7f 84 24
	30 05 00 00	 movdqa	 XMMWORD PTR y5o_l$65[rsp], xmm0
  01da5	66 0f 6f 84 24
	20 05 00 00	 movdqa	 xmm0, XMMWORD PTR rot1_0hi$64[rsp]
  01dae	66 0f f5 84 24
	60 01 00 00	 pmaddwd xmm0, XMMWORD PTR rot1_1$[rsp]
  01db7	66 0f 7f 84 24
	80 14 00 00	 movdqa	 XMMWORD PTR $T310[rsp], xmm0
  01dc0	66 0f 6f 84 24
	80 14 00 00	 movdqa	 xmm0, XMMWORD PTR $T310[rsp]
  01dc9	66 0f 7f 84 24
	40 05 00 00	 movdqa	 XMMWORD PTR y5o_h$66[rsp], xmm0
  01dd2	66 0f 6f 84 24
	90 14 00 00	 movdqa	 xmm0, XMMWORD PTR y0o_l$311[rsp]
  01ddb	66 0f fe 84 24
	50 05 00 00	 paddd	 xmm0, XMMWORD PTR y4o_l$67[rsp]
  01de4	66 0f 7f 84 24
	a0 14 00 00	 movdqa	 XMMWORD PTR $T312[rsp], xmm0
  01ded	66 0f 6f 84 24
	a0 14 00 00	 movdqa	 xmm0, XMMWORD PTR $T312[rsp]
  01df6	66 0f 7f 84 24
	40 06 00 00	 movdqa	 XMMWORD PTR x4_l$82[rsp], xmm0
  01dff	66 0f 6f 84 24
	b0 14 00 00	 movdqa	 xmm0, XMMWORD PTR y0o_h$313[rsp]
  01e08	66 0f fe 84 24
	60 05 00 00	 paddd	 xmm0, XMMWORD PTR y4o_h$68[rsp]
  01e11	66 0f 7f 84 24
	c0 14 00 00	 movdqa	 XMMWORD PTR $T314[rsp], xmm0
  01e1a	66 0f 6f 84 24
	c0 14 00 00	 movdqa	 xmm0, XMMWORD PTR $T314[rsp]
  01e23	66 0f 7f 84 24
	60 06 00 00	 movdqa	 XMMWORD PTR x4_h$84[rsp], xmm0
  01e2c	66 0f 6f 84 24
	d0 14 00 00	 movdqa	 xmm0, XMMWORD PTR y1o_l$315[rsp]
  01e35	66 0f fe 84 24
	30 05 00 00	 paddd	 xmm0, XMMWORD PTR y5o_l$65[rsp]
  01e3e	66 0f 7f 84 24
	e0 14 00 00	 movdqa	 XMMWORD PTR $T316[rsp], xmm0
  01e47	66 0f 6f 84 24
	e0 14 00 00	 movdqa	 xmm0, XMMWORD PTR $T316[rsp]
  01e50	66 0f 7f 84 24
	00 06 00 00	 movdqa	 XMMWORD PTR x5_l$78[rsp], xmm0
  01e59	66 0f 6f 84 24
	f0 14 00 00	 movdqa	 xmm0, XMMWORD PTR y1o_h$317[rsp]
  01e62	66 0f fe 84 24
	40 05 00 00	 paddd	 xmm0, XMMWORD PTR y5o_h$66[rsp]
  01e6b	66 0f 7f 84 24
	00 15 00 00	 movdqa	 XMMWORD PTR $T318[rsp], xmm0
  01e74	66 0f 6f 84 24
	00 15 00 00	 movdqa	 xmm0, XMMWORD PTR $T318[rsp]
  01e7d	66 0f 7f 84 24
	20 06 00 00	 movdqa	 XMMWORD PTR x5_h$80[rsp], xmm0
  01e86	66 0f 6f 84 24
	10 15 00 00	 movdqa	 xmm0, XMMWORD PTR y2o_l$319[rsp]
  01e8f	66 0f fe 84 24
	30 05 00 00	 paddd	 xmm0, XMMWORD PTR y5o_l$65[rsp]
  01e98	66 0f 7f 84 24
	20 15 00 00	 movdqa	 XMMWORD PTR $T320[rsp], xmm0
  01ea1	66 0f 6f 84 24
	20 15 00 00	 movdqa	 xmm0, XMMWORD PTR $T320[rsp]
  01eaa	66 0f 7f 84 24
	c0 05 00 00	 movdqa	 XMMWORD PTR x6_l$74[rsp], xmm0
  01eb3	66 0f 6f 84 24
	30 15 00 00	 movdqa	 xmm0, XMMWORD PTR y2o_h$321[rsp]
  01ebc	66 0f fe 84 24
	40 05 00 00	 paddd	 xmm0, XMMWORD PTR y5o_h$66[rsp]
  01ec5	66 0f 7f 84 24
	40 15 00 00	 movdqa	 XMMWORD PTR $T322[rsp], xmm0
  01ece	66 0f 6f 84 24
	40 15 00 00	 movdqa	 xmm0, XMMWORD PTR $T322[rsp]
  01ed7	66 0f 7f 84 24
	e0 05 00 00	 movdqa	 XMMWORD PTR x6_h$76[rsp], xmm0
  01ee0	66 0f 6f 84 24
	50 15 00 00	 movdqa	 xmm0, XMMWORD PTR y3o_l$323[rsp]
  01ee9	66 0f fe 84 24
	50 05 00 00	 paddd	 xmm0, XMMWORD PTR y4o_l$67[rsp]
  01ef2	66 0f 7f 84 24
	60 15 00 00	 movdqa	 XMMWORD PTR $T324[rsp], xmm0
  01efb	66 0f 6f 84 24
	60 15 00 00	 movdqa	 xmm0, XMMWORD PTR $T324[rsp]
  01f04	66 0f 7f 84 24
	80 05 00 00	 movdqa	 XMMWORD PTR x7_l$70[rsp], xmm0
  01f0d	66 0f 6f 84 24
	70 15 00 00	 movdqa	 xmm0, XMMWORD PTR y3o_h$325[rsp]
  01f16	66 0f fe 84 24
	60 05 00 00	 paddd	 xmm0, XMMWORD PTR y4o_h$68[rsp]
  01f1f	66 0f 7f 84 24
	80 15 00 00	 movdqa	 XMMWORD PTR $T326[rsp], xmm0
  01f28	66 0f 6f 84 24
	80 15 00 00	 movdqa	 xmm0, XMMWORD PTR $T326[rsp]
  01f31	66 0f 7f 84 24
	a0 05 00 00	 movdqa	 XMMWORD PTR x7_h$72[rsp], xmm0
  01f3a	66 0f 6f 84 24
	90 15 00 00	 movdqa	 xmm0, XMMWORD PTR x0_l$327[rsp]
  01f43	66 0f fe 84 24
	e0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rsp]
  01f4c	66 0f 7f 84 24
	a0 15 00 00	 movdqa	 XMMWORD PTR $T328[rsp], xmm0
  01f55	66 0f 6f 84 24
	a0 15 00 00	 movdqa	 xmm0, XMMWORD PTR $T328[rsp]
  01f5e	66 0f 7f 84 24
	70 05 00 00	 movdqa	 XMMWORD PTR abiased_l$69[rsp], xmm0
  01f67	66 0f 6f 84 24
	b0 15 00 00	 movdqa	 xmm0, XMMWORD PTR x0_h$329[rsp]
  01f70	66 0f fe 84 24
	e0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rsp]
  01f79	66 0f 7f 84 24
	c0 15 00 00	 movdqa	 XMMWORD PTR $T330[rsp], xmm0
  01f82	66 0f 6f 84 24
	c0 15 00 00	 movdqa	 xmm0, XMMWORD PTR $T330[rsp]
  01f8b	66 0f 7f 84 24
	90 05 00 00	 movdqa	 XMMWORD PTR abiased_h$71[rsp], xmm0
  01f94	66 0f 6f 84 24
	70 05 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$69[rsp]
  01f9d	66 0f fe 84 24
	80 05 00 00	 paddd	 xmm0, XMMWORD PTR x7_l$70[rsp]
  01fa6	66 0f 7f 84 24
	d0 15 00 00	 movdqa	 XMMWORD PTR $T331[rsp], xmm0
  01faf	66 0f 6f 84 24
	d0 15 00 00	 movdqa	 xmm0, XMMWORD PTR $T331[rsp]
  01fb8	66 0f 7f 84 24
	20 16 00 00	 movdqa	 XMMWORD PTR sum_l$336[rsp], xmm0
  01fc1	66 0f 6f 84 24
	90 05 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$71[rsp]
  01fca	66 0f fe 84 24
	a0 05 00 00	 paddd	 xmm0, XMMWORD PTR x7_h$72[rsp]
  01fd3	66 0f 7f 84 24
	e0 15 00 00	 movdqa	 XMMWORD PTR $T332[rsp], xmm0
  01fdc	66 0f 6f 84 24
	e0 15 00 00	 movdqa	 xmm0, XMMWORD PTR $T332[rsp]
  01fe5	66 0f 7f 84 24
	10 16 00 00	 movdqa	 XMMWORD PTR sum_h$335[rsp], xmm0
  01fee	66 0f 6f 84 24
	70 05 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$69[rsp]
  01ff7	66 0f fa 84 24
	80 05 00 00	 psubd	 xmm0, XMMWORD PTR x7_l$70[rsp]
  02000	66 0f 7f 84 24
	f0 15 00 00	 movdqa	 XMMWORD PTR $T333[rsp], xmm0
  02009	66 0f 6f 84 24
	f0 15 00 00	 movdqa	 xmm0, XMMWORD PTR $T333[rsp]
  02012	66 0f 7f 84 24
	70 16 00 00	 movdqa	 XMMWORD PTR dif_l$341[rsp], xmm0
  0201b	66 0f 6f 84 24
	90 05 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$71[rsp]
  02024	66 0f fa 84 24
	a0 05 00 00	 psubd	 xmm0, XMMWORD PTR x7_h$72[rsp]
  0202d	66 0f 7f 84 24
	00 16 00 00	 movdqa	 XMMWORD PTR $T334[rsp], xmm0
  02036	66 0f 6f 84 24
	00 16 00 00	 movdqa	 xmm0, XMMWORD PTR $T334[rsp]
  0203f	66 0f 7f 84 24
	60 16 00 00	 movdqa	 XMMWORD PTR dif_h$340[rsp], xmm0
  02048	66 0f 6f 84 24
	10 16 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$335[rsp]
  02051	66 0f 72 e0 11	 psrad	 xmm0, 17
  02056	66 0f 7f 84 24
	40 16 00 00	 movdqa	 XMMWORD PTR $T338[rsp], xmm0
  0205f	66 0f 6f 84 24
	20 16 00 00	 movdqa	 xmm0, XMMWORD PTR sum_l$336[rsp]
  02068	66 0f 72 e0 11	 psrad	 xmm0, 17
  0206d	66 0f 7f 84 24
	30 16 00 00	 movdqa	 XMMWORD PTR $T337[rsp], xmm0
  02076	66 0f 6f 84 24
	30 16 00 00	 movdqa	 xmm0, XMMWORD PTR $T337[rsp]
  0207f	66 0f 6b 84 24
	40 16 00 00	 packssdw xmm0, XMMWORD PTR $T338[rsp]
  02088	66 0f 7f 84 24
	50 16 00 00	 movdqa	 XMMWORD PTR $T339[rsp], xmm0
  02091	66 0f 6f 84 24
	50 16 00 00	 movdqa	 xmm0, XMMWORD PTR $T339[rsp]
  0209a	66 0f 7f 44 24
	50		 movdqa	 XMMWORD PTR row0$[rsp], xmm0
  020a0	66 0f 6f 84 24
	60 16 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$340[rsp]
  020a9	66 0f 72 e0 11	 psrad	 xmm0, 17
  020ae	66 0f 7f 84 24
	90 16 00 00	 movdqa	 XMMWORD PTR $T343[rsp], xmm0
  020b7	66 0f 6f 84 24
	70 16 00 00	 movdqa	 xmm0, XMMWORD PTR dif_l$341[rsp]
  020c0	66 0f 72 e0 11	 psrad	 xmm0, 17
  020c5	66 0f 7f 84 24
	80 16 00 00	 movdqa	 XMMWORD PTR $T342[rsp], xmm0
  020ce	66 0f 6f 84 24
	80 16 00 00	 movdqa	 xmm0, XMMWORD PTR $T342[rsp]
  020d7	66 0f 6b 84 24
	90 16 00 00	 packssdw xmm0, XMMWORD PTR $T343[rsp]
  020e0	66 0f 7f 84 24
	a0 16 00 00	 movdqa	 XMMWORD PTR $T344[rsp], xmm0
  020e9	66 0f 6f 84 24
	a0 16 00 00	 movdqa	 xmm0, XMMWORD PTR $T344[rsp]
  020f2	66 0f 7f 44 24
	40		 movdqa	 XMMWORD PTR row7$[rsp], xmm0
  020f8	66 0f 6f 84 24
	b0 16 00 00	 movdqa	 xmm0, XMMWORD PTR x1_l$345[rsp]
  02101	66 0f fe 84 24
	e0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rsp]
  0210a	66 0f 7f 84 24
	c0 16 00 00	 movdqa	 XMMWORD PTR $T346[rsp], xmm0
  02113	66 0f 6f 84 24
	c0 16 00 00	 movdqa	 xmm0, XMMWORD PTR $T346[rsp]
  0211c	66 0f 7f 84 24
	b0 05 00 00	 movdqa	 XMMWORD PTR abiased_l$73[rsp], xmm0
  02125	66 0f 6f 84 24
	d0 16 00 00	 movdqa	 xmm0, XMMWORD PTR x1_h$347[rsp]
  0212e	66 0f fe 84 24
	e0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rsp]
  02137	66 0f 7f 84 24
	e0 16 00 00	 movdqa	 XMMWORD PTR $T348[rsp], xmm0
  02140	66 0f 6f 84 24
	e0 16 00 00	 movdqa	 xmm0, XMMWORD PTR $T348[rsp]
  02149	66 0f 7f 84 24
	d0 05 00 00	 movdqa	 XMMWORD PTR abiased_h$75[rsp], xmm0
  02152	66 0f 6f 84 24
	b0 05 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$73[rsp]
  0215b	66 0f fe 84 24
	c0 05 00 00	 paddd	 xmm0, XMMWORD PTR x6_l$74[rsp]
  02164	66 0f 7f 84 24
	f0 16 00 00	 movdqa	 XMMWORD PTR $T349[rsp], xmm0
  0216d	66 0f 6f 84 24
	f0 16 00 00	 movdqa	 xmm0, XMMWORD PTR $T349[rsp]
  02176	66 0f 7f 84 24
	40 17 00 00	 movdqa	 XMMWORD PTR sum_l$354[rsp], xmm0
  0217f	66 0f 6f 84 24
	d0 05 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$75[rsp]
  02188	66 0f fe 84 24
	e0 05 00 00	 paddd	 xmm0, XMMWORD PTR x6_h$76[rsp]
  02191	66 0f 7f 84 24
	00 17 00 00	 movdqa	 XMMWORD PTR $T350[rsp], xmm0
  0219a	66 0f 6f 84 24
	00 17 00 00	 movdqa	 xmm0, XMMWORD PTR $T350[rsp]
  021a3	66 0f 7f 84 24
	30 17 00 00	 movdqa	 XMMWORD PTR sum_h$353[rsp], xmm0
  021ac	66 0f 6f 84 24
	b0 05 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$73[rsp]
  021b5	66 0f fa 84 24
	c0 05 00 00	 psubd	 xmm0, XMMWORD PTR x6_l$74[rsp]
  021be	66 0f 7f 84 24
	10 17 00 00	 movdqa	 XMMWORD PTR $T351[rsp], xmm0
  021c7	66 0f 6f 84 24
	10 17 00 00	 movdqa	 xmm0, XMMWORD PTR $T351[rsp]
  021d0	66 0f 7f 84 24
	90 17 00 00	 movdqa	 XMMWORD PTR dif_l$359[rsp], xmm0
  021d9	66 0f 6f 84 24
	d0 05 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$75[rsp]
  021e2	66 0f fa 84 24
	e0 05 00 00	 psubd	 xmm0, XMMWORD PTR x6_h$76[rsp]
  021eb	66 0f 7f 84 24
	20 17 00 00	 movdqa	 XMMWORD PTR $T352[rsp], xmm0
  021f4	66 0f 6f 84 24
	20 17 00 00	 movdqa	 xmm0, XMMWORD PTR $T352[rsp]
  021fd	66 0f 7f 84 24
	80 17 00 00	 movdqa	 XMMWORD PTR dif_h$358[rsp], xmm0
  02206	66 0f 6f 84 24
	30 17 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$353[rsp]
  0220f	66 0f 72 e0 11	 psrad	 xmm0, 17
  02214	66 0f 7f 84 24
	60 17 00 00	 movdqa	 XMMWORD PTR $T356[rsp], xmm0
  0221d	66 0f 6f 84 24
	40 17 00 00	 movdqa	 xmm0, XMMWORD PTR sum_l$354[rsp]
  02226	66 0f 72 e0 11	 psrad	 xmm0, 17
  0222b	66 0f 7f 84 24
	50 17 00 00	 movdqa	 XMMWORD PTR $T355[rsp], xmm0
  02234	66 0f 6f 84 24
	50 17 00 00	 movdqa	 xmm0, XMMWORD PTR $T355[rsp]
  0223d	66 0f 6b 84 24
	60 17 00 00	 packssdw xmm0, XMMWORD PTR $T356[rsp]
  02246	66 0f 7f 84 24
	70 17 00 00	 movdqa	 XMMWORD PTR $T357[rsp], xmm0
  0224f	66 0f 6f 84 24
	70 17 00 00	 movdqa	 xmm0, XMMWORD PTR $T357[rsp]
  02258	66 0f 7f 44 24
	10		 movdqa	 XMMWORD PTR row1$[rsp], xmm0
  0225e	66 0f 6f 84 24
	80 17 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$358[rsp]
  02267	66 0f 72 e0 11	 psrad	 xmm0, 17
  0226c	66 0f 7f 84 24
	b0 17 00 00	 movdqa	 XMMWORD PTR $T361[rsp], xmm0
  02275	66 0f 6f 84 24
	90 17 00 00	 movdqa	 xmm0, XMMWORD PTR dif_l$359[rsp]
  0227e	66 0f 72 e0 11	 psrad	 xmm0, 17
  02283	66 0f 7f 84 24
	a0 17 00 00	 movdqa	 XMMWORD PTR $T360[rsp], xmm0
  0228c	66 0f 6f 84 24
	a0 17 00 00	 movdqa	 xmm0, XMMWORD PTR $T360[rsp]
  02295	66 0f 6b 84 24
	b0 17 00 00	 packssdw xmm0, XMMWORD PTR $T361[rsp]
  0229e	66 0f 7f 84 24
	c0 17 00 00	 movdqa	 XMMWORD PTR $T362[rsp], xmm0
  022a7	66 0f 6f 84 24
	c0 17 00 00	 movdqa	 xmm0, XMMWORD PTR $T362[rsp]
  022b0	66 0f 7f 84 24
	80 00 00 00	 movdqa	 XMMWORD PTR row6$[rsp], xmm0
  022b9	66 0f 6f 84 24
	d0 17 00 00	 movdqa	 xmm0, XMMWORD PTR x2_l$363[rsp]
  022c2	66 0f fe 84 24
	e0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rsp]
  022cb	66 0f 7f 84 24
	e0 17 00 00	 movdqa	 XMMWORD PTR $T364[rsp], xmm0
  022d4	66 0f 6f 84 24
	e0 17 00 00	 movdqa	 xmm0, XMMWORD PTR $T364[rsp]
  022dd	66 0f 7f 84 24
	f0 05 00 00	 movdqa	 XMMWORD PTR abiased_l$77[rsp], xmm0
  022e6	66 0f 6f 84 24
	f0 17 00 00	 movdqa	 xmm0, XMMWORD PTR x2_h$365[rsp]
  022ef	66 0f fe 84 24
	e0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rsp]
  022f8	66 0f 7f 84 24
	00 18 00 00	 movdqa	 XMMWORD PTR $T366[rsp], xmm0
  02301	66 0f 6f 84 24
	00 18 00 00	 movdqa	 xmm0, XMMWORD PTR $T366[rsp]
  0230a	66 0f 7f 84 24
	10 06 00 00	 movdqa	 XMMWORD PTR abiased_h$79[rsp], xmm0
  02313	66 0f 6f 84 24
	f0 05 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$77[rsp]
  0231c	66 0f fe 84 24
	00 06 00 00	 paddd	 xmm0, XMMWORD PTR x5_l$78[rsp]
  02325	66 0f 7f 84 24
	10 18 00 00	 movdqa	 XMMWORD PTR $T367[rsp], xmm0
  0232e	66 0f 6f 84 24
	10 18 00 00	 movdqa	 xmm0, XMMWORD PTR $T367[rsp]
  02337	66 0f 7f 84 24
	60 18 00 00	 movdqa	 XMMWORD PTR sum_l$372[rsp], xmm0
  02340	66 0f 6f 84 24
	10 06 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$79[rsp]
  02349	66 0f fe 84 24
	20 06 00 00	 paddd	 xmm0, XMMWORD PTR x5_h$80[rsp]
  02352	66 0f 7f 84 24
	20 18 00 00	 movdqa	 XMMWORD PTR $T368[rsp], xmm0
  0235b	66 0f 6f 84 24
	20 18 00 00	 movdqa	 xmm0, XMMWORD PTR $T368[rsp]
  02364	66 0f 7f 84 24
	50 18 00 00	 movdqa	 XMMWORD PTR sum_h$371[rsp], xmm0
  0236d	66 0f 6f 84 24
	f0 05 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$77[rsp]
  02376	66 0f fa 84 24
	00 06 00 00	 psubd	 xmm0, XMMWORD PTR x5_l$78[rsp]
  0237f	66 0f 7f 84 24
	30 18 00 00	 movdqa	 XMMWORD PTR $T369[rsp], xmm0
  02388	66 0f 6f 84 24
	30 18 00 00	 movdqa	 xmm0, XMMWORD PTR $T369[rsp]
  02391	66 0f 7f 84 24
	b0 18 00 00	 movdqa	 XMMWORD PTR dif_l$377[rsp], xmm0
  0239a	66 0f 6f 84 24
	10 06 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$79[rsp]
  023a3	66 0f fa 84 24
	20 06 00 00	 psubd	 xmm0, XMMWORD PTR x5_h$80[rsp]
  023ac	66 0f 7f 84 24
	40 18 00 00	 movdqa	 XMMWORD PTR $T370[rsp], xmm0
  023b5	66 0f 6f 84 24
	40 18 00 00	 movdqa	 xmm0, XMMWORD PTR $T370[rsp]
  023be	66 0f 7f 84 24
	a0 18 00 00	 movdqa	 XMMWORD PTR dif_h$376[rsp], xmm0
  023c7	66 0f 6f 84 24
	50 18 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$371[rsp]
  023d0	66 0f 72 e0 11	 psrad	 xmm0, 17
  023d5	66 0f 7f 84 24
	80 18 00 00	 movdqa	 XMMWORD PTR $T374[rsp], xmm0
  023de	66 0f 6f 84 24
	60 18 00 00	 movdqa	 xmm0, XMMWORD PTR sum_l$372[rsp]
  023e7	66 0f 72 e0 11	 psrad	 xmm0, 17
  023ec	66 0f 7f 84 24
	70 18 00 00	 movdqa	 XMMWORD PTR $T373[rsp], xmm0
  023f5	66 0f 6f 84 24
	70 18 00 00	 movdqa	 xmm0, XMMWORD PTR $T373[rsp]
  023fe	66 0f 6b 84 24
	80 18 00 00	 packssdw xmm0, XMMWORD PTR $T374[rsp]
  02407	66 0f 7f 84 24
	90 18 00 00	 movdqa	 XMMWORD PTR $T375[rsp], xmm0
  02410	66 0f 6f 84 24
	90 18 00 00	 movdqa	 xmm0, XMMWORD PTR $T375[rsp]
  02419	66 0f 7f 44 24
	60		 movdqa	 XMMWORD PTR row2$[rsp], xmm0
  0241f	66 0f 6f 84 24
	a0 18 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$376[rsp]
  02428	66 0f 72 e0 11	 psrad	 xmm0, 17
  0242d	66 0f 7f 84 24
	d0 18 00 00	 movdqa	 XMMWORD PTR $T379[rsp], xmm0
  02436	66 0f 6f 84 24
	b0 18 00 00	 movdqa	 xmm0, XMMWORD PTR dif_l$377[rsp]
  0243f	66 0f 72 e0 11	 psrad	 xmm0, 17
  02444	66 0f 7f 84 24
	c0 18 00 00	 movdqa	 XMMWORD PTR $T378[rsp], xmm0
  0244d	66 0f 6f 84 24
	c0 18 00 00	 movdqa	 xmm0, XMMWORD PTR $T378[rsp]
  02456	66 0f 6b 84 24
	d0 18 00 00	 packssdw xmm0, XMMWORD PTR $T379[rsp]
  0245f	66 0f 7f 84 24
	e0 18 00 00	 movdqa	 XMMWORD PTR $T380[rsp], xmm0
  02468	66 0f 6f 84 24
	e0 18 00 00	 movdqa	 xmm0, XMMWORD PTR $T380[rsp]
  02471	66 0f 7f 44 24
	30		 movdqa	 XMMWORD PTR row5$[rsp], xmm0
  02477	66 0f 6f 84 24
	f0 18 00 00	 movdqa	 xmm0, XMMWORD PTR x3_l$381[rsp]
  02480	66 0f fe 84 24
	e0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rsp]
  02489	66 0f 7f 84 24
	00 19 00 00	 movdqa	 XMMWORD PTR $T382[rsp], xmm0
  02492	66 0f 6f 84 24
	00 19 00 00	 movdqa	 xmm0, XMMWORD PTR $T382[rsp]
  0249b	66 0f 7f 84 24
	30 06 00 00	 movdqa	 XMMWORD PTR abiased_l$81[rsp], xmm0
  024a4	66 0f 6f 84 24
	10 19 00 00	 movdqa	 xmm0, XMMWORD PTR x3_h$383[rsp]
  024ad	66 0f fe 84 24
	e0 00 00 00	 paddd	 xmm0, XMMWORD PTR bias_1$[rsp]
  024b6	66 0f 7f 84 24
	20 19 00 00	 movdqa	 XMMWORD PTR $T384[rsp], xmm0
  024bf	66 0f 6f 84 24
	20 19 00 00	 movdqa	 xmm0, XMMWORD PTR $T384[rsp]
  024c8	66 0f 7f 84 24
	50 06 00 00	 movdqa	 XMMWORD PTR abiased_h$83[rsp], xmm0
  024d1	66 0f 6f 84 24
	30 06 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$81[rsp]
  024da	66 0f fe 84 24
	40 06 00 00	 paddd	 xmm0, XMMWORD PTR x4_l$82[rsp]
  024e3	66 0f 7f 84 24
	30 19 00 00	 movdqa	 XMMWORD PTR $T385[rsp], xmm0
  024ec	66 0f 6f 84 24
	30 19 00 00	 movdqa	 xmm0, XMMWORD PTR $T385[rsp]
  024f5	66 0f 7f 84 24
	80 19 00 00	 movdqa	 XMMWORD PTR sum_l$390[rsp], xmm0
  024fe	66 0f 6f 84 24
	50 06 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$83[rsp]
  02507	66 0f fe 84 24
	60 06 00 00	 paddd	 xmm0, XMMWORD PTR x4_h$84[rsp]
  02510	66 0f 7f 84 24
	40 19 00 00	 movdqa	 XMMWORD PTR $T386[rsp], xmm0
  02519	66 0f 6f 84 24
	40 19 00 00	 movdqa	 xmm0, XMMWORD PTR $T386[rsp]
  02522	66 0f 7f 84 24
	70 19 00 00	 movdqa	 XMMWORD PTR sum_h$389[rsp], xmm0
  0252b	66 0f 6f 84 24
	30 06 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_l$81[rsp]
  02534	66 0f fa 84 24
	40 06 00 00	 psubd	 xmm0, XMMWORD PTR x4_l$82[rsp]
  0253d	66 0f 7f 84 24
	50 19 00 00	 movdqa	 XMMWORD PTR $T387[rsp], xmm0
  02546	66 0f 6f 84 24
	50 19 00 00	 movdqa	 xmm0, XMMWORD PTR $T387[rsp]
  0254f	66 0f 7f 84 24
	d0 19 00 00	 movdqa	 XMMWORD PTR dif_l$395[rsp], xmm0
  02558	66 0f 6f 84 24
	50 06 00 00	 movdqa	 xmm0, XMMWORD PTR abiased_h$83[rsp]
  02561	66 0f fa 84 24
	60 06 00 00	 psubd	 xmm0, XMMWORD PTR x4_h$84[rsp]
  0256a	66 0f 7f 84 24
	60 19 00 00	 movdqa	 XMMWORD PTR $T388[rsp], xmm0
  02573	66 0f 6f 84 24
	60 19 00 00	 movdqa	 xmm0, XMMWORD PTR $T388[rsp]
  0257c	66 0f 7f 84 24
	c0 19 00 00	 movdqa	 XMMWORD PTR dif_h$394[rsp], xmm0
  02585	66 0f 6f 84 24
	70 19 00 00	 movdqa	 xmm0, XMMWORD PTR sum_h$389[rsp]
  0258e	66 0f 72 e0 11	 psrad	 xmm0, 17
  02593	66 0f 7f 84 24
	a0 19 00 00	 movdqa	 XMMWORD PTR $T392[rsp], xmm0
  0259c	66 0f 6f 84 24
	80 19 00 00	 movdqa	 xmm0, XMMWORD PTR sum_l$390[rsp]
  025a5	66 0f 72 e0 11	 psrad	 xmm0, 17
  025aa	66 0f 7f 84 24
	90 19 00 00	 movdqa	 XMMWORD PTR $T391[rsp], xmm0
  025b3	66 0f 6f 84 24
	90 19 00 00	 movdqa	 xmm0, XMMWORD PTR $T391[rsp]
  025bc	66 0f 6b 84 24
	a0 19 00 00	 packssdw xmm0, XMMWORD PTR $T392[rsp]
  025c5	66 0f 7f 84 24
	b0 19 00 00	 movdqa	 XMMWORD PTR $T393[rsp], xmm0
  025ce	66 0f 6f 84 24
	b0 19 00 00	 movdqa	 xmm0, XMMWORD PTR $T393[rsp]
  025d7	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR row3$[rsp], xmm0
  025dd	66 0f 6f 84 24
	c0 19 00 00	 movdqa	 xmm0, XMMWORD PTR dif_h$394[rsp]
  025e6	66 0f 72 e0 11	 psrad	 xmm0, 17
  025eb	66 0f 7f 84 24
	f0 19 00 00	 movdqa	 XMMWORD PTR $T397[rsp], xmm0
  025f4	66 0f 6f 84 24
	d0 19 00 00	 movdqa	 xmm0, XMMWORD PTR dif_l$395[rsp]
  025fd	66 0f 72 e0 11	 psrad	 xmm0, 17
  02602	66 0f 7f 84 24
	e0 19 00 00	 movdqa	 XMMWORD PTR $T396[rsp], xmm0
  0260b	66 0f 6f 84 24
	e0 19 00 00	 movdqa	 xmm0, XMMWORD PTR $T396[rsp]
  02614	66 0f 6b 84 24
	f0 19 00 00	 packssdw xmm0, XMMWORD PTR $T397[rsp]
  0261d	66 0f 7f 84 24
	00 1a 00 00	 movdqa	 XMMWORD PTR $T398[rsp], xmm0
  02626	66 0f 6f 84 24
	00 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T398[rsp]
  0262f	66 0f 7f 44 24
	70		 movdqa	 XMMWORD PTR row4$[rsp], xmm0

; 2662 :     
; 2663 :     {
; 2664 :         // pack
; 2665 :         __m128i p0 = _mm_packus_epi16(row0, row1); // a0a1a2a3...a7b0b1b2b3...b7

  02635	66 0f 6f 44 24
	50		 movdqa	 xmm0, XMMWORD PTR row0$[rsp]
  0263b	66 0f 67 44 24
	10		 packuswb xmm0, XMMWORD PTR row1$[rsp]
  02641	66 0f 7f 84 24
	10 1a 00 00	 movdqa	 XMMWORD PTR $T399[rsp], xmm0
  0264a	66 0f 6f 84 24
	10 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T399[rsp]
  02653	66 0f 7f 84 24
	90 00 00 00	 movdqa	 XMMWORD PTR p0$1[rsp], xmm0

; 2666 :         __m128i p1 = _mm_packus_epi16(row2, row3);

  0265c	66 0f 6f 44 24
	60		 movdqa	 xmm0, XMMWORD PTR row2$[rsp]
  02662	66 0f 67 44 24
	20		 packuswb xmm0, XMMWORD PTR row3$[rsp]
  02668	66 0f 7f 84 24
	20 1a 00 00	 movdqa	 XMMWORD PTR $T400[rsp], xmm0
  02671	66 0f 6f 84 24
	20 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T400[rsp]
  0267a	66 0f 7f 84 24
	b0 00 00 00	 movdqa	 XMMWORD PTR p1$3[rsp], xmm0

; 2667 :         __m128i p2 = _mm_packus_epi16(row4, row5);

  02683	66 0f 6f 44 24
	70		 movdqa	 xmm0, XMMWORD PTR row4$[rsp]
  02689	66 0f 67 44 24
	30		 packuswb xmm0, XMMWORD PTR row5$[rsp]
  0268f	66 0f 7f 84 24
	30 1a 00 00	 movdqa	 XMMWORD PTR $T401[rsp], xmm0
  02698	66 0f 6f 84 24
	30 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T401[rsp]
  026a1	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR p2$2[rsp], xmm0

; 2668 :         __m128i p3 = _mm_packus_epi16(row6, row7);

  026aa	66 0f 6f 84 24
	80 00 00 00	 movdqa	 xmm0, XMMWORD PTR row6$[rsp]
  026b3	66 0f 67 44 24
	40		 packuswb xmm0, XMMWORD PTR row7$[rsp]
  026b9	66 0f 7f 84 24
	40 1a 00 00	 movdqa	 XMMWORD PTR $T402[rsp], xmm0
  026c2	66 0f 6f 84 24
	40 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T402[rsp]
  026cb	66 0f 7f 84 24
	c0 00 00 00	 movdqa	 XMMWORD PTR p3$4[rsp], xmm0

; 2669 :         
; 2670 :         // 8bit 8x8 transpose pass 1
; 2671 :         dct_interleave8(p0, p2); // a0e0a1e1...

  026d4	66 0f 6f 84 24
	90 00 00 00	 movdqa	 xmm0, XMMWORD PTR p0$1[rsp]
  026dd	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  026e2	66 0f 6f 84 24
	90 00 00 00	 movdqa	 xmm0, XMMWORD PTR p0$1[rsp]
  026eb	66 0f 60 84 24
	a0 00 00 00	 punpcklbw xmm0, XMMWORD PTR p2$2[rsp]
  026f4	66 0f 7f 84 24
	50 1a 00 00	 movdqa	 XMMWORD PTR $T403[rsp], xmm0
  026fd	66 0f 6f 84 24
	50 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T403[rsp]
  02706	66 0f 7f 84 24
	90 00 00 00	 movdqa	 XMMWORD PTR p0$1[rsp], xmm0
  0270f	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  02714	66 0f 68 84 24
	a0 00 00 00	 punpckhbw xmm0, XMMWORD PTR p2$2[rsp]
  0271d	66 0f 7f 84 24
	60 1a 00 00	 movdqa	 XMMWORD PTR $T404[rsp], xmm0
  02726	66 0f 6f 84 24
	60 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T404[rsp]
  0272f	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR p2$2[rsp], xmm0

; 2672 :         dct_interleave8(p1, p3); // c0g0c1g1...

  02738	66 0f 6f 84 24
	b0 00 00 00	 movdqa	 xmm0, XMMWORD PTR p1$3[rsp]
  02741	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  02746	66 0f 6f 84 24
	b0 00 00 00	 movdqa	 xmm0, XMMWORD PTR p1$3[rsp]
  0274f	66 0f 60 84 24
	c0 00 00 00	 punpcklbw xmm0, XMMWORD PTR p3$4[rsp]
  02758	66 0f 7f 84 24
	70 1a 00 00	 movdqa	 XMMWORD PTR $T405[rsp], xmm0
  02761	66 0f 6f 84 24
	70 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T405[rsp]
  0276a	66 0f 7f 84 24
	b0 00 00 00	 movdqa	 XMMWORD PTR p1$3[rsp], xmm0
  02773	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  02778	66 0f 68 84 24
	c0 00 00 00	 punpckhbw xmm0, XMMWORD PTR p3$4[rsp]
  02781	66 0f 7f 84 24
	80 1a 00 00	 movdqa	 XMMWORD PTR $T406[rsp], xmm0
  0278a	66 0f 6f 84 24
	80 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T406[rsp]
  02793	66 0f 7f 84 24
	c0 00 00 00	 movdqa	 XMMWORD PTR p3$4[rsp], xmm0

; 2673 :         
; 2674 :         // transpose pass 2
; 2675 :         dct_interleave8(p0, p1); // a0c0e0g0...

  0279c	66 0f 6f 84 24
	90 00 00 00	 movdqa	 xmm0, XMMWORD PTR p0$1[rsp]
  027a5	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  027aa	66 0f 6f 84 24
	90 00 00 00	 movdqa	 xmm0, XMMWORD PTR p0$1[rsp]
  027b3	66 0f 60 84 24
	b0 00 00 00	 punpcklbw xmm0, XMMWORD PTR p1$3[rsp]
  027bc	66 0f 7f 84 24
	90 1a 00 00	 movdqa	 XMMWORD PTR $T407[rsp], xmm0
  027c5	66 0f 6f 84 24
	90 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T407[rsp]
  027ce	66 0f 7f 84 24
	90 00 00 00	 movdqa	 XMMWORD PTR p0$1[rsp], xmm0
  027d7	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  027dc	66 0f 68 84 24
	b0 00 00 00	 punpckhbw xmm0, XMMWORD PTR p1$3[rsp]
  027e5	66 0f 7f 84 24
	a0 1a 00 00	 movdqa	 XMMWORD PTR $T408[rsp], xmm0
  027ee	66 0f 6f 84 24
	a0 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T408[rsp]
  027f7	66 0f 7f 84 24
	b0 00 00 00	 movdqa	 XMMWORD PTR p1$3[rsp], xmm0

; 2676 :         dct_interleave8(p2, p3); // b0d0f0h0...

  02800	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR p2$2[rsp]
  02809	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  0280e	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR p2$2[rsp]
  02817	66 0f 60 84 24
	c0 00 00 00	 punpcklbw xmm0, XMMWORD PTR p3$4[rsp]
  02820	66 0f 7f 84 24
	b0 1a 00 00	 movdqa	 XMMWORD PTR $T409[rsp], xmm0
  02829	66 0f 6f 84 24
	b0 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T409[rsp]
  02832	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR p2$2[rsp], xmm0
  0283b	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  02840	66 0f 68 84 24
	c0 00 00 00	 punpckhbw xmm0, XMMWORD PTR p3$4[rsp]
  02849	66 0f 7f 84 24
	c0 1a 00 00	 movdqa	 XMMWORD PTR $T410[rsp], xmm0
  02852	66 0f 6f 84 24
	c0 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T410[rsp]
  0285b	66 0f 7f 84 24
	c0 00 00 00	 movdqa	 XMMWORD PTR p3$4[rsp], xmm0

; 2677 :         
; 2678 :         // transpose pass 3
; 2679 :         dct_interleave8(p0, p2); // a0b0c0d0...

  02864	66 0f 6f 84 24
	90 00 00 00	 movdqa	 xmm0, XMMWORD PTR p0$1[rsp]
  0286d	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  02872	66 0f 6f 84 24
	90 00 00 00	 movdqa	 xmm0, XMMWORD PTR p0$1[rsp]
  0287b	66 0f 60 84 24
	a0 00 00 00	 punpcklbw xmm0, XMMWORD PTR p2$2[rsp]
  02884	66 0f 7f 84 24
	d0 1a 00 00	 movdqa	 XMMWORD PTR $T411[rsp], xmm0
  0288d	66 0f 6f 84 24
	d0 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T411[rsp]
  02896	66 0f 7f 84 24
	90 00 00 00	 movdqa	 XMMWORD PTR p0$1[rsp], xmm0
  0289f	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  028a4	66 0f 68 84 24
	a0 00 00 00	 punpckhbw xmm0, XMMWORD PTR p2$2[rsp]
  028ad	66 0f 7f 84 24
	e0 1a 00 00	 movdqa	 XMMWORD PTR $T412[rsp], xmm0
  028b6	66 0f 6f 84 24
	e0 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T412[rsp]
  028bf	66 0f 7f 84 24
	a0 00 00 00	 movdqa	 XMMWORD PTR p2$2[rsp], xmm0

; 2680 :         dct_interleave8(p1, p3); // a4b4c4d4...

  028c8	66 0f 6f 84 24
	b0 00 00 00	 movdqa	 xmm0, XMMWORD PTR p1$3[rsp]
  028d1	66 0f 7f 04 24	 movdqa	 XMMWORD PTR tmp$[rsp], xmm0
  028d6	66 0f 6f 84 24
	b0 00 00 00	 movdqa	 xmm0, XMMWORD PTR p1$3[rsp]
  028df	66 0f 60 84 24
	c0 00 00 00	 punpcklbw xmm0, XMMWORD PTR p3$4[rsp]
  028e8	66 0f 7f 84 24
	f0 1a 00 00	 movdqa	 XMMWORD PTR $T413[rsp], xmm0
  028f1	66 0f 6f 84 24
	f0 1a 00 00	 movdqa	 xmm0, XMMWORD PTR $T413[rsp]
  028fa	66 0f 7f 84 24
	b0 00 00 00	 movdqa	 XMMWORD PTR p1$3[rsp], xmm0
  02903	66 0f 6f 04 24	 movdqa	 xmm0, XMMWORD PTR tmp$[rsp]
  02908	66 0f 68 84 24
	c0 00 00 00	 punpckhbw xmm0, XMMWORD PTR p3$4[rsp]
  02911	66 0f 7f 84 24
	00 1b 00 00	 movdqa	 XMMWORD PTR $T414[rsp], xmm0
  0291a	66 0f 6f 84 24
	00 1b 00 00	 movdqa	 xmm0, XMMWORD PTR $T414[rsp]
  02923	66 0f 7f 84 24
	c0 00 00 00	 movdqa	 XMMWORD PTR p3$4[rsp], xmm0

; 2681 :         
; 2682 :         // store
; 2683 :         _mm_storel_epi64((__m128i *) out, p0); out += out_stride;

  0292c	48 8b 84 24 60
	1b 00 00	 mov	 rax, QWORD PTR out$[rsp]
  02934	66 0f 6f 84 24
	90 00 00 00	 movdqa	 xmm0, XMMWORD PTR p0$1[rsp]
  0293d	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0
  02941	48 63 84 24 68
	1b 00 00	 movsxd	 rax, DWORD PTR out_stride$[rsp]
  02949	48 8b 8c 24 60
	1b 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  02951	48 03 c8	 add	 rcx, rax
  02954	48 8b c1	 mov	 rax, rcx
  02957	48 89 84 24 60
	1b 00 00	 mov	 QWORD PTR out$[rsp], rax

; 2684 :         _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p0, 0x4e)); out += out_stride;

  0295f	66 0f 6f 84 24
	90 00 00 00	 movdqa	 xmm0, XMMWORD PTR p0$1[rsp]
  02968	66 0f 70 c0 4e	 pshufd	 xmm0, xmm0, 78		; 0000004eH
  0296d	66 0f 7f 84 24
	10 1b 00 00	 movdqa	 XMMWORD PTR $T415[rsp], xmm0
  02976	48 8b 84 24 60
	1b 00 00	 mov	 rax, QWORD PTR out$[rsp]
  0297e	66 0f 6f 84 24
	10 1b 00 00	 movdqa	 xmm0, XMMWORD PTR $T415[rsp]
  02987	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0
  0298b	48 63 84 24 68
	1b 00 00	 movsxd	 rax, DWORD PTR out_stride$[rsp]
  02993	48 8b 8c 24 60
	1b 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  0299b	48 03 c8	 add	 rcx, rax
  0299e	48 8b c1	 mov	 rax, rcx
  029a1	48 89 84 24 60
	1b 00 00	 mov	 QWORD PTR out$[rsp], rax

; 2685 :         _mm_storel_epi64((__m128i *) out, p2); out += out_stride;

  029a9	48 8b 84 24 60
	1b 00 00	 mov	 rax, QWORD PTR out$[rsp]
  029b1	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR p2$2[rsp]
  029ba	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0
  029be	48 63 84 24 68
	1b 00 00	 movsxd	 rax, DWORD PTR out_stride$[rsp]
  029c6	48 8b 8c 24 60
	1b 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  029ce	48 03 c8	 add	 rcx, rax
  029d1	48 8b c1	 mov	 rax, rcx
  029d4	48 89 84 24 60
	1b 00 00	 mov	 QWORD PTR out$[rsp], rax

; 2686 :         _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p2, 0x4e)); out += out_stride;

  029dc	66 0f 6f 84 24
	a0 00 00 00	 movdqa	 xmm0, XMMWORD PTR p2$2[rsp]
  029e5	66 0f 70 c0 4e	 pshufd	 xmm0, xmm0, 78		; 0000004eH
  029ea	66 0f 7f 84 24
	20 1b 00 00	 movdqa	 XMMWORD PTR $T416[rsp], xmm0
  029f3	48 8b 84 24 60
	1b 00 00	 mov	 rax, QWORD PTR out$[rsp]
  029fb	66 0f 6f 84 24
	20 1b 00 00	 movdqa	 xmm0, XMMWORD PTR $T416[rsp]
  02a04	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0
  02a08	48 63 84 24 68
	1b 00 00	 movsxd	 rax, DWORD PTR out_stride$[rsp]
  02a10	48 8b 8c 24 60
	1b 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  02a18	48 03 c8	 add	 rcx, rax
  02a1b	48 8b c1	 mov	 rax, rcx
  02a1e	48 89 84 24 60
	1b 00 00	 mov	 QWORD PTR out$[rsp], rax

; 2687 :         _mm_storel_epi64((__m128i *) out, p1); out += out_stride;

  02a26	48 8b 84 24 60
	1b 00 00	 mov	 rax, QWORD PTR out$[rsp]
  02a2e	66 0f 6f 84 24
	b0 00 00 00	 movdqa	 xmm0, XMMWORD PTR p1$3[rsp]
  02a37	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0
  02a3b	48 63 84 24 68
	1b 00 00	 movsxd	 rax, DWORD PTR out_stride$[rsp]
  02a43	48 8b 8c 24 60
	1b 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  02a4b	48 03 c8	 add	 rcx, rax
  02a4e	48 8b c1	 mov	 rax, rcx
  02a51	48 89 84 24 60
	1b 00 00	 mov	 QWORD PTR out$[rsp], rax

; 2688 :         _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p1, 0x4e)); out += out_stride;

  02a59	66 0f 6f 84 24
	b0 00 00 00	 movdqa	 xmm0, XMMWORD PTR p1$3[rsp]
  02a62	66 0f 70 c0 4e	 pshufd	 xmm0, xmm0, 78		; 0000004eH
  02a67	66 0f 7f 84 24
	30 1b 00 00	 movdqa	 XMMWORD PTR $T417[rsp], xmm0
  02a70	48 8b 84 24 60
	1b 00 00	 mov	 rax, QWORD PTR out$[rsp]
  02a78	66 0f 6f 84 24
	30 1b 00 00	 movdqa	 xmm0, XMMWORD PTR $T417[rsp]
  02a81	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0
  02a85	48 63 84 24 68
	1b 00 00	 movsxd	 rax, DWORD PTR out_stride$[rsp]
  02a8d	48 8b 8c 24 60
	1b 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  02a95	48 03 c8	 add	 rcx, rax
  02a98	48 8b c1	 mov	 rax, rcx
  02a9b	48 89 84 24 60
	1b 00 00	 mov	 QWORD PTR out$[rsp], rax

; 2689 :         _mm_storel_epi64((__m128i *) out, p3); out += out_stride;

  02aa3	48 8b 84 24 60
	1b 00 00	 mov	 rax, QWORD PTR out$[rsp]
  02aab	66 0f 6f 84 24
	c0 00 00 00	 movdqa	 xmm0, XMMWORD PTR p3$4[rsp]
  02ab4	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0
  02ab8	48 63 84 24 68
	1b 00 00	 movsxd	 rax, DWORD PTR out_stride$[rsp]
  02ac0	48 8b 8c 24 60
	1b 00 00	 mov	 rcx, QWORD PTR out$[rsp]
  02ac8	48 03 c8	 add	 rcx, rax
  02acb	48 8b c1	 mov	 rax, rcx
  02ace	48 89 84 24 60
	1b 00 00	 mov	 QWORD PTR out$[rsp], rax

; 2690 :         _mm_storel_epi64((__m128i *) out, _mm_shuffle_epi32(p3, 0x4e));

  02ad6	66 0f 6f 84 24
	c0 00 00 00	 movdqa	 xmm0, XMMWORD PTR p3$4[rsp]
  02adf	66 0f 70 c0 4e	 pshufd	 xmm0, xmm0, 78		; 0000004eH
  02ae4	66 0f 7f 84 24
	40 1b 00 00	 movdqa	 XMMWORD PTR $T418[rsp], xmm0
  02aed	48 8b 84 24 60
	1b 00 00	 mov	 rax, QWORD PTR out$[rsp]
  02af5	66 0f 6f 84 24
	40 1b 00 00	 movdqa	 xmm0, XMMWORD PTR $T418[rsp]
  02afe	66 0f d6 00	 movq	 QWORD PTR [rax], xmm0

; 2691 :     }
; 2692 :     
; 2693 : #undef dct_const
; 2694 : #undef dct_rot
; 2695 : #undef dct_widen
; 2696 : #undef dct_wadd
; 2697 : #undef dct_wsub
; 2698 : #undef dct_bfly32o
; 2699 : #undef dct_interleave8
; 2700 : #undef dct_interleave16
; 2701 : #undef dct_pass
; 2702 : }

  02b02	48 81 c4 58 1b
	00 00		 add	 rsp, 7000		; 00001b58H
  02b09	c3		 ret	 0
?stbi__idct_simd@@YAXPEAEHQEAF@Z ENDP			; stbi__idct_simd
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
v$ = 32
p3$1 = 40
t3$2 = 44
t2$3 = 48
t1$4 = 52
t0$5 = 56
p3$6 = 60
t3$7 = 64
t2$8 = 68
t1$9 = 72
t0$10 = 76
p2$11 = 80
p2$12 = 84
d$ = 88
dcterm$13 = 96
p1$14 = 100
i$ = 104
p1$15 = 108
p4$16 = 112
p4$17 = 116
o$ = 120
x0$18 = 128
x1$19 = 132
x2$20 = 136
x3$21 = 140
x0$22 = 144
x1$23 = 148
x2$24 = 152
x3$25 = 156
p5$26 = 160
p5$27 = 164
val$ = 176
__$ArrayPad$ = 432
out$ = 464
out_stride$ = 472
data$ = 480
?stbi__idct_block@@YAXPEAEHQEAF@Z PROC			; stbi__idct_block

; 2467 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec c8 01
	00 00		 sub	 rsp, 456		; 000001c8H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2468 :     int i,val[64],*v=val;

  00027	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR val$[rsp]
  0002f	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax

; 2469 :     stbi_uc *o;
; 2470 :     short *d = data;

  00034	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR data$[rsp]
  0003c	48 89 44 24 58	 mov	 QWORD PTR d$[rsp], rax

; 2471 :     
; 2472 :     // columns
; 2473 :     for (i=0; i < 8; ++i,++d, ++v) {

  00041	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00049	eb 26		 jmp	 SHORT $LN4@stbi__idct
$LN2@stbi__idct:
  0004b	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  0004f	ff c0		 inc	 eax
  00051	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
  00055	48 8b 44 24 58	 mov	 rax, QWORD PTR d$[rsp]
  0005a	48 83 c0 02	 add	 rax, 2
  0005e	48 89 44 24 58	 mov	 QWORD PTR d$[rsp], rax
  00063	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  00068	48 83 c0 04	 add	 rax, 4
  0006c	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax
$LN4@stbi__idct:
  00071	83 7c 24 68 08	 cmp	 DWORD PTR i$[rsp], 8
  00076	0f 8d 7a 05 00
	00		 jge	 $LN3@stbi__idct

; 2474 :         // if all zeroes, shortcut -- this avoids dequantizing 0s and IDCTing
; 2475 :         if (d[ 8]==0 && d[16]==0 && d[24]==0 && d[32]==0
; 2476 :             && d[40]==0 && d[48]==0 && d[56]==0) {

  0007c	b8 02 00 00 00	 mov	 eax, 2
  00081	48 6b c0 08	 imul	 rax, rax, 8
  00085	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  0008a	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0008e	85 c0		 test	 eax, eax
  00090	0f 85 62 01 00
	00		 jne	 $LN8@stbi__idct
  00096	b8 02 00 00 00	 mov	 eax, 2
  0009b	48 6b c0 10	 imul	 rax, rax, 16
  0009f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  000a4	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  000a8	85 c0		 test	 eax, eax
  000aa	0f 85 48 01 00
	00		 jne	 $LN8@stbi__idct
  000b0	b8 02 00 00 00	 mov	 eax, 2
  000b5	48 6b c0 18	 imul	 rax, rax, 24
  000b9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  000be	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  000c2	85 c0		 test	 eax, eax
  000c4	0f 85 2e 01 00
	00		 jne	 $LN8@stbi__idct
  000ca	b8 02 00 00 00	 mov	 eax, 2
  000cf	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  000d3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  000d8	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  000dc	85 c0		 test	 eax, eax
  000de	0f 85 14 01 00
	00		 jne	 $LN8@stbi__idct
  000e4	b8 02 00 00 00	 mov	 eax, 2
  000e9	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  000ed	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  000f2	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  000f6	85 c0		 test	 eax, eax
  000f8	0f 85 fa 00 00
	00		 jne	 $LN8@stbi__idct
  000fe	b8 02 00 00 00	 mov	 eax, 2
  00103	48 6b c0 30	 imul	 rax, rax, 48		; 00000030H
  00107	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  0010c	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00110	85 c0		 test	 eax, eax
  00112	0f 85 e0 00 00
	00		 jne	 $LN8@stbi__idct
  00118	b8 02 00 00 00	 mov	 eax, 2
  0011d	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  00121	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  00126	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0012a	85 c0		 test	 eax, eax
  0012c	0f 85 c6 00 00
	00		 jne	 $LN8@stbi__idct

; 2477 :             //    no shortcut                 0     seconds
; 2478 :             //    (1|2|3|4|5|6|7)==0          0     seconds
; 2479 :             //    all separate               -0.047 seconds
; 2480 :             //    1 && 2|3 && 4|5 && 6|7:    -0.047 seconds
; 2481 :             int dcterm = d[0]*4;

  00132	b8 02 00 00 00	 mov	 eax, 2
  00137	48 6b c0 00	 imul	 rax, rax, 0
  0013b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  00140	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00144	c1 e0 02	 shl	 eax, 2
  00147	89 44 24 60	 mov	 DWORD PTR dcterm$13[rsp], eax

; 2482 :             v[0] = v[8] = v[16] = v[24] = v[32] = v[40] = v[48] = v[56] = dcterm;

  0014b	b8 04 00 00 00	 mov	 eax, 4
  00150	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  00154	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00159	8b 54 24 60	 mov	 edx, DWORD PTR dcterm$13[rsp]
  0015d	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
  00160	b8 04 00 00 00	 mov	 eax, 4
  00165	48 6b c0 30	 imul	 rax, rax, 48		; 00000030H
  00169	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  0016e	8b 54 24 60	 mov	 edx, DWORD PTR dcterm$13[rsp]
  00172	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
  00175	b8 04 00 00 00	 mov	 eax, 4
  0017a	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  0017e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00183	8b 54 24 60	 mov	 edx, DWORD PTR dcterm$13[rsp]
  00187	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
  0018a	b8 04 00 00 00	 mov	 eax, 4
  0018f	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00193	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00198	8b 54 24 60	 mov	 edx, DWORD PTR dcterm$13[rsp]
  0019c	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
  0019f	b8 04 00 00 00	 mov	 eax, 4
  001a4	48 6b c0 18	 imul	 rax, rax, 24
  001a8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  001ad	8b 54 24 60	 mov	 edx, DWORD PTR dcterm$13[rsp]
  001b1	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
  001b4	b8 04 00 00 00	 mov	 eax, 4
  001b9	48 6b c0 10	 imul	 rax, rax, 16
  001bd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  001c2	8b 54 24 60	 mov	 edx, DWORD PTR dcterm$13[rsp]
  001c6	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
  001c9	b8 04 00 00 00	 mov	 eax, 4
  001ce	48 6b c0 08	 imul	 rax, rax, 8
  001d2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  001d7	8b 54 24 60	 mov	 edx, DWORD PTR dcterm$13[rsp]
  001db	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
  001de	b8 04 00 00 00	 mov	 eax, 4
  001e3	48 6b c0 00	 imul	 rax, rax, 0
  001e7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  001ec	8b 54 24 60	 mov	 edx, DWORD PTR dcterm$13[rsp]
  001f0	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 2483 :         } else {

  001f3	e9 f9 03 00 00	 jmp	 $LN9@stbi__idct
$LN8@stbi__idct:

; 2484 :             STBI__IDCT_1D(d[ 0],d[ 8],d[16],d[24],d[32],d[40],d[48],d[56])

  001f8	b8 02 00 00 00	 mov	 eax, 2
  001fd	48 6b c0 10	 imul	 rax, rax, 16
  00201	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  00206	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0020a	89 44 24 50	 mov	 DWORD PTR p2$11[rsp], eax
  0020e	b8 02 00 00 00	 mov	 eax, 2
  00213	48 6b c0 30	 imul	 rax, rax, 48		; 00000030H
  00217	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  0021c	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00220	89 44 24 28	 mov	 DWORD PTR p3$1[rsp], eax
  00224	8b 44 24 28	 mov	 eax, DWORD PTR p3$1[rsp]
  00228	8b 4c 24 50	 mov	 ecx, DWORD PTR p2$11[rsp]
  0022c	03 c8		 add	 ecx, eax
  0022e	8b c1		 mov	 eax, ecx
  00230	69 c0 a9 08 00
	00		 imul	 eax, eax, 2217		; 000008a9H
  00236	89 44 24 64	 mov	 DWORD PTR p1$14[rsp], eax
  0023a	69 44 24 28 71
	e2 ff ff	 imul	 eax, DWORD PTR p3$1[rsp], -7567 ; ffffffffffffe271H
  00242	8b 4c 24 64	 mov	 ecx, DWORD PTR p1$14[rsp]
  00246	03 c8		 add	 ecx, eax
  00248	8b c1		 mov	 eax, ecx
  0024a	89 44 24 30	 mov	 DWORD PTR t2$3[rsp], eax
  0024e	69 44 24 50 3f
	0c 00 00	 imul	 eax, DWORD PTR p2$11[rsp], 3135 ; 00000c3fH
  00256	8b 4c 24 64	 mov	 ecx, DWORD PTR p1$14[rsp]
  0025a	03 c8		 add	 ecx, eax
  0025c	8b c1		 mov	 eax, ecx
  0025e	89 44 24 2c	 mov	 DWORD PTR t3$2[rsp], eax
  00262	b8 02 00 00 00	 mov	 eax, 2
  00267	48 6b c0 00	 imul	 rax, rax, 0
  0026b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  00270	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00274	89 44 24 50	 mov	 DWORD PTR p2$11[rsp], eax
  00278	b8 02 00 00 00	 mov	 eax, 2
  0027d	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00281	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  00286	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0028a	89 44 24 28	 mov	 DWORD PTR p3$1[rsp], eax
  0028e	8b 44 24 28	 mov	 eax, DWORD PTR p3$1[rsp]
  00292	8b 4c 24 50	 mov	 ecx, DWORD PTR p2$11[rsp]
  00296	03 c8		 add	 ecx, eax
  00298	8b c1		 mov	 eax, ecx
  0029a	69 c0 00 10 00
	00		 imul	 eax, eax, 4096		; 00001000H
  002a0	89 44 24 38	 mov	 DWORD PTR t0$5[rsp], eax
  002a4	8b 44 24 28	 mov	 eax, DWORD PTR p3$1[rsp]
  002a8	8b 4c 24 50	 mov	 ecx, DWORD PTR p2$11[rsp]
  002ac	2b c8		 sub	 ecx, eax
  002ae	8b c1		 mov	 eax, ecx
  002b0	69 c0 00 10 00
	00		 imul	 eax, eax, 4096		; 00001000H
  002b6	89 44 24 34	 mov	 DWORD PTR t1$4[rsp], eax
  002ba	8b 44 24 2c	 mov	 eax, DWORD PTR t3$2[rsp]
  002be	8b 4c 24 38	 mov	 ecx, DWORD PTR t0$5[rsp]
  002c2	03 c8		 add	 ecx, eax
  002c4	8b c1		 mov	 eax, ecx
  002c6	89 84 24 80 00
	00 00		 mov	 DWORD PTR x0$18[rsp], eax
  002cd	8b 44 24 2c	 mov	 eax, DWORD PTR t3$2[rsp]
  002d1	8b 4c 24 38	 mov	 ecx, DWORD PTR t0$5[rsp]
  002d5	2b c8		 sub	 ecx, eax
  002d7	8b c1		 mov	 eax, ecx
  002d9	89 84 24 8c 00
	00 00		 mov	 DWORD PTR x3$21[rsp], eax
  002e0	8b 44 24 30	 mov	 eax, DWORD PTR t2$3[rsp]
  002e4	8b 4c 24 34	 mov	 ecx, DWORD PTR t1$4[rsp]
  002e8	03 c8		 add	 ecx, eax
  002ea	8b c1		 mov	 eax, ecx
  002ec	89 84 24 84 00
	00 00		 mov	 DWORD PTR x1$19[rsp], eax
  002f3	8b 44 24 30	 mov	 eax, DWORD PTR t2$3[rsp]
  002f7	8b 4c 24 34	 mov	 ecx, DWORD PTR t1$4[rsp]
  002fb	2b c8		 sub	 ecx, eax
  002fd	8b c1		 mov	 eax, ecx
  002ff	89 84 24 88 00
	00 00		 mov	 DWORD PTR x2$20[rsp], eax
  00306	b8 02 00 00 00	 mov	 eax, 2
  0030b	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  0030f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  00314	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00318	89 44 24 38	 mov	 DWORD PTR t0$5[rsp], eax
  0031c	b8 02 00 00 00	 mov	 eax, 2
  00321	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  00325	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  0032a	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0032e	89 44 24 34	 mov	 DWORD PTR t1$4[rsp], eax
  00332	b8 02 00 00 00	 mov	 eax, 2
  00337	48 6b c0 18	 imul	 rax, rax, 24
  0033b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  00340	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  00344	89 44 24 30	 mov	 DWORD PTR t2$3[rsp], eax
  00348	b8 02 00 00 00	 mov	 eax, 2
  0034d	48 6b c0 08	 imul	 rax, rax, 8
  00351	48 8b 4c 24 58	 mov	 rcx, QWORD PTR d$[rsp]
  00356	0f bf 04 01	 movsx	 eax, WORD PTR [rcx+rax]
  0035a	89 44 24 2c	 mov	 DWORD PTR t3$2[rsp], eax
  0035e	8b 44 24 30	 mov	 eax, DWORD PTR t2$3[rsp]
  00362	8b 4c 24 38	 mov	 ecx, DWORD PTR t0$5[rsp]
  00366	03 c8		 add	 ecx, eax
  00368	8b c1		 mov	 eax, ecx
  0036a	89 44 24 28	 mov	 DWORD PTR p3$1[rsp], eax
  0036e	8b 44 24 2c	 mov	 eax, DWORD PTR t3$2[rsp]
  00372	8b 4c 24 34	 mov	 ecx, DWORD PTR t1$4[rsp]
  00376	03 c8		 add	 ecx, eax
  00378	8b c1		 mov	 eax, ecx
  0037a	89 44 24 70	 mov	 DWORD PTR p4$16[rsp], eax
  0037e	8b 44 24 2c	 mov	 eax, DWORD PTR t3$2[rsp]
  00382	8b 4c 24 38	 mov	 ecx, DWORD PTR t0$5[rsp]
  00386	03 c8		 add	 ecx, eax
  00388	8b c1		 mov	 eax, ecx
  0038a	89 44 24 64	 mov	 DWORD PTR p1$14[rsp], eax
  0038e	8b 44 24 30	 mov	 eax, DWORD PTR t2$3[rsp]
  00392	8b 4c 24 34	 mov	 ecx, DWORD PTR t1$4[rsp]
  00396	03 c8		 add	 ecx, eax
  00398	8b c1		 mov	 eax, ecx
  0039a	89 44 24 50	 mov	 DWORD PTR p2$11[rsp], eax
  0039e	8b 44 24 70	 mov	 eax, DWORD PTR p4$16[rsp]
  003a2	8b 4c 24 28	 mov	 ecx, DWORD PTR p3$1[rsp]
  003a6	03 c8		 add	 ecx, eax
  003a8	8b c1		 mov	 eax, ecx
  003aa	69 c0 d0 12 00
	00		 imul	 eax, eax, 4816		; 000012d0H
  003b0	89 84 24 a0 00
	00 00		 mov	 DWORD PTR p5$26[rsp], eax
  003b7	69 44 24 38 c7
	04 00 00	 imul	 eax, DWORD PTR t0$5[rsp], 1223 ; 000004c7H
  003bf	89 44 24 38	 mov	 DWORD PTR t0$5[rsp], eax
  003c3	69 44 24 34 da
	20 00 00	 imul	 eax, DWORD PTR t1$4[rsp], 8410 ; 000020daH
  003cb	89 44 24 34	 mov	 DWORD PTR t1$4[rsp], eax
  003cf	69 44 24 30 2a
	31 00 00	 imul	 eax, DWORD PTR t2$3[rsp], 12586 ; 0000312aH
  003d7	89 44 24 30	 mov	 DWORD PTR t2$3[rsp], eax
  003db	69 44 24 2c 05
	18 00 00	 imul	 eax, DWORD PTR t3$2[rsp], 6149 ; 00001805H
  003e3	89 44 24 2c	 mov	 DWORD PTR t3$2[rsp], eax
  003e7	69 44 24 64 9b
	f1 ff ff	 imul	 eax, DWORD PTR p1$14[rsp], -3685 ; fffffffffffff19bH
  003ef	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR p5$26[rsp]
  003f6	03 c8		 add	 ecx, eax
  003f8	8b c1		 mov	 eax, ecx
  003fa	89 44 24 64	 mov	 DWORD PTR p1$14[rsp], eax
  003fe	69 44 24 50 ff
	d6 ff ff	 imul	 eax, DWORD PTR p2$11[rsp], -10497 ; ffffffffffffd6ffH
  00406	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR p5$26[rsp]
  0040d	03 c8		 add	 ecx, eax
  0040f	8b c1		 mov	 eax, ecx
  00411	89 44 24 50	 mov	 DWORD PTR p2$11[rsp], eax
  00415	69 44 24 28 9e
	e0 ff ff	 imul	 eax, DWORD PTR p3$1[rsp], -8034 ; ffffffffffffe09eH
  0041d	89 44 24 28	 mov	 DWORD PTR p3$1[rsp], eax
  00421	69 44 24 70 c3
	f9 ff ff	 imul	 eax, DWORD PTR p4$16[rsp], -1597 ; fffffffffffff9c3H
  00429	89 44 24 70	 mov	 DWORD PTR p4$16[rsp], eax
  0042d	8b 44 24 70	 mov	 eax, DWORD PTR p4$16[rsp]
  00431	8b 4c 24 64	 mov	 ecx, DWORD PTR p1$14[rsp]
  00435	03 c8		 add	 ecx, eax
  00437	8b c1		 mov	 eax, ecx
  00439	8b 4c 24 2c	 mov	 ecx, DWORD PTR t3$2[rsp]
  0043d	03 c8		 add	 ecx, eax
  0043f	8b c1		 mov	 eax, ecx
  00441	89 44 24 2c	 mov	 DWORD PTR t3$2[rsp], eax
  00445	8b 44 24 28	 mov	 eax, DWORD PTR p3$1[rsp]
  00449	8b 4c 24 50	 mov	 ecx, DWORD PTR p2$11[rsp]
  0044d	03 c8		 add	 ecx, eax
  0044f	8b c1		 mov	 eax, ecx
  00451	8b 4c 24 30	 mov	 ecx, DWORD PTR t2$3[rsp]
  00455	03 c8		 add	 ecx, eax
  00457	8b c1		 mov	 eax, ecx
  00459	89 44 24 30	 mov	 DWORD PTR t2$3[rsp], eax
  0045d	8b 44 24 70	 mov	 eax, DWORD PTR p4$16[rsp]
  00461	8b 4c 24 50	 mov	 ecx, DWORD PTR p2$11[rsp]
  00465	03 c8		 add	 ecx, eax
  00467	8b c1		 mov	 eax, ecx
  00469	8b 4c 24 34	 mov	 ecx, DWORD PTR t1$4[rsp]
  0046d	03 c8		 add	 ecx, eax
  0046f	8b c1		 mov	 eax, ecx
  00471	89 44 24 34	 mov	 DWORD PTR t1$4[rsp], eax
  00475	8b 44 24 28	 mov	 eax, DWORD PTR p3$1[rsp]
  00479	8b 4c 24 64	 mov	 ecx, DWORD PTR p1$14[rsp]
  0047d	03 c8		 add	 ecx, eax
  0047f	8b c1		 mov	 eax, ecx
  00481	8b 4c 24 38	 mov	 ecx, DWORD PTR t0$5[rsp]
  00485	03 c8		 add	 ecx, eax
  00487	8b c1		 mov	 eax, ecx
  00489	89 44 24 38	 mov	 DWORD PTR t0$5[rsp], eax

; 2485 :                 // constants scaled things up by 1<<12; let's bring them back
; 2486 :                 // down, but keep 2 extra bits of precision
; 2487 :                 x0 += 512; x1 += 512; x2 += 512; x3 += 512;

  0048d	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR x0$18[rsp]
  00494	05 00 02 00 00	 add	 eax, 512		; 00000200H
  00499	89 84 24 80 00
	00 00		 mov	 DWORD PTR x0$18[rsp], eax
  004a0	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR x1$19[rsp]
  004a7	05 00 02 00 00	 add	 eax, 512		; 00000200H
  004ac	89 84 24 84 00
	00 00		 mov	 DWORD PTR x1$19[rsp], eax
  004b3	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x2$20[rsp]
  004ba	05 00 02 00 00	 add	 eax, 512		; 00000200H
  004bf	89 84 24 88 00
	00 00		 mov	 DWORD PTR x2$20[rsp], eax
  004c6	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR x3$21[rsp]
  004cd	05 00 02 00 00	 add	 eax, 512		; 00000200H
  004d2	89 84 24 8c 00
	00 00		 mov	 DWORD PTR x3$21[rsp], eax

; 2488 :             v[ 0] = (x0+t3) >> 10;

  004d9	8b 44 24 2c	 mov	 eax, DWORD PTR t3$2[rsp]
  004dd	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR x0$18[rsp]
  004e4	03 c8		 add	 ecx, eax
  004e6	8b c1		 mov	 eax, ecx
  004e8	c1 f8 0a	 sar	 eax, 10
  004eb	b9 04 00 00 00	 mov	 ecx, 4
  004f0	48 6b c9 00	 imul	 rcx, rcx, 0
  004f4	48 8b 54 24 20	 mov	 rdx, QWORD PTR v$[rsp]
  004f9	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 2489 :             v[56] = (x0-t3) >> 10;

  004fc	8b 44 24 2c	 mov	 eax, DWORD PTR t3$2[rsp]
  00500	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR x0$18[rsp]
  00507	2b c8		 sub	 ecx, eax
  00509	8b c1		 mov	 eax, ecx
  0050b	c1 f8 0a	 sar	 eax, 10
  0050e	b9 04 00 00 00	 mov	 ecx, 4
  00513	48 6b c9 38	 imul	 rcx, rcx, 56		; 00000038H
  00517	48 8b 54 24 20	 mov	 rdx, QWORD PTR v$[rsp]
  0051c	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 2490 :             v[ 8] = (x1+t2) >> 10;

  0051f	8b 44 24 30	 mov	 eax, DWORD PTR t2$3[rsp]
  00523	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR x1$19[rsp]
  0052a	03 c8		 add	 ecx, eax
  0052c	8b c1		 mov	 eax, ecx
  0052e	c1 f8 0a	 sar	 eax, 10
  00531	b9 04 00 00 00	 mov	 ecx, 4
  00536	48 6b c9 08	 imul	 rcx, rcx, 8
  0053a	48 8b 54 24 20	 mov	 rdx, QWORD PTR v$[rsp]
  0053f	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 2491 :             v[48] = (x1-t2) >> 10;

  00542	8b 44 24 30	 mov	 eax, DWORD PTR t2$3[rsp]
  00546	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR x1$19[rsp]
  0054d	2b c8		 sub	 ecx, eax
  0054f	8b c1		 mov	 eax, ecx
  00551	c1 f8 0a	 sar	 eax, 10
  00554	b9 04 00 00 00	 mov	 ecx, 4
  00559	48 6b c9 30	 imul	 rcx, rcx, 48		; 00000030H
  0055d	48 8b 54 24 20	 mov	 rdx, QWORD PTR v$[rsp]
  00562	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 2492 :             v[16] = (x2+t1) >> 10;

  00565	8b 44 24 34	 mov	 eax, DWORD PTR t1$4[rsp]
  00569	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR x2$20[rsp]
  00570	03 c8		 add	 ecx, eax
  00572	8b c1		 mov	 eax, ecx
  00574	c1 f8 0a	 sar	 eax, 10
  00577	b9 04 00 00 00	 mov	 ecx, 4
  0057c	48 6b c9 10	 imul	 rcx, rcx, 16
  00580	48 8b 54 24 20	 mov	 rdx, QWORD PTR v$[rsp]
  00585	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 2493 :             v[40] = (x2-t1) >> 10;

  00588	8b 44 24 34	 mov	 eax, DWORD PTR t1$4[rsp]
  0058c	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR x2$20[rsp]
  00593	2b c8		 sub	 ecx, eax
  00595	8b c1		 mov	 eax, ecx
  00597	c1 f8 0a	 sar	 eax, 10
  0059a	b9 04 00 00 00	 mov	 ecx, 4
  0059f	48 6b c9 28	 imul	 rcx, rcx, 40		; 00000028H
  005a3	48 8b 54 24 20	 mov	 rdx, QWORD PTR v$[rsp]
  005a8	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 2494 :             v[24] = (x3+t0) >> 10;

  005ab	8b 44 24 38	 mov	 eax, DWORD PTR t0$5[rsp]
  005af	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR x3$21[rsp]
  005b6	03 c8		 add	 ecx, eax
  005b8	8b c1		 mov	 eax, ecx
  005ba	c1 f8 0a	 sar	 eax, 10
  005bd	b9 04 00 00 00	 mov	 ecx, 4
  005c2	48 6b c9 18	 imul	 rcx, rcx, 24
  005c6	48 8b 54 24 20	 mov	 rdx, QWORD PTR v$[rsp]
  005cb	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 2495 :             v[32] = (x3-t0) >> 10;

  005ce	8b 44 24 38	 mov	 eax, DWORD PTR t0$5[rsp]
  005d2	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR x3$21[rsp]
  005d9	2b c8		 sub	 ecx, eax
  005db	8b c1		 mov	 eax, ecx
  005dd	c1 f8 0a	 sar	 eax, 10
  005e0	b9 04 00 00 00	 mov	 ecx, 4
  005e5	48 6b c9 20	 imul	 rcx, rcx, 32		; 00000020H
  005e9	48 8b 54 24 20	 mov	 rdx, QWORD PTR v$[rsp]
  005ee	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax
$LN9@stbi__idct:

; 2496 :         }
; 2497 :     }

  005f1	e9 55 fa ff ff	 jmp	 $LN2@stbi__idct
$LN3@stbi__idct:

; 2498 :     
; 2499 :     for (i=0, v=val, o=out; i < 8; ++i,v+=8,o+=out_stride) {

  005f6	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  005fe	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR val$[rsp]
  00606	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax
  0060b	48 8b 84 24 d0
	01 00 00	 mov	 rax, QWORD PTR out$[rsp]
  00613	48 89 44 24 78	 mov	 QWORD PTR o$[rsp], rax
  00618	eb 30		 jmp	 SHORT $LN7@stbi__idct
$LN5@stbi__idct:
  0061a	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  0061e	ff c0		 inc	 eax
  00620	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
  00624	48 8b 44 24 20	 mov	 rax, QWORD PTR v$[rsp]
  00629	48 83 c0 20	 add	 rax, 32			; 00000020H
  0062d	48 89 44 24 20	 mov	 QWORD PTR v$[rsp], rax
  00632	48 63 84 24 d8
	01 00 00	 movsxd	 rax, DWORD PTR out_stride$[rsp]
  0063a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR o$[rsp]
  0063f	48 03 c8	 add	 rcx, rax
  00642	48 8b c1	 mov	 rax, rcx
  00645	48 89 44 24 78	 mov	 QWORD PTR o$[rsp], rax
$LN7@stbi__idct:
  0064a	83 7c 24 68 08	 cmp	 DWORD PTR i$[rsp], 8
  0064f	0f 8d 2e 04 00
	00		 jge	 $LN6@stbi__idct

; 2500 :         // no fast case since the first 1D IDCT spread components out
; 2501 :         STBI__IDCT_1D(v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7])

  00655	b8 04 00 00 00	 mov	 eax, 4
  0065a	48 6b c0 02	 imul	 rax, rax, 2
  0065e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00663	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00666	89 44 24 54	 mov	 DWORD PTR p2$12[rsp], eax
  0066a	b8 04 00 00 00	 mov	 eax, 4
  0066f	48 6b c0 06	 imul	 rax, rax, 6
  00673	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00678	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  0067b	89 44 24 3c	 mov	 DWORD PTR p3$6[rsp], eax
  0067f	8b 44 24 3c	 mov	 eax, DWORD PTR p3$6[rsp]
  00683	8b 4c 24 54	 mov	 ecx, DWORD PTR p2$12[rsp]
  00687	03 c8		 add	 ecx, eax
  00689	8b c1		 mov	 eax, ecx
  0068b	69 c0 a9 08 00
	00		 imul	 eax, eax, 2217		; 000008a9H
  00691	89 44 24 6c	 mov	 DWORD PTR p1$15[rsp], eax
  00695	69 44 24 3c 71
	e2 ff ff	 imul	 eax, DWORD PTR p3$6[rsp], -7567 ; ffffffffffffe271H
  0069d	8b 4c 24 6c	 mov	 ecx, DWORD PTR p1$15[rsp]
  006a1	03 c8		 add	 ecx, eax
  006a3	8b c1		 mov	 eax, ecx
  006a5	89 44 24 44	 mov	 DWORD PTR t2$8[rsp], eax
  006a9	69 44 24 54 3f
	0c 00 00	 imul	 eax, DWORD PTR p2$12[rsp], 3135 ; 00000c3fH
  006b1	8b 4c 24 6c	 mov	 ecx, DWORD PTR p1$15[rsp]
  006b5	03 c8		 add	 ecx, eax
  006b7	8b c1		 mov	 eax, ecx
  006b9	89 44 24 40	 mov	 DWORD PTR t3$7[rsp], eax
  006bd	b8 04 00 00 00	 mov	 eax, 4
  006c2	48 6b c0 00	 imul	 rax, rax, 0
  006c6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  006cb	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  006ce	89 44 24 54	 mov	 DWORD PTR p2$12[rsp], eax
  006d2	b8 04 00 00 00	 mov	 eax, 4
  006d7	48 6b c0 04	 imul	 rax, rax, 4
  006db	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  006e0	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  006e3	89 44 24 3c	 mov	 DWORD PTR p3$6[rsp], eax
  006e7	8b 44 24 3c	 mov	 eax, DWORD PTR p3$6[rsp]
  006eb	8b 4c 24 54	 mov	 ecx, DWORD PTR p2$12[rsp]
  006ef	03 c8		 add	 ecx, eax
  006f1	8b c1		 mov	 eax, ecx
  006f3	69 c0 00 10 00
	00		 imul	 eax, eax, 4096		; 00001000H
  006f9	89 44 24 4c	 mov	 DWORD PTR t0$10[rsp], eax
  006fd	8b 44 24 3c	 mov	 eax, DWORD PTR p3$6[rsp]
  00701	8b 4c 24 54	 mov	 ecx, DWORD PTR p2$12[rsp]
  00705	2b c8		 sub	 ecx, eax
  00707	8b c1		 mov	 eax, ecx
  00709	69 c0 00 10 00
	00		 imul	 eax, eax, 4096		; 00001000H
  0070f	89 44 24 48	 mov	 DWORD PTR t1$9[rsp], eax
  00713	8b 44 24 40	 mov	 eax, DWORD PTR t3$7[rsp]
  00717	8b 4c 24 4c	 mov	 ecx, DWORD PTR t0$10[rsp]
  0071b	03 c8		 add	 ecx, eax
  0071d	8b c1		 mov	 eax, ecx
  0071f	89 84 24 90 00
	00 00		 mov	 DWORD PTR x0$22[rsp], eax
  00726	8b 44 24 40	 mov	 eax, DWORD PTR t3$7[rsp]
  0072a	8b 4c 24 4c	 mov	 ecx, DWORD PTR t0$10[rsp]
  0072e	2b c8		 sub	 ecx, eax
  00730	8b c1		 mov	 eax, ecx
  00732	89 84 24 9c 00
	00 00		 mov	 DWORD PTR x3$25[rsp], eax
  00739	8b 44 24 44	 mov	 eax, DWORD PTR t2$8[rsp]
  0073d	8b 4c 24 48	 mov	 ecx, DWORD PTR t1$9[rsp]
  00741	03 c8		 add	 ecx, eax
  00743	8b c1		 mov	 eax, ecx
  00745	89 84 24 94 00
	00 00		 mov	 DWORD PTR x1$23[rsp], eax
  0074c	8b 44 24 44	 mov	 eax, DWORD PTR t2$8[rsp]
  00750	8b 4c 24 48	 mov	 ecx, DWORD PTR t1$9[rsp]
  00754	2b c8		 sub	 ecx, eax
  00756	8b c1		 mov	 eax, ecx
  00758	89 84 24 98 00
	00 00		 mov	 DWORD PTR x2$24[rsp], eax
  0075f	b8 04 00 00 00	 mov	 eax, 4
  00764	48 6b c0 07	 imul	 rax, rax, 7
  00768	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  0076d	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00770	89 44 24 4c	 mov	 DWORD PTR t0$10[rsp], eax
  00774	b8 04 00 00 00	 mov	 eax, 4
  00779	48 6b c0 05	 imul	 rax, rax, 5
  0077d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00782	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  00785	89 44 24 48	 mov	 DWORD PTR t1$9[rsp], eax
  00789	b8 04 00 00 00	 mov	 eax, 4
  0078e	48 6b c0 03	 imul	 rax, rax, 3
  00792	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  00797	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  0079a	89 44 24 44	 mov	 DWORD PTR t2$8[rsp], eax
  0079e	b8 04 00 00 00	 mov	 eax, 4
  007a3	48 6b c0 01	 imul	 rax, rax, 1
  007a7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR v$[rsp]
  007ac	8b 04 01	 mov	 eax, DWORD PTR [rcx+rax]
  007af	89 44 24 40	 mov	 DWORD PTR t3$7[rsp], eax
  007b3	8b 44 24 44	 mov	 eax, DWORD PTR t2$8[rsp]
  007b7	8b 4c 24 4c	 mov	 ecx, DWORD PTR t0$10[rsp]
  007bb	03 c8		 add	 ecx, eax
  007bd	8b c1		 mov	 eax, ecx
  007bf	89 44 24 3c	 mov	 DWORD PTR p3$6[rsp], eax
  007c3	8b 44 24 40	 mov	 eax, DWORD PTR t3$7[rsp]
  007c7	8b 4c 24 48	 mov	 ecx, DWORD PTR t1$9[rsp]
  007cb	03 c8		 add	 ecx, eax
  007cd	8b c1		 mov	 eax, ecx
  007cf	89 44 24 74	 mov	 DWORD PTR p4$17[rsp], eax
  007d3	8b 44 24 40	 mov	 eax, DWORD PTR t3$7[rsp]
  007d7	8b 4c 24 4c	 mov	 ecx, DWORD PTR t0$10[rsp]
  007db	03 c8		 add	 ecx, eax
  007dd	8b c1		 mov	 eax, ecx
  007df	89 44 24 6c	 mov	 DWORD PTR p1$15[rsp], eax
  007e3	8b 44 24 44	 mov	 eax, DWORD PTR t2$8[rsp]
  007e7	8b 4c 24 48	 mov	 ecx, DWORD PTR t1$9[rsp]
  007eb	03 c8		 add	 ecx, eax
  007ed	8b c1		 mov	 eax, ecx
  007ef	89 44 24 54	 mov	 DWORD PTR p2$12[rsp], eax
  007f3	8b 44 24 74	 mov	 eax, DWORD PTR p4$17[rsp]
  007f7	8b 4c 24 3c	 mov	 ecx, DWORD PTR p3$6[rsp]
  007fb	03 c8		 add	 ecx, eax
  007fd	8b c1		 mov	 eax, ecx
  007ff	69 c0 d0 12 00
	00		 imul	 eax, eax, 4816		; 000012d0H
  00805	89 84 24 a4 00
	00 00		 mov	 DWORD PTR p5$27[rsp], eax
  0080c	69 44 24 4c c7
	04 00 00	 imul	 eax, DWORD PTR t0$10[rsp], 1223 ; 000004c7H
  00814	89 44 24 4c	 mov	 DWORD PTR t0$10[rsp], eax
  00818	69 44 24 48 da
	20 00 00	 imul	 eax, DWORD PTR t1$9[rsp], 8410 ; 000020daH
  00820	89 44 24 48	 mov	 DWORD PTR t1$9[rsp], eax
  00824	69 44 24 44 2a
	31 00 00	 imul	 eax, DWORD PTR t2$8[rsp], 12586 ; 0000312aH
  0082c	89 44 24 44	 mov	 DWORD PTR t2$8[rsp], eax
  00830	69 44 24 40 05
	18 00 00	 imul	 eax, DWORD PTR t3$7[rsp], 6149 ; 00001805H
  00838	89 44 24 40	 mov	 DWORD PTR t3$7[rsp], eax
  0083c	69 44 24 6c 9b
	f1 ff ff	 imul	 eax, DWORD PTR p1$15[rsp], -3685 ; fffffffffffff19bH
  00844	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR p5$27[rsp]
  0084b	03 c8		 add	 ecx, eax
  0084d	8b c1		 mov	 eax, ecx
  0084f	89 44 24 6c	 mov	 DWORD PTR p1$15[rsp], eax
  00853	69 44 24 54 ff
	d6 ff ff	 imul	 eax, DWORD PTR p2$12[rsp], -10497 ; ffffffffffffd6ffH
  0085b	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR p5$27[rsp]
  00862	03 c8		 add	 ecx, eax
  00864	8b c1		 mov	 eax, ecx
  00866	89 44 24 54	 mov	 DWORD PTR p2$12[rsp], eax
  0086a	69 44 24 3c 9e
	e0 ff ff	 imul	 eax, DWORD PTR p3$6[rsp], -8034 ; ffffffffffffe09eH
  00872	89 44 24 3c	 mov	 DWORD PTR p3$6[rsp], eax
  00876	69 44 24 74 c3
	f9 ff ff	 imul	 eax, DWORD PTR p4$17[rsp], -1597 ; fffffffffffff9c3H
  0087e	89 44 24 74	 mov	 DWORD PTR p4$17[rsp], eax
  00882	8b 44 24 74	 mov	 eax, DWORD PTR p4$17[rsp]
  00886	8b 4c 24 6c	 mov	 ecx, DWORD PTR p1$15[rsp]
  0088a	03 c8		 add	 ecx, eax
  0088c	8b c1		 mov	 eax, ecx
  0088e	8b 4c 24 40	 mov	 ecx, DWORD PTR t3$7[rsp]
  00892	03 c8		 add	 ecx, eax
  00894	8b c1		 mov	 eax, ecx
  00896	89 44 24 40	 mov	 DWORD PTR t3$7[rsp], eax
  0089a	8b 44 24 3c	 mov	 eax, DWORD PTR p3$6[rsp]
  0089e	8b 4c 24 54	 mov	 ecx, DWORD PTR p2$12[rsp]
  008a2	03 c8		 add	 ecx, eax
  008a4	8b c1		 mov	 eax, ecx
  008a6	8b 4c 24 44	 mov	 ecx, DWORD PTR t2$8[rsp]
  008aa	03 c8		 add	 ecx, eax
  008ac	8b c1		 mov	 eax, ecx
  008ae	89 44 24 44	 mov	 DWORD PTR t2$8[rsp], eax
  008b2	8b 44 24 74	 mov	 eax, DWORD PTR p4$17[rsp]
  008b6	8b 4c 24 54	 mov	 ecx, DWORD PTR p2$12[rsp]
  008ba	03 c8		 add	 ecx, eax
  008bc	8b c1		 mov	 eax, ecx
  008be	8b 4c 24 48	 mov	 ecx, DWORD PTR t1$9[rsp]
  008c2	03 c8		 add	 ecx, eax
  008c4	8b c1		 mov	 eax, ecx
  008c6	89 44 24 48	 mov	 DWORD PTR t1$9[rsp], eax
  008ca	8b 44 24 3c	 mov	 eax, DWORD PTR p3$6[rsp]
  008ce	8b 4c 24 6c	 mov	 ecx, DWORD PTR p1$15[rsp]
  008d2	03 c8		 add	 ecx, eax
  008d4	8b c1		 mov	 eax, ecx
  008d6	8b 4c 24 4c	 mov	 ecx, DWORD PTR t0$10[rsp]
  008da	03 c8		 add	 ecx, eax
  008dc	8b c1		 mov	 eax, ecx
  008de	89 44 24 4c	 mov	 DWORD PTR t0$10[rsp], eax

; 2502 :             // constants scaled things up by 1<<12, plus we had 1<<2 from first
; 2503 :             // loop, plus horizontal and vertical each scale by sqrt(8) so together
; 2504 :             // we've got an extra 1<<3, so 1<<17 total we need to remove.
; 2505 :             // so we want to round that, which means adding 0.5 * 1<<17,
; 2506 :             // aka 65536. Also, we'll end up with -128 to 127 that we want
; 2507 :             // to encode as 0..255 by adding 128, so we'll add that before the shift
; 2508 :             x0 += 65536 + (128<<17);

  008e2	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR x0$22[rsp]
  008e9	05 00 00 01 01	 add	 eax, 16842752		; 01010000H
  008ee	89 84 24 90 00
	00 00		 mov	 DWORD PTR x0$22[rsp], eax

; 2509 :         x1 += 65536 + (128<<17);

  008f5	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR x1$23[rsp]
  008fc	05 00 00 01 01	 add	 eax, 16842752		; 01010000H
  00901	89 84 24 94 00
	00 00		 mov	 DWORD PTR x1$23[rsp], eax

; 2510 :         x2 += 65536 + (128<<17);

  00908	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR x2$24[rsp]
  0090f	05 00 00 01 01	 add	 eax, 16842752		; 01010000H
  00914	89 84 24 98 00
	00 00		 mov	 DWORD PTR x2$24[rsp], eax

; 2511 :         x3 += 65536 + (128<<17);

  0091b	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR x3$25[rsp]
  00922	05 00 00 01 01	 add	 eax, 16842752		; 01010000H
  00927	89 84 24 9c 00
	00 00		 mov	 DWORD PTR x3$25[rsp], eax

; 2512 :         // tried computing the shifts into temps, or'ing the temps to see
; 2513 :         // if any were out of range, but that was slower
; 2514 :         o[0] = stbi__clamp((x0+t3) >> 17);

  0092e	8b 44 24 40	 mov	 eax, DWORD PTR t3$7[rsp]
  00932	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR x0$22[rsp]
  00939	03 c8		 add	 ecx, eax
  0093b	8b c1		 mov	 eax, ecx
  0093d	c1 f8 11	 sar	 eax, 17
  00940	8b c8		 mov	 ecx, eax
  00942	e8 00 00 00 00	 call	 ?stbi__clamp@@YAEH@Z	; stbi__clamp
  00947	b9 01 00 00 00	 mov	 ecx, 1
  0094c	48 6b c9 00	 imul	 rcx, rcx, 0
  00950	48 8b 54 24 78	 mov	 rdx, QWORD PTR o$[rsp]
  00955	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2515 :         o[7] = stbi__clamp((x0-t3) >> 17);

  00958	8b 44 24 40	 mov	 eax, DWORD PTR t3$7[rsp]
  0095c	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR x0$22[rsp]
  00963	2b c8		 sub	 ecx, eax
  00965	8b c1		 mov	 eax, ecx
  00967	c1 f8 11	 sar	 eax, 17
  0096a	8b c8		 mov	 ecx, eax
  0096c	e8 00 00 00 00	 call	 ?stbi__clamp@@YAEH@Z	; stbi__clamp
  00971	b9 01 00 00 00	 mov	 ecx, 1
  00976	48 6b c9 07	 imul	 rcx, rcx, 7
  0097a	48 8b 54 24 78	 mov	 rdx, QWORD PTR o$[rsp]
  0097f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2516 :         o[1] = stbi__clamp((x1+t2) >> 17);

  00982	8b 44 24 44	 mov	 eax, DWORD PTR t2$8[rsp]
  00986	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR x1$23[rsp]
  0098d	03 c8		 add	 ecx, eax
  0098f	8b c1		 mov	 eax, ecx
  00991	c1 f8 11	 sar	 eax, 17
  00994	8b c8		 mov	 ecx, eax
  00996	e8 00 00 00 00	 call	 ?stbi__clamp@@YAEH@Z	; stbi__clamp
  0099b	b9 01 00 00 00	 mov	 ecx, 1
  009a0	48 6b c9 01	 imul	 rcx, rcx, 1
  009a4	48 8b 54 24 78	 mov	 rdx, QWORD PTR o$[rsp]
  009a9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2517 :         o[6] = stbi__clamp((x1-t2) >> 17);

  009ac	8b 44 24 44	 mov	 eax, DWORD PTR t2$8[rsp]
  009b0	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR x1$23[rsp]
  009b7	2b c8		 sub	 ecx, eax
  009b9	8b c1		 mov	 eax, ecx
  009bb	c1 f8 11	 sar	 eax, 17
  009be	8b c8		 mov	 ecx, eax
  009c0	e8 00 00 00 00	 call	 ?stbi__clamp@@YAEH@Z	; stbi__clamp
  009c5	b9 01 00 00 00	 mov	 ecx, 1
  009ca	48 6b c9 06	 imul	 rcx, rcx, 6
  009ce	48 8b 54 24 78	 mov	 rdx, QWORD PTR o$[rsp]
  009d3	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2518 :         o[2] = stbi__clamp((x2+t1) >> 17);

  009d6	8b 44 24 48	 mov	 eax, DWORD PTR t1$9[rsp]
  009da	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR x2$24[rsp]
  009e1	03 c8		 add	 ecx, eax
  009e3	8b c1		 mov	 eax, ecx
  009e5	c1 f8 11	 sar	 eax, 17
  009e8	8b c8		 mov	 ecx, eax
  009ea	e8 00 00 00 00	 call	 ?stbi__clamp@@YAEH@Z	; stbi__clamp
  009ef	b9 01 00 00 00	 mov	 ecx, 1
  009f4	48 6b c9 02	 imul	 rcx, rcx, 2
  009f8	48 8b 54 24 78	 mov	 rdx, QWORD PTR o$[rsp]
  009fd	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2519 :         o[5] = stbi__clamp((x2-t1) >> 17);

  00a00	8b 44 24 48	 mov	 eax, DWORD PTR t1$9[rsp]
  00a04	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR x2$24[rsp]
  00a0b	2b c8		 sub	 ecx, eax
  00a0d	8b c1		 mov	 eax, ecx
  00a0f	c1 f8 11	 sar	 eax, 17
  00a12	8b c8		 mov	 ecx, eax
  00a14	e8 00 00 00 00	 call	 ?stbi__clamp@@YAEH@Z	; stbi__clamp
  00a19	b9 01 00 00 00	 mov	 ecx, 1
  00a1e	48 6b c9 05	 imul	 rcx, rcx, 5
  00a22	48 8b 54 24 78	 mov	 rdx, QWORD PTR o$[rsp]
  00a27	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2520 :         o[3] = stbi__clamp((x3+t0) >> 17);

  00a2a	8b 44 24 4c	 mov	 eax, DWORD PTR t0$10[rsp]
  00a2e	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR x3$25[rsp]
  00a35	03 c8		 add	 ecx, eax
  00a37	8b c1		 mov	 eax, ecx
  00a39	c1 f8 11	 sar	 eax, 17
  00a3c	8b c8		 mov	 ecx, eax
  00a3e	e8 00 00 00 00	 call	 ?stbi__clamp@@YAEH@Z	; stbi__clamp
  00a43	b9 01 00 00 00	 mov	 ecx, 1
  00a48	48 6b c9 03	 imul	 rcx, rcx, 3
  00a4c	48 8b 54 24 78	 mov	 rdx, QWORD PTR o$[rsp]
  00a51	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2521 :         o[4] = stbi__clamp((x3-t0) >> 17);

  00a54	8b 44 24 4c	 mov	 eax, DWORD PTR t0$10[rsp]
  00a58	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR x3$25[rsp]
  00a5f	2b c8		 sub	 ecx, eax
  00a61	8b c1		 mov	 eax, ecx
  00a63	c1 f8 11	 sar	 eax, 17
  00a66	8b c8		 mov	 ecx, eax
  00a68	e8 00 00 00 00	 call	 ?stbi__clamp@@YAEH@Z	; stbi__clamp
  00a6d	b9 01 00 00 00	 mov	 ecx, 1
  00a72	48 6b c9 04	 imul	 rcx, rcx, 4
  00a76	48 8b 54 24 78	 mov	 rdx, QWORD PTR o$[rsp]
  00a7b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2522 :     }

  00a7e	e9 97 fb ff ff	 jmp	 $LN5@stbi__idct
$LN6@stbi__idct:

; 2523 : }

  00a83	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00a8b	48 33 cc	 xor	 rcx, rsp
  00a8e	e8 00 00 00 00	 call	 __security_check_cookie
  00a93	48 81 c4 c8 01
	00 00		 add	 rsp, 456		; 000001c8H
  00a9a	c3		 ret	 0
?stbi__idct_block@@YAXPEAEHQEAF@Z ENDP			; stbi__idct_block
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
x$ = 8
?stbi__clamp@@YAEH@Z PROC				; stbi__clamp

; 2416 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 2417 :     // trick to use a single test to catch both cases
; 2418 :     if ((unsigned int) x > 255) {

  00004	81 7c 24 08 ff
	00 00 00	 cmp	 DWORD PTR x$[rsp], 255	; 000000ffH
  0000c	76 19		 jbe	 SHORT $LN2@stbi__clam

; 2419 :         if (x < 0) return 0;

  0000e	83 7c 24 08 00	 cmp	 DWORD PTR x$[rsp], 0
  00013	7d 04		 jge	 SHORT $LN3@stbi__clam
  00015	32 c0		 xor	 al, al
  00017	eb 13		 jmp	 SHORT $LN1@stbi__clam
$LN3@stbi__clam:

; 2420 :         if (x > 255) return 255;

  00019	81 7c 24 08 ff
	00 00 00	 cmp	 DWORD PTR x$[rsp], 255	; 000000ffH
  00021	7e 04		 jle	 SHORT $LN4@stbi__clam
  00023	b0 ff		 mov	 al, 255			; 000000ffH
  00025	eb 05		 jmp	 SHORT $LN1@stbi__clam
$LN4@stbi__clam:
$LN2@stbi__clam:

; 2421 :     }
; 2422 :     return (stbi_uc) x;

  00027	0f b6 44 24 08	 movzx	 eax, BYTE PTR x$[rsp]
$LN1@stbi__clam:

; 2423 : }

  0002c	c3		 ret	 0
?stbi__clamp@@YAEH@Z ENDP				; stbi__clamp
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
k$ = 32
bit$1 = 36
r$2 = 40
r$3 = 44
s$4 = 48
s$5 = 52
p$6 = 56
rs$7 = 64
zig$8 = 68
rs$9 = 72
p$10 = 80
shift$11 = 88
c$12 = 92
tv370 = 96
tv392 = 100
tv419 = 104
tv353 = 112
j$ = 144
data$ = 152
hac$ = 160
fac$ = 168
?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z PROC ; stbi__jpeg_decode_block_prog_ac

; 2295 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 2296 :     int k;
; 2297 :     if (j->spec_start == 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

  0001b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00023	83 b8 34 48 00
	00 00		 cmp	 DWORD PTR [rax+18484], 0
  0002a	75 11		 jne	 SHORT $LN13@stbi__jpeg
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG77603
  00033	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00038	e9 32 06 00 00	 jmp	 $LN1@stbi__jpeg
$LN13@stbi__jpeg:

; 2298 :     
; 2299 :     if (j->succ_high == 0) {

  0003d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00045	83 b8 3c 48 00
	00 00		 cmp	 DWORD PTR [rax+18492], 0
  0004c	0f 85 f3 02 00
	00		 jne	 $LN14@stbi__jpeg

; 2300 :         int shift = j->succ_low;

  00052	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0005a	8b 80 40 48 00
	00		 mov	 eax, DWORD PTR [rax+18496]
  00060	89 44 24 58	 mov	 DWORD PTR shift$11[rsp], eax

; 2301 :         
; 2302 :         if (j->eob_run) {

  00064	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0006c	83 b8 44 48 00
	00 00		 cmp	 DWORD PTR [rax+18500], 0
  00073	74 28		 je	 SHORT $LN16@stbi__jpeg

; 2303 :             --j->eob_run;

  00075	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0007d	8b 80 44 48 00
	00		 mov	 eax, DWORD PTR [rax+18500]
  00083	ff c8		 dec	 eax
  00085	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  0008d	89 81 44 48 00
	00		 mov	 DWORD PTR [rcx+18500], eax

; 2304 :             return 1;

  00093	b8 01 00 00 00	 mov	 eax, 1
  00098	e9 d2 05 00 00	 jmp	 $LN1@stbi__jpeg
$LN16@stbi__jpeg:

; 2305 :         }
; 2306 :         
; 2307 :         k = j->spec_start;

  0009d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  000a5	8b 80 34 48 00
	00		 mov	 eax, DWORD PTR [rax+18484]
  000ab	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
$LN4@stbi__jpeg:

; 2308 :         do {
; 2309 :             unsigned int zig;
; 2310 :             int c,r,s;
; 2311 :             if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

  000af	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  000b7	83 b8 24 48 00
	00 10		 cmp	 DWORD PTR [rax+18468], 16
  000be	7d 0d		 jge	 SHORT $LN17@stbi__jpeg
  000c0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  000c8	e8 00 00 00 00	 call	 ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN17@stbi__jpeg:

; 2312 :             c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);

  000cd	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  000d5	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  000db	c1 e8 17	 shr	 eax, 23
  000de	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  000e3	89 44 24 5c	 mov	 DWORD PTR c$12[rsp], eax

; 2313 :             r = fac[c];

  000e7	48 63 44 24 5c	 movsxd	 rax, DWORD PTR c$12[rsp]
  000ec	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR fac$[rsp]
  000f4	0f bf 04 41	 movsx	 eax, WORD PTR [rcx+rax*2]
  000f8	89 44 24 28	 mov	 DWORD PTR r$2[rsp], eax

; 2314 :             if (r) { // fast-AC path

  000fc	83 7c 24 28 00	 cmp	 DWORD PTR r$2[rsp], 0
  00101	0f 84 e1 00 00
	00		 je	 $LN18@stbi__jpeg

; 2315 :                 k += (r >> 4) & 15; // run

  00107	8b 44 24 28	 mov	 eax, DWORD PTR r$2[rsp]
  0010b	c1 f8 04	 sar	 eax, 4
  0010e	83 e0 0f	 and	 eax, 15
  00111	8b 4c 24 20	 mov	 ecx, DWORD PTR k$[rsp]
  00115	03 c8		 add	 ecx, eax
  00117	8b c1		 mov	 eax, ecx
  00119	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2316 :                 s = r & 15; // combined length

  0011d	8b 44 24 28	 mov	 eax, DWORD PTR r$2[rsp]
  00121	83 e0 0f	 and	 eax, 15
  00124	89 44 24 30	 mov	 DWORD PTR s$4[rsp], eax

; 2317 :                 if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");

  00128	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00130	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00136	39 44 24 30	 cmp	 DWORD PTR s$4[rsp], eax
  0013a	7e 11		 jle	 SHORT $LN20@stbi__jpeg
  0013c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG77611
  00143	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00148	e9 22 05 00 00	 jmp	 $LN1@stbi__jpeg
$LN20@stbi__jpeg:

; 2318 :                 j->code_buffer <<= s;

  0014d	8b 44 24 30	 mov	 eax, DWORD PTR s$4[rsp]
  00151	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00159	48 89 4c 24 70	 mov	 QWORD PTR tv353[rsp], rcx
  0015e	0f b6 c8	 movzx	 ecx, al
  00161	48 8b 44 24 70	 mov	 rax, QWORD PTR tv353[rsp]
  00166	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0016c	d3 e0		 shl	 eax, cl
  0016e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00176	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2319 :                 j->code_bits -= s;

  0017c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00184	8b 4c 24 30	 mov	 ecx, DWORD PTR s$4[rsp]
  00188	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  0018e	2b c1		 sub	 eax, ecx
  00190	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00198	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2320 :                 zig = stbi__jpeg_dezigzag[k++];

  0019e	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  001a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__jpeg_dezigzag@@3QBEB
  001aa	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001ae	89 44 24 44	 mov	 DWORD PTR zig$8[rsp], eax
  001b2	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  001b6	ff c0		 inc	 eax
  001b8	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2321 :                 data[zig] = (short) ((r >> 8) * (1 << shift));

  001bc	8b 44 24 28	 mov	 eax, DWORD PTR r$2[rsp]
  001c0	c1 f8 08	 sar	 eax, 8
  001c3	8b 4c 24 58	 mov	 ecx, DWORD PTR shift$11[rsp]
  001c7	ba 01 00 00 00	 mov	 edx, 1
  001cc	d3 e2		 shl	 edx, cl
  001ce	8b ca		 mov	 ecx, edx
  001d0	0f af c1	 imul	 eax, ecx
  001d3	8b 4c 24 44	 mov	 ecx, DWORD PTR zig$8[rsp]
  001d7	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR data$[rsp]
  001df	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax

; 2322 :             } else {

  001e3	e9 40 01 00 00	 jmp	 $LN19@stbi__jpeg
$LN18@stbi__jpeg:

; 2323 :                 int rs = stbi__jpeg_huff_decode(j, hac);

  001e8	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR hac$[rsp]
  001f0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  001f8	e8 00 00 00 00	 call	 ?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z ; stbi__jpeg_huff_decode
  001fd	89 44 24 40	 mov	 DWORD PTR rs$7[rsp], eax

; 2324 :                 if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");

  00201	83 7c 24 40 00	 cmp	 DWORD PTR rs$7[rsp], 0
  00206	7d 11		 jge	 SHORT $LN21@stbi__jpeg
  00208	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG77613
  0020f	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00214	e9 56 04 00 00	 jmp	 $LN1@stbi__jpeg
$LN21@stbi__jpeg:

; 2325 :                 s = rs & 15;

  00219	8b 44 24 40	 mov	 eax, DWORD PTR rs$7[rsp]
  0021d	83 e0 0f	 and	 eax, 15
  00220	89 44 24 30	 mov	 DWORD PTR s$4[rsp], eax

; 2326 :                 r = rs >> 4;

  00224	8b 44 24 40	 mov	 eax, DWORD PTR rs$7[rsp]
  00228	c1 f8 04	 sar	 eax, 4
  0022b	89 44 24 28	 mov	 DWORD PTR r$2[rsp], eax

; 2327 :                 if (s == 0) {

  0022f	83 7c 24 30 00	 cmp	 DWORD PTR s$4[rsp], 0
  00234	0f 85 8f 00 00
	00		 jne	 $LN22@stbi__jpeg

; 2328 :                     if (r < 15) {

  0023a	83 7c 24 28 0f	 cmp	 DWORD PTR r$2[rsp], 15
  0023f	7d 7b		 jge	 SHORT $LN24@stbi__jpeg

; 2329 :                         j->eob_run = (1 << r);

  00241	8b 44 24 28	 mov	 eax, DWORD PTR r$2[rsp]
  00245	b9 01 00 00 00	 mov	 ecx, 1
  0024a	89 4c 24 60	 mov	 DWORD PTR tv370[rsp], ecx
  0024e	0f b6 c8	 movzx	 ecx, al
  00251	8b 44 24 60	 mov	 eax, DWORD PTR tv370[rsp]
  00255	d3 e0		 shl	 eax, cl
  00257	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  0025f	89 81 44 48 00
	00		 mov	 DWORD PTR [rcx+18500], eax

; 2330 :                         if (r)

  00265	83 7c 24 28 00	 cmp	 DWORD PTR r$2[rsp], 0
  0026a	74 2d		 je	 SHORT $LN25@stbi__jpeg

; 2331 :                             j->eob_run += stbi__jpeg_get_bits(j, r);

  0026c	8b 54 24 28	 mov	 edx, DWORD PTR r$2[rsp]
  00270	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00278	e8 00 00 00 00	 call	 ?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z ; stbi__jpeg_get_bits
  0027d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00285	03 81 44 48 00
	00		 add	 eax, DWORD PTR [rcx+18500]
  0028b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00293	89 81 44 48 00
	00		 mov	 DWORD PTR [rcx+18500], eax
$LN25@stbi__jpeg:

; 2332 :                         --j->eob_run;

  00299	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  002a1	8b 80 44 48 00
	00		 mov	 eax, DWORD PTR [rax+18500]
  002a7	ff c8		 dec	 eax
  002a9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  002b1	89 81 44 48 00
	00		 mov	 DWORD PTR [rcx+18500], eax

; 2333 :                         break;

  002b7	e9 84 00 00 00	 jmp	 $LN3@stbi__jpeg
$LN24@stbi__jpeg:

; 2334 :                     }
; 2335 :                     k += 16;

  002bc	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  002c0	83 c0 10	 add	 eax, 16
  002c3	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2336 :                 } else {

  002c7	eb 5f		 jmp	 SHORT $LN23@stbi__jpeg
$LN22@stbi__jpeg:

; 2337 :                     k += r;

  002c9	8b 44 24 28	 mov	 eax, DWORD PTR r$2[rsp]
  002cd	8b 4c 24 20	 mov	 ecx, DWORD PTR k$[rsp]
  002d1	03 c8		 add	 ecx, eax
  002d3	8b c1		 mov	 eax, ecx
  002d5	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2338 :                     zig = stbi__jpeg_dezigzag[k++];

  002d9	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  002de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__jpeg_dezigzag@@3QBEB
  002e5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002e9	89 44 24 44	 mov	 DWORD PTR zig$8[rsp], eax
  002ed	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  002f1	ff c0		 inc	 eax
  002f3	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2339 :                     data[zig] = (short) (stbi__extend_receive(j,s) * (1 << shift));

  002f7	8b 54 24 30	 mov	 edx, DWORD PTR s$4[rsp]
  002fb	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00303	e8 00 00 00 00	 call	 ?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z ; stbi__extend_receive
  00308	8b 4c 24 58	 mov	 ecx, DWORD PTR shift$11[rsp]
  0030c	ba 01 00 00 00	 mov	 edx, 1
  00311	d3 e2		 shl	 edx, cl
  00313	8b ca		 mov	 ecx, edx
  00315	0f af c1	 imul	 eax, ecx
  00318	8b 4c 24 44	 mov	 ecx, DWORD PTR zig$8[rsp]
  0031c	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR data$[rsp]
  00324	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax
$LN23@stbi__jpeg:
$LN19@stbi__jpeg:

; 2340 :                 }
; 2341 :             }
; 2342 :         } while (k <= j->spec_end);

  00328	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00330	8b 80 38 48 00
	00		 mov	 eax, DWORD PTR [rax+18488]
  00336	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  0033a	0f 8e 6f fd ff
	ff		 jle	 $LN4@stbi__jpeg
$LN3@stbi__jpeg:

; 2343 :     } else {

  00340	e9 25 03 00 00	 jmp	 $LN15@stbi__jpeg
$LN14@stbi__jpeg:

; 2344 :         // refinement scan for these AC coefficients
; 2345 :         
; 2346 :         short bit = (short) (1 << j->succ_low);

  00345	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0034d	8b 80 40 48 00
	00		 mov	 eax, DWORD PTR [rax+18496]
  00353	b9 01 00 00 00	 mov	 ecx, 1
  00358	89 4c 24 64	 mov	 DWORD PTR tv392[rsp], ecx
  0035c	0f b6 c8	 movzx	 ecx, al
  0035f	8b 44 24 64	 mov	 eax, DWORD PTR tv392[rsp]
  00363	d3 e0		 shl	 eax, cl
  00365	66 89 44 24 24	 mov	 WORD PTR bit$1[rsp], ax

; 2347 :         
; 2348 :         if (j->eob_run) {

  0036a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00372	83 b8 44 48 00
	00 00		 cmp	 DWORD PTR [rax+18500], 0
  00379	0f 84 ef 00 00
	00		 je	 $LN26@stbi__jpeg

; 2349 :             --j->eob_run;

  0037f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00387	8b 80 44 48 00
	00		 mov	 eax, DWORD PTR [rax+18500]
  0038d	ff c8		 dec	 eax
  0038f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00397	89 81 44 48 00
	00		 mov	 DWORD PTR [rcx+18500], eax

; 2350 :             for (k = j->spec_start; k <= j->spec_end; ++k) {

  0039d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  003a5	8b 80 34 48 00
	00		 mov	 eax, DWORD PTR [rax+18484]
  003ab	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
  003af	eb 0a		 jmp	 SHORT $LN7@stbi__jpeg
$LN5@stbi__jpeg:
  003b1	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  003b5	ff c0		 inc	 eax
  003b7	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
$LN7@stbi__jpeg:
  003bb	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  003c3	8b 80 38 48 00
	00		 mov	 eax, DWORD PTR [rax+18488]
  003c9	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  003cd	0f 8f 96 00 00
	00		 jg	 $LN6@stbi__jpeg

; 2351 :                 short *p = &data[stbi__jpeg_dezigzag[k]];

  003d3	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  003d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__jpeg_dezigzag@@3QBEB
  003df	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003e3	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  003eb	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  003ef	48 89 44 24 50	 mov	 QWORD PTR p$10[rsp], rax

; 2352 :                 if (*p != 0)

  003f4	48 8b 44 24 50	 mov	 rax, QWORD PTR p$10[rsp]
  003f9	0f bf 00	 movsx	 eax, WORD PTR [rax]
  003fc	85 c0		 test	 eax, eax
  003fe	74 64		 je	 SHORT $LN28@stbi__jpeg

; 2353 :                     if (stbi__jpeg_get_bit(j))

  00400	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00408	e8 00 00 00 00	 call	 ?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z ; stbi__jpeg_get_bit
  0040d	85 c0		 test	 eax, eax
  0040f	74 53		 je	 SHORT $LN29@stbi__jpeg

; 2354 :                     if ((*p & bit)==0) {

  00411	48 8b 44 24 50	 mov	 rax, QWORD PTR p$10[rsp]
  00416	0f bf 00	 movsx	 eax, WORD PTR [rax]
  00419	0f bf 4c 24 24	 movsx	 ecx, WORD PTR bit$1[rsp]
  0041e	23 c1		 and	 eax, ecx
  00420	85 c0		 test	 eax, eax
  00422	75 40		 jne	 SHORT $LN30@stbi__jpeg

; 2355 :                     if (*p > 0)

  00424	48 8b 44 24 50	 mov	 rax, QWORD PTR p$10[rsp]
  00429	0f bf 00	 movsx	 eax, WORD PTR [rax]
  0042c	85 c0		 test	 eax, eax
  0042e	7e 1b		 jle	 SHORT $LN31@stbi__jpeg

; 2356 :                         *p += bit;

  00430	0f bf 44 24 24	 movsx	 eax, WORD PTR bit$1[rsp]
  00435	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$10[rsp]
  0043a	0f bf 09	 movsx	 ecx, WORD PTR [rcx]
  0043d	03 c8		 add	 ecx, eax
  0043f	8b c1		 mov	 eax, ecx
  00441	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$10[rsp]
  00446	66 89 01	 mov	 WORD PTR [rcx], ax
  00449	eb 19		 jmp	 SHORT $LN32@stbi__jpeg
$LN31@stbi__jpeg:

; 2357 :                     else
; 2358 :                         *p -= bit;

  0044b	0f bf 44 24 24	 movsx	 eax, WORD PTR bit$1[rsp]
  00450	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$10[rsp]
  00455	0f bf 09	 movsx	 ecx, WORD PTR [rcx]
  00458	2b c8		 sub	 ecx, eax
  0045a	8b c1		 mov	 eax, ecx
  0045c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$10[rsp]
  00461	66 89 01	 mov	 WORD PTR [rcx], ax
$LN32@stbi__jpeg:
$LN30@stbi__jpeg:
$LN29@stbi__jpeg:
$LN28@stbi__jpeg:

; 2359 :                 }
; 2360 :             }

  00464	e9 48 ff ff ff	 jmp	 $LN5@stbi__jpeg
$LN6@stbi__jpeg:

; 2361 :         } else {

  00469	e9 fc 01 00 00	 jmp	 $LN27@stbi__jpeg
$LN26@stbi__jpeg:

; 2362 :             k = j->spec_start;

  0046e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00476	8b 80 34 48 00
	00		 mov	 eax, DWORD PTR [rax+18484]
  0047c	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
$LN10@stbi__jpeg:

; 2363 :             do {
; 2364 :                 int r,s;
; 2365 :                 int rs = stbi__jpeg_huff_decode(j, hac); // @OPTIMIZE see if we can use the fast path here, advance-by-r is so slow, eh

  00480	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR hac$[rsp]
  00488	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00490	e8 00 00 00 00	 call	 ?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z ; stbi__jpeg_huff_decode
  00495	89 44 24 48	 mov	 DWORD PTR rs$9[rsp], eax

; 2366 :                 if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");

  00499	83 7c 24 48 00	 cmp	 DWORD PTR rs$9[rsp], 0
  0049e	7d 11		 jge	 SHORT $LN33@stbi__jpeg
  004a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG77626
  004a7	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  004ac	e9 be 01 00 00	 jmp	 $LN1@stbi__jpeg
$LN33@stbi__jpeg:

; 2367 :                 s = rs & 15;

  004b1	8b 44 24 48	 mov	 eax, DWORD PTR rs$9[rsp]
  004b5	83 e0 0f	 and	 eax, 15
  004b8	89 44 24 34	 mov	 DWORD PTR s$5[rsp], eax

; 2368 :                 r = rs >> 4;

  004bc	8b 44 24 48	 mov	 eax, DWORD PTR rs$9[rsp]
  004c0	c1 f8 04	 sar	 eax, 4
  004c3	89 44 24 2c	 mov	 DWORD PTR r$3[rsp], eax

; 2369 :                 if (s == 0) {

  004c7	83 7c 24 34 00	 cmp	 DWORD PTR s$5[rsp], 0
  004cc	75 6b		 jne	 SHORT $LN34@stbi__jpeg

; 2370 :                     if (r < 15) {

  004ce	83 7c 24 2c 0f	 cmp	 DWORD PTR r$3[rsp], 15
  004d3	7d 62		 jge	 SHORT $LN36@stbi__jpeg

; 2371 :                         j->eob_run = (1 << r) - 1;

  004d5	8b 44 24 2c	 mov	 eax, DWORD PTR r$3[rsp]
  004d9	b9 01 00 00 00	 mov	 ecx, 1
  004de	89 4c 24 68	 mov	 DWORD PTR tv419[rsp], ecx
  004e2	0f b6 c8	 movzx	 ecx, al
  004e5	8b 44 24 68	 mov	 eax, DWORD PTR tv419[rsp]
  004e9	d3 e0		 shl	 eax, cl
  004eb	ff c8		 dec	 eax
  004ed	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  004f5	89 81 44 48 00
	00		 mov	 DWORD PTR [rcx+18500], eax

; 2372 :                         if (r)

  004fb	83 7c 24 2c 00	 cmp	 DWORD PTR r$3[rsp], 0
  00500	74 2d		 je	 SHORT $LN38@stbi__jpeg

; 2373 :                             j->eob_run += stbi__jpeg_get_bits(j, r);

  00502	8b 54 24 2c	 mov	 edx, DWORD PTR r$3[rsp]
  00506	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  0050e	e8 00 00 00 00	 call	 ?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z ; stbi__jpeg_get_bits
  00513	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  0051b	03 81 44 48 00
	00		 add	 eax, DWORD PTR [rcx+18500]
  00521	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00529	89 81 44 48 00
	00		 mov	 DWORD PTR [rcx+18500], eax
$LN38@stbi__jpeg:

; 2374 :                         r = 64; // force end of block

  0052f	c7 44 24 2c 40
	00 00 00	 mov	 DWORD PTR r$3[rsp], 64	; 00000040H
$LN36@stbi__jpeg:

; 2375 :                     } else {
; 2376 :                         // r=15 s=0 should write 16 0s, so we just do
; 2377 :                         // a run of 15 0s and then write s (which is 0),
; 2378 :                         // so we don't have to do anything special here
; 2379 :                     }
; 2380 :                 } else {

  00537	eb 3f		 jmp	 SHORT $LN35@stbi__jpeg
$LN34@stbi__jpeg:

; 2381 :                     if (s != 1) return stbi__err("bad huffman code", "Corrupt JPEG");

  00539	83 7c 24 34 01	 cmp	 DWORD PTR s$5[rsp], 1
  0053e	74 11		 je	 SHORT $LN39@stbi__jpeg
  00540	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG77633
  00547	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0054c	e9 1e 01 00 00	 jmp	 $LN1@stbi__jpeg
$LN39@stbi__jpeg:

; 2382 :                     // sign bit
; 2383 :                     if (stbi__jpeg_get_bit(j))

  00551	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  00559	e8 00 00 00 00	 call	 ?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z ; stbi__jpeg_get_bit
  0055e	85 c0		 test	 eax, eax
  00560	74 0b		 je	 SHORT $LN40@stbi__jpeg

; 2384 :                         s = bit;

  00562	0f bf 44 24 24	 movsx	 eax, WORD PTR bit$1[rsp]
  00567	89 44 24 34	 mov	 DWORD PTR s$5[rsp], eax
  0056b	eb 0b		 jmp	 SHORT $LN41@stbi__jpeg
$LN40@stbi__jpeg:

; 2385 :                     else
; 2386 :                         s = -bit;

  0056d	0f bf 44 24 24	 movsx	 eax, WORD PTR bit$1[rsp]
  00572	f7 d8		 neg	 eax
  00574	89 44 24 34	 mov	 DWORD PTR s$5[rsp], eax
$LN41@stbi__jpeg:
$LN35@stbi__jpeg:
$LN11@stbi__jpeg:

; 2387 :                 }
; 2388 :                 
; 2389 :                 // advance by r
; 2390 :                 while (k <= j->spec_end) {

  00578	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  00580	8b 80 38 48 00
	00		 mov	 eax, DWORD PTR [rax+18488]
  00586	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  0058a	0f 8f c2 00 00
	00		 jg	 $LN12@stbi__jpeg

; 2391 :                     short *p = &data[stbi__jpeg_dezigzag[k++]];

  00590	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  00595	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__jpeg_dezigzag@@3QBEB
  0059c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  005a0	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  005a8	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  005ac	48 89 44 24 38	 mov	 QWORD PTR p$6[rsp], rax
  005b1	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  005b5	ff c0		 inc	 eax
  005b7	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2392 :                     if (*p != 0) {

  005bb	48 8b 44 24 38	 mov	 rax, QWORD PTR p$6[rsp]
  005c0	0f bf 00	 movsx	 eax, WORD PTR [rax]
  005c3	85 c0		 test	 eax, eax
  005c5	74 66		 je	 SHORT $LN42@stbi__jpeg

; 2393 :                         if (stbi__jpeg_get_bit(j))

  005c7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR j$[rsp]
  005cf	e8 00 00 00 00	 call	 ?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z ; stbi__jpeg_get_bit
  005d4	85 c0		 test	 eax, eax
  005d6	74 53		 je	 SHORT $LN44@stbi__jpeg

; 2394 :                             if ((*p & bit)==0) {

  005d8	48 8b 44 24 38	 mov	 rax, QWORD PTR p$6[rsp]
  005dd	0f bf 00	 movsx	 eax, WORD PTR [rax]
  005e0	0f bf 4c 24 24	 movsx	 ecx, WORD PTR bit$1[rsp]
  005e5	23 c1		 and	 eax, ecx
  005e7	85 c0		 test	 eax, eax
  005e9	75 40		 jne	 SHORT $LN45@stbi__jpeg

; 2395 :                             if (*p > 0)

  005eb	48 8b 44 24 38	 mov	 rax, QWORD PTR p$6[rsp]
  005f0	0f bf 00	 movsx	 eax, WORD PTR [rax]
  005f3	85 c0		 test	 eax, eax
  005f5	7e 1b		 jle	 SHORT $LN46@stbi__jpeg

; 2396 :                                 *p += bit;

  005f7	0f bf 44 24 24	 movsx	 eax, WORD PTR bit$1[rsp]
  005fc	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$6[rsp]
  00601	0f bf 09	 movsx	 ecx, WORD PTR [rcx]
  00604	03 c8		 add	 ecx, eax
  00606	8b c1		 mov	 eax, ecx
  00608	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$6[rsp]
  0060d	66 89 01	 mov	 WORD PTR [rcx], ax
  00610	eb 19		 jmp	 SHORT $LN47@stbi__jpeg
$LN46@stbi__jpeg:

; 2397 :                             else
; 2398 :                                 *p -= bit;

  00612	0f bf 44 24 24	 movsx	 eax, WORD PTR bit$1[rsp]
  00617	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$6[rsp]
  0061c	0f bf 09	 movsx	 ecx, WORD PTR [rcx]
  0061f	2b c8		 sub	 ecx, eax
  00621	8b c1		 mov	 eax, ecx
  00623	48 8b 4c 24 38	 mov	 rcx, QWORD PTR p$6[rsp]
  00628	66 89 01	 mov	 WORD PTR [rcx], ax
$LN47@stbi__jpeg:
$LN45@stbi__jpeg:
$LN44@stbi__jpeg:

; 2399 :                         }
; 2400 :                     } else {

  0062b	eb 20		 jmp	 SHORT $LN43@stbi__jpeg
$LN42@stbi__jpeg:

; 2401 :                         if (r == 0) {

  0062d	83 7c 24 2c 00	 cmp	 DWORD PTR r$3[rsp], 0
  00632	75 0f		 jne	 SHORT $LN48@stbi__jpeg

; 2402 :                             *p = (short) s;

  00634	48 8b 44 24 38	 mov	 rax, QWORD PTR p$6[rsp]
  00639	0f b7 4c 24 34	 movzx	 ecx, WORD PTR s$5[rsp]
  0063e	66 89 08	 mov	 WORD PTR [rax], cx

; 2403 :                             break;

  00641	eb 0f		 jmp	 SHORT $LN12@stbi__jpeg
$LN48@stbi__jpeg:

; 2404 :                         }
; 2405 :                         --r;

  00643	8b 44 24 2c	 mov	 eax, DWORD PTR r$3[rsp]
  00647	ff c8		 dec	 eax
  00649	89 44 24 2c	 mov	 DWORD PTR r$3[rsp], eax
$LN43@stbi__jpeg:

; 2406 :                     }
; 2407 :                 }

  0064d	e9 26 ff ff ff	 jmp	 $LN11@stbi__jpeg
$LN12@stbi__jpeg:

; 2408 :             } while (k <= j->spec_end);

  00652	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0065a	8b 80 38 48 00
	00		 mov	 eax, DWORD PTR [rax+18488]
  00660	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  00664	0f 8e 16 fe ff
	ff		 jle	 $LN10@stbi__jpeg
$LN27@stbi__jpeg:
$LN15@stbi__jpeg:

; 2409 :         }
; 2410 :     }
; 2411 :     return 1;

  0066a	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__jpeg:

; 2412 : }

  0066f	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00676	c3		 ret	 0
?stbi__jpeg_decode_block_prog_ac@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@PEAF@Z ENDP ; stbi__jpeg_decode_block_prog_ac
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
t$ = 32
dc$ = 36
tv87 = 40
diff$ = 44
tv205 = 48
tv209 = 52
j$ = 80
data$ = 88
hdc$ = 96
b$ = 104
?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z PROC ; stbi__jpeg_decode_block_prog_dc

; 2265 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2266 :     int diff,dc;
; 2267 :     int t;
; 2268 :     if (j->spec_end != 0) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

  00018	48 8b 44 24 50	 mov	 rax, QWORD PTR j$[rsp]
  0001d	83 b8 38 48 00
	00 00		 cmp	 DWORD PTR [rax+18488], 0
  00024	74 11		 je	 SHORT $LN2@stbi__jpeg
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG77556
  0002d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00032	e9 c9 01 00 00	 jmp	 $LN1@stbi__jpeg
$LN2@stbi__jpeg:

; 2269 :     
; 2270 :     if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

  00037	48 8b 44 24 50	 mov	 rax, QWORD PTR j$[rsp]
  0003c	83 b8 24 48 00
	00 10		 cmp	 DWORD PTR [rax+18468], 16
  00043	7d 0a		 jge	 SHORT $LN3@stbi__jpeg
  00045	48 8b 4c 24 50	 mov	 rcx, QWORD PTR j$[rsp]
  0004a	e8 00 00 00 00	 call	 ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN3@stbi__jpeg:

; 2271 :     
; 2272 :     if (j->succ_high == 0) {

  0004f	48 8b 44 24 50	 mov	 rax, QWORD PTR j$[rsp]
  00054	83 b8 3c 48 00
	00 00		 cmp	 DWORD PTR [rax+18492], 0
  0005b	0f 85 4f 01 00
	00		 jne	 $LN4@stbi__jpeg

; 2273 :         // first scan for DC coefficient, must be first
; 2274 :         memset(data,0,64*sizeof(data[0])); // 0 all the ac values now

  00061	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  00067	33 d2		 xor	 edx, edx
  00069	48 8b 4c 24 58	 mov	 rcx, QWORD PTR data$[rsp]
  0006e	e8 00 00 00 00	 call	 memset

; 2275 :         t = stbi__jpeg_huff_decode(j, hdc);

  00073	48 8b 54 24 60	 mov	 rdx, QWORD PTR hdc$[rsp]
  00078	48 8b 4c 24 50	 mov	 rcx, QWORD PTR j$[rsp]
  0007d	e8 00 00 00 00	 call	 ?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z ; stbi__jpeg_huff_decode
  00082	89 44 24 20	 mov	 DWORD PTR t$[rsp], eax

; 2276 :         if (t < 0 || t > 15) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

  00086	83 7c 24 20 00	 cmp	 DWORD PTR t$[rsp], 0
  0008b	7c 07		 jl	 SHORT $LN7@stbi__jpeg
  0008d	83 7c 24 20 0f	 cmp	 DWORD PTR t$[rsp], 15
  00092	7e 11		 jle	 SHORT $LN6@stbi__jpeg
$LN7@stbi__jpeg:
  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG77562
  0009b	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000a0	e9 5b 01 00 00	 jmp	 $LN1@stbi__jpeg
$LN6@stbi__jpeg:

; 2277 :         diff = t ? stbi__extend_receive(j, t) : 0;

  000a5	83 7c 24 20 00	 cmp	 DWORD PTR t$[rsp], 0
  000aa	74 14		 je	 SHORT $LN12@stbi__jpeg
  000ac	8b 54 24 20	 mov	 edx, DWORD PTR t$[rsp]
  000b0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR j$[rsp]
  000b5	e8 00 00 00 00	 call	 ?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z ; stbi__extend_receive
  000ba	89 44 24 28	 mov	 DWORD PTR tv87[rsp], eax
  000be	eb 08		 jmp	 SHORT $LN13@stbi__jpeg
$LN12@stbi__jpeg:
  000c0	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv87[rsp], 0
$LN13@stbi__jpeg:
  000c8	8b 44 24 28	 mov	 eax, DWORD PTR tv87[rsp]
  000cc	89 44 24 2c	 mov	 DWORD PTR diff$[rsp], eax

; 2278 :         
; 2279 :         if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta", "Corrupt JPEG");

  000d0	48 63 44 24 68	 movsxd	 rax, DWORD PTR b$[rsp]
  000d5	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000d9	8b 54 24 2c	 mov	 edx, DWORD PTR diff$[rsp]
  000dd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR j$[rsp]
  000e2	8b 8c 01 b8 46
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+18104]
  000e9	e8 00 00 00 00	 call	 ?stbi__addints_valid@@YAHHH@Z ; stbi__addints_valid
  000ee	85 c0		 test	 eax, eax
  000f0	75 11		 jne	 SHORT $LN8@stbi__jpeg
  000f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG77564
  000f9	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000fe	e9 fd 00 00 00	 jmp	 $LN1@stbi__jpeg
$LN8@stbi__jpeg:

; 2280 :         dc = j->img_comp[b].dc_pred + diff;

  00103	48 63 44 24 68	 movsxd	 rax, DWORD PTR b$[rsp]
  00108	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  0010c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR j$[rsp]
  00111	8b 84 01 b8 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18104]
  00118	03 44 24 2c	 add	 eax, DWORD PTR diff$[rsp]
  0011c	89 44 24 24	 mov	 DWORD PTR dc$[rsp], eax

; 2281 :         j->img_comp[b].dc_pred = dc;

  00120	48 63 44 24 68	 movsxd	 rax, DWORD PTR b$[rsp]
  00125	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00129	48 8b 4c 24 50	 mov	 rcx, QWORD PTR j$[rsp]
  0012e	8b 54 24 24	 mov	 edx, DWORD PTR dc$[rsp]
  00132	89 94 01 b8 46
	00 00		 mov	 DWORD PTR [rcx+rax+18104], edx

; 2282 :         if (!stbi__mul2shorts_valid(dc, 1 << j->succ_low)) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

  00139	48 8b 44 24 50	 mov	 rax, QWORD PTR j$[rsp]
  0013e	8b 80 40 48 00
	00		 mov	 eax, DWORD PTR [rax+18496]
  00144	b9 01 00 00 00	 mov	 ecx, 1
  00149	89 4c 24 30	 mov	 DWORD PTR tv205[rsp], ecx
  0014d	0f b6 c8	 movzx	 ecx, al
  00150	8b 44 24 30	 mov	 eax, DWORD PTR tv205[rsp]
  00154	d3 e0		 shl	 eax, cl
  00156	8b d0		 mov	 edx, eax
  00158	8b 4c 24 24	 mov	 ecx, DWORD PTR dc$[rsp]
  0015c	e8 00 00 00 00	 call	 ?stbi__mul2shorts_valid@@YAHHH@Z ; stbi__mul2shorts_valid
  00161	85 c0		 test	 eax, eax
  00163	75 11		 jne	 SHORT $LN9@stbi__jpeg
  00165	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG77566
  0016c	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00171	e9 8a 00 00 00	 jmp	 $LN1@stbi__jpeg
$LN9@stbi__jpeg:

; 2283 :         data[0] = (short) (dc * (1 << j->succ_low));

  00176	48 8b 44 24 50	 mov	 rax, QWORD PTR j$[rsp]
  0017b	8b 80 40 48 00
	00		 mov	 eax, DWORD PTR [rax+18496]
  00181	b9 01 00 00 00	 mov	 ecx, 1
  00186	89 4c 24 34	 mov	 DWORD PTR tv209[rsp], ecx
  0018a	0f b6 c8	 movzx	 ecx, al
  0018d	8b 44 24 34	 mov	 eax, DWORD PTR tv209[rsp]
  00191	d3 e0		 shl	 eax, cl
  00193	8b 4c 24 24	 mov	 ecx, DWORD PTR dc$[rsp]
  00197	0f af c8	 imul	 ecx, eax
  0019a	8b c1		 mov	 eax, ecx
  0019c	b9 02 00 00 00	 mov	 ecx, 2
  001a1	48 6b c9 00	 imul	 rcx, rcx, 0
  001a5	48 8b 54 24 58	 mov	 rdx, QWORD PTR data$[rsp]
  001aa	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax

; 2284 :     } else {

  001ae	eb 4b		 jmp	 SHORT $LN5@stbi__jpeg
$LN4@stbi__jpeg:

; 2285 :         // refinement scan for DC coefficient
; 2286 :         if (stbi__jpeg_get_bit(j))

  001b0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR j$[rsp]
  001b5	e8 00 00 00 00	 call	 ?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z ; stbi__jpeg_get_bit
  001ba	85 c0		 test	 eax, eax
  001bc	74 3d		 je	 SHORT $LN10@stbi__jpeg

; 2287 :             data[0] += (short) (1 << j->succ_low);

  001be	b8 02 00 00 00	 mov	 eax, 2
  001c3	48 6b c0 00	 imul	 rax, rax, 0
  001c7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR j$[rsp]
  001cc	8b 89 40 48 00
	00		 mov	 ecx, DWORD PTR [rcx+18496]
  001d2	ba 01 00 00 00	 mov	 edx, 1
  001d7	d3 e2		 shl	 edx, cl
  001d9	8b ca		 mov	 ecx, edx
  001db	0f bf c9	 movsx	 ecx, cx
  001de	48 8b 54 24 58	 mov	 rdx, QWORD PTR data$[rsp]
  001e3	0f bf 04 02	 movsx	 eax, WORD PTR [rdx+rax]
  001e7	03 c1		 add	 eax, ecx
  001e9	b9 02 00 00 00	 mov	 ecx, 2
  001ee	48 6b c9 00	 imul	 rcx, rcx, 0
  001f2	48 8b 54 24 58	 mov	 rdx, QWORD PTR data$[rsp]
  001f7	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
$LN10@stbi__jpeg:
$LN5@stbi__jpeg:

; 2288 :     }
; 2289 :     return 1;

  001fb	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__jpeg:

; 2290 : }

  00200	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00204	c3		 ret	 0
?stbi__jpeg_decode_block_prog_dc@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@H@Z ENDP ; stbi__jpeg_decode_block_prog_dc
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
k$ = 32
r$1 = 36
s$2 = 40
zig$3 = 44
t$ = 48
rs$4 = 52
dc$ = 56
tv81 = 60
diff$ = 64
c$5 = 68
tv275 = 72
j$ = 96
data$ = 104
hdc$ = 112
hac$ = 120
fac$ = 128
b$ = 136
dequant$ = 144
?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z PROC ; stbi__jpeg_decode_block

; 2210 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2211 :     int diff,dc,k;
; 2212 :     int t;
; 2213 :     
; 2214 :     if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  0001d	83 b8 24 48 00
	00 10		 cmp	 DWORD PTR [rax+18468], 16
  00024	7d 0a		 jge	 SHORT $LN5@stbi__jpeg
  00026	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  0002b	e8 00 00 00 00	 call	 ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN5@stbi__jpeg:

; 2215 :     t = stbi__jpeg_huff_decode(j, hdc);

  00030	48 8b 54 24 70	 mov	 rdx, QWORD PTR hdc$[rsp]
  00035	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  0003a	e8 00 00 00 00	 call	 ?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z ; stbi__jpeg_huff_decode
  0003f	89 44 24 30	 mov	 DWORD PTR t$[rsp], eax

; 2216 :     if (t < 0 || t > 15) return stbi__err("bad huffman code","Corrupt JPEG");

  00043	83 7c 24 30 00	 cmp	 DWORD PTR t$[rsp], 0
  00048	7c 07		 jl	 SHORT $LN7@stbi__jpeg
  0004a	83 7c 24 30 0f	 cmp	 DWORD PTR t$[rsp], 15
  0004f	7e 11		 jle	 SHORT $LN6@stbi__jpeg
$LN7@stbi__jpeg:
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG77529
  00058	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0005d	e9 0a 03 00 00	 jmp	 $LN1@stbi__jpeg
$LN6@stbi__jpeg:

; 2217 :     
; 2218 :     // 0 all the ac values now so we can do it 32-bits at a time
; 2219 :     memset(data,0,64*sizeof(data[0]));

  00062	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  00068	33 d2		 xor	 edx, edx
  0006a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR data$[rsp]
  0006f	e8 00 00 00 00	 call	 memset

; 2220 :     
; 2221 :     diff = t ? stbi__extend_receive(j, t) : 0;

  00074	83 7c 24 30 00	 cmp	 DWORD PTR t$[rsp], 0
  00079	74 14		 je	 SHORT $LN19@stbi__jpeg
  0007b	8b 54 24 30	 mov	 edx, DWORD PTR t$[rsp]
  0007f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  00084	e8 00 00 00 00	 call	 ?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z ; stbi__extend_receive
  00089	89 44 24 3c	 mov	 DWORD PTR tv81[rsp], eax
  0008d	eb 08		 jmp	 SHORT $LN20@stbi__jpeg
$LN19@stbi__jpeg:
  0008f	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN20@stbi__jpeg:
  00097	8b 44 24 3c	 mov	 eax, DWORD PTR tv81[rsp]
  0009b	89 44 24 40	 mov	 DWORD PTR diff$[rsp], eax

; 2222 :     if (!stbi__addints_valid(j->img_comp[b].dc_pred, diff)) return stbi__err("bad delta","Corrupt JPEG");

  0009f	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR b$[rsp]
  000a7	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000ab	8b 54 24 40	 mov	 edx, DWORD PTR diff$[rsp]
  000af	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  000b4	8b 8c 01 b8 46
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+18104]
  000bb	e8 00 00 00 00	 call	 ?stbi__addints_valid@@YAHHH@Z ; stbi__addints_valid
  000c0	85 c0		 test	 eax, eax
  000c2	75 11		 jne	 SHORT $LN8@stbi__jpeg
  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG77531
  000cb	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000d0	e9 97 02 00 00	 jmp	 $LN1@stbi__jpeg
$LN8@stbi__jpeg:

; 2223 :     dc = j->img_comp[b].dc_pred + diff;

  000d5	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR b$[rsp]
  000dd	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  000e1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  000e6	8b 84 01 b8 46
	00 00		 mov	 eax, DWORD PTR [rcx+rax+18104]
  000ed	03 44 24 40	 add	 eax, DWORD PTR diff$[rsp]
  000f1	89 44 24 38	 mov	 DWORD PTR dc$[rsp], eax

; 2224 :     j->img_comp[b].dc_pred = dc;

  000f5	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR b$[rsp]
  000fd	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00101	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  00106	8b 54 24 38	 mov	 edx, DWORD PTR dc$[rsp]
  0010a	89 94 01 b8 46
	00 00		 mov	 DWORD PTR [rcx+rax+18104], edx

; 2225 :     if (!stbi__mul2shorts_valid(dc, dequant[0])) return stbi__err("can't merge dc and ac", "Corrupt JPEG");

  00111	b8 02 00 00 00	 mov	 eax, 2
  00116	48 6b c0 00	 imul	 rax, rax, 0
  0011a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dequant$[rsp]
  00122	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  00126	8b d0		 mov	 edx, eax
  00128	8b 4c 24 38	 mov	 ecx, DWORD PTR dc$[rsp]
  0012c	e8 00 00 00 00	 call	 ?stbi__mul2shorts_valid@@YAHHH@Z ; stbi__mul2shorts_valid
  00131	85 c0		 test	 eax, eax
  00133	75 11		 jne	 SHORT $LN9@stbi__jpeg
  00135	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG77533
  0013c	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00141	e9 26 02 00 00	 jmp	 $LN1@stbi__jpeg
$LN9@stbi__jpeg:

; 2226 :     data[0] = (short) (dc * dequant[0]);

  00146	b8 02 00 00 00	 mov	 eax, 2
  0014b	48 6b c0 00	 imul	 rax, rax, 0
  0014f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dequant$[rsp]
  00157	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  0015b	8b 4c 24 38	 mov	 ecx, DWORD PTR dc$[rsp]
  0015f	0f af c8	 imul	 ecx, eax
  00162	8b c1		 mov	 eax, ecx
  00164	b9 02 00 00 00	 mov	 ecx, 2
  00169	48 6b c9 00	 imul	 rcx, rcx, 0
  0016d	48 8b 54 24 68	 mov	 rdx, QWORD PTR data$[rsp]
  00172	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax

; 2227 :     
; 2228 :     // decode AC components, see JPEG spec
; 2229 :     k = 1;

  00176	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR k$[rsp], 1
$LN4@stbi__jpeg:

; 2230 :     do {
; 2231 :         unsigned int zig;
; 2232 :         int c,r,s;
; 2233 :         if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

  0017e	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  00183	83 b8 24 48 00
	00 10		 cmp	 DWORD PTR [rax+18468], 16
  0018a	7d 0a		 jge	 SHORT $LN10@stbi__jpeg
  0018c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  00191	e8 00 00 00 00	 call	 ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN10@stbi__jpeg:

; 2234 :         c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);

  00196	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  0019b	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  001a1	c1 e8 17	 shr	 eax, 23
  001a4	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  001a9	89 44 24 44	 mov	 DWORD PTR c$5[rsp], eax

; 2235 :         r = fac[c];

  001ad	48 63 44 24 44	 movsxd	 rax, DWORD PTR c$5[rsp]
  001b2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR fac$[rsp]
  001ba	0f bf 04 41	 movsx	 eax, WORD PTR [rcx+rax*2]
  001be	89 44 24 24	 mov	 DWORD PTR r$1[rsp], eax

; 2236 :         if (r) { // fast-AC path

  001c2	83 7c 24 24 00	 cmp	 DWORD PTR r$1[rsp], 0
  001c7	0f 84 d2 00 00
	00		 je	 $LN11@stbi__jpeg

; 2237 :             k += (r >> 4) & 15; // run

  001cd	8b 44 24 24	 mov	 eax, DWORD PTR r$1[rsp]
  001d1	c1 f8 04	 sar	 eax, 4
  001d4	83 e0 0f	 and	 eax, 15
  001d7	8b 4c 24 20	 mov	 ecx, DWORD PTR k$[rsp]
  001db	03 c8		 add	 ecx, eax
  001dd	8b c1		 mov	 eax, ecx
  001df	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2238 :             s = r & 15; // combined length

  001e3	8b 44 24 24	 mov	 eax, DWORD PTR r$1[rsp]
  001e7	83 e0 0f	 and	 eax, 15
  001ea	89 44 24 28	 mov	 DWORD PTR s$2[rsp], eax

; 2239 :             if (s > j->code_bits) return stbi__err("bad huffman code", "Combined length longer than code bits available");

  001ee	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  001f3	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  001f9	39 44 24 28	 cmp	 DWORD PTR s$2[rsp], eax
  001fd	7e 11		 jle	 SHORT $LN13@stbi__jpeg
  001ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG77538
  00206	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0020b	e9 5c 01 00 00	 jmp	 $LN1@stbi__jpeg
$LN13@stbi__jpeg:

; 2240 :             j->code_buffer <<= s;

  00210	8b 44 24 28	 mov	 eax, DWORD PTR s$2[rsp]
  00214	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  00219	48 89 4c 24 48	 mov	 QWORD PTR tv275[rsp], rcx
  0021e	0f b6 c8	 movzx	 ecx, al
  00221	48 8b 44 24 48	 mov	 rax, QWORD PTR tv275[rsp]
  00226	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0022c	d3 e0		 shl	 eax, cl
  0022e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  00233	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2241 :             j->code_bits -= s;

  00239	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  0023e	8b 4c 24 28	 mov	 ecx, DWORD PTR s$2[rsp]
  00242	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00248	2b c1		 sub	 eax, ecx
  0024a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  0024f	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2242 :             // decode into unzigzag'd location
; 2243 :             zig = stbi__jpeg_dezigzag[k++];

  00255	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  0025a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__jpeg_dezigzag@@3QBEB
  00261	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00265	89 44 24 2c	 mov	 DWORD PTR zig$3[rsp], eax
  00269	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  0026d	ff c0		 inc	 eax
  0026f	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2244 :             data[zig] = (short) ((r >> 8) * dequant[zig]);

  00273	8b 44 24 24	 mov	 eax, DWORD PTR r$1[rsp]
  00277	c1 f8 08	 sar	 eax, 8
  0027a	8b 4c 24 2c	 mov	 ecx, DWORD PTR zig$3[rsp]
  0027e	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR dequant$[rsp]
  00286	0f b7 0c 4a	 movzx	 ecx, WORD PTR [rdx+rcx*2]
  0028a	0f af c1	 imul	 eax, ecx
  0028d	8b 4c 24 2c	 mov	 ecx, DWORD PTR zig$3[rsp]
  00291	48 8b 54 24 68	 mov	 rdx, QWORD PTR data$[rsp]
  00296	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax

; 2245 :         } else {

  0029a	e9 bd 00 00 00	 jmp	 $LN12@stbi__jpeg
$LN11@stbi__jpeg:

; 2246 :             int rs = stbi__jpeg_huff_decode(j, hac);

  0029f	48 8b 54 24 78	 mov	 rdx, QWORD PTR hac$[rsp]
  002a4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  002a9	e8 00 00 00 00	 call	 ?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z ; stbi__jpeg_huff_decode
  002ae	89 44 24 34	 mov	 DWORD PTR rs$4[rsp], eax

; 2247 :             if (rs < 0) return stbi__err("bad huffman code","Corrupt JPEG");

  002b2	83 7c 24 34 00	 cmp	 DWORD PTR rs$4[rsp], 0
  002b7	7d 11		 jge	 SHORT $LN14@stbi__jpeg
  002b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG77540
  002c0	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  002c5	e9 a2 00 00 00	 jmp	 $LN1@stbi__jpeg
$LN14@stbi__jpeg:

; 2248 :             s = rs & 15;

  002ca	8b 44 24 34	 mov	 eax, DWORD PTR rs$4[rsp]
  002ce	83 e0 0f	 and	 eax, 15
  002d1	89 44 24 28	 mov	 DWORD PTR s$2[rsp], eax

; 2249 :             r = rs >> 4;

  002d5	8b 44 24 34	 mov	 eax, DWORD PTR rs$4[rsp]
  002d9	c1 f8 04	 sar	 eax, 4
  002dc	89 44 24 24	 mov	 DWORD PTR r$1[rsp], eax

; 2250 :             if (s == 0) {

  002e0	83 7c 24 28 00	 cmp	 DWORD PTR s$2[rsp], 0
  002e5	75 19		 jne	 SHORT $LN15@stbi__jpeg

; 2251 :                 if (rs != 0xf0) break; // end block

  002e7	81 7c 24 34 f0
	00 00 00	 cmp	 DWORD PTR rs$4[rsp], 240 ; 000000f0H
  002ef	74 02		 je	 SHORT $LN17@stbi__jpeg
  002f1	eb 74		 jmp	 SHORT $LN3@stbi__jpeg
$LN17@stbi__jpeg:

; 2252 :                 k += 16;

  002f3	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  002f7	83 c0 10	 add	 eax, 16
  002fa	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2253 :             } else {

  002fe	eb 5c		 jmp	 SHORT $LN16@stbi__jpeg
$LN15@stbi__jpeg:

; 2254 :                 k += r;

  00300	8b 44 24 24	 mov	 eax, DWORD PTR r$1[rsp]
  00304	8b 4c 24 20	 mov	 ecx, DWORD PTR k$[rsp]
  00308	03 c8		 add	 ecx, eax
  0030a	8b c1		 mov	 eax, ecx
  0030c	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2255 :                 // decode into unzigzag'd location
; 2256 :                 zig = stbi__jpeg_dezigzag[k++];

  00310	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  00315	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__jpeg_dezigzag@@3QBEB
  0031c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00320	89 44 24 2c	 mov	 DWORD PTR zig$3[rsp], eax
  00324	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  00328	ff c0		 inc	 eax
  0032a	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2257 :                 data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]);

  0032e	8b 54 24 28	 mov	 edx, DWORD PTR s$2[rsp]
  00332	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  00337	e8 00 00 00 00	 call	 ?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z ; stbi__extend_receive
  0033c	8b 4c 24 2c	 mov	 ecx, DWORD PTR zig$3[rsp]
  00340	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR dequant$[rsp]
  00348	0f b7 0c 4a	 movzx	 ecx, WORD PTR [rdx+rcx*2]
  0034c	0f af c1	 imul	 eax, ecx
  0034f	8b 4c 24 2c	 mov	 ecx, DWORD PTR zig$3[rsp]
  00353	48 8b 54 24 68	 mov	 rdx, QWORD PTR data$[rsp]
  00358	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax
$LN16@stbi__jpeg:
$LN12@stbi__jpeg:

; 2258 :             }
; 2259 :         }
; 2260 :     } while (k < 64);

  0035c	83 7c 24 20 40	 cmp	 DWORD PTR k$[rsp], 64	; 00000040H
  00361	0f 8c 17 fe ff
	ff		 jl	 $LN4@stbi__jpeg
$LN3@stbi__jpeg:

; 2261 :     return 1;

  00367	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__jpeg:

; 2262 : }

  0036c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00370	c3		 ret	 0
?stbi__jpeg_decode_block@@YAHPEAUstbi__jpeg@@QEAFPEAUstbi__huffman@@2PEAFHPEAG@Z ENDP ; stbi__jpeg_decode_block
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
k$ = 32
j$ = 64
?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z PROC		; stbi__jpeg_get_bit

; 2181 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2182 :     unsigned int k;
; 2183 :     if (j->code_bits < 1) stbi__grow_buffer_unsafe(j);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0000e	83 b8 24 48 00
	00 01		 cmp	 DWORD PTR [rax+18468], 1
  00015	7d 0a		 jge	 SHORT $LN2@stbi__jpeg
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  0001c	e8 00 00 00 00	 call	 ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN2@stbi__jpeg:

; 2184 :     if (j->code_bits < 1) return 0; // ran out of bits from stream, return 0s intead of continuing

  00021	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00026	83 b8 24 48 00
	00 01		 cmp	 DWORD PTR [rax+18468], 1
  0002d	7d 04		 jge	 SHORT $LN3@stbi__jpeg
  0002f	33 c0		 xor	 eax, eax
  00031	eb 48		 jmp	 SHORT $LN1@stbi__jpeg
$LN3@stbi__jpeg:

; 2185 :     k = j->code_buffer;

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00038	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0003e	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2186 :     j->code_buffer <<= 1;

  00042	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00047	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0004d	d1 e0		 shl	 eax, 1
  0004f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00054	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2187 :     --j->code_bits;

  0005a	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0005f	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00065	ff c8		 dec	 eax
  00067	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  0006c	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2188 :     return k & 0x80000000;

  00072	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  00076	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
$LN1@stbi__jpeg:

; 2189 : }

  0007b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007f	c3		 ret	 0
?stbi__jpeg_get_bit@@YAHPEAUstbi__jpeg@@@Z ENDP		; stbi__jpeg_get_bit
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
k$ = 32
j$ = 64
n$ = 72
?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z PROC	; stbi__jpeg_get_bits

; 2169 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2170 :     unsigned int k;
; 2171 :     if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00012	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  00016	39 88 24 48 00
	00		 cmp	 DWORD PTR [rax+18468], ecx
  0001c	7d 0a		 jge	 SHORT $LN2@stbi__jpeg
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00023	e8 00 00 00 00	 call	 ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN2@stbi__jpeg:

; 2172 :     if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing

  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0002d	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  00031	39 88 24 48 00
	00		 cmp	 DWORD PTR [rax+18468], ecx
  00037	7d 04		 jge	 SHORT $LN3@stbi__jpeg
  00039	33 c0		 xor	 eax, eax
  0003b	eb 77		 jmp	 SHORT $LN1@stbi__jpeg
$LN3@stbi__jpeg:

; 2173 :     k = stbi_lrot(j->code_buffer, n);

  0003d	8b 54 24 48	 mov	 edx, DWORD PTR n$[rsp]
  00041	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00046	8b 88 20 48 00
	00		 mov	 ecx, DWORD PTR [rax+18464]
  0004c	e8 00 00 00 00	 call	 _lrotl
  00051	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2174 :     j->code_buffer = k & ~stbi__bmask[n];

  00055	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$[rsp]
  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__bmask@@3QBIB
  00061	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00064	f7 d0		 not	 eax
  00066	8b 4c 24 20	 mov	 ecx, DWORD PTR k$[rsp]
  0006a	23 c8		 and	 ecx, eax
  0006c	8b c1		 mov	 eax, ecx
  0006e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00073	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2175 :     k &= stbi__bmask[n];

  00079	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$[rsp]
  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__bmask@@3QBIB
  00085	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00088	8b 4c 24 20	 mov	 ecx, DWORD PTR k$[rsp]
  0008c	23 c8		 and	 ecx, eax
  0008e	8b c1		 mov	 eax, ecx
  00090	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2176 :     j->code_bits -= n;

  00094	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00099	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  0009d	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  000a3	2b c1		 sub	 eax, ecx
  000a5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  000aa	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2177 :     return k;

  000b0	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
$LN1@stbi__jpeg:

; 2178 : }

  000b4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b8	c3		 ret	 0
?stbi__jpeg_get_bits@@YAHPEAUstbi__jpeg@@H@Z ENDP	; stbi__jpeg_get_bits
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
k$ = 32
sgn$ = 36
j$ = 64
n$ = 72
?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z PROC	; stbi__extend_receive

; 2153 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2154 :     unsigned int k;
; 2155 :     int sgn;
; 2156 :     if (j->code_bits < n) stbi__grow_buffer_unsafe(j);

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00012	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  00016	39 88 24 48 00
	00		 cmp	 DWORD PTR [rax+18468], ecx
  0001c	7d 0a		 jge	 SHORT $LN2@stbi__exte
  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00023	e8 00 00 00 00	 call	 ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN2@stbi__exte:

; 2157 :     if (j->code_bits < n) return 0; // ran out of bits from stream, return 0s intead of continuing

  00028	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0002d	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  00031	39 88 24 48 00
	00		 cmp	 DWORD PTR [rax+18468], ecx
  00037	7d 07		 jge	 SHORT $LN3@stbi__exte
  00039	33 c0		 xor	 eax, eax
  0003b	e9 a4 00 00 00	 jmp	 $LN1@stbi__exte
$LN3@stbi__exte:

; 2158 :     
; 2159 :     sgn = j->code_buffer >> 31; // sign bit always in MSB; 0 if MSB clear (positive), 1 if MSB set (negative)

  00040	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00045	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0004b	c1 e8 1f	 shr	 eax, 31
  0004e	89 44 24 24	 mov	 DWORD PTR sgn$[rsp], eax

; 2160 :     k = stbi_lrot(j->code_buffer, n);

  00052	8b 54 24 48	 mov	 edx, DWORD PTR n$[rsp]
  00056	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0005b	8b 88 20 48 00
	00		 mov	 ecx, DWORD PTR [rax+18464]
  00061	e8 00 00 00 00	 call	 _lrotl
  00066	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2161 :     j->code_buffer = k & ~stbi__bmask[n];

  0006a	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$[rsp]
  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__bmask@@3QBIB
  00076	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00079	f7 d0		 not	 eax
  0007b	8b 4c 24 20	 mov	 ecx, DWORD PTR k$[rsp]
  0007f	23 c8		 and	 ecx, eax
  00081	8b c1		 mov	 eax, ecx
  00083	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  00088	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2162 :     k &= stbi__bmask[n];

  0008e	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$[rsp]
  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__bmask@@3QBIB
  0009a	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0009d	8b 4c 24 20	 mov	 ecx, DWORD PTR k$[rsp]
  000a1	23 c8		 and	 ecx, eax
  000a3	8b c1		 mov	 eax, ecx
  000a5	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2163 :     j->code_bits -= n;

  000a9	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  000ae	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  000b2	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  000b8	2b c1		 sub	 eax, ecx
  000ba	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  000bf	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2164 :     return k + (stbi__jbias[n] & (sgn - 1));

  000c5	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$[rsp]
  000ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stbi__jbias@@3QBHB
  000d1	8b 54 24 24	 mov	 edx, DWORD PTR sgn$[rsp]
  000d5	ff ca		 dec	 edx
  000d7	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000da	23 c2		 and	 eax, edx
  000dc	8b 4c 24 20	 mov	 ecx, DWORD PTR k$[rsp]
  000e0	03 c8		 add	 ecx, eax
  000e2	8b c1		 mov	 eax, ecx
$LN1@stbi__exte:

; 2165 : }

  000e4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e8	c3		 ret	 0
?stbi__extend_receive@@YAHPEAUstbi__jpeg@@H@Z ENDP	; stbi__extend_receive
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
k$ = 32
c$ = 36
s$1 = 40
temp$ = 44
tv211 = 48
tv232 = 56
tv241 = 64
tv252 = 72
j$ = 96
h$ = 104
?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z PROC ; stbi__jpeg_huff_decode

; 2097 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2098 :     unsigned int temp;
; 2099 :     int c,k;
; 2100 :     
; 2101 :     if (j->code_bits < 16) stbi__grow_buffer_unsafe(j);

  0000e	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  00013	83 b8 24 48 00
	00 10		 cmp	 DWORD PTR [rax+18468], 16
  0001a	7d 0a		 jge	 SHORT $LN5@stbi__jpeg
  0001c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  00021	e8 00 00 00 00	 call	 ?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ; stbi__grow_buffer_unsafe
$LN5@stbi__jpeg:

; 2102 :     
; 2103 :     // look at the top FAST_BITS and determine what symbol ID it is,
; 2104 :     // if the code is <= FAST_BITS
; 2105 :     c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1);

  00026	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  0002b	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00031	c1 e8 17	 shr	 eax, 23
  00034	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  00039	89 44 24 24	 mov	 DWORD PTR c$[rsp], eax

; 2106 :     k = h->fast[c];

  0003d	48 63 44 24 24	 movsxd	 rax, DWORD PTR c$[rsp]
  00042	48 8b 4c 24 68	 mov	 rcx, QWORD PTR h$[rsp]
  00047	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0004b	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax

; 2107 :     if (k < 255) {

  0004f	81 7c 24 20 ff
	00 00 00	 cmp	 DWORD PTR k$[rsp], 255	; 000000ffH
  00057	0f 8d 8d 00 00
	00		 jge	 $LN6@stbi__jpeg

; 2108 :         int s = h->size[k];

  0005d	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  00062	48 8b 4c 24 68	 mov	 rcx, QWORD PTR h$[rsp]
  00067	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  0006f	89 44 24 28	 mov	 DWORD PTR s$1[rsp], eax

; 2109 :         if (s > j->code_bits)

  00073	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  00078	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  0007e	39 44 24 28	 cmp	 DWORD PTR s$1[rsp], eax
  00082	7e 0a		 jle	 SHORT $LN7@stbi__jpeg

; 2110 :             return -1;

  00084	b8 ff ff ff ff	 mov	 eax, -1
  00089	e9 1d 02 00 00	 jmp	 $LN1@stbi__jpeg
$LN7@stbi__jpeg:

; 2111 :         j->code_buffer <<= s;

  0008e	8b 44 24 28	 mov	 eax, DWORD PTR s$1[rsp]
  00092	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  00097	48 89 4c 24 30	 mov	 QWORD PTR tv211[rsp], rcx
  0009c	0f b6 c8	 movzx	 ecx, al
  0009f	48 8b 44 24 30	 mov	 rax, QWORD PTR tv211[rsp]
  000a4	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  000aa	d3 e0		 shl	 eax, cl
  000ac	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  000b1	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2112 :         j->code_bits -= s;

  000b7	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  000bc	8b 4c 24 28	 mov	 ecx, DWORD PTR s$1[rsp]
  000c0	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  000c6	2b c1		 sub	 eax, ecx
  000c8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  000cd	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2113 :         return h->values[k];

  000d3	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  000d8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR h$[rsp]
  000dd	0f b6 84 01 00
	04 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1024]
  000e5	e9 c1 01 00 00	 jmp	 $LN1@stbi__jpeg
$LN6@stbi__jpeg:

; 2114 :     }
; 2115 :     
; 2116 :     // naive test is to shift the code_buffer down so k bits are
; 2117 :     // valid, then test against maxcode. To speed this up, we've
; 2118 :     // preshifted maxcode left so that it has (16-k) 0s at the
; 2119 :     // end; in other words, regardless of the number of bits, it
; 2120 :     // wants to be compared against something shifted to have 16;
; 2121 :     // that way we don't need to shift inside the loop.
; 2122 :     temp = j->code_buffer >> 16;

  000ea	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  000ef	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  000f5	c1 e8 10	 shr	 eax, 16
  000f8	89 44 24 2c	 mov	 DWORD PTR temp$[rsp], eax

; 2123 :     for (k=FAST_BITS+1 ; ; ++k)

  000fc	c7 44 24 20 0a
	00 00 00	 mov	 DWORD PTR k$[rsp], 10
  00104	eb 0a		 jmp	 SHORT $LN4@stbi__jpeg
$LN2@stbi__jpeg:
  00106	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  0010a	ff c0		 inc	 eax
  0010c	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
$LN4@stbi__jpeg:

; 2124 :         if (temp < h->maxcode[k])

  00110	48 63 44 24 20	 movsxd	 rax, DWORD PTR k$[rsp]
  00115	48 8b 4c 24 68	 mov	 rcx, QWORD PTR h$[rsp]
  0011a	8b 84 81 04 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+1540]
  00121	39 44 24 2c	 cmp	 DWORD PTR temp$[rsp], eax
  00125	73 02		 jae	 SHORT $LN8@stbi__jpeg

; 2125 :         break;

  00127	eb 02		 jmp	 SHORT $LN3@stbi__jpeg
$LN8@stbi__jpeg:
  00129	eb db		 jmp	 SHORT $LN2@stbi__jpeg
$LN3@stbi__jpeg:

; 2126 :     if (k == 17) {

  0012b	83 7c 24 20 11	 cmp	 DWORD PTR k$[rsp], 17
  00130	75 23		 jne	 SHORT $LN9@stbi__jpeg

; 2127 :         // error! code not found
; 2128 :         j->code_bits -= 16;

  00132	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  00137	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  0013d	83 e8 10	 sub	 eax, 16
  00140	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  00145	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2129 :         return -1;

  0014b	b8 ff ff ff ff	 mov	 eax, -1
  00150	e9 56 01 00 00	 jmp	 $LN1@stbi__jpeg
$LN9@stbi__jpeg:

; 2130 :     }
; 2131 :     
; 2132 :     if (k > j->code_bits)

  00155	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  0015a	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00160	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  00164	7e 0a		 jle	 SHORT $LN10@stbi__jpeg

; 2133 :         return -1;

  00166	b8 ff ff ff ff	 mov	 eax, -1
  0016b	e9 3b 01 00 00	 jmp	 $LN1@stbi__jpeg
$LN10@stbi__jpeg:

; 2134 :     
; 2135 :     // convert the huffman code to the symbol id
; 2136 :     c = ((j->code_buffer >> (32 - k)) & stbi__bmask[k]) + h->delta[k];

  00170	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00175	2b 44 24 20	 sub	 eax, DWORD PTR k$[rsp]
  00179	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  0017e	48 89 4c 24 38	 mov	 QWORD PTR tv232[rsp], rcx
  00183	0f b6 c8	 movzx	 ecx, al
  00186	48 8b 44 24 38	 mov	 rax, QWORD PTR tv232[rsp]
  0018b	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00191	d3 e8		 shr	 eax, cl
  00193	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  00198	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?stbi__bmask@@3QBIB
  0019f	23 04 8a	 and	 eax, DWORD PTR [rdx+rcx*4]
  001a2	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR k$[rsp]
  001a7	48 8b 54 24 68	 mov	 rdx, QWORD PTR h$[rsp]
  001ac	03 84 8a 4c 06
	00 00		 add	 eax, DWORD PTR [rdx+rcx*4+1612]
  001b3	89 44 24 24	 mov	 DWORD PTR c$[rsp], eax

; 2137 :     if(c < 0 || c >= 256) // symbol id out of bounds!

  001b7	83 7c 24 24 00	 cmp	 DWORD PTR c$[rsp], 0
  001bc	7c 0a		 jl	 SHORT $LN12@stbi__jpeg
  001be	81 7c 24 24 00
	01 00 00	 cmp	 DWORD PTR c$[rsp], 256	; 00000100H
  001c6	7c 0a		 jl	 SHORT $LN11@stbi__jpeg
$LN12@stbi__jpeg:

; 2138 :         return -1;

  001c8	b8 ff ff ff ff	 mov	 eax, -1
  001cd	e9 d9 00 00 00	 jmp	 $LN1@stbi__jpeg
$LN11@stbi__jpeg:

; 2139 :     STBI_ASSERT((((j->code_buffer) >> (32 - h->size[c])) & stbi__bmask[h->size[c]]) == h->code[c]);

  001d2	48 63 44 24 24	 movsxd	 rax, DWORD PTR c$[rsp]
  001d7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR h$[rsp]
  001dc	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  001e4	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  001e9	2b c8		 sub	 ecx, eax
  001eb	8b c1		 mov	 eax, ecx
  001ed	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  001f2	48 89 4c 24 40	 mov	 QWORD PTR tv241[rsp], rcx
  001f7	0f b6 c8	 movzx	 ecx, al
  001fa	48 8b 44 24 40	 mov	 rax, QWORD PTR tv241[rsp]
  001ff	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  00205	d3 e8		 shr	 eax, cl
  00207	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR c$[rsp]
  0020c	48 8b 54 24 68	 mov	 rdx, QWORD PTR h$[rsp]
  00211	0f b6 8c 0a 00
	05 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+1280]
  00219	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?stbi__bmask@@3QBIB
  00220	23 04 8a	 and	 eax, DWORD PTR [rdx+rcx*4]
  00223	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR c$[rsp]
  00228	48 8b 54 24 68	 mov	 rdx, QWORD PTR h$[rsp]
  0022d	0f b7 8c 4a 00
	02 00 00	 movzx	 ecx, WORD PTR [rdx+rcx*2+512]
  00235	3b c1		 cmp	 eax, ecx
  00237	74 1b		 je	 SHORT $LN14@stbi__jpeg
  00239	41 b8 5b 08 00
	00		 mov	 r8d, 2139		; 0000085bH
  0023f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG77477
  00246	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG77478
  0024d	e8 00 00 00 00	 call	 _wassert
  00252	33 c0		 xor	 eax, eax
$LN14@stbi__jpeg:

; 2140 :     
; 2141 :     // convert the id to a symbol
; 2142 :     j->code_bits -= k;

  00254	48 8b 44 24 60	 mov	 rax, QWORD PTR j$[rsp]
  00259	8b 4c 24 20	 mov	 ecx, DWORD PTR k$[rsp]
  0025d	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  00263	2b c1		 sub	 eax, ecx
  00265	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  0026a	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2143 :     j->code_buffer <<= k;

  00270	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  00274	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  00279	48 89 4c 24 48	 mov	 QWORD PTR tv252[rsp], rcx
  0027e	0f b6 c8	 movzx	 ecx, al
  00281	48 8b 44 24 48	 mov	 rax, QWORD PTR tv252[rsp]
  00286	8b 80 20 48 00
	00		 mov	 eax, DWORD PTR [rax+18464]
  0028c	d3 e0		 shl	 eax, cl
  0028e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR j$[rsp]
  00293	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2144 :     return h->values[c];

  00299	48 63 44 24 24	 movsxd	 rax, DWORD PTR c$[rsp]
  0029e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR h$[rsp]
  002a3	0f b6 84 01 00
	04 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1024]
$LN1@stbi__jpeg:

; 2145 : }

  002ab	48 83 c4 58	 add	 rsp, 88			; 00000058H
  002af	c3		 ret	 0
?stbi__jpeg_huff_decode@@YAHPEAUstbi__jpeg@@PEAUstbi__huffman@@@Z ENDP ; stbi__jpeg_huff_decode
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
c$1 = 32
tv70 = 36
b$2 = 40
j$ = 64
?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z PROC	; stbi__grow_buffer_unsafe

; 2075 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@stbi__grow:

; 2076 :     do {
; 2077 :         unsigned int b = j->nomore ? 0 : stbi__get8(j->s);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0000e	83 b8 2c 48 00
	00 00		 cmp	 DWORD PTR [rax+18476], 0
  00015	74 0a		 je	 SHORT $LN10@stbi__grow
  00017	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  0001f	eb 14		 jmp	 SHORT $LN11@stbi__grow
$LN10@stbi__grow:
  00021	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00026	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00029	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0002e	0f b6 c0	 movzx	 eax, al
  00031	89 44 24 24	 mov	 DWORD PTR tv70[rsp], eax
$LN11@stbi__grow:
  00035	8b 44 24 24	 mov	 eax, DWORD PTR tv70[rsp]
  00039	89 44 24 28	 mov	 DWORD PTR b$2[rsp], eax

; 2078 :         if (b == 0xff) {

  0003d	81 7c 24 28 ff
	00 00 00	 cmp	 DWORD PTR b$2[rsp], 255	; 000000ffH
  00045	75 5c		 jne	 SHORT $LN7@stbi__grow

; 2079 :             int c = stbi__get8(j->s);

  00047	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0004c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0004f	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00054	0f b6 c0	 movzx	 eax, al
  00057	89 44 24 20	 mov	 DWORD PTR c$1[rsp], eax
$LN5@stbi__grow:

; 2080 :             while (c == 0xff) c = stbi__get8(j->s); // consume fill bytes

  0005b	81 7c 24 20 ff
	00 00 00	 cmp	 DWORD PTR c$1[rsp], 255	; 000000ffH
  00063	75 16		 jne	 SHORT $LN6@stbi__grow
  00065	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  0006a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0006d	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00072	0f b6 c0	 movzx	 eax, al
  00075	89 44 24 20	 mov	 DWORD PTR c$1[rsp], eax
  00079	eb e0		 jmp	 SHORT $LN5@stbi__grow
$LN6@stbi__grow:

; 2081 :             if (c != 0) {

  0007b	83 7c 24 20 00	 cmp	 DWORD PTR c$1[rsp], 0
  00080	74 21		 je	 SHORT $LN8@stbi__grow

; 2082 :                 j->marker = (unsigned char) c;

  00082	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00087	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR c$1[rsp]
  0008c	88 88 28 48 00
	00		 mov	 BYTE PTR [rax+18472], cl

; 2083 :                 j->nomore = 1;

  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  00097	c7 80 2c 48 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+18476], 1

; 2084 :                 return;

  000a1	eb 60		 jmp	 SHORT $LN1@stbi__grow
$LN8@stbi__grow:
$LN7@stbi__grow:

; 2085 :             }
; 2086 :         }
; 2087 :         j->code_buffer |= b << (24 - j->code_bits);

  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  000a8	b9 18 00 00 00	 mov	 ecx, 24
  000ad	2b 88 24 48 00
	00		 sub	 ecx, DWORD PTR [rax+18468]
  000b3	8b c1		 mov	 eax, ecx
  000b5	0f b6 c8	 movzx	 ecx, al
  000b8	8b 44 24 28	 mov	 eax, DWORD PTR b$2[rsp]
  000bc	d3 e0		 shl	 eax, cl
  000be	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  000c3	8b 89 20 48 00
	00		 mov	 ecx, DWORD PTR [rcx+18464]
  000c9	0b c8		 or	 ecx, eax
  000cb	8b c1		 mov	 eax, ecx
  000cd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  000d2	89 81 20 48 00
	00		 mov	 DWORD PTR [rcx+18464], eax

; 2088 :         j->code_bits += 8;

  000d8	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  000dd	8b 80 24 48 00
	00		 mov	 eax, DWORD PTR [rax+18468]
  000e3	83 c0 08	 add	 eax, 8
  000e6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR j$[rsp]
  000eb	89 81 24 48 00
	00		 mov	 DWORD PTR [rcx+18468], eax

; 2089 :     } while (j->code_bits <= 24);

  000f1	48 8b 44 24 40	 mov	 rax, QWORD PTR j$[rsp]
  000f6	83 b8 24 48 00
	00 18		 cmp	 DWORD PTR [rax+18468], 24
  000fd	0f 8e 06 ff ff
	ff		 jle	 $LN4@stbi__grow
$LN1@stbi__grow:

; 2090 : }

  00103	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00107	c3		 ret	 0
?stbi__grow_buffer_unsafe@@YAXPEAUstbi__jpeg@@@Z ENDP	; stbi__grow_buffer_unsafe
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
fast$1 = 0
i$ = 4
k$2 = 8
magbits$3 = 12
len$4 = 16
rs$5 = 20
tv173 = 24
m$6 = 28
tv177 = 32
run$7 = 36
fast_ac$ = 64
h$ = 72
?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z PROC	; stbi__build_fast_ac

; 2050 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2051 :     int i;
; 2052 :     for (i=0; i < (1 << FAST_BITS); ++i) {

  0000e	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00016	eb 0a		 jmp	 SHORT $LN4@stbi__buil
$LN2@stbi__buil:
  00018	8b 44 24 04	 mov	 eax, DWORD PTR i$[rsp]
  0001c	ff c0		 inc	 eax
  0001e	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__buil:
  00022	81 7c 24 04 00
	02 00 00	 cmp	 DWORD PTR i$[rsp], 512	; 00000200H
  0002a	0f 8d 3a 01 00
	00		 jge	 $LN3@stbi__buil

; 2053 :         stbi_uc fast = h->fast[i];

  00030	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  00035	48 8b 4c 24 48	 mov	 rcx, QWORD PTR h$[rsp]
  0003a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0003e	88 04 24	 mov	 BYTE PTR fast$1[rsp], al

; 2054 :         fast_ac[i] = 0;

  00041	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  00046	33 c9		 xor	 ecx, ecx
  00048	48 8b 54 24 40	 mov	 rdx, QWORD PTR fast_ac$[rsp]
  0004d	66 89 0c 42	 mov	 WORD PTR [rdx+rax*2], cx

; 2055 :         if (fast < 255) {

  00051	0f b6 04 24	 movzx	 eax, BYTE PTR fast$1[rsp]
  00055	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0005a	0f 8d 05 01 00
	00		 jge	 $LN5@stbi__buil

; 2056 :             int rs = h->values[fast];

  00060	0f b6 04 24	 movzx	 eax, BYTE PTR fast$1[rsp]
  00064	48 8b 4c 24 48	 mov	 rcx, QWORD PTR h$[rsp]
  00069	0f b6 84 01 00
	04 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1024]
  00071	89 44 24 14	 mov	 DWORD PTR rs$5[rsp], eax

; 2057 :             int run = (rs >> 4) & 15;

  00075	8b 44 24 14	 mov	 eax, DWORD PTR rs$5[rsp]
  00079	c1 f8 04	 sar	 eax, 4
  0007c	83 e0 0f	 and	 eax, 15
  0007f	89 44 24 24	 mov	 DWORD PTR run$7[rsp], eax

; 2058 :             int magbits = rs & 15;

  00083	8b 44 24 14	 mov	 eax, DWORD PTR rs$5[rsp]
  00087	83 e0 0f	 and	 eax, 15
  0008a	89 44 24 0c	 mov	 DWORD PTR magbits$3[rsp], eax

; 2059 :             int len = h->size[fast];

  0008e	0f b6 04 24	 movzx	 eax, BYTE PTR fast$1[rsp]
  00092	48 8b 4c 24 48	 mov	 rcx, QWORD PTR h$[rsp]
  00097	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  0009f	89 44 24 10	 mov	 DWORD PTR len$4[rsp], eax

; 2060 :             
; 2061 :             if (magbits && len + magbits <= FAST_BITS) {

  000a3	83 7c 24 0c 00	 cmp	 DWORD PTR magbits$3[rsp], 0
  000a8	0f 84 b7 00 00
	00		 je	 $LN6@stbi__buil
  000ae	8b 44 24 0c	 mov	 eax, DWORD PTR magbits$3[rsp]
  000b2	8b 4c 24 10	 mov	 ecx, DWORD PTR len$4[rsp]
  000b6	03 c8		 add	 ecx, eax
  000b8	8b c1		 mov	 eax, ecx
  000ba	83 f8 09	 cmp	 eax, 9
  000bd	0f 8f a2 00 00
	00		 jg	 $LN6@stbi__buil

; 2062 :                 // magnitude code followed by receive_extend code
; 2063 :                 int k = ((i << len) & ((1 << FAST_BITS) - 1)) >> (FAST_BITS - magbits);

  000c3	8b 44 24 10	 mov	 eax, DWORD PTR len$4[rsp]
  000c7	0f b6 c8	 movzx	 ecx, al
  000ca	8b 44 24 04	 mov	 eax, DWORD PTR i$[rsp]
  000ce	d3 e0		 shl	 eax, cl
  000d0	25 ff 01 00 00	 and	 eax, 511		; 000001ffH
  000d5	b9 09 00 00 00	 mov	 ecx, 9
  000da	2b 4c 24 0c	 sub	 ecx, DWORD PTR magbits$3[rsp]
  000de	d3 f8		 sar	 eax, cl
  000e0	89 44 24 08	 mov	 DWORD PTR k$2[rsp], eax

; 2064 :                 int m = 1 << (magbits - 1);

  000e4	8b 44 24 0c	 mov	 eax, DWORD PTR magbits$3[rsp]
  000e8	ff c8		 dec	 eax
  000ea	b9 01 00 00 00	 mov	 ecx, 1
  000ef	89 4c 24 18	 mov	 DWORD PTR tv173[rsp], ecx
  000f3	0f b6 c8	 movzx	 ecx, al
  000f6	8b 44 24 18	 mov	 eax, DWORD PTR tv173[rsp]
  000fa	d3 e0		 shl	 eax, cl
  000fc	89 44 24 1c	 mov	 DWORD PTR m$6[rsp], eax

; 2065 :                 if (k < m) k += (~0U << magbits) + 1;

  00100	8b 44 24 1c	 mov	 eax, DWORD PTR m$6[rsp]
  00104	39 44 24 08	 cmp	 DWORD PTR k$2[rsp], eax
  00108	7d 22		 jge	 SHORT $LN7@stbi__buil
  0010a	8b 44 24 0c	 mov	 eax, DWORD PTR magbits$3[rsp]
  0010e	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00113	89 4c 24 20	 mov	 DWORD PTR tv177[rsp], ecx
  00117	0f b6 c8	 movzx	 ecx, al
  0011a	8b 44 24 20	 mov	 eax, DWORD PTR tv177[rsp]
  0011e	d3 e0		 shl	 eax, cl
  00120	8b 4c 24 08	 mov	 ecx, DWORD PTR k$2[rsp]
  00124	8d 44 01 01	 lea	 eax, DWORD PTR [rcx+rax+1]
  00128	89 44 24 08	 mov	 DWORD PTR k$2[rsp], eax
$LN7@stbi__buil:

; 2066 :                 // if the result is small enough, we can fit it in fast_ac table
; 2067 :                 if (k >= -128 && k <= 127)

  0012c	83 7c 24 08 80	 cmp	 DWORD PTR k$2[rsp], -128 ; ffffffffffffff80H
  00131	7c 32		 jl	 SHORT $LN8@stbi__buil
  00133	83 7c 24 08 7f	 cmp	 DWORD PTR k$2[rsp], 127	; 0000007fH
  00138	7f 2b		 jg	 SHORT $LN8@stbi__buil

; 2068 :                     fast_ac[i] = (stbi__int16) ((k * 256) + (run * 16) + (len + magbits));

  0013a	69 44 24 08 00
	01 00 00	 imul	 eax, DWORD PTR k$2[rsp], 256 ; 00000100H
  00142	6b 4c 24 24 10	 imul	 ecx, DWORD PTR run$7[rsp], 16
  00147	03 c1		 add	 eax, ecx
  00149	8b 4c 24 0c	 mov	 ecx, DWORD PTR magbits$3[rsp]
  0014d	8b 54 24 10	 mov	 edx, DWORD PTR len$4[rsp]
  00151	03 d1		 add	 edx, ecx
  00153	8b ca		 mov	 ecx, edx
  00155	03 c1		 add	 eax, ecx
  00157	48 63 4c 24 04	 movsxd	 rcx, DWORD PTR i$[rsp]
  0015c	48 8b 54 24 40	 mov	 rdx, QWORD PTR fast_ac$[rsp]
  00161	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax
$LN8@stbi__buil:
$LN6@stbi__buil:
$LN5@stbi__buil:

; 2069 :             }
; 2070 :         }
; 2071 :     }

  00165	e9 ae fe ff ff	 jmp	 $LN2@stbi__buil
$LN3@stbi__buil:

; 2072 : }

  0016a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0016e	c3		 ret	 0
?stbi__build_fast_ac@@YAXPEAFPEAUstbi__huffman@@@Z ENDP	; stbi__build_fast_ac
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
j$ = 32
k$ = 36
i$ = 40
code$ = 44
s$1 = 48
tv237 = 52
m$2 = 56
c$3 = 60
h$ = 80
count$ = 88
?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z PROC	; stbi__build_huffman

; 2003 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2004 :     int i,j,k=0;

  0000e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0

; 2005 :     unsigned int code;
; 2006 :     // build size list for each symbol (from JPEG spec)
; 2007 :     for (i=0; i < 16; ++i) {

  00016	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0001e	eb 0a		 jmp	 SHORT $LN4@stbi__buil
$LN2@stbi__buil:
  00020	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00024	ff c0		 inc	 eax
  00026	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__buil:
  0002a	83 7c 24 28 10	 cmp	 DWORD PTR i$[rsp], 16
  0002f	7d 67		 jge	 SHORT $LN3@stbi__buil

; 2008 :         for (j=0; j < count[i]; ++j) {

  00031	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00039	eb 0a		 jmp	 SHORT $LN7@stbi__buil
$LN5@stbi__buil:
  0003b	8b 44 24 20	 mov	 eax, DWORD PTR j$[rsp]
  0003f	ff c0		 inc	 eax
  00041	89 44 24 20	 mov	 DWORD PTR j$[rsp], eax
$LN7@stbi__buil:
  00045	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  0004a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR count$[rsp]
  0004f	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00052	39 44 24 20	 cmp	 DWORD PTR j$[rsp], eax
  00056	7d 3e		 jge	 SHORT $LN6@stbi__buil

; 2009 :             h->size[k++] = (stbi_uc) (i+1);

  00058	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0005c	ff c0		 inc	 eax
  0005e	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR k$[rsp]
  00063	48 8b 54 24 50	 mov	 rdx, QWORD PTR h$[rsp]
  00068	88 84 0a 00 05
	00 00		 mov	 BYTE PTR [rdx+rcx+1280], al
  0006f	8b 44 24 24	 mov	 eax, DWORD PTR k$[rsp]
  00073	ff c0		 inc	 eax
  00075	89 44 24 24	 mov	 DWORD PTR k$[rsp], eax

; 2010 :             if(k >= 257) return stbi__err("bad size list","Corrupt JPEG");

  00079	81 7c 24 24 01
	01 00 00	 cmp	 DWORD PTR k$[rsp], 257	; 00000101H
  00081	7c 11		 jl	 SHORT $LN19@stbi__buil
  00083	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG77417
  0008a	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0008f	e9 0a 02 00 00	 jmp	 $LN1@stbi__buil
$LN19@stbi__buil:

; 2011 :         }

  00094	eb a5		 jmp	 SHORT $LN5@stbi__buil
$LN6@stbi__buil:

; 2012 :     }

  00096	eb 88		 jmp	 SHORT $LN2@stbi__buil
$LN3@stbi__buil:

; 2013 :     h->size[k] = 0;

  00098	48 63 44 24 24	 movsxd	 rax, DWORD PTR k$[rsp]
  0009d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR h$[rsp]
  000a2	c6 84 01 00 05
	00 00 00	 mov	 BYTE PTR [rcx+rax+1280], 0

; 2014 :     
; 2015 :     // compute actual symbols (from jpeg spec)
; 2016 :     code = 0;

  000aa	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR code$[rsp], 0

; 2017 :     k = 0;

  000b2	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0

; 2018 :     for(j=1; j <= 16; ++j) {

  000ba	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR j$[rsp], 1
  000c2	eb 0a		 jmp	 SHORT $LN10@stbi__buil
$LN8@stbi__buil:
  000c4	8b 44 24 20	 mov	 eax, DWORD PTR j$[rsp]
  000c8	ff c0		 inc	 eax
  000ca	89 44 24 20	 mov	 DWORD PTR j$[rsp], eax
$LN10@stbi__buil:
  000ce	83 7c 24 20 10	 cmp	 DWORD PTR j$[rsp], 16
  000d3	0f 8f d4 00 00
	00		 jg	 $LN9@stbi__buil

; 2019 :         // compute delta to add to code to compute symbol id
; 2020 :         h->delta[j] = k - code;

  000d9	8b 44 24 2c	 mov	 eax, DWORD PTR code$[rsp]
  000dd	8b 4c 24 24	 mov	 ecx, DWORD PTR k$[rsp]
  000e1	2b c8		 sub	 ecx, eax
  000e3	8b c1		 mov	 eax, ecx
  000e5	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR j$[rsp]
  000ea	48 8b 54 24 50	 mov	 rdx, QWORD PTR h$[rsp]
  000ef	89 84 8a 4c 06
	00 00		 mov	 DWORD PTR [rdx+rcx*4+1612], eax

; 2021 :         if (h->size[k] == j) {

  000f6	48 63 44 24 24	 movsxd	 rax, DWORD PTR k$[rsp]
  000fb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR h$[rsp]
  00100	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  00108	3b 44 24 20	 cmp	 eax, DWORD PTR j$[rsp]
  0010c	75 6d		 jne	 SHORT $LN20@stbi__buil
$LN11@stbi__buil:

; 2022 :             while (h->size[k] == j)

  0010e	48 63 44 24 24	 movsxd	 rax, DWORD PTR k$[rsp]
  00113	48 8b 4c 24 50	 mov	 rcx, QWORD PTR h$[rsp]
  00118	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  00120	3b 44 24 20	 cmp	 eax, DWORD PTR j$[rsp]
  00124	75 2d		 jne	 SHORT $LN12@stbi__buil

; 2023 :                 h->code[k++] = (stbi__uint16) (code++);

  00126	48 63 44 24 24	 movsxd	 rax, DWORD PTR k$[rsp]
  0012b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR h$[rsp]
  00130	0f b7 54 24 2c	 movzx	 edx, WORD PTR code$[rsp]
  00135	66 89 94 41 00
	02 00 00	 mov	 WORD PTR [rcx+rax*2+512], dx
  0013d	8b 44 24 24	 mov	 eax, DWORD PTR k$[rsp]
  00141	ff c0		 inc	 eax
  00143	89 44 24 24	 mov	 DWORD PTR k$[rsp], eax
  00147	8b 44 24 2c	 mov	 eax, DWORD PTR code$[rsp]
  0014b	ff c0		 inc	 eax
  0014d	89 44 24 2c	 mov	 DWORD PTR code$[rsp], eax
  00151	eb bb		 jmp	 SHORT $LN11@stbi__buil
$LN12@stbi__buil:

; 2024 :             if (code-1 >= (1u << j)) return stbi__err("bad code lengths","Corrupt JPEG");

  00153	8b 44 24 2c	 mov	 eax, DWORD PTR code$[rsp]
  00157	ff c8		 dec	 eax
  00159	8b 4c 24 20	 mov	 ecx, DWORD PTR j$[rsp]
  0015d	ba 01 00 00 00	 mov	 edx, 1
  00162	d3 e2		 shl	 edx, cl
  00164	8b ca		 mov	 ecx, edx
  00166	3b c1		 cmp	 eax, ecx
  00168	72 11		 jb	 SHORT $LN21@stbi__buil
  0016a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG77420
  00171	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00176	e9 23 01 00 00	 jmp	 $LN1@stbi__buil
$LN21@stbi__buil:
$LN20@stbi__buil:

; 2025 :         }
; 2026 :         // compute largest code + 1 for this size, preshifted as needed later
; 2027 :         h->maxcode[j] = code << (16-j);

  0017b	b8 10 00 00 00	 mov	 eax, 16
  00180	2b 44 24 20	 sub	 eax, DWORD PTR j$[rsp]
  00184	0f b6 c8	 movzx	 ecx, al
  00187	8b 44 24 2c	 mov	 eax, DWORD PTR code$[rsp]
  0018b	d3 e0		 shl	 eax, cl
  0018d	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR j$[rsp]
  00192	48 8b 54 24 50	 mov	 rdx, QWORD PTR h$[rsp]
  00197	89 84 8a 04 06
	00 00		 mov	 DWORD PTR [rdx+rcx*4+1540], eax

; 2028 :         code <<= 1;

  0019e	8b 44 24 2c	 mov	 eax, DWORD PTR code$[rsp]
  001a2	d1 e0		 shl	 eax, 1
  001a4	89 44 24 2c	 mov	 DWORD PTR code$[rsp], eax

; 2029 :     }

  001a8	e9 17 ff ff ff	 jmp	 $LN8@stbi__buil
$LN9@stbi__buil:

; 2030 :     h->maxcode[j] = 0xffffffff;

  001ad	48 63 44 24 20	 movsxd	 rax, DWORD PTR j$[rsp]
  001b2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR h$[rsp]
  001b7	c7 84 81 04 06
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [rcx+rax*4+1540], -1 ; ffffffffH

; 2031 :     
; 2032 :     // build non-spec acceleration table; 255 is flag for not-accelerated
; 2033 :     memset(h->fast, 255, 1 << FAST_BITS);

  001c2	48 8b 44 24 50	 mov	 rax, QWORD PTR h$[rsp]
  001c7	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  001cd	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  001d2	48 8b c8	 mov	 rcx, rax
  001d5	e8 00 00 00 00	 call	 memset

; 2034 :     for (i=0; i < k; ++i) {

  001da	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001e2	eb 0a		 jmp	 SHORT $LN15@stbi__buil
$LN13@stbi__buil:
  001e4	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  001e8	ff c0		 inc	 eax
  001ea	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN15@stbi__buil:
  001ee	8b 44 24 24	 mov	 eax, DWORD PTR k$[rsp]
  001f2	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  001f6	0f 8d 9d 00 00
	00		 jge	 $LN14@stbi__buil

; 2035 :         int s = h->size[i];

  001fc	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  00201	48 8b 4c 24 50	 mov	 rcx, QWORD PTR h$[rsp]
  00206	0f b6 84 01 00
	05 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1280]
  0020e	89 44 24 30	 mov	 DWORD PTR s$1[rsp], eax

; 2036 :         if (s <= FAST_BITS) {

  00212	83 7c 24 30 09	 cmp	 DWORD PTR s$1[rsp], 9
  00217	7f 7b		 jg	 SHORT $LN22@stbi__buil

; 2037 :             int c = h->code[i] << (FAST_BITS-s);

  00219	48 63 44 24 28	 movsxd	 rax, DWORD PTR i$[rsp]
  0021e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR h$[rsp]
  00223	0f b7 84 41 00
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax*2+512]
  0022b	b9 09 00 00 00	 mov	 ecx, 9
  00230	2b 4c 24 30	 sub	 ecx, DWORD PTR s$1[rsp]
  00234	d3 e0		 shl	 eax, cl
  00236	89 44 24 3c	 mov	 DWORD PTR c$3[rsp], eax

; 2038 :             int m = 1 << (FAST_BITS-s);

  0023a	b8 09 00 00 00	 mov	 eax, 9
  0023f	2b 44 24 30	 sub	 eax, DWORD PTR s$1[rsp]
  00243	b9 01 00 00 00	 mov	 ecx, 1
  00248	89 4c 24 34	 mov	 DWORD PTR tv237[rsp], ecx
  0024c	0f b6 c8	 movzx	 ecx, al
  0024f	8b 44 24 34	 mov	 eax, DWORD PTR tv237[rsp]
  00253	d3 e0		 shl	 eax, cl
  00255	89 44 24 38	 mov	 DWORD PTR m$2[rsp], eax

; 2039 :             for (j=0; j < m; ++j) {

  00259	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00261	eb 0a		 jmp	 SHORT $LN18@stbi__buil
$LN16@stbi__buil:
  00263	8b 44 24 20	 mov	 eax, DWORD PTR j$[rsp]
  00267	ff c0		 inc	 eax
  00269	89 44 24 20	 mov	 DWORD PTR j$[rsp], eax
$LN18@stbi__buil:
  0026d	8b 44 24 38	 mov	 eax, DWORD PTR m$2[rsp]
  00271	39 44 24 20	 cmp	 DWORD PTR j$[rsp], eax
  00275	7d 1d		 jge	 SHORT $LN17@stbi__buil

; 2040 :                 h->fast[c+j] = (stbi_uc) i;

  00277	8b 44 24 20	 mov	 eax, DWORD PTR j$[rsp]
  0027b	8b 4c 24 3c	 mov	 ecx, DWORD PTR c$3[rsp]
  0027f	03 c8		 add	 ecx, eax
  00281	8b c1		 mov	 eax, ecx
  00283	48 98		 cdqe
  00285	48 8b 4c 24 50	 mov	 rcx, QWORD PTR h$[rsp]
  0028a	0f b6 54 24 28	 movzx	 edx, BYTE PTR i$[rsp]
  0028f	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 2041 :             }

  00292	eb cf		 jmp	 SHORT $LN16@stbi__buil
$LN17@stbi__buil:
$LN22@stbi__buil:

; 2042 :         }
; 2043 :     }

  00294	e9 4b ff ff ff	 jmp	 $LN13@stbi__buil
$LN14@stbi__buil:

; 2044 :     return 1;

  00299	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__buil:

; 2045 : }

  0029e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002a2	c3		 ret	 0
?stbi__build_huffman@@YAHPEAUstbi__huffman@@PEAH@Z ENDP	; stbi__build_huffman
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
i$ = 32
dest$1 = 40
src$2 = 48
j$ = 56
tv130 = 60
tv82 = 64
tv357 = 68
good$ = 72
tv262 = 80
tv282 = 84
tv304 = 88
tv324 = 92
data$ = 112
img_n$ = 120
req_comp$ = 128
x$ = 136
y$ = 144
?stbi__convert_format16@@YAPEAGPEAGHHII@Z PROC		; stbi__convert_format16

; 1812 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1813 :     int i,j;
; 1814 :     stbi__uint16 *good;
; 1815 :     
; 1816 :     if (req_comp == img_n) return data;

  00017	8b 44 24 78	 mov	 eax, DWORD PTR img_n$[rsp]
  0001b	39 84 24 80 00
	00 00		 cmp	 DWORD PTR req_comp$[rsp], eax
  00022	75 0a		 jne	 SHORT $LN43@stbi__conv
  00024	48 8b 44 24 70	 mov	 rax, QWORD PTR data$[rsp]
  00029	e9 fd 09 00 00	 jmp	 $LN1@stbi__conv
$LN43@stbi__conv:

; 1817 :     STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

  0002e	83 bc 24 80 00
	00 00 01	 cmp	 DWORD PTR req_comp$[rsp], 1
  00036	7c 0a		 jl	 SHORT $LN59@stbi__conv
  00038	83 bc 24 80 00
	00 00 04	 cmp	 DWORD PTR req_comp$[rsp], 4
  00040	7e 1b		 jle	 SHORT $LN60@stbi__conv
$LN59@stbi__conv:
  00042	41 b8 19 07 00
	00		 mov	 r8d, 1817		; 00000719H
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG77173
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG77174
  00056	e8 00 00 00 00	 call	 _wassert
  0005b	33 c0		 xor	 eax, eax
$LN60@stbi__conv:

; 1818 :     
; 1819 :     good = (stbi__uint16 *) stbi__malloc(req_comp * x * y * 2);

  0005d	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00064	0f af 84 24 88
	00 00 00	 imul	 eax, DWORD PTR x$[rsp]
  0006c	0f af 84 24 90
	00 00 00	 imul	 eax, DWORD PTR y$[rsp]
  00074	d1 e0		 shl	 eax, 1
  00076	8b c0		 mov	 eax, eax
  00078	8b c8		 mov	 ecx, eax
  0007a	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  0007f	48 89 44 24 48	 mov	 QWORD PTR good$[rsp], rax

; 1820 :     if (good == NULL) {

  00084	48 83 7c 24 48
	00		 cmp	 QWORD PTR good$[rsp], 0
  0008a	75 36		 jne	 SHORT $LN44@stbi__conv

; 1821 :         STBI_FREE(data);

  0008c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR data$[rsp]
  00091	e8 00 00 00 00	 call	 free

; 1822 :         return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");

  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG77176
  0009d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000a2	85 c0		 test	 eax, eax
  000a4	74 0a		 je	 SHORT $LN61@stbi__conv
  000a6	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
  000ae	eb 08		 jmp	 SHORT $LN62@stbi__conv
$LN61@stbi__conv:
  000b0	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN62@stbi__conv:
  000b8	48 63 44 24 40	 movsxd	 rax, DWORD PTR tv82[rsp]
  000bd	e9 69 09 00 00	 jmp	 $LN1@stbi__conv
$LN44@stbi__conv:

; 1823 :     }
; 1824 :     
; 1825 :     for (j=0; j < (int) y; ++j) {

  000c2	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  000ca	eb 0a		 jmp	 SHORT $LN4@stbi__conv
$LN2@stbi__conv:
  000cc	8b 44 24 38	 mov	 eax, DWORD PTR j$[rsp]
  000d0	ff c0		 inc	 eax
  000d2	89 44 24 38	 mov	 DWORD PTR j$[rsp], eax
$LN4@stbi__conv:
  000d6	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR y$[rsp]
  000dd	39 44 24 38	 cmp	 DWORD PTR j$[rsp], eax
  000e1	0f 8d 35 09 00
	00		 jge	 $LN3@stbi__conv

; 1826 :         stbi__uint16 *src  = data + j * x * img_n   ;

  000e7	8b 44 24 38	 mov	 eax, DWORD PTR j$[rsp]
  000eb	0f af 84 24 88
	00 00 00	 imul	 eax, DWORD PTR x$[rsp]
  000f3	0f af 44 24 78	 imul	 eax, DWORD PTR img_n$[rsp]
  000f8	8b c0		 mov	 eax, eax
  000fa	48 8b 4c 24 70	 mov	 rcx, QWORD PTR data$[rsp]
  000ff	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  00103	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax

; 1827 :         stbi__uint16 *dest = good + j * x * req_comp;

  00108	8b 44 24 38	 mov	 eax, DWORD PTR j$[rsp]
  0010c	0f af 84 24 88
	00 00 00	 imul	 eax, DWORD PTR x$[rsp]
  00114	0f af 84 24 80
	00 00 00	 imul	 eax, DWORD PTR req_comp$[rsp]
  0011c	8b c0		 mov	 eax, eax
  0011e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR good$[rsp]
  00123	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  00127	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax

; 1828 :         
; 1829 : #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1830 : #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1831 :         // convert source image with img_n components to one with req_comp components;
; 1832 :         // avoid switch per pixel, so use switch per scanline and massive macros
; 1833 :         switch (STBI__COMBO(img_n, req_comp)) {

  0012c	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00133	8b 4c 24 78	 mov	 ecx, DWORD PTR img_n$[rsp]
  00137	8d 04 c8	 lea	 eax, DWORD PTR [rax+rcx*8]
  0013a	89 44 24 3c	 mov	 DWORD PTR tv130[rsp], eax
  0013e	8b 44 24 3c	 mov	 eax, DWORD PTR tv130[rsp]
  00142	83 e8 0a	 sub	 eax, 10
  00145	89 44 24 3c	 mov	 DWORD PTR tv130[rsp], eax
  00149	83 7c 24 3c 19	 cmp	 DWORD PTR tv130[rsp], 25
  0014e	0f 87 65 08 00
	00		 ja	 $LN57@stbi__conv
  00154	48 63 44 24 3c	 movsxd	 rax, DWORD PTR tv130[rsp]
  00159	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00160	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN66@stbi__conv[rcx+rax*4]
  00167	48 03 c1	 add	 rax, rcx
  0016a	ff e0		 jmp	 rax
$LN45@stbi__conv:

; 1834 :             STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=0xffff;                                     } break;

  0016c	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00173	ff c8		 dec	 eax
  00175	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00179	eb 26		 jmp	 SHORT $LN9@stbi__conv
$LN7@stbi__conv:
  0017b	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0017f	ff c8		 dec	 eax
  00181	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00185	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  0018a	48 83 c0 02	 add	 rax, 2
  0018e	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  00193	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  00198	48 83 c0 04	 add	 rax, 4
  0019c	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN9@stbi__conv:
  001a1	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  001a6	7c 3e		 jl	 SHORT $LN8@stbi__conv
  001a8	b8 02 00 00 00	 mov	 eax, 2
  001ad	48 6b c0 00	 imul	 rax, rax, 0
  001b1	b9 02 00 00 00	 mov	 ecx, 2
  001b6	48 6b c9 00	 imul	 rcx, rcx, 0
  001ba	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  001bf	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  001c4	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  001c9	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  001cd	b8 02 00 00 00	 mov	 eax, 2
  001d2	48 6b c0 01	 imul	 rax, rax, 1
  001d6	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  001db	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  001e0	66 89 0c 02	 mov	 WORD PTR [rdx+rax], cx
  001e4	eb 95		 jmp	 SHORT $LN7@stbi__conv
$LN8@stbi__conv:
  001e6	e9 2c 08 00 00	 jmp	 $LN5@stbi__conv
$LN46@stbi__conv:

; 1835 :             STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;

  001eb	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  001f2	ff c8		 dec	 eax
  001f4	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  001f8	eb 26		 jmp	 SHORT $LN12@stbi__conv
$LN10@stbi__conv:
  001fa	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001fe	ff c8		 dec	 eax
  00200	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00204	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  00209	48 83 c0 02	 add	 rax, 2
  0020d	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  00212	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  00217	48 83 c0 06	 add	 rax, 6
  0021b	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN12@stbi__conv:
  00220	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00225	7c 74		 jl	 SHORT $LN11@stbi__conv
  00227	b8 02 00 00 00	 mov	 eax, 2
  0022c	48 6b c0 00	 imul	 rax, rax, 0
  00230	b9 02 00 00 00	 mov	 ecx, 2
  00235	48 6b c9 02	 imul	 rcx, rcx, 2
  00239	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0023e	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  00243	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00248	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  0024c	b8 02 00 00 00	 mov	 eax, 2
  00251	48 6b c0 02	 imul	 rax, rax, 2
  00255	b9 02 00 00 00	 mov	 ecx, 2
  0025a	48 6b c9 01	 imul	 rcx, rcx, 1
  0025e	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00263	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  00268	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  0026d	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00271	b8 02 00 00 00	 mov	 eax, 2
  00276	48 6b c0 01	 imul	 rax, rax, 1
  0027a	b9 02 00 00 00	 mov	 ecx, 2
  0027f	48 6b c9 00	 imul	 rcx, rcx, 0
  00283	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00288	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  0028d	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00292	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00296	e9 5f ff ff ff	 jmp	 $LN10@stbi__conv
$LN11@stbi__conv:
  0029b	e9 77 07 00 00	 jmp	 $LN5@stbi__conv
$LN47@stbi__conv:

; 1836 :             STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=0xffff;                     } break;

  002a0	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  002a7	ff c8		 dec	 eax
  002a9	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  002ad	eb 26		 jmp	 SHORT $LN15@stbi__conv
$LN13@stbi__conv:
  002af	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  002b3	ff c8		 dec	 eax
  002b5	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  002b9	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  002be	48 83 c0 02	 add	 rax, 2
  002c2	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  002c7	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  002cc	48 83 c0 08	 add	 rax, 8
  002d0	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN15@stbi__conv:
  002d5	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  002da	0f 8c 8b 00 00
	00		 jl	 $LN14@stbi__conv
  002e0	b8 02 00 00 00	 mov	 eax, 2
  002e5	48 6b c0 00	 imul	 rax, rax, 0
  002e9	b9 02 00 00 00	 mov	 ecx, 2
  002ee	48 6b c9 02	 imul	 rcx, rcx, 2
  002f2	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  002f7	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  002fc	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00301	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00305	b8 02 00 00 00	 mov	 eax, 2
  0030a	48 6b c0 02	 imul	 rax, rax, 2
  0030e	b9 02 00 00 00	 mov	 ecx, 2
  00313	48 6b c9 01	 imul	 rcx, rcx, 1
  00317	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0031c	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  00321	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00326	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  0032a	b8 02 00 00 00	 mov	 eax, 2
  0032f	48 6b c0 01	 imul	 rax, rax, 1
  00333	b9 02 00 00 00	 mov	 ecx, 2
  00338	48 6b c9 00	 imul	 rcx, rcx, 0
  0033c	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00341	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  00346	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  0034b	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  0034f	b8 02 00 00 00	 mov	 eax, 2
  00354	48 6b c0 03	 imul	 rax, rax, 3
  00358	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0035d	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00362	66 89 0c 02	 mov	 WORD PTR [rdx+rax], cx
  00366	e9 44 ff ff ff	 jmp	 $LN13@stbi__conv
$LN14@stbi__conv:
  0036b	e9 a7 06 00 00	 jmp	 $LN5@stbi__conv
$LN48@stbi__conv:

; 1837 :             STBI__CASE(2,1) { dest[0]=src[0];                                                     } break;

  00370	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00377	ff c8		 dec	 eax
  00379	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0037d	eb 26		 jmp	 SHORT $LN18@stbi__conv
$LN16@stbi__conv:
  0037f	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00383	ff c8		 dec	 eax
  00385	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00389	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  0038e	48 83 c0 04	 add	 rax, 4
  00392	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  00397	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  0039c	48 83 c0 02	 add	 rax, 2
  003a0	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN18@stbi__conv:
  003a5	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  003aa	7c 27		 jl	 SHORT $LN17@stbi__conv
  003ac	b8 02 00 00 00	 mov	 eax, 2
  003b1	48 6b c0 00	 imul	 rax, rax, 0
  003b5	b9 02 00 00 00	 mov	 ecx, 2
  003ba	48 6b c9 00	 imul	 rcx, rcx, 0
  003be	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  003c3	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  003c8	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  003cd	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  003d1	eb ac		 jmp	 SHORT $LN16@stbi__conv
$LN17@stbi__conv:
  003d3	e9 3f 06 00 00	 jmp	 $LN5@stbi__conv
$LN49@stbi__conv:

; 1838 :             STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                     } break;

  003d8	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  003df	ff c8		 dec	 eax
  003e1	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  003e5	eb 26		 jmp	 SHORT $LN21@stbi__conv
$LN19@stbi__conv:
  003e7	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  003eb	ff c8		 dec	 eax
  003ed	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  003f1	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  003f6	48 83 c0 04	 add	 rax, 4
  003fa	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  003ff	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  00404	48 83 c0 06	 add	 rax, 6
  00408	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN21@stbi__conv:
  0040d	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00412	7c 74		 jl	 SHORT $LN20@stbi__conv
  00414	b8 02 00 00 00	 mov	 eax, 2
  00419	48 6b c0 00	 imul	 rax, rax, 0
  0041d	b9 02 00 00 00	 mov	 ecx, 2
  00422	48 6b c9 02	 imul	 rcx, rcx, 2
  00426	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0042b	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  00430	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00435	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00439	b8 02 00 00 00	 mov	 eax, 2
  0043e	48 6b c0 02	 imul	 rax, rax, 2
  00442	b9 02 00 00 00	 mov	 ecx, 2
  00447	48 6b c9 01	 imul	 rcx, rcx, 1
  0044b	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00450	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  00455	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  0045a	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  0045e	b8 02 00 00 00	 mov	 eax, 2
  00463	48 6b c0 01	 imul	 rax, rax, 1
  00467	b9 02 00 00 00	 mov	 ecx, 2
  0046c	48 6b c9 00	 imul	 rcx, rcx, 0
  00470	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00475	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  0047a	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  0047f	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00483	e9 5f ff ff ff	 jmp	 $LN19@stbi__conv
$LN20@stbi__conv:
  00488	e9 8a 05 00 00	 jmp	 $LN5@stbi__conv
$LN50@stbi__conv:

; 1839 :             STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                     } break;

  0048d	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00494	ff c8		 dec	 eax
  00496	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0049a	eb 26		 jmp	 SHORT $LN24@stbi__conv
$LN22@stbi__conv:
  0049c	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  004a0	ff c8		 dec	 eax
  004a2	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  004a6	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  004ab	48 83 c0 04	 add	 rax, 4
  004af	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  004b4	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  004b9	48 83 c0 08	 add	 rax, 8
  004bd	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN24@stbi__conv:
  004c2	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  004c7	0f 8c 99 00 00
	00		 jl	 $LN23@stbi__conv
  004cd	b8 02 00 00 00	 mov	 eax, 2
  004d2	48 6b c0 00	 imul	 rax, rax, 0
  004d6	b9 02 00 00 00	 mov	 ecx, 2
  004db	48 6b c9 02	 imul	 rcx, rcx, 2
  004df	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  004e4	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  004e9	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  004ee	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  004f2	b8 02 00 00 00	 mov	 eax, 2
  004f7	48 6b c0 02	 imul	 rax, rax, 2
  004fb	b9 02 00 00 00	 mov	 ecx, 2
  00500	48 6b c9 01	 imul	 rcx, rcx, 1
  00504	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00509	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  0050e	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00513	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00517	b8 02 00 00 00	 mov	 eax, 2
  0051c	48 6b c0 01	 imul	 rax, rax, 1
  00520	b9 02 00 00 00	 mov	 ecx, 2
  00525	48 6b c9 00	 imul	 rcx, rcx, 0
  00529	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0052e	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  00533	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00538	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  0053c	b8 02 00 00 00	 mov	 eax, 2
  00541	48 6b c0 01	 imul	 rax, rax, 1
  00545	b9 02 00 00 00	 mov	 ecx, 2
  0054a	48 6b c9 03	 imul	 rcx, rcx, 3
  0054e	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00553	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  00558	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  0055d	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00561	e9 36 ff ff ff	 jmp	 $LN22@stbi__conv
$LN23@stbi__conv:
  00566	e9 ac 04 00 00	 jmp	 $LN5@stbi__conv
$LN51@stbi__conv:

; 1840 :             STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=0xffff;        } break;

  0056b	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00572	ff c8		 dec	 eax
  00574	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00578	eb 26		 jmp	 SHORT $LN27@stbi__conv
$LN25@stbi__conv:
  0057a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0057e	ff c8		 dec	 eax
  00580	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00584	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  00589	48 83 c0 06	 add	 rax, 6
  0058d	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  00592	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  00597	48 83 c0 08	 add	 rax, 8
  0059b	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN27@stbi__conv:
  005a0	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  005a5	0f 8c 8b 00 00
	00		 jl	 $LN26@stbi__conv
  005ab	b8 02 00 00 00	 mov	 eax, 2
  005b0	48 6b c0 00	 imul	 rax, rax, 0
  005b4	b9 02 00 00 00	 mov	 ecx, 2
  005b9	48 6b c9 00	 imul	 rcx, rcx, 0
  005bd	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  005c2	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  005c7	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  005cc	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  005d0	b8 02 00 00 00	 mov	 eax, 2
  005d5	48 6b c0 01	 imul	 rax, rax, 1
  005d9	b9 02 00 00 00	 mov	 ecx, 2
  005de	48 6b c9 01	 imul	 rcx, rcx, 1
  005e2	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  005e7	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  005ec	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  005f1	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  005f5	b8 02 00 00 00	 mov	 eax, 2
  005fa	48 6b c0 02	 imul	 rax, rax, 2
  005fe	b9 02 00 00 00	 mov	 ecx, 2
  00603	48 6b c9 02	 imul	 rcx, rcx, 2
  00607	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0060c	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  00611	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00616	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  0061a	b8 02 00 00 00	 mov	 eax, 2
  0061f	48 6b c0 03	 imul	 rax, rax, 3
  00623	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00628	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0062d	66 89 0c 02	 mov	 WORD PTR [rdx+rax], cx
  00631	e9 44 ff ff ff	 jmp	 $LN25@stbi__conv
$LN26@stbi__conv:
  00636	e9 dc 03 00 00	 jmp	 $LN5@stbi__conv
$LN52@stbi__conv:

; 1841 :             STBI__CASE(3,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;

  0063b	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00642	ff c8		 dec	 eax
  00644	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00648	eb 26		 jmp	 SHORT $LN30@stbi__conv
$LN28@stbi__conv:
  0064a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0064e	ff c8		 dec	 eax
  00650	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00654	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  00659	48 83 c0 06	 add	 rax, 6
  0065d	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  00662	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  00667	48 83 c0 02	 add	 rax, 2
  0066b	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN30@stbi__conv:
  00670	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00675	7c 62		 jl	 SHORT $LN29@stbi__conv
  00677	b8 02 00 00 00	 mov	 eax, 2
  0067c	48 6b c0 02	 imul	 rax, rax, 2
  00680	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$2[rsp]
  00685	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  00689	b9 02 00 00 00	 mov	 ecx, 2
  0068e	48 6b c9 01	 imul	 rcx, rcx, 1
  00692	48 8b 54 24 30	 mov	 rdx, QWORD PTR src$2[rsp]
  00697	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  0069b	ba 02 00 00 00	 mov	 edx, 2
  006a0	48 6b d2 00	 imul	 rdx, rdx, 0
  006a4	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  006a9	41 0f b7 14 10	 movzx	 edx, WORD PTR [r8+rdx]
  006ae	89 54 24 50	 mov	 DWORD PTR tv262[rsp], edx
  006b2	44 8b c0	 mov	 r8d, eax
  006b5	8b d1		 mov	 edx, ecx
  006b7	8b 44 24 50	 mov	 eax, DWORD PTR tv262[rsp]
  006bb	8b c8		 mov	 ecx, eax
  006bd	e8 00 00 00 00	 call	 ?stbi__compute_y_16@@YAGHHH@Z ; stbi__compute_y_16
  006c2	b9 02 00 00 00	 mov	 ecx, 2
  006c7	48 6b c9 00	 imul	 rcx, rcx, 0
  006cb	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  006d0	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  006d4	e9 71 ff ff ff	 jmp	 $LN28@stbi__conv
$LN29@stbi__conv:
  006d9	e9 39 03 00 00	 jmp	 $LN5@stbi__conv
$LN53@stbi__conv:

; 1842 :             STBI__CASE(3,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = 0xffff; } break;

  006de	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  006e5	ff c8		 dec	 eax
  006e7	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  006eb	eb 26		 jmp	 SHORT $LN33@stbi__conv
$LN31@stbi__conv:
  006ed	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  006f1	ff c8		 dec	 eax
  006f3	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  006f7	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  006fc	48 83 c0 06	 add	 rax, 6
  00700	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  00705	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  0070a	48 83 c0 04	 add	 rax, 4
  0070e	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN33@stbi__conv:
  00713	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00718	7c 79		 jl	 SHORT $LN32@stbi__conv
  0071a	b8 02 00 00 00	 mov	 eax, 2
  0071f	48 6b c0 02	 imul	 rax, rax, 2
  00723	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$2[rsp]
  00728	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  0072c	b9 02 00 00 00	 mov	 ecx, 2
  00731	48 6b c9 01	 imul	 rcx, rcx, 1
  00735	48 8b 54 24 30	 mov	 rdx, QWORD PTR src$2[rsp]
  0073a	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  0073e	ba 02 00 00 00	 mov	 edx, 2
  00743	48 6b d2 00	 imul	 rdx, rdx, 0
  00747	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  0074c	41 0f b7 14 10	 movzx	 edx, WORD PTR [r8+rdx]
  00751	89 54 24 54	 mov	 DWORD PTR tv282[rsp], edx
  00755	44 8b c0	 mov	 r8d, eax
  00758	8b d1		 mov	 edx, ecx
  0075a	8b 44 24 54	 mov	 eax, DWORD PTR tv282[rsp]
  0075e	8b c8		 mov	 ecx, eax
  00760	e8 00 00 00 00	 call	 ?stbi__compute_y_16@@YAGHHH@Z ; stbi__compute_y_16
  00765	b9 02 00 00 00	 mov	 ecx, 2
  0076a	48 6b c9 00	 imul	 rcx, rcx, 0
  0076e	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00773	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00777	b8 02 00 00 00	 mov	 eax, 2
  0077c	48 6b c0 01	 imul	 rax, rax, 1
  00780	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00785	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0078a	66 89 0c 02	 mov	 WORD PTR [rdx+rax], cx
  0078e	e9 5a ff ff ff	 jmp	 $LN31@stbi__conv
$LN32@stbi__conv:
  00793	e9 7f 02 00 00	 jmp	 $LN5@stbi__conv
$LN54@stbi__conv:

; 1843 :             STBI__CASE(4,1) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]);                   } break;

  00798	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  0079f	ff c8		 dec	 eax
  007a1	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  007a5	eb 26		 jmp	 SHORT $LN36@stbi__conv
$LN34@stbi__conv:
  007a7	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  007ab	ff c8		 dec	 eax
  007ad	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  007b1	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  007b6	48 83 c0 08	 add	 rax, 8
  007ba	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  007bf	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  007c4	48 83 c0 02	 add	 rax, 2
  007c8	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN36@stbi__conv:
  007cd	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  007d2	7c 62		 jl	 SHORT $LN35@stbi__conv
  007d4	b8 02 00 00 00	 mov	 eax, 2
  007d9	48 6b c0 02	 imul	 rax, rax, 2
  007dd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$2[rsp]
  007e2	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  007e6	b9 02 00 00 00	 mov	 ecx, 2
  007eb	48 6b c9 01	 imul	 rcx, rcx, 1
  007ef	48 8b 54 24 30	 mov	 rdx, QWORD PTR src$2[rsp]
  007f4	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  007f8	ba 02 00 00 00	 mov	 edx, 2
  007fd	48 6b d2 00	 imul	 rdx, rdx, 0
  00801	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  00806	41 0f b7 14 10	 movzx	 edx, WORD PTR [r8+rdx]
  0080b	89 54 24 58	 mov	 DWORD PTR tv304[rsp], edx
  0080f	44 8b c0	 mov	 r8d, eax
  00812	8b d1		 mov	 edx, ecx
  00814	8b 44 24 58	 mov	 eax, DWORD PTR tv304[rsp]
  00818	8b c8		 mov	 ecx, eax
  0081a	e8 00 00 00 00	 call	 ?stbi__compute_y_16@@YAGHHH@Z ; stbi__compute_y_16
  0081f	b9 02 00 00 00	 mov	 ecx, 2
  00824	48 6b c9 00	 imul	 rcx, rcx, 0
  00828	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0082d	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00831	e9 71 ff ff ff	 jmp	 $LN34@stbi__conv
$LN35@stbi__conv:
  00836	e9 dc 01 00 00	 jmp	 $LN5@stbi__conv
$LN55@stbi__conv:

; 1844 :             STBI__CASE(4,2) { dest[0]=stbi__compute_y_16(src[0],src[1],src[2]); dest[1] = src[3]; } break;

  0083b	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00842	ff c8		 dec	 eax
  00844	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00848	eb 26		 jmp	 SHORT $LN39@stbi__conv
$LN37@stbi__conv:
  0084a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0084e	ff c8		 dec	 eax
  00850	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00854	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  00859	48 83 c0 08	 add	 rax, 8
  0085d	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  00862	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  00867	48 83 c0 04	 add	 rax, 4
  0086b	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN39@stbi__conv:
  00870	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00875	0f 8c 87 00 00
	00		 jl	 $LN38@stbi__conv
  0087b	b8 02 00 00 00	 mov	 eax, 2
  00880	48 6b c0 02	 imul	 rax, rax, 2
  00884	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$2[rsp]
  00889	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  0088d	b9 02 00 00 00	 mov	 ecx, 2
  00892	48 6b c9 01	 imul	 rcx, rcx, 1
  00896	48 8b 54 24 30	 mov	 rdx, QWORD PTR src$2[rsp]
  0089b	0f b7 0c 0a	 movzx	 ecx, WORD PTR [rdx+rcx]
  0089f	ba 02 00 00 00	 mov	 edx, 2
  008a4	48 6b d2 00	 imul	 rdx, rdx, 0
  008a8	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  008ad	41 0f b7 14 10	 movzx	 edx, WORD PTR [r8+rdx]
  008b2	89 54 24 5c	 mov	 DWORD PTR tv324[rsp], edx
  008b6	44 8b c0	 mov	 r8d, eax
  008b9	8b d1		 mov	 edx, ecx
  008bb	8b 44 24 5c	 mov	 eax, DWORD PTR tv324[rsp]
  008bf	8b c8		 mov	 ecx, eax
  008c1	e8 00 00 00 00	 call	 ?stbi__compute_y_16@@YAGHHH@Z ; stbi__compute_y_16
  008c6	b9 02 00 00 00	 mov	 ecx, 2
  008cb	48 6b c9 00	 imul	 rcx, rcx, 0
  008cf	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  008d4	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  008d8	b8 02 00 00 00	 mov	 eax, 2
  008dd	48 6b c0 03	 imul	 rax, rax, 3
  008e1	b9 02 00 00 00	 mov	 ecx, 2
  008e6	48 6b c9 01	 imul	 rcx, rcx, 1
  008ea	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  008ef	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  008f4	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  008f9	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  008fd	e9 48 ff ff ff	 jmp	 $LN37@stbi__conv
$LN38@stbi__conv:
  00902	e9 10 01 00 00	 jmp	 $LN5@stbi__conv
$LN56@stbi__conv:

; 1845 :             STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                       } break;

  00907	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  0090e	ff c8		 dec	 eax
  00910	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00914	eb 26		 jmp	 SHORT $LN42@stbi__conv
$LN40@stbi__conv:
  00916	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0091a	ff c8		 dec	 eax
  0091c	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00920	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  00925	48 83 c0 08	 add	 rax, 8
  00929	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  0092e	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  00933	48 83 c0 06	 add	 rax, 6
  00937	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN42@stbi__conv:
  0093c	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00941	7c 74		 jl	 SHORT $LN41@stbi__conv
  00943	b8 02 00 00 00	 mov	 eax, 2
  00948	48 6b c0 00	 imul	 rax, rax, 0
  0094c	b9 02 00 00 00	 mov	 ecx, 2
  00951	48 6b c9 00	 imul	 rcx, rcx, 0
  00955	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0095a	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  0095f	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00964	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  00968	b8 02 00 00 00	 mov	 eax, 2
  0096d	48 6b c0 01	 imul	 rax, rax, 1
  00971	b9 02 00 00 00	 mov	 ecx, 2
  00976	48 6b c9 01	 imul	 rcx, rcx, 1
  0097a	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0097f	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  00984	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  00989	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  0098d	b8 02 00 00 00	 mov	 eax, 2
  00992	48 6b c0 02	 imul	 rax, rax, 2
  00996	b9 02 00 00 00	 mov	 ecx, 2
  0099b	48 6b c9 02	 imul	 rcx, rcx, 2
  0099f	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  009a4	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  009a9	41 0f b7 04 00	 movzx	 eax, WORD PTR [r8+rax]
  009ae	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
  009b2	e9 5f ff ff ff	 jmp	 $LN40@stbi__conv
$LN41@stbi__conv:
  009b7	eb 5e		 jmp	 SHORT $LN5@stbi__conv
$LN57@stbi__conv:

; 1846 :             default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return (stbi__uint16*) stbi__errpuc("unsupported", "Unsupported format conversion");

  009b9	33 c0		 xor	 eax, eax
  009bb	85 c0		 test	 eax, eax
  009bd	75 1b		 jne	 SHORT $LN63@stbi__conv
  009bf	41 b8 36 07 00
	00		 mov	 r8d, 1846		; 00000736H
  009c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG77190
  009cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG77191
  009d3	e8 00 00 00 00	 call	 _wassert
  009d8	33 c0		 xor	 eax, eax
$LN63@stbi__conv:
  009da	48 8b 4c 24 70	 mov	 rcx, QWORD PTR data$[rsp]
  009df	e8 00 00 00 00	 call	 free
  009e4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR good$[rsp]
  009e9	e8 00 00 00 00	 call	 free
  009ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG77192
  009f5	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  009fa	85 c0		 test	 eax, eax
  009fc	74 0a		 je	 SHORT $LN64@stbi__conv
  009fe	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv357[rsp], 0
  00a06	eb 08		 jmp	 SHORT $LN65@stbi__conv
$LN64@stbi__conv:
  00a08	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv357[rsp], 0
$LN65@stbi__conv:
  00a10	48 63 44 24 44	 movsxd	 rax, DWORD PTR tv357[rsp]
  00a15	eb 14		 jmp	 SHORT $LN1@stbi__conv
$LN5@stbi__conv:

; 1847 :         }
; 1848 : #undef STBI__CASE
; 1849 :     }

  00a17	e9 b0 f6 ff ff	 jmp	 $LN2@stbi__conv
$LN3@stbi__conv:

; 1850 :     
; 1851 :     STBI_FREE(data);

  00a1c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR data$[rsp]
  00a21	e8 00 00 00 00	 call	 free

; 1852 :     return good;

  00a26	48 8b 44 24 48	 mov	 rax, QWORD PTR good$[rsp]
$LN1@stbi__conv:

; 1853 : }

  00a2b	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00a2f	c3		 ret	 0
$LN66@stbi__conv:
  00a30	00 00 00 00	 DD	 $LN45@stbi__conv
  00a34	00 00 00 00	 DD	 $LN46@stbi__conv
  00a38	00 00 00 00	 DD	 $LN47@stbi__conv
  00a3c	00 00 00 00	 DD	 $LN57@stbi__conv
  00a40	00 00 00 00	 DD	 $LN57@stbi__conv
  00a44	00 00 00 00	 DD	 $LN57@stbi__conv
  00a48	00 00 00 00	 DD	 $LN57@stbi__conv
  00a4c	00 00 00 00	 DD	 $LN48@stbi__conv
  00a50	00 00 00 00	 DD	 $LN57@stbi__conv
  00a54	00 00 00 00	 DD	 $LN49@stbi__conv
  00a58	00 00 00 00	 DD	 $LN50@stbi__conv
  00a5c	00 00 00 00	 DD	 $LN57@stbi__conv
  00a60	00 00 00 00	 DD	 $LN57@stbi__conv
  00a64	00 00 00 00	 DD	 $LN57@stbi__conv
  00a68	00 00 00 00	 DD	 $LN57@stbi__conv
  00a6c	00 00 00 00	 DD	 $LN52@stbi__conv
  00a70	00 00 00 00	 DD	 $LN53@stbi__conv
  00a74	00 00 00 00	 DD	 $LN57@stbi__conv
  00a78	00 00 00 00	 DD	 $LN51@stbi__conv
  00a7c	00 00 00 00	 DD	 $LN57@stbi__conv
  00a80	00 00 00 00	 DD	 $LN57@stbi__conv
  00a84	00 00 00 00	 DD	 $LN57@stbi__conv
  00a88	00 00 00 00	 DD	 $LN57@stbi__conv
  00a8c	00 00 00 00	 DD	 $LN54@stbi__conv
  00a90	00 00 00 00	 DD	 $LN55@stbi__conv
  00a94	00 00 00 00	 DD	 $LN56@stbi__conv
?stbi__convert_format16@@YAPEAGPEAGHHII@Z ENDP		; stbi__convert_format16
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
r$ = 8
g$ = 16
b$ = 24
?stbi__compute_y_16@@YAGHHH@Z PROC			; stbi__compute_y_16

; 1803 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 1804 :     return (stbi__uint16) (((r*77) + (g*150) +  (29*b)) >> 8);

  0000d	6b 44 24 08 4d	 imul	 eax, DWORD PTR r$[rsp], 77 ; 0000004dH
  00012	69 4c 24 10 96
	00 00 00	 imul	 ecx, DWORD PTR g$[rsp], 150 ; 00000096H
  0001a	03 c1		 add	 eax, ecx
  0001c	6b 4c 24 18 1d	 imul	 ecx, DWORD PTR b$[rsp], 29
  00021	03 c1		 add	 eax, ecx
  00023	c1 f8 08	 sar	 eax, 8

; 1805 : }

  00026	c3		 ret	 0
?stbi__compute_y_16@@YAGHHH@Z ENDP			; stbi__compute_y_16
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
i$ = 32
dest$1 = 40
src$2 = 48
j$ = 56
tv95 = 60
tv81 = 64
tv354 = 68
good$ = 72
tv259 = 80
tv279 = 84
tv301 = 88
tv321 = 92
data$ = 112
img_n$ = 120
req_comp$ = 128
x$ = 136
y$ = 144
?stbi__convert_format@@YAPEAEPEAEHHII@Z PROC		; stbi__convert_format

; 1755 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1756 :     int i,j;
; 1757 :     unsigned char *good;
; 1758 :     
; 1759 :     if (req_comp == img_n) return data;

  00017	8b 44 24 78	 mov	 eax, DWORD PTR img_n$[rsp]
  0001b	39 84 24 80 00
	00 00		 cmp	 DWORD PTR req_comp$[rsp], eax
  00022	75 0a		 jne	 SHORT $LN43@stbi__conv
  00024	48 8b 44 24 70	 mov	 rax, QWORD PTR data$[rsp]
  00029	e9 c9 09 00 00	 jmp	 $LN1@stbi__conv
$LN43@stbi__conv:

; 1760 :     STBI_ASSERT(req_comp >= 1 && req_comp <= 4);

  0002e	83 bc 24 80 00
	00 00 01	 cmp	 DWORD PTR req_comp$[rsp], 1
  00036	7c 0a		 jl	 SHORT $LN59@stbi__conv
  00038	83 bc 24 80 00
	00 00 04	 cmp	 DWORD PTR req_comp$[rsp], 4
  00040	7e 1b		 jle	 SHORT $LN60@stbi__conv
$LN59@stbi__conv:
  00042	41 b8 e0 06 00
	00		 mov	 r8d, 1760		; 000006e0H
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG77081
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG77082
  00056	e8 00 00 00 00	 call	 _wassert
  0005b	33 c0		 xor	 eax, eax
$LN60@stbi__conv:

; 1761 :     
; 1762 :     good = (unsigned char *) stbi__malloc_mad3(req_comp, x, y, 0);

  0005d	45 33 c9	 xor	 r9d, r9d
  00060	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR y$[rsp]
  00068	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR x$[rsp]
  0006f	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR req_comp$[rsp]
  00076	e8 00 00 00 00	 call	 ?stbi__malloc_mad3@@YAPEAXHHHH@Z ; stbi__malloc_mad3
  0007b	48 89 44 24 48	 mov	 QWORD PTR good$[rsp], rax

; 1763 :     if (good == NULL) {

  00080	48 83 7c 24 48
	00		 cmp	 QWORD PTR good$[rsp], 0
  00086	75 36		 jne	 SHORT $LN44@stbi__conv

; 1764 :         STBI_FREE(data);

  00088	48 8b 4c 24 70	 mov	 rcx, QWORD PTR data$[rsp]
  0008d	e8 00 00 00 00	 call	 free

; 1765 :         return stbi__errpuc("outofmem", "Out of memory");

  00092	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG77084
  00099	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0009e	85 c0		 test	 eax, eax
  000a0	74 0a		 je	 SHORT $LN61@stbi__conv
  000a2	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
  000aa	eb 08		 jmp	 SHORT $LN62@stbi__conv
$LN61@stbi__conv:
  000ac	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN62@stbi__conv:
  000b4	48 63 44 24 40	 movsxd	 rax, DWORD PTR tv81[rsp]
  000b9	e9 39 09 00 00	 jmp	 $LN1@stbi__conv
$LN44@stbi__conv:

; 1766 :     }
; 1767 :     
; 1768 :     for (j=0; j < (int) y; ++j) {

  000be	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  000c6	eb 0a		 jmp	 SHORT $LN4@stbi__conv
$LN2@stbi__conv:
  000c8	8b 44 24 38	 mov	 eax, DWORD PTR j$[rsp]
  000cc	ff c0		 inc	 eax
  000ce	89 44 24 38	 mov	 DWORD PTR j$[rsp], eax
$LN4@stbi__conv:
  000d2	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR y$[rsp]
  000d9	39 44 24 38	 cmp	 DWORD PTR j$[rsp], eax
  000dd	0f 8d 05 09 00
	00		 jge	 $LN3@stbi__conv

; 1769 :         unsigned char *src  = data + j * x * img_n   ;

  000e3	8b 44 24 38	 mov	 eax, DWORD PTR j$[rsp]
  000e7	0f af 84 24 88
	00 00 00	 imul	 eax, DWORD PTR x$[rsp]
  000ef	0f af 44 24 78	 imul	 eax, DWORD PTR img_n$[rsp]
  000f4	8b c0		 mov	 eax, eax
  000f6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR data$[rsp]
  000fb	48 03 c8	 add	 rcx, rax
  000fe	48 8b c1	 mov	 rax, rcx
  00101	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax

; 1770 :         unsigned char *dest = good + j * x * req_comp;

  00106	8b 44 24 38	 mov	 eax, DWORD PTR j$[rsp]
  0010a	0f af 84 24 88
	00 00 00	 imul	 eax, DWORD PTR x$[rsp]
  00112	0f af 84 24 80
	00 00 00	 imul	 eax, DWORD PTR req_comp$[rsp]
  0011a	8b c0		 mov	 eax, eax
  0011c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR good$[rsp]
  00121	48 03 c8	 add	 rcx, rax
  00124	48 8b c1	 mov	 rax, rcx
  00127	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax

; 1771 :         
; 1772 : #define STBI__COMBO(a,b)  ((a)*8+(b))
; 1773 : #define STBI__CASE(a,b)   case STBI__COMBO(a,b): for(i=x-1; i >= 0; --i, src += a, dest += b)
; 1774 :         // convert source image with img_n components to one with req_comp components;
; 1775 :         // avoid switch per pixel, so use switch per scanline and massive macros
; 1776 :         switch (STBI__COMBO(img_n, req_comp)) {

  0012c	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00133	8b 4c 24 78	 mov	 ecx, DWORD PTR img_n$[rsp]
  00137	8d 04 c8	 lea	 eax, DWORD PTR [rax+rcx*8]
  0013a	89 44 24 3c	 mov	 DWORD PTR tv95[rsp], eax
  0013e	8b 44 24 3c	 mov	 eax, DWORD PTR tv95[rsp]
  00142	83 e8 0a	 sub	 eax, 10
  00145	89 44 24 3c	 mov	 DWORD PTR tv95[rsp], eax
  00149	83 7c 24 3c 19	 cmp	 DWORD PTR tv95[rsp], 25
  0014e	0f 87 31 08 00
	00		 ja	 $LN57@stbi__conv
  00154	48 63 44 24 3c	 movsxd	 rax, DWORD PTR tv95[rsp]
  00159	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00160	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN66@stbi__conv[rcx+rax*4]
  00167	48 03 c1	 add	 rax, rcx
  0016a	ff e0		 jmp	 rax
$LN45@stbi__conv:

; 1777 :             STBI__CASE(1,2) { dest[0]=src[0]; dest[1]=255;                                     } break;

  0016c	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00173	ff c8		 dec	 eax
  00175	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00179	eb 25		 jmp	 SHORT $LN9@stbi__conv
$LN7@stbi__conv:
  0017b	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0017f	ff c8		 dec	 eax
  00181	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00185	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  0018a	48 ff c0	 inc	 rax
  0018d	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  00192	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  00197	48 83 c0 02	 add	 rax, 2
  0019b	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN9@stbi__conv:
  001a0	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  001a5	7c 38		 jl	 SHORT $LN8@stbi__conv
  001a7	b8 01 00 00 00	 mov	 eax, 1
  001ac	48 6b c0 00	 imul	 rax, rax, 0
  001b0	b9 01 00 00 00	 mov	 ecx, 1
  001b5	48 6b c9 00	 imul	 rcx, rcx, 0
  001b9	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  001be	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  001c3	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  001c8	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  001cb	b8 01 00 00 00	 mov	 eax, 1
  001d0	48 6b c0 01	 imul	 rax, rax, 1
  001d4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dest$1[rsp]
  001d9	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  001dd	eb 9c		 jmp	 SHORT $LN7@stbi__conv
$LN8@stbi__conv:
  001df	e9 ff 07 00 00	 jmp	 $LN5@stbi__conv
$LN46@stbi__conv:

; 1778 :             STBI__CASE(1,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;

  001e4	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  001eb	ff c8		 dec	 eax
  001ed	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  001f1	eb 25		 jmp	 SHORT $LN12@stbi__conv
$LN10@stbi__conv:
  001f3	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001f7	ff c8		 dec	 eax
  001f9	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  001fd	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  00202	48 ff c0	 inc	 rax
  00205	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  0020a	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  0020f	48 83 c0 03	 add	 rax, 3
  00213	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN12@stbi__conv:
  00218	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  0021d	7c 71		 jl	 SHORT $LN11@stbi__conv
  0021f	b8 01 00 00 00	 mov	 eax, 1
  00224	48 6b c0 00	 imul	 rax, rax, 0
  00228	b9 01 00 00 00	 mov	 ecx, 1
  0022d	48 6b c9 02	 imul	 rcx, rcx, 2
  00231	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00236	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  0023b	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00240	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00243	b8 01 00 00 00	 mov	 eax, 1
  00248	48 6b c0 02	 imul	 rax, rax, 2
  0024c	b9 01 00 00 00	 mov	 ecx, 1
  00251	48 6b c9 01	 imul	 rcx, rcx, 1
  00255	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0025a	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  0025f	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00264	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00267	b8 01 00 00 00	 mov	 eax, 1
  0026c	48 6b c0 01	 imul	 rax, rax, 1
  00270	b9 01 00 00 00	 mov	 ecx, 1
  00275	48 6b c9 00	 imul	 rcx, rcx, 0
  00279	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0027e	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  00283	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00288	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0028b	e9 63 ff ff ff	 jmp	 $LN10@stbi__conv
$LN11@stbi__conv:
  00290	e9 4e 07 00 00	 jmp	 $LN5@stbi__conv
$LN47@stbi__conv:

; 1779 :             STBI__CASE(1,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=255;                     } break;

  00295	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  0029c	ff c8		 dec	 eax
  0029e	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  002a2	eb 25		 jmp	 SHORT $LN15@stbi__conv
$LN13@stbi__conv:
  002a4	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  002a8	ff c8		 dec	 eax
  002aa	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  002ae	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  002b3	48 ff c0	 inc	 rax
  002b6	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  002bb	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  002c0	48 83 c0 04	 add	 rax, 4
  002c4	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN15@stbi__conv:
  002c9	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  002ce	0f 8c 83 00 00
	00		 jl	 $LN14@stbi__conv
  002d4	b8 01 00 00 00	 mov	 eax, 1
  002d9	48 6b c0 00	 imul	 rax, rax, 0
  002dd	b9 01 00 00 00	 mov	 ecx, 1
  002e2	48 6b c9 02	 imul	 rcx, rcx, 2
  002e6	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  002eb	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  002f0	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  002f5	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  002f8	b8 01 00 00 00	 mov	 eax, 1
  002fd	48 6b c0 02	 imul	 rax, rax, 2
  00301	b9 01 00 00 00	 mov	 ecx, 1
  00306	48 6b c9 01	 imul	 rcx, rcx, 1
  0030a	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0030f	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  00314	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00319	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0031c	b8 01 00 00 00	 mov	 eax, 1
  00321	48 6b c0 01	 imul	 rax, rax, 1
  00325	b9 01 00 00 00	 mov	 ecx, 1
  0032a	48 6b c9 00	 imul	 rcx, rcx, 0
  0032e	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00333	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  00338	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0033d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00340	b8 01 00 00 00	 mov	 eax, 1
  00345	48 6b c0 03	 imul	 rax, rax, 3
  00349	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dest$1[rsp]
  0034e	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00352	e9 4d ff ff ff	 jmp	 $LN13@stbi__conv
$LN14@stbi__conv:
  00357	e9 87 06 00 00	 jmp	 $LN5@stbi__conv
$LN48@stbi__conv:

; 1780 :             STBI__CASE(2,1) { dest[0]=src[0];                                                  } break;

  0035c	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00363	ff c8		 dec	 eax
  00365	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00369	eb 25		 jmp	 SHORT $LN18@stbi__conv
$LN16@stbi__conv:
  0036b	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0036f	ff c8		 dec	 eax
  00371	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00375	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  0037a	48 83 c0 02	 add	 rax, 2
  0037e	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  00383	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  00388	48 ff c0	 inc	 rax
  0038b	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN18@stbi__conv:
  00390	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00395	7c 26		 jl	 SHORT $LN17@stbi__conv
  00397	b8 01 00 00 00	 mov	 eax, 1
  0039c	48 6b c0 00	 imul	 rax, rax, 0
  003a0	b9 01 00 00 00	 mov	 ecx, 1
  003a5	48 6b c9 00	 imul	 rcx, rcx, 0
  003a9	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  003ae	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  003b3	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  003b8	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  003bb	eb ae		 jmp	 SHORT $LN16@stbi__conv
$LN17@stbi__conv:
  003bd	e9 21 06 00 00	 jmp	 $LN5@stbi__conv
$LN49@stbi__conv:

; 1781 :             STBI__CASE(2,3) { dest[0]=dest[1]=dest[2]=src[0];                                  } break;

  003c2	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  003c9	ff c8		 dec	 eax
  003cb	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  003cf	eb 26		 jmp	 SHORT $LN21@stbi__conv
$LN19@stbi__conv:
  003d1	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  003d5	ff c8		 dec	 eax
  003d7	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  003db	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  003e0	48 83 c0 02	 add	 rax, 2
  003e4	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  003e9	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  003ee	48 83 c0 03	 add	 rax, 3
  003f2	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN21@stbi__conv:
  003f7	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  003fc	7c 71		 jl	 SHORT $LN20@stbi__conv
  003fe	b8 01 00 00 00	 mov	 eax, 1
  00403	48 6b c0 00	 imul	 rax, rax, 0
  00407	b9 01 00 00 00	 mov	 ecx, 1
  0040c	48 6b c9 02	 imul	 rcx, rcx, 2
  00410	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00415	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  0041a	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0041f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00422	b8 01 00 00 00	 mov	 eax, 1
  00427	48 6b c0 02	 imul	 rax, rax, 2
  0042b	b9 01 00 00 00	 mov	 ecx, 1
  00430	48 6b c9 01	 imul	 rcx, rcx, 1
  00434	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00439	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  0043e	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00443	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00446	b8 01 00 00 00	 mov	 eax, 1
  0044b	48 6b c0 01	 imul	 rax, rax, 1
  0044f	b9 01 00 00 00	 mov	 ecx, 1
  00454	48 6b c9 00	 imul	 rcx, rcx, 0
  00458	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0045d	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  00462	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00467	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0046a	e9 62 ff ff ff	 jmp	 $LN19@stbi__conv
$LN20@stbi__conv:
  0046f	e9 6f 05 00 00	 jmp	 $LN5@stbi__conv
$LN50@stbi__conv:

; 1782 :             STBI__CASE(2,4) { dest[0]=dest[1]=dest[2]=src[0]; dest[3]=src[1];                  } break;

  00474	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  0047b	ff c8		 dec	 eax
  0047d	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00481	eb 26		 jmp	 SHORT $LN24@stbi__conv
$LN22@stbi__conv:
  00483	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00487	ff c8		 dec	 eax
  00489	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0048d	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  00492	48 83 c0 02	 add	 rax, 2
  00496	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  0049b	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  004a0	48 83 c0 04	 add	 rax, 4
  004a4	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN24@stbi__conv:
  004a9	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  004ae	0f 8c 95 00 00
	00		 jl	 $LN23@stbi__conv
  004b4	b8 01 00 00 00	 mov	 eax, 1
  004b9	48 6b c0 00	 imul	 rax, rax, 0
  004bd	b9 01 00 00 00	 mov	 ecx, 1
  004c2	48 6b c9 02	 imul	 rcx, rcx, 2
  004c6	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  004cb	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  004d0	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  004d5	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  004d8	b8 01 00 00 00	 mov	 eax, 1
  004dd	48 6b c0 02	 imul	 rax, rax, 2
  004e1	b9 01 00 00 00	 mov	 ecx, 1
  004e6	48 6b c9 01	 imul	 rcx, rcx, 1
  004ea	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  004ef	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  004f4	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  004f9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  004fc	b8 01 00 00 00	 mov	 eax, 1
  00501	48 6b c0 01	 imul	 rax, rax, 1
  00505	b9 01 00 00 00	 mov	 ecx, 1
  0050a	48 6b c9 00	 imul	 rcx, rcx, 0
  0050e	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00513	4c 8b 44 24 28	 mov	 r8, QWORD PTR dest$1[rsp]
  00518	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0051d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00520	b8 01 00 00 00	 mov	 eax, 1
  00525	48 6b c0 01	 imul	 rax, rax, 1
  00529	b9 01 00 00 00	 mov	 ecx, 1
  0052e	48 6b c9 03	 imul	 rcx, rcx, 3
  00532	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00537	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  0053c	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00541	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00544	e9 3a ff ff ff	 jmp	 $LN22@stbi__conv
$LN23@stbi__conv:
  00549	e9 95 04 00 00	 jmp	 $LN5@stbi__conv
$LN51@stbi__conv:

; 1783 :             STBI__CASE(3,4) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];dest[3]=255;        } break;

  0054e	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00555	ff c8		 dec	 eax
  00557	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0055b	eb 26		 jmp	 SHORT $LN27@stbi__conv
$LN25@stbi__conv:
  0055d	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00561	ff c8		 dec	 eax
  00563	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00567	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  0056c	48 83 c0 03	 add	 rax, 3
  00570	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  00575	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  0057a	48 83 c0 04	 add	 rax, 4
  0057e	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN27@stbi__conv:
  00583	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00588	0f 8c 83 00 00
	00		 jl	 $LN26@stbi__conv
  0058e	b8 01 00 00 00	 mov	 eax, 1
  00593	48 6b c0 00	 imul	 rax, rax, 0
  00597	b9 01 00 00 00	 mov	 ecx, 1
  0059c	48 6b c9 00	 imul	 rcx, rcx, 0
  005a0	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  005a5	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  005aa	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  005af	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  005b2	b8 01 00 00 00	 mov	 eax, 1
  005b7	48 6b c0 01	 imul	 rax, rax, 1
  005bb	b9 01 00 00 00	 mov	 ecx, 1
  005c0	48 6b c9 01	 imul	 rcx, rcx, 1
  005c4	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  005c9	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  005ce	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  005d3	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  005d6	b8 01 00 00 00	 mov	 eax, 1
  005db	48 6b c0 02	 imul	 rax, rax, 2
  005df	b9 01 00 00 00	 mov	 ecx, 1
  005e4	48 6b c9 02	 imul	 rcx, rcx, 2
  005e8	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  005ed	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  005f2	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  005f7	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  005fa	b8 01 00 00 00	 mov	 eax, 1
  005ff	48 6b c0 03	 imul	 rax, rax, 3
  00603	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dest$1[rsp]
  00608	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  0060c	e9 4c ff ff ff	 jmp	 $LN25@stbi__conv
$LN26@stbi__conv:
  00611	e9 cd 03 00 00	 jmp	 $LN5@stbi__conv
$LN52@stbi__conv:

; 1784 :             STBI__CASE(3,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;

  00616	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  0061d	ff c8		 dec	 eax
  0061f	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00623	eb 25		 jmp	 SHORT $LN30@stbi__conv
$LN28@stbi__conv:
  00625	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00629	ff c8		 dec	 eax
  0062b	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  0062f	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  00634	48 83 c0 03	 add	 rax, 3
  00638	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  0063d	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  00642	48 ff c0	 inc	 rax
  00645	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN30@stbi__conv:
  0064a	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  0064f	7c 61		 jl	 SHORT $LN29@stbi__conv
  00651	b8 01 00 00 00	 mov	 eax, 1
  00656	48 6b c0 02	 imul	 rax, rax, 2
  0065a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$2[rsp]
  0065f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00663	b9 01 00 00 00	 mov	 ecx, 1
  00668	48 6b c9 01	 imul	 rcx, rcx, 1
  0066c	48 8b 54 24 30	 mov	 rdx, QWORD PTR src$2[rsp]
  00671	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00675	ba 01 00 00 00	 mov	 edx, 1
  0067a	48 6b d2 00	 imul	 rdx, rdx, 0
  0067e	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  00683	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  00688	89 54 24 50	 mov	 DWORD PTR tv259[rsp], edx
  0068c	44 8b c0	 mov	 r8d, eax
  0068f	8b d1		 mov	 edx, ecx
  00691	8b 44 24 50	 mov	 eax, DWORD PTR tv259[rsp]
  00695	8b c8		 mov	 ecx, eax
  00697	e8 00 00 00 00	 call	 ?stbi__compute_y@@YAEHHH@Z ; stbi__compute_y
  0069c	b9 01 00 00 00	 mov	 ecx, 1
  006a1	48 6b c9 00	 imul	 rcx, rcx, 0
  006a5	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  006aa	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  006ad	e9 73 ff ff ff	 jmp	 $LN28@stbi__conv
$LN29@stbi__conv:
  006b2	e9 2c 03 00 00	 jmp	 $LN5@stbi__conv
$LN53@stbi__conv:

; 1785 :             STBI__CASE(3,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = 255;    } break;

  006b7	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  006be	ff c8		 dec	 eax
  006c0	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  006c4	eb 26		 jmp	 SHORT $LN33@stbi__conv
$LN31@stbi__conv:
  006c6	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  006ca	ff c8		 dec	 eax
  006cc	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  006d0	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  006d5	48 83 c0 03	 add	 rax, 3
  006d9	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  006de	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  006e3	48 83 c0 02	 add	 rax, 2
  006e7	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN33@stbi__conv:
  006ec	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  006f1	7c 73		 jl	 SHORT $LN32@stbi__conv
  006f3	b8 01 00 00 00	 mov	 eax, 1
  006f8	48 6b c0 02	 imul	 rax, rax, 2
  006fc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$2[rsp]
  00701	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00705	b9 01 00 00 00	 mov	 ecx, 1
  0070a	48 6b c9 01	 imul	 rcx, rcx, 1
  0070e	48 8b 54 24 30	 mov	 rdx, QWORD PTR src$2[rsp]
  00713	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00717	ba 01 00 00 00	 mov	 edx, 1
  0071c	48 6b d2 00	 imul	 rdx, rdx, 0
  00720	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  00725	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  0072a	89 54 24 54	 mov	 DWORD PTR tv279[rsp], edx
  0072e	44 8b c0	 mov	 r8d, eax
  00731	8b d1		 mov	 edx, ecx
  00733	8b 44 24 54	 mov	 eax, DWORD PTR tv279[rsp]
  00737	8b c8		 mov	 ecx, eax
  00739	e8 00 00 00 00	 call	 ?stbi__compute_y@@YAEHHH@Z ; stbi__compute_y
  0073e	b9 01 00 00 00	 mov	 ecx, 1
  00743	48 6b c9 00	 imul	 rcx, rcx, 0
  00747	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0074c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0074f	b8 01 00 00 00	 mov	 eax, 1
  00754	48 6b c0 01	 imul	 rax, rax, 1
  00758	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dest$1[rsp]
  0075d	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00761	e9 60 ff ff ff	 jmp	 $LN31@stbi__conv
$LN32@stbi__conv:
  00766	e9 78 02 00 00	 jmp	 $LN5@stbi__conv
$LN54@stbi__conv:

; 1786 :             STBI__CASE(4,1) { dest[0]=stbi__compute_y(src[0],src[1],src[2]);                   } break;

  0076b	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00772	ff c8		 dec	 eax
  00774	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00778	eb 25		 jmp	 SHORT $LN36@stbi__conv
$LN34@stbi__conv:
  0077a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0077e	ff c8		 dec	 eax
  00780	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00784	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  00789	48 83 c0 04	 add	 rax, 4
  0078d	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  00792	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  00797	48 ff c0	 inc	 rax
  0079a	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN36@stbi__conv:
  0079f	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  007a4	7c 61		 jl	 SHORT $LN35@stbi__conv
  007a6	b8 01 00 00 00	 mov	 eax, 1
  007ab	48 6b c0 02	 imul	 rax, rax, 2
  007af	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$2[rsp]
  007b4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  007b8	b9 01 00 00 00	 mov	 ecx, 1
  007bd	48 6b c9 01	 imul	 rcx, rcx, 1
  007c1	48 8b 54 24 30	 mov	 rdx, QWORD PTR src$2[rsp]
  007c6	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  007ca	ba 01 00 00 00	 mov	 edx, 1
  007cf	48 6b d2 00	 imul	 rdx, rdx, 0
  007d3	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  007d8	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  007dd	89 54 24 58	 mov	 DWORD PTR tv301[rsp], edx
  007e1	44 8b c0	 mov	 r8d, eax
  007e4	8b d1		 mov	 edx, ecx
  007e6	8b 44 24 58	 mov	 eax, DWORD PTR tv301[rsp]
  007ea	8b c8		 mov	 ecx, eax
  007ec	e8 00 00 00 00	 call	 ?stbi__compute_y@@YAEHHH@Z ; stbi__compute_y
  007f1	b9 01 00 00 00	 mov	 ecx, 1
  007f6	48 6b c9 00	 imul	 rcx, rcx, 0
  007fa	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  007ff	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00802	e9 73 ff ff ff	 jmp	 $LN34@stbi__conv
$LN35@stbi__conv:
  00807	e9 d7 01 00 00	 jmp	 $LN5@stbi__conv
$LN55@stbi__conv:

; 1787 :             STBI__CASE(4,2) { dest[0]=stbi__compute_y(src[0],src[1],src[2]); dest[1] = src[3]; } break;

  0080c	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  00813	ff c8		 dec	 eax
  00815	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00819	eb 26		 jmp	 SHORT $LN39@stbi__conv
$LN37@stbi__conv:
  0081b	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0081f	ff c8		 dec	 eax
  00821	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00825	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  0082a	48 83 c0 04	 add	 rax, 4
  0082e	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  00833	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  00838	48 83 c0 02	 add	 rax, 2
  0083c	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN39@stbi__conv:
  00841	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00846	0f 8c 85 00 00
	00		 jl	 $LN38@stbi__conv
  0084c	b8 01 00 00 00	 mov	 eax, 1
  00851	48 6b c0 02	 imul	 rax, rax, 2
  00855	48 8b 4c 24 30	 mov	 rcx, QWORD PTR src$2[rsp]
  0085a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0085e	b9 01 00 00 00	 mov	 ecx, 1
  00863	48 6b c9 01	 imul	 rcx, rcx, 1
  00867	48 8b 54 24 30	 mov	 rdx, QWORD PTR src$2[rsp]
  0086c	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00870	ba 01 00 00 00	 mov	 edx, 1
  00875	48 6b d2 00	 imul	 rdx, rdx, 0
  00879	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  0087e	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  00883	89 54 24 5c	 mov	 DWORD PTR tv321[rsp], edx
  00887	44 8b c0	 mov	 r8d, eax
  0088a	8b d1		 mov	 edx, ecx
  0088c	8b 44 24 5c	 mov	 eax, DWORD PTR tv321[rsp]
  00890	8b c8		 mov	 ecx, eax
  00892	e8 00 00 00 00	 call	 ?stbi__compute_y@@YAEHHH@Z ; stbi__compute_y
  00897	b9 01 00 00 00	 mov	 ecx, 1
  0089c	48 6b c9 00	 imul	 rcx, rcx, 0
  008a0	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  008a5	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  008a8	b8 01 00 00 00	 mov	 eax, 1
  008ad	48 6b c0 03	 imul	 rax, rax, 3
  008b1	b9 01 00 00 00	 mov	 ecx, 1
  008b6	48 6b c9 01	 imul	 rcx, rcx, 1
  008ba	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  008bf	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  008c4	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  008c9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  008cc	e9 4a ff ff ff	 jmp	 $LN37@stbi__conv
$LN38@stbi__conv:
  008d1	e9 0d 01 00 00	 jmp	 $LN5@stbi__conv
$LN56@stbi__conv:

; 1788 :             STBI__CASE(4,3) { dest[0]=src[0];dest[1]=src[1];dest[2]=src[2];                    } break;

  008d6	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR x$[rsp]
  008dd	ff c8		 dec	 eax
  008df	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  008e3	eb 26		 jmp	 SHORT $LN42@stbi__conv
$LN40@stbi__conv:
  008e5	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  008e9	ff c8		 dec	 eax
  008eb	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  008ef	48 8b 44 24 30	 mov	 rax, QWORD PTR src$2[rsp]
  008f4	48 83 c0 04	 add	 rax, 4
  008f8	48 89 44 24 30	 mov	 QWORD PTR src$2[rsp], rax
  008fd	48 8b 44 24 28	 mov	 rax, QWORD PTR dest$1[rsp]
  00902	48 83 c0 03	 add	 rax, 3
  00906	48 89 44 24 28	 mov	 QWORD PTR dest$1[rsp], rax
$LN42@stbi__conv:
  0090b	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  00910	7c 71		 jl	 SHORT $LN41@stbi__conv
  00912	b8 01 00 00 00	 mov	 eax, 1
  00917	48 6b c0 00	 imul	 rax, rax, 0
  0091b	b9 01 00 00 00	 mov	 ecx, 1
  00920	48 6b c9 00	 imul	 rcx, rcx, 0
  00924	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00929	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  0092e	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00933	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00936	b8 01 00 00 00	 mov	 eax, 1
  0093b	48 6b c0 01	 imul	 rax, rax, 1
  0093f	b9 01 00 00 00	 mov	 ecx, 1
  00944	48 6b c9 01	 imul	 rcx, rcx, 1
  00948	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  0094d	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  00952	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00957	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0095a	b8 01 00 00 00	 mov	 eax, 1
  0095f	48 6b c0 02	 imul	 rax, rax, 2
  00963	b9 01 00 00 00	 mov	 ecx, 1
  00968	48 6b c9 02	 imul	 rcx, rcx, 2
  0096c	48 8b 54 24 28	 mov	 rdx, QWORD PTR dest$1[rsp]
  00971	4c 8b 44 24 30	 mov	 r8, QWORD PTR src$2[rsp]
  00976	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0097b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0097e	e9 62 ff ff ff	 jmp	 $LN40@stbi__conv
$LN41@stbi__conv:
  00983	eb 5e		 jmp	 SHORT $LN5@stbi__conv
$LN57@stbi__conv:

; 1789 :             default: STBI_ASSERT(0); STBI_FREE(data); STBI_FREE(good); return stbi__errpuc("unsupported", "Unsupported format conversion");

  00985	33 c0		 xor	 eax, eax
  00987	85 c0		 test	 eax, eax
  00989	75 1b		 jne	 SHORT $LN63@stbi__conv
  0098b	41 b8 fd 06 00
	00		 mov	 r8d, 1789		; 000006fdH
  00991	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG77098
  00998	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG77099
  0099f	e8 00 00 00 00	 call	 _wassert
  009a4	33 c0		 xor	 eax, eax
$LN63@stbi__conv:
  009a6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR data$[rsp]
  009ab	e8 00 00 00 00	 call	 free
  009b0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR good$[rsp]
  009b5	e8 00 00 00 00	 call	 free
  009ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG77100
  009c1	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  009c6	85 c0		 test	 eax, eax
  009c8	74 0a		 je	 SHORT $LN64@stbi__conv
  009ca	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv354[rsp], 0
  009d2	eb 08		 jmp	 SHORT $LN65@stbi__conv
$LN64@stbi__conv:
  009d4	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv354[rsp], 0
$LN65@stbi__conv:
  009dc	48 63 44 24 44	 movsxd	 rax, DWORD PTR tv354[rsp]
  009e1	eb 14		 jmp	 SHORT $LN1@stbi__conv
$LN5@stbi__conv:

; 1790 :         }
; 1791 : #undef STBI__CASE
; 1792 :     }

  009e3	e9 e0 f6 ff ff	 jmp	 $LN2@stbi__conv
$LN3@stbi__conv:

; 1793 :     
; 1794 :     STBI_FREE(data);

  009e8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR data$[rsp]
  009ed	e8 00 00 00 00	 call	 free

; 1795 :     return good;

  009f2	48 8b 44 24 48	 mov	 rax, QWORD PTR good$[rsp]
$LN1@stbi__conv:

; 1796 : }

  009f7	48 83 c4 68	 add	 rsp, 104		; 00000068H
  009fb	c3		 ret	 0
$LN66@stbi__conv:
  009fc	00 00 00 00	 DD	 $LN45@stbi__conv
  00a00	00 00 00 00	 DD	 $LN46@stbi__conv
  00a04	00 00 00 00	 DD	 $LN47@stbi__conv
  00a08	00 00 00 00	 DD	 $LN57@stbi__conv
  00a0c	00 00 00 00	 DD	 $LN57@stbi__conv
  00a10	00 00 00 00	 DD	 $LN57@stbi__conv
  00a14	00 00 00 00	 DD	 $LN57@stbi__conv
  00a18	00 00 00 00	 DD	 $LN48@stbi__conv
  00a1c	00 00 00 00	 DD	 $LN57@stbi__conv
  00a20	00 00 00 00	 DD	 $LN49@stbi__conv
  00a24	00 00 00 00	 DD	 $LN50@stbi__conv
  00a28	00 00 00 00	 DD	 $LN57@stbi__conv
  00a2c	00 00 00 00	 DD	 $LN57@stbi__conv
  00a30	00 00 00 00	 DD	 $LN57@stbi__conv
  00a34	00 00 00 00	 DD	 $LN57@stbi__conv
  00a38	00 00 00 00	 DD	 $LN52@stbi__conv
  00a3c	00 00 00 00	 DD	 $LN53@stbi__conv
  00a40	00 00 00 00	 DD	 $LN57@stbi__conv
  00a44	00 00 00 00	 DD	 $LN51@stbi__conv
  00a48	00 00 00 00	 DD	 $LN57@stbi__conv
  00a4c	00 00 00 00	 DD	 $LN57@stbi__conv
  00a50	00 00 00 00	 DD	 $LN57@stbi__conv
  00a54	00 00 00 00	 DD	 $LN57@stbi__conv
  00a58	00 00 00 00	 DD	 $LN54@stbi__conv
  00a5c	00 00 00 00	 DD	 $LN55@stbi__conv
  00a60	00 00 00 00	 DD	 $LN56@stbi__conv
?stbi__convert_format@@YAPEAEPEAEHHII@Z ENDP		; stbi__convert_format
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
r$ = 8
g$ = 16
b$ = 24
?stbi__compute_y@@YAEHHH@Z PROC				; stbi__compute_y

; 1746 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 1747 :     return (stbi_uc) (((r*77) + (g*150) +  (29*b)) >> 8);

  0000d	6b 44 24 08 4d	 imul	 eax, DWORD PTR r$[rsp], 77 ; 0000004dH
  00012	69 4c 24 10 96
	00 00 00	 imul	 ecx, DWORD PTR g$[rsp], 150 ; 00000096H
  0001a	03 c1		 add	 eax, ecx
  0001c	6b 4c 24 18 1d	 imul	 ecx, DWORD PTR b$[rsp], 29
  00021	03 c1		 add	 eax, ecx
  00023	c1 f8 08	 sar	 eax, 8

; 1748 : }

  00026	c3		 ret	 0
?stbi__compute_y@@YAEHHH@Z ENDP				; stbi__compute_y
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
z$ = 32
s$ = 64
?stbi__get32le@@YAIPEAUstbi__context@@@Z PROC		; stbi__get32le

; 1722 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1723 :     stbi__uint32 z = stbi__get16le(s);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  00013	89 44 24 20	 mov	 DWORD PTR z$[rsp], eax

; 1724 :     z += (stbi__uint32)stbi__get16le(s) << 16;

  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001c	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  00021	c1 e0 10	 shl	 eax, 16
  00024	8b 4c 24 20	 mov	 ecx, DWORD PTR z$[rsp]
  00028	03 c8		 add	 ecx, eax
  0002a	8b c1		 mov	 eax, ecx
  0002c	89 44 24 20	 mov	 DWORD PTR z$[rsp], eax

; 1725 :     return z;

  00030	8b 44 24 20	 mov	 eax, DWORD PTR z$[rsp]

; 1726 : }

  00034	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00038	c3		 ret	 0
?stbi__get32le@@YAIPEAUstbi__context@@@Z ENDP		; stbi__get32le
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
z$ = 32
s$ = 64
?stbi__get16le@@YAHPEAUstbi__context@@@Z PROC		; stbi__get16le

; 1714 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1715 :     int z = stbi__get8(s);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00013	0f b6 c0	 movzx	 eax, al
  00016	89 44 24 20	 mov	 DWORD PTR z$[rsp], eax

; 1716 :     return z + (stbi__get8(s) << 8);

  0001a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001f	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00024	0f b6 c0	 movzx	 eax, al
  00027	c1 e0 08	 shl	 eax, 8
  0002a	8b 4c 24 20	 mov	 ecx, DWORD PTR z$[rsp]
  0002e	03 c8		 add	 ecx, eax
  00030	8b c1		 mov	 eax, ecx

; 1717 : }

  00032	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00036	c3		 ret	 0
?stbi__get16le@@YAHPEAUstbi__context@@@Z ENDP		; stbi__get16le
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
z$ = 32
tv66 = 36
s$ = 64
?stbi__get32be@@YAIPEAUstbi__context@@@Z PROC		; stbi__get32be

; 1704 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1705 :     stbi__uint32 z = stbi__get16be(s);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  00013	89 44 24 20	 mov	 DWORD PTR z$[rsp], eax

; 1706 :     return (z << 16) + stbi__get16be(s);

  00017	8b 44 24 20	 mov	 eax, DWORD PTR z$[rsp]
  0001b	c1 e0 10	 shl	 eax, 16
  0001e	89 44 24 24	 mov	 DWORD PTR tv66[rsp], eax
  00022	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00027	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  0002c	8b 4c 24 24	 mov	 ecx, DWORD PTR tv66[rsp]
  00030	03 c8		 add	 ecx, eax
  00032	8b c1		 mov	 eax, ecx

; 1707 : }

  00034	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00038	c3		 ret	 0
?stbi__get32be@@YAIPEAUstbi__context@@@Z ENDP		; stbi__get32be
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
z$ = 32
tv67 = 36
s$ = 64
?stbi__get16be@@YAHPEAUstbi__context@@@Z PROC		; stbi__get16be

; 1694 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1695 :     int z = stbi__get8(s);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00013	0f b6 c0	 movzx	 eax, al
  00016	89 44 24 20	 mov	 DWORD PTR z$[rsp], eax

; 1696 :     return (z << 8) + stbi__get8(s);

  0001a	8b 44 24 20	 mov	 eax, DWORD PTR z$[rsp]
  0001e	c1 e0 08	 shl	 eax, 8
  00021	89 44 24 24	 mov	 DWORD PTR tv67[rsp], eax
  00025	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0002a	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0002f	0f b6 c0	 movzx	 eax, al
  00032	8b 4c 24 24	 mov	 ecx, DWORD PTR tv67[rsp]
  00036	03 c8		 add	 ecx, eax
  00038	8b c1		 mov	 eax, ecx

; 1697 : }

  0003a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003e	c3		 ret	 0
?stbi__get16be@@YAHPEAUstbi__context@@@Z ENDP		; stbi__get16be
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
blen$1 = 32
tv89 = 36
count$2 = 40
res$3 = 44
s$ = 64
buffer$ = 72
n$ = 80
?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z PROC		; stbi__getn

; 1666 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1667 :     if (s->io.read) {

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00018	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0001d	0f 84 cc 00 00
	00		 je	 $LN2@stbi__getn

; 1668 :         int blen = (int) (s->img_buffer_end - s->img_buffer);

  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00028	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0002d	48 8b 89 c0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+192]
  00034	48 8b 80 c8 00
	00 00		 mov	 rax, QWORD PTR [rax+200]
  0003b	48 2b c1	 sub	 rax, rcx
  0003e	89 44 24 20	 mov	 DWORD PTR blen$1[rsp], eax

; 1669 :         if (blen < n) {

  00042	8b 44 24 50	 mov	 eax, DWORD PTR n$[rsp]
  00046	39 44 24 20	 cmp	 DWORD PTR blen$1[rsp], eax
  0004a	0f 8d 9f 00 00
	00		 jge	 $LN3@stbi__getn

; 1670 :             int res, count;
; 1671 :             
; 1672 :             memcpy(buffer, s->img_buffer, blen);

  00050	48 63 44 24 20	 movsxd	 rax, DWORD PTR blen$1[rsp]
  00055	4c 8b c0	 mov	 r8, rax
  00058	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0005d	48 8b 90 c0 00
	00 00		 mov	 rdx, QWORD PTR [rax+192]
  00064	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buffer$[rsp]
  00069	e8 00 00 00 00	 call	 memcpy

; 1673 :             
; 1674 :             count = (s->io.read)(s->io_user_data, (char*) buffer + blen, n - blen);

  0006e	8b 44 24 20	 mov	 eax, DWORD PTR blen$1[rsp]
  00072	8b 4c 24 50	 mov	 ecx, DWORD PTR n$[rsp]
  00076	2b c8		 sub	 ecx, eax
  00078	8b c1		 mov	 eax, ecx
  0007a	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR blen$1[rsp]
  0007f	48 8b 54 24 48	 mov	 rdx, QWORD PTR buffer$[rsp]
  00084	48 03 d1	 add	 rdx, rcx
  00087	48 8b ca	 mov	 rcx, rdx
  0008a	44 8b c0	 mov	 r8d, eax
  0008d	48 8b d1	 mov	 rdx, rcx
  00090	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00095	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00099	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0009e	ff 50 10	 call	 QWORD PTR [rax+16]
  000a1	89 44 24 28	 mov	 DWORD PTR count$2[rsp], eax

; 1675 :             res = (count == (n-blen));

  000a5	8b 44 24 20	 mov	 eax, DWORD PTR blen$1[rsp]
  000a9	8b 4c 24 50	 mov	 ecx, DWORD PTR n$[rsp]
  000ad	2b c8		 sub	 ecx, eax
  000af	8b c1		 mov	 eax, ecx
  000b1	39 44 24 28	 cmp	 DWORD PTR count$2[rsp], eax
  000b5	75 0a		 jne	 SHORT $LN7@stbi__getn
  000b7	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv89[rsp], 1
  000bf	eb 08		 jmp	 SHORT $LN8@stbi__getn
$LN7@stbi__getn:
  000c1	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv89[rsp], 0
$LN8@stbi__getn:
  000c9	8b 44 24 24	 mov	 eax, DWORD PTR tv89[rsp]
  000cd	89 44 24 2c	 mov	 DWORD PTR res$3[rsp], eax

; 1676 :             s->img_buffer = s->img_buffer_end;

  000d1	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000d6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000db	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  000e2	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 1677 :             return res;

  000e9	8b 44 24 2c	 mov	 eax, DWORD PTR res$3[rsp]
  000ed	eb 65		 jmp	 SHORT $LN1@stbi__getn
$LN3@stbi__getn:
$LN2@stbi__getn:

; 1678 :         }
; 1679 :     }
; 1680 :     
; 1681 :     if (s->img_buffer+n <= s->img_buffer_end) {

  000ef	48 63 44 24 50	 movsxd	 rax, DWORD PTR n$[rsp]
  000f4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000f9	48 03 81 c0 00
	00 00		 add	 rax, QWORD PTR [rcx+192]
  00100	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00105	48 3b 81 c8 00
	00 00		 cmp	 rax, QWORD PTR [rcx+200]
  0010c	77 44		 ja	 SHORT $LN4@stbi__getn

; 1682 :         memcpy(buffer, s->img_buffer, n);

  0010e	48 63 44 24 50	 movsxd	 rax, DWORD PTR n$[rsp]
  00113	4c 8b c0	 mov	 r8, rax
  00116	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0011b	48 8b 90 c0 00
	00 00		 mov	 rdx, QWORD PTR [rax+192]
  00122	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buffer$[rsp]
  00127	e8 00 00 00 00	 call	 memcpy

; 1683 :         s->img_buffer += n;

  0012c	48 63 44 24 50	 movsxd	 rax, DWORD PTR n$[rsp]
  00131	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00136	48 03 81 c0 00
	00 00		 add	 rax, QWORD PTR [rcx+192]
  0013d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00142	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax

; 1684 :         return 1;

  00149	b8 01 00 00 00	 mov	 eax, 1
  0014e	eb 04		 jmp	 SHORT $LN1@stbi__getn

; 1685 :     } else

  00150	eb 02		 jmp	 SHORT $LN5@stbi__getn
$LN4@stbi__getn:

; 1686 :         return 0;

  00152	33 c0		 xor	 eax, eax
$LN5@stbi__getn:
$LN1@stbi__getn:

; 1687 : }

  00154	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00158	c3		 ret	 0
?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z ENDP		; stbi__getn
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
blen$1 = 32
s$ = 64
n$ = 72
?stbi__skip@@YAXPEAUstbi__context@@H@Z PROC		; stbi__skip

; 1644 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1645 :     if (n == 0) return;  // already there!

  0000d	83 7c 24 48 00	 cmp	 DWORD PTR n$[rsp], 0
  00012	75 05		 jne	 SHORT $LN2@stbi__skip
  00014	e9 af 00 00 00	 jmp	 $LN1@stbi__skip
$LN2@stbi__skip:

; 1646 :     if (n < 0) {

  00019	83 7c 24 48 00	 cmp	 DWORD PTR n$[rsp], 0
  0001e	7d 1d		 jge	 SHORT $LN3@stbi__skip

; 1647 :         s->img_buffer = s->img_buffer_end;

  00020	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00025	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0002a	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00031	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 1648 :         return;

  00038	e9 8b 00 00 00	 jmp	 $LN1@stbi__skip
$LN3@stbi__skip:

; 1649 :     }
; 1650 :     if (s->io.read) {

  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00042	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00047	74 62		 je	 SHORT $LN4@stbi__skip

; 1651 :         int blen = (int) (s->img_buffer_end - s->img_buffer);

  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0004e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00053	48 8b 89 c0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+192]
  0005a	48 8b 80 c8 00
	00 00		 mov	 rax, QWORD PTR [rax+200]
  00061	48 2b c1	 sub	 rax, rcx
  00064	89 44 24 20	 mov	 DWORD PTR blen$1[rsp], eax

; 1652 :         if (blen < n) {

  00068	8b 44 24 48	 mov	 eax, DWORD PTR n$[rsp]
  0006c	39 44 24 20	 cmp	 DWORD PTR blen$1[rsp], eax
  00070	7d 39		 jge	 SHORT $LN5@stbi__skip

; 1653 :             s->img_buffer = s->img_buffer_end;

  00072	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00077	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0007c	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00083	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 1654 :             (s->io.skip)(s->io_user_data, n - blen);

  0008a	8b 44 24 20	 mov	 eax, DWORD PTR blen$1[rsp]
  0008e	8b 4c 24 48	 mov	 ecx, DWORD PTR n$[rsp]
  00092	2b c8		 sub	 ecx, eax
  00094	8b c1		 mov	 eax, ecx
  00096	8b d0		 mov	 edx, eax
  00098	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0009d	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  000a1	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000a6	ff 50 18	 call	 QWORD PTR [rax+24]

; 1655 :             return;

  000a9	eb 1d		 jmp	 SHORT $LN1@stbi__skip
$LN5@stbi__skip:
$LN4@stbi__skip:

; 1656 :         }
; 1657 :     }
; 1658 :     s->img_buffer += n;

  000ab	48 63 44 24 48	 movsxd	 rax, DWORD PTR n$[rsp]
  000b0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000b5	48 03 81 c0 00
	00 00		 add	 rax, QWORD PTR [rcx+192]
  000bc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000c1	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
$LN1@stbi__skip:

; 1659 : }

  000c8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cc	c3		 ret	 0
?stbi__skip@@YAXPEAUstbi__context@@H@Z ENDP		; stbi__skip
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv78 = 32
s$ = 64
?stbi__at_eof@@YAHPEAUstbi__context@@@Z PROC		; stbi__at_eof

; 1628 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1629 :     if (s->io.read) {

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0000e	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00013	74 2b		 je	 SHORT $LN2@stbi__at_e

; 1630 :         if (!(s->io.eof)(s->io_user_data)) return 0;

  00015	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0001a	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00023	ff 50 20	 call	 QWORD PTR [rax+32]
  00026	85 c0		 test	 eax, eax
  00028	75 04		 jne	 SHORT $LN3@stbi__at_e
  0002a	33 c0		 xor	 eax, eax
  0002c	eb 42		 jmp	 SHORT $LN1@stbi__at_e
$LN3@stbi__at_e:

; 1631 :         // if feof() is true, check if buffer = end
; 1632 :         // special case: we've only got the special 0 character at the end
; 1633 :         if (s->read_from_callbacks == 0) return 1;

  0002e	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00033	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00037	75 07		 jne	 SHORT $LN4@stbi__at_e
  00039	b8 01 00 00 00	 mov	 eax, 1
  0003e	eb 30		 jmp	 SHORT $LN1@stbi__at_e
$LN4@stbi__at_e:
$LN2@stbi__at_e:

; 1634 :     }
; 1635 :     
; 1636 :     return s->img_buffer >= s->img_buffer_end;

  00040	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00045	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0004a	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  00051	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00058	72 0a		 jb	 SHORT $LN6@stbi__at_e
  0005a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv78[rsp], 1
  00062	eb 08		 jmp	 SHORT $LN7@stbi__at_e
$LN6@stbi__at_e:
  00064	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
$LN7@stbi__at_e:
  0006c	8b 44 24 20	 mov	 eax, DWORD PTR tv78[rsp]
$LN1@stbi__at_e:

; 1637 : }

  00070	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00074	c3		 ret	 0
?stbi__at_eof@@YAHPEAUstbi__context@@@Z ENDP		; stbi__at_eof
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv72 = 32
tv81 = 33
s$ = 64
?stbi__get8@@YAEPEAUstbi__context@@@Z PROC		; stbi__get8

; 1614 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1615 :     if (s->img_buffer < s->img_buffer_end)

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00013	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  0001a	48 39 88 c0 00
	00 00		 cmp	 QWORD PTR [rax+192], rcx
  00021	73 35		 jae	 SHORT $LN2@stbi__get8

; 1616 :         return *s->img_buffer++;

  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00028	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0002f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00032	88 44 24 20	 mov	 BYTE PTR tv72[rsp], al
  00036	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0003b	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00042	48 ff c0	 inc	 rax
  00045	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0004a	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  00051	0f b6 44 24 20	 movzx	 eax, BYTE PTR tv72[rsp]
  00056	eb 4c		 jmp	 SHORT $LN1@stbi__get8
$LN2@stbi__get8:

; 1617 :     if (s->read_from_callbacks) {

  00058	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0005d	83 78 30 00	 cmp	 DWORD PTR [rax+48], 0
  00061	74 3f		 je	 SHORT $LN3@stbi__get8

; 1618 :         stbi__refill_buffer(s);

  00063	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00068	e8 00 00 00 00	 call	 ?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 1619 :         return *s->img_buffer++;

  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00072	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  00079	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0007c	88 44 24 21	 mov	 BYTE PTR tv81[rsp], al
  00080	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00085	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0008c	48 ff c0	 inc	 rax
  0008f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00094	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax
  0009b	0f b6 44 24 21	 movzx	 eax, BYTE PTR tv81[rsp]
  000a0	eb 02		 jmp	 SHORT $LN1@stbi__get8
$LN3@stbi__get8:

; 1620 :     }
; 1621 :     return 0;

  000a2	32 c0		 xor	 al, al
$LN1@stbi__get8:

; 1622 : }

  000a4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a8	c3		 ret	 0
?stbi__get8@@YAEPEAUstbi__context@@@Z ENDP		; stbi__get8
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv89 = 48
tv129 = 52
hdr_data$1 = 56
data$ = 64
ri$2 = 72
__$ArrayPad$ = 88
s$ = 112
x$ = 120
y$ = 128
comp$ = 136
req_comp$ = 144
?stbi__loadf_main@@YAPEAMPEAUstbi__context@@PEAH11H@Z PROC ; stbi__loadf_main

; 1460 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1461 :     unsigned char *data;
; 1462 : #ifndef STBI_NO_HDR
; 1463 :     if (stbi__hdr_test(s)) {

  00027	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0002c	e8 00 00 00 00	 call	 ?stbi__hdr_test@@YAHPEAUstbi__context@@@Z ; stbi__hdr_test
  00031	85 c0		 test	 eax, eax
  00033	74 75		 je	 SHORT $LN2@stbi__load

; 1464 :         stbi__result_info ri;
; 1465 :         float *hdr_data = stbi__hdr_load(s,x,y,comp,req_comp, &ri);

  00035	48 8d 44 24 48	 lea	 rax, QWORD PTR ri$2[rsp]
  0003a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0003f	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00046	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0004a	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00052	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR y$[rsp]
  0005a	48 8b 54 24 78	 mov	 rdx, QWORD PTR x$[rsp]
  0005f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00064	e8 00 00 00 00	 call	 ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ; stbi__hdr_load
  00069	48 89 44 24 38	 mov	 QWORD PTR hdr_data$1[rsp], rax

; 1466 :         if (hdr_data)

  0006e	48 83 7c 24 38
	00		 cmp	 QWORD PTR hdr_data$1[rsp], 0
  00074	74 2a		 je	 SHORT $LN3@stbi__load

; 1467 :             stbi__float_postprocess(hdr_data,x,y,comp,req_comp);

  00076	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  0007d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00081	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00089	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00091	48 8b 54 24 78	 mov	 rdx, QWORD PTR x$[rsp]
  00096	48 8b 4c 24 38	 mov	 rcx, QWORD PTR hdr_data$1[rsp]
  0009b	e8 00 00 00 00	 call	 ?stbi__float_postprocess@@YAXPEAMPEAH11H@Z ; stbi__float_postprocess
$LN3@stbi__load:

; 1468 :         return hdr_data;

  000a0	48 8b 44 24 38	 mov	 rax, QWORD PTR hdr_data$1[rsp]
  000a5	e9 a6 00 00 00	 jmp	 $LN1@stbi__load
$LN2@stbi__load:

; 1469 :     }
; 1470 : #endif
; 1471 :     data = stbi__load_and_postprocess_8bit(s, x, y, comp, req_comp);

  000aa	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  000b1	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000b5	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  000bd	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR y$[rsp]
  000c5	48 8b 54 24 78	 mov	 rdx, QWORD PTR x$[rsp]
  000ca	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  000cf	e8 00 00 00 00	 call	 ?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z ; stbi__load_and_postprocess_8bit
  000d4	48 89 44 24 40	 mov	 QWORD PTR data$[rsp], rax

; 1472 :     if (data)

  000d9	48 83 7c 24 40
	00		 cmp	 QWORD PTR data$[rsp], 0
  000df	74 48		 je	 SHORT $LN4@stbi__load

; 1473 :         return stbi__ldr_to_hdr(data, *x, *y, req_comp ? req_comp : *comp);

  000e1	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  000e9	74 0d		 je	 SHORT $LN6@stbi__load
  000eb	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  000f2	89 44 24 30	 mov	 DWORD PTR tv89[rsp], eax
  000f6	eb 0e		 jmp	 SHORT $LN7@stbi__load
$LN6@stbi__load:
  000f8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  00100	8b 00		 mov	 eax, DWORD PTR [rax]
  00102	89 44 24 30	 mov	 DWORD PTR tv89[rsp], eax
$LN7@stbi__load:
  00106	44 8b 4c 24 30	 mov	 r9d, DWORD PTR tv89[rsp]
  0010b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR y$[rsp]
  00113	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  00116	48 8b 44 24 78	 mov	 rax, QWORD PTR x$[rsp]
  0011b	8b 10		 mov	 edx, DWORD PTR [rax]
  0011d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR data$[rsp]
  00122	e8 00 00 00 00	 call	 ?stbi__ldr_to_hdr@@YAPEAMPEAEHHH@Z ; stbi__ldr_to_hdr
  00127	eb 27		 jmp	 SHORT $LN1@stbi__load
$LN4@stbi__load:

; 1474 :     return stbi__errpf("unknown image type", "Image not of any known type, or corrupt");

  00129	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG76865
  00130	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00135	85 c0		 test	 eax, eax
  00137	74 0a		 je	 SHORT $LN8@stbi__load
  00139	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv129[rsp], 0
  00141	eb 08		 jmp	 SHORT $LN9@stbi__load
$LN8@stbi__load:
  00143	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv129[rsp], 0
$LN9@stbi__load:
  0014b	48 63 44 24 34	 movsxd	 rax, DWORD PTR tv129[rsp]
$LN1@stbi__load:

; 1475 : }

  00150	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00155	48 33 cc	 xor	 rcx, rsp
  00158	e8 00 00 00 00	 call	 __security_check_cookie
  0015d	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00161	c3		 ret	 0
?stbi__loadf_main@@YAPEAMPEAUstbi__context@@PEAH11H@Z ENDP ; stbi__loadf_main
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
f$ = 32
filename$ = 64
mode$ = 72
?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z PROC		; stbi__fopen

; 1337 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1338 :     FILE *f;
; 1339 : #if defined(_WIN32) && defined(STBI_WINDOWS_UTF8)
; 1340 :     wchar_t wMode[64];
; 1341 :     wchar_t wFilename[1024];
; 1342 : 	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, filename, -1, wFilename, sizeof(wFilename)/sizeof(*wFilename)))
; 1343 :         return 0;
; 1344 :     
; 1345 : 	if (0 == MultiByteToWideChar(65001 /* UTF8 */, 0, mode, -1, wMode, sizeof(wMode)/sizeof(*wMode)))
; 1346 :         return 0;
; 1347 :     
; 1348 : #if defined(_MSC_VER) && _MSC_VER >= 1400
; 1349 : 	if (0 != _wfopen_s(&f, wFilename, wMode))
; 1350 : 		f = 0;
; 1351 : #else
; 1352 :     f = _wfopen(wFilename, wMode);
; 1353 : #endif
; 1354 :     
; 1355 : #elif defined(_MSC_VER) && _MSC_VER >= 1400
; 1356 :     if (0 != fopen_s(&f, filename, mode))

  0000e	4c 8b 44 24 48	 mov	 r8, QWORD PTR mode$[rsp]
  00013	48 8b 54 24 40	 mov	 rdx, QWORD PTR filename$[rsp]
  00018	48 8d 4c 24 20	 lea	 rcx, QWORD PTR f$[rsp]
  0001d	e8 00 00 00 00	 call	 fopen_s
  00022	85 c0		 test	 eax, eax
  00024	74 09		 je	 SHORT $LN2@stbi__fope

; 1357 :         f=0;

  00026	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR f$[rsp], 0
$LN2@stbi__fope:

; 1358 : #else
; 1359 :     f = fopen(filename, mode);
; 1360 : #endif
; 1361 :     return f;

  0002f	48 8b 44 24 20	 mov	 rax, QWORD PTR f$[rsp]

; 1362 : }

  00034	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00038	c3		 ret	 0
?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z ENDP		; stbi__fopen
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv77 = 32
tv81 = 36
channels$1 = 40
result$ = 64
x$ = 72
y$ = 80
comp$ = 88
req_comp$ = 96
?stbi__float_postprocess@@YAXPEAMPEAH11H@Z PROC		; stbi__float_postprocess

; 1314 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1315 :     if (stbi__vertically_flip_on_load && result != NULL) {

  00018	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__vertically_flip_on_load_set@@3HA
  0001d	8b c0		 mov	 eax, eax
  0001f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00025	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0002e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00032	83 3c 08 00	 cmp	 DWORD PTR [rax+rcx], 0
  00036	74 23		 je	 SHORT $LN4@stbi__floa
  00038	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__vertically_flip_on_load_local@@3HA
  0003d	8b c0		 mov	 eax, eax
  0003f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00045	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0004e	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00052	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]
  00055	89 44 24 20	 mov	 DWORD PTR tv77[rsp], eax
  00059	eb 0a		 jmp	 SHORT $LN5@stbi__floa
$LN4@stbi__floa:
  0005b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?stbi__vertically_flip_on_load_global@@3HA
  00061	89 44 24 20	 mov	 DWORD PTR tv77[rsp], eax
$LN5@stbi__floa:
  00065	83 7c 24 20 00	 cmp	 DWORD PTR tv77[rsp], 0
  0006a	74 51		 je	 SHORT $LN2@stbi__floa
  0006c	48 83 7c 24 40
	00		 cmp	 QWORD PTR result$[rsp], 0
  00072	74 49		 je	 SHORT $LN2@stbi__floa

; 1316 :         int channels = req_comp ? req_comp : *comp;

  00074	83 7c 24 60 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  00079	74 0a		 je	 SHORT $LN6@stbi__floa
  0007b	8b 44 24 60	 mov	 eax, DWORD PTR req_comp$[rsp]
  0007f	89 44 24 24	 mov	 DWORD PTR tv81[rsp], eax
  00083	eb 0b		 jmp	 SHORT $LN7@stbi__floa
$LN6@stbi__floa:
  00085	48 8b 44 24 58	 mov	 rax, QWORD PTR comp$[rsp]
  0008a	8b 00		 mov	 eax, DWORD PTR [rax]
  0008c	89 44 24 24	 mov	 DWORD PTR tv81[rsp], eax
$LN7@stbi__floa:
  00090	8b 44 24 24	 mov	 eax, DWORD PTR tv81[rsp]
  00094	89 44 24 28	 mov	 DWORD PTR channels$1[rsp], eax

; 1317 :         stbi__vertical_flip(result, *x, *y, channels * sizeof(float));

  00098	48 63 44 24 28	 movsxd	 rax, DWORD PTR channels$1[rsp]
  0009d	48 c1 e0 02	 shl	 rax, 2
  000a1	44 8b c8	 mov	 r9d, eax
  000a4	48 8b 44 24 50	 mov	 rax, QWORD PTR y$[rsp]
  000a9	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  000ac	48 8b 44 24 48	 mov	 rax, QWORD PTR x$[rsp]
  000b1	8b 10		 mov	 edx, DWORD PTR [rax]
  000b3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR result$[rsp]
  000b8	e8 00 00 00 00	 call	 ?stbi__vertical_flip@@YAXPEAXHHH@Z ; stbi__vertical_flip
$LN2@stbi__floa:

; 1318 :     }
; 1319 : }

  000bd	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c1	c3		 ret	 0
?stbi__float_postprocess@@YAXPEAMPEAH11H@Z ENDP		; stbi__float_postprocess
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv82 = 64
tv132 = 68
tv135 = 72
result$ = 80
channels$1 = 88
ri$ = 96
__$ArrayPad$ = 112
s$ = 144
x$ = 152
y$ = 160
comp$ = 168
req_comp$ = 176
?stbi__load_and_postprocess_16bit@@YAPEAGPEAUstbi__context@@PEAH11H@Z PROC ; stbi__load_and_postprocess_16bit

; 1286 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1287 :     stbi__result_info ri;
; 1288 :     void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 16);

  0002a	c7 44 24 30 10
	00 00 00	 mov	 DWORD PTR [rsp+48], 16
  00032	48 8d 44 24 60	 lea	 rax, QWORD PTR ri$[rsp]
  00037	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0003c	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00043	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00047	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  0004f	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00057	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  0005f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00067	e8 00 00 00 00	 call	 ?stbi__load_main@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z ; stbi__load_main
  0006c	48 89 44 24 50	 mov	 QWORD PTR result$[rsp], rax

; 1289 :     
; 1290 :     if (result == NULL)

  00071	48 83 7c 24 50
	00		 cmp	 QWORD PTR result$[rsp], 0
  00077	75 07		 jne	 SHORT $LN2@stbi__load

; 1291 :         return NULL;

  00079	33 c0		 xor	 eax, eax
  0007b	e9 36 01 00 00	 jmp	 $LN1@stbi__load
$LN2@stbi__load:

; 1292 :     
; 1293 :     // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
; 1294 :     STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);

  00080	83 7c 24 60 08	 cmp	 DWORD PTR ri$[rsp], 8
  00085	74 22		 je	 SHORT $LN6@stbi__load
  00087	83 7c 24 60 10	 cmp	 DWORD PTR ri$[rsp], 16
  0008c	74 1b		 je	 SHORT $LN6@stbi__load
  0008e	41 b8 0e 05 00
	00		 mov	 r8d, 1294		; 0000050eH
  00094	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG76727
  0009b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG76728
  000a2	e8 00 00 00 00	 call	 _wassert
  000a7	33 c0		 xor	 eax, eax
$LN6@stbi__load:

; 1295 :     
; 1296 :     if (ri.bits_per_channel != 16) {

  000a9	83 7c 24 60 10	 cmp	 DWORD PTR ri$[rsp], 16
  000ae	74 56		 je	 SHORT $LN3@stbi__load

; 1297 :         result = stbi__convert_8_to_16((stbi_uc *) result, *x, *y, req_comp == 0 ? *comp : req_comp);

  000b0	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  000b8	75 10		 jne	 SHORT $LN7@stbi__load
  000ba	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  000c2	8b 00		 mov	 eax, DWORD PTR [rax]
  000c4	89 44 24 40	 mov	 DWORD PTR tv82[rsp], eax
  000c8	eb 0b		 jmp	 SHORT $LN8@stbi__load
$LN7@stbi__load:
  000ca	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  000d1	89 44 24 40	 mov	 DWORD PTR tv82[rsp], eax
$LN8@stbi__load:
  000d5	44 8b 4c 24 40	 mov	 r9d, DWORD PTR tv82[rsp]
  000da	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR y$[rsp]
  000e2	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  000e5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR x$[rsp]
  000ed	8b 10		 mov	 edx, DWORD PTR [rax]
  000ef	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result$[rsp]
  000f4	e8 00 00 00 00	 call	 ?stbi__convert_8_to_16@@YAPEAGPEAEHHH@Z ; stbi__convert_8_to_16
  000f9	48 89 44 24 50	 mov	 QWORD PTR result$[rsp], rax

; 1298 :         ri.bits_per_channel = 16;

  000fe	c7 44 24 60 10
	00 00 00	 mov	 DWORD PTR ri$[rsp], 16
$LN3@stbi__load:

; 1299 :     }
; 1300 :     
; 1301 :     // @TODO: move stbi__convert_format16 to here
; 1302 :     // @TODO: special case RGB-to-Y (and RGBA-to-YA) for 8-bit-to-16-bit case to keep more precision
; 1303 :     
; 1304 :     if (stbi__vertically_flip_on_load) {

  00106	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__vertically_flip_on_load_set@@3HA
  0010b	8b c0		 mov	 eax, eax
  0010d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00113	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0011c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00120	83 3c 08 00	 cmp	 DWORD PTR [rax+rcx], 0
  00124	74 23		 je	 SHORT $LN9@stbi__load
  00126	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__vertically_flip_on_load_local@@3HA
  0012b	8b c0		 mov	 eax, eax
  0012d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00133	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0013c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00140	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]
  00143	89 44 24 44	 mov	 DWORD PTR tv132[rsp], eax
  00147	eb 0a		 jmp	 SHORT $LN10@stbi__load
$LN9@stbi__load:
  00149	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?stbi__vertically_flip_on_load_global@@3HA
  0014f	89 44 24 44	 mov	 DWORD PTR tv132[rsp], eax
$LN10@stbi__load:
  00153	83 7c 24 44 00	 cmp	 DWORD PTR tv132[rsp], 0
  00158	74 57		 je	 SHORT $LN4@stbi__load

; 1305 :         int channels = req_comp ? req_comp : *comp;

  0015a	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  00162	74 0d		 je	 SHORT $LN11@stbi__load
  00164	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  0016b	89 44 24 48	 mov	 DWORD PTR tv135[rsp], eax
  0016f	eb 0e		 jmp	 SHORT $LN12@stbi__load
$LN11@stbi__load:
  00171	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  00179	8b 00		 mov	 eax, DWORD PTR [rax]
  0017b	89 44 24 48	 mov	 DWORD PTR tv135[rsp], eax
$LN12@stbi__load:
  0017f	8b 44 24 48	 mov	 eax, DWORD PTR tv135[rsp]
  00183	89 44 24 58	 mov	 DWORD PTR channels$1[rsp], eax

; 1306 :         stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi__uint16));

  00187	48 63 44 24 58	 movsxd	 rax, DWORD PTR channels$1[rsp]
  0018c	48 d1 e0	 shl	 rax, 1
  0018f	44 8b c8	 mov	 r9d, eax
  00192	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR y$[rsp]
  0019a	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  0019d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR x$[rsp]
  001a5	8b 10		 mov	 edx, DWORD PTR [rax]
  001a7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result$[rsp]
  001ac	e8 00 00 00 00	 call	 ?stbi__vertical_flip@@YAXPEAXHHH@Z ; stbi__vertical_flip
$LN4@stbi__load:

; 1307 :     }
; 1308 :     
; 1309 :     return (stbi__uint16 *) result;

  001b1	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
$LN1@stbi__load:

; 1310 : }

  001b6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001bb	48 33 cc	 xor	 rcx, rsp
  001be	e8 00 00 00 00	 call	 __security_check_cookie
  001c3	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001ca	c3		 ret	 0
?stbi__load_and_postprocess_16bit@@YAPEAGPEAUstbi__context@@PEAH11H@Z ENDP ; stbi__load_and_postprocess_16bit
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv82 = 64
tv132 = 68
tv135 = 72
result$ = 80
channels$1 = 88
ri$ = 96
__$ArrayPad$ = 112
s$ = 144
x$ = 152
y$ = 160
comp$ = 168
req_comp$ = 176
?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z PROC ; stbi__load_and_postprocess_8bit

; 1260 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1261 :     stbi__result_info ri;
; 1262 :     void *result = stbi__load_main(s, x, y, comp, req_comp, &ri, 8);

  0002a	c7 44 24 30 08
	00 00 00	 mov	 DWORD PTR [rsp+48], 8
  00032	48 8d 44 24 60	 lea	 rax, QWORD PTR ri$[rsp]
  00037	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0003c	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00043	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00047	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  0004f	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00057	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  0005f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00067	e8 00 00 00 00	 call	 ?stbi__load_main@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z ; stbi__load_main
  0006c	48 89 44 24 50	 mov	 QWORD PTR result$[rsp], rax

; 1263 :     
; 1264 :     if (result == NULL)

  00071	48 83 7c 24 50
	00		 cmp	 QWORD PTR result$[rsp], 0
  00077	75 07		 jne	 SHORT $LN2@stbi__load

; 1265 :         return NULL;

  00079	33 c0		 xor	 eax, eax
  0007b	e9 30 01 00 00	 jmp	 $LN1@stbi__load
$LN2@stbi__load:

; 1266 :     
; 1267 :     // it is the responsibility of the loaders to make sure we get either 8 or 16 bit.
; 1268 :     STBI_ASSERT(ri.bits_per_channel == 8 || ri.bits_per_channel == 16);

  00080	83 7c 24 60 08	 cmp	 DWORD PTR ri$[rsp], 8
  00085	74 22		 je	 SHORT $LN6@stbi__load
  00087	83 7c 24 60 10	 cmp	 DWORD PTR ri$[rsp], 16
  0008c	74 1b		 je	 SHORT $LN6@stbi__load
  0008e	41 b8 f4 04 00
	00		 mov	 r8d, 1268		; 000004f4H
  00094	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG76707
  0009b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG76708
  000a2	e8 00 00 00 00	 call	 _wassert
  000a7	33 c0		 xor	 eax, eax
$LN6@stbi__load:

; 1269 :     
; 1270 :     if (ri.bits_per_channel != 8) {

  000a9	83 7c 24 60 08	 cmp	 DWORD PTR ri$[rsp], 8
  000ae	74 56		 je	 SHORT $LN3@stbi__load

; 1271 :         result = stbi__convert_16_to_8((stbi__uint16 *) result, *x, *y, req_comp == 0 ? *comp : req_comp);

  000b0	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  000b8	75 10		 jne	 SHORT $LN7@stbi__load
  000ba	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  000c2	8b 00		 mov	 eax, DWORD PTR [rax]
  000c4	89 44 24 40	 mov	 DWORD PTR tv82[rsp], eax
  000c8	eb 0b		 jmp	 SHORT $LN8@stbi__load
$LN7@stbi__load:
  000ca	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  000d1	89 44 24 40	 mov	 DWORD PTR tv82[rsp], eax
$LN8@stbi__load:
  000d5	44 8b 4c 24 40	 mov	 r9d, DWORD PTR tv82[rsp]
  000da	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR y$[rsp]
  000e2	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  000e5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR x$[rsp]
  000ed	8b 10		 mov	 edx, DWORD PTR [rax]
  000ef	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result$[rsp]
  000f4	e8 00 00 00 00	 call	 ?stbi__convert_16_to_8@@YAPEAEPEAGHHH@Z ; stbi__convert_16_to_8
  000f9	48 89 44 24 50	 mov	 QWORD PTR result$[rsp], rax

; 1272 :         ri.bits_per_channel = 8;

  000fe	c7 44 24 60 08
	00 00 00	 mov	 DWORD PTR ri$[rsp], 8
$LN3@stbi__load:

; 1273 :     }
; 1274 :     
; 1275 :     // @TODO: move stbi__convert_format to here
; 1276 :     
; 1277 :     if (stbi__vertically_flip_on_load) {

  00106	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__vertically_flip_on_load_set@@3HA
  0010b	8b c0		 mov	 eax, eax
  0010d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00113	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0011c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00120	83 3c 08 00	 cmp	 DWORD PTR [rax+rcx], 0
  00124	74 23		 je	 SHORT $LN9@stbi__load
  00126	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__vertically_flip_on_load_local@@3HA
  0012b	8b c0		 mov	 eax, eax
  0012d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00133	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0013c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00140	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]
  00143	89 44 24 44	 mov	 DWORD PTR tv132[rsp], eax
  00147	eb 0a		 jmp	 SHORT $LN10@stbi__load
$LN9@stbi__load:
  00149	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?stbi__vertically_flip_on_load_global@@3HA
  0014f	89 44 24 44	 mov	 DWORD PTR tv132[rsp], eax
$LN10@stbi__load:
  00153	83 7c 24 44 00	 cmp	 DWORD PTR tv132[rsp], 0
  00158	74 51		 je	 SHORT $LN4@stbi__load

; 1278 :         int channels = req_comp ? req_comp : *comp;

  0015a	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  00162	74 0d		 je	 SHORT $LN11@stbi__load
  00164	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  0016b	89 44 24 48	 mov	 DWORD PTR tv135[rsp], eax
  0016f	eb 0e		 jmp	 SHORT $LN12@stbi__load
$LN11@stbi__load:
  00171	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  00179	8b 00		 mov	 eax, DWORD PTR [rax]
  0017b	89 44 24 48	 mov	 DWORD PTR tv135[rsp], eax
$LN12@stbi__load:
  0017f	8b 44 24 48	 mov	 eax, DWORD PTR tv135[rsp]
  00183	89 44 24 58	 mov	 DWORD PTR channels$1[rsp], eax

; 1279 :         stbi__vertical_flip(result, *x, *y, channels * sizeof(stbi_uc));

  00187	44 8b 4c 24 58	 mov	 r9d, DWORD PTR channels$1[rsp]
  0018c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR y$[rsp]
  00194	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  00197	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR x$[rsp]
  0019f	8b 10		 mov	 edx, DWORD PTR [rax]
  001a1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR result$[rsp]
  001a6	e8 00 00 00 00	 call	 ?stbi__vertical_flip@@YAXPEAXHHH@Z ; stbi__vertical_flip
$LN4@stbi__load:

; 1280 :     }
; 1281 :     
; 1282 :     return (unsigned char *) result;

  001ab	48 8b 44 24 50	 mov	 rax, QWORD PTR result$[rsp]
$LN1@stbi__load:

; 1283 : }

  001b0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001b5	48 33 cc	 xor	 rcx, rsp
  001b8	e8 00 00 00 00	 call	 __security_check_cookie
  001bd	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001c4	c3		 ret	 0
?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z ENDP ; stbi__load_and_postprocess_8bit
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
slice$ = 32
slice_size$ = 36
bytes$ = 40
image$ = 64
w$ = 72
h$ = 80
z$ = 88
bytes_per_pixel$ = 96
?stbi__vertical_flip_slices@@YAXPEAXHHHH@Z PROC		; stbi__vertical_flip_slices

; 1247 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1248 :     int slice;
; 1249 :     int slice_size = w * h * bytes_per_pixel;

  00017	8b 44 24 48	 mov	 eax, DWORD PTR w$[rsp]
  0001b	0f af 44 24 50	 imul	 eax, DWORD PTR h$[rsp]
  00020	0f af 44 24 60	 imul	 eax, DWORD PTR bytes_per_pixel$[rsp]
  00025	89 44 24 24	 mov	 DWORD PTR slice_size$[rsp], eax

; 1250 :     
; 1251 :     stbi_uc *bytes = (stbi_uc *)image;

  00029	48 8b 44 24 40	 mov	 rax, QWORD PTR image$[rsp]
  0002e	48 89 44 24 28	 mov	 QWORD PTR bytes$[rsp], rax

; 1252 :     for (slice = 0; slice < z; ++slice) {

  00033	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR slice$[rsp], 0
  0003b	eb 0a		 jmp	 SHORT $LN4@stbi__vert
$LN2@stbi__vert:
  0003d	8b 44 24 20	 mov	 eax, DWORD PTR slice$[rsp]
  00041	ff c0		 inc	 eax
  00043	89 44 24 20	 mov	 DWORD PTR slice$[rsp], eax
$LN4@stbi__vert:
  00047	8b 44 24 58	 mov	 eax, DWORD PTR z$[rsp]
  0004b	39 44 24 20	 cmp	 DWORD PTR slice$[rsp], eax
  0004f	7d 2f		 jge	 SHORT $LN3@stbi__vert

; 1253 :         stbi__vertical_flip(bytes, w, h, bytes_per_pixel);

  00051	44 8b 4c 24 60	 mov	 r9d, DWORD PTR bytes_per_pixel$[rsp]
  00056	44 8b 44 24 50	 mov	 r8d, DWORD PTR h$[rsp]
  0005b	8b 54 24 48	 mov	 edx, DWORD PTR w$[rsp]
  0005f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bytes$[rsp]
  00064	e8 00 00 00 00	 call	 ?stbi__vertical_flip@@YAXPEAXHHH@Z ; stbi__vertical_flip

; 1254 :         bytes += slice_size;

  00069	48 63 44 24 24	 movsxd	 rax, DWORD PTR slice_size$[rsp]
  0006e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bytes$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 28	 mov	 QWORD PTR bytes$[rsp], rax

; 1255 :     }

  0007e	eb bd		 jmp	 SHORT $LN2@stbi__vert
$LN3@stbi__vert:

; 1256 : }

  00080	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00084	c3		 ret	 0
?stbi__vertical_flip_slices@@YAXPEAXHHHH@Z ENDP		; stbi__vertical_flip_slices
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
row$ = 32
bytes_copy$1 = 40
bytes_left$2 = 48
row0$3 = 56
row1$4 = 64
bytes_per_row$ = 72
bytes$ = 80
tv80 = 88
temp$ = 96
__$ArrayPad$ = 2144
image$ = 2176
w$ = 2184
h$ = 2192
bytes_per_pixel$ = 2200
?stbi__vertical_flip@@YAXPEAXHHH@Z PROC			; stbi__vertical_flip

; 1222 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 78 08
	00 00		 sub	 rsp, 2168		; 00000878H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 60
	08 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1223 :     int row;
; 1224 :     size_t bytes_per_row = (size_t)w * bytes_per_pixel;

  0002c	48 63 84 24 88
	08 00 00	 movsxd	 rax, DWORD PTR w$[rsp]
  00034	48 63 8c 24 98
	08 00 00	 movsxd	 rcx, DWORD PTR bytes_per_pixel$[rsp]
  0003c	48 0f af c1	 imul	 rax, rcx
  00040	48 89 44 24 48	 mov	 QWORD PTR bytes_per_row$[rsp], rax

; 1225 :     stbi_uc temp[2048];
; 1226 :     stbi_uc *bytes = (stbi_uc *)image;

  00045	48 8b 84 24 80
	08 00 00	 mov	 rax, QWORD PTR image$[rsp]
  0004d	48 89 44 24 50	 mov	 QWORD PTR bytes$[rsp], rax

; 1227 :     
; 1228 :     for (row = 0; row < (h>>1); row++) {

  00052	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR row$[rsp], 0
  0005a	eb 0a		 jmp	 SHORT $LN4@stbi__vert
$LN2@stbi__vert:
  0005c	8b 44 24 20	 mov	 eax, DWORD PTR row$[rsp]
  00060	ff c0		 inc	 eax
  00062	89 44 24 20	 mov	 DWORD PTR row$[rsp], eax
$LN4@stbi__vert:
  00066	8b 84 24 90 08
	00 00		 mov	 eax, DWORD PTR h$[rsp]
  0006d	d1 f8		 sar	 eax, 1
  0006f	39 44 24 20	 cmp	 DWORD PTR row$[rsp], eax
  00073	0f 8d 09 01 00
	00		 jge	 $LN3@stbi__vert

; 1229 :         stbi_uc *row0 = bytes + row*bytes_per_row;

  00079	48 63 44 24 20	 movsxd	 rax, DWORD PTR row$[rsp]
  0007e	48 0f af 44 24
	48		 imul	 rax, QWORD PTR bytes_per_row$[rsp]
  00084	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bytes$[rsp]
  00089	48 03 c8	 add	 rcx, rax
  0008c	48 8b c1	 mov	 rax, rcx
  0008f	48 89 44 24 38	 mov	 QWORD PTR row0$3[rsp], rax

; 1230 :         stbi_uc *row1 = bytes + (h - row - 1)*bytes_per_row;

  00094	8b 44 24 20	 mov	 eax, DWORD PTR row$[rsp]
  00098	8b 8c 24 90 08
	00 00		 mov	 ecx, DWORD PTR h$[rsp]
  0009f	2b c8		 sub	 ecx, eax
  000a1	8b c1		 mov	 eax, ecx
  000a3	ff c8		 dec	 eax
  000a5	48 98		 cdqe
  000a7	48 0f af 44 24
	48		 imul	 rax, QWORD PTR bytes_per_row$[rsp]
  000ad	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bytes$[rsp]
  000b2	48 03 c8	 add	 rcx, rax
  000b5	48 8b c1	 mov	 rax, rcx
  000b8	48 89 44 24 40	 mov	 QWORD PTR row1$4[rsp], rax

; 1231 :         // swap row0 with row1
; 1232 :         size_t bytes_left = bytes_per_row;

  000bd	48 8b 44 24 48	 mov	 rax, QWORD PTR bytes_per_row$[rsp]
  000c2	48 89 44 24 30	 mov	 QWORD PTR bytes_left$2[rsp], rax
$LN5@stbi__vert:

; 1233 :         while (bytes_left) {

  000c7	48 83 7c 24 30
	00		 cmp	 QWORD PTR bytes_left$2[rsp], 0
  000cd	0f 84 aa 00 00
	00		 je	 $LN6@stbi__vert

; 1234 :             size_t bytes_copy = (bytes_left < sizeof(temp)) ? bytes_left : sizeof(temp);

  000d3	48 81 7c 24 30
	00 08 00 00	 cmp	 QWORD PTR bytes_left$2[rsp], 2048 ; 00000800H
  000dc	73 0c		 jae	 SHORT $LN8@stbi__vert
  000de	48 8b 44 24 30	 mov	 rax, QWORD PTR bytes_left$2[rsp]
  000e3	48 89 44 24 58	 mov	 QWORD PTR tv80[rsp], rax
  000e8	eb 09		 jmp	 SHORT $LN9@stbi__vert
$LN8@stbi__vert:
  000ea	48 c7 44 24 58
	00 08 00 00	 mov	 QWORD PTR tv80[rsp], 2048 ; 00000800H
$LN9@stbi__vert:
  000f3	48 8b 44 24 58	 mov	 rax, QWORD PTR tv80[rsp]
  000f8	48 89 44 24 28	 mov	 QWORD PTR bytes_copy$1[rsp], rax

; 1235 :             memcpy(temp, row0, bytes_copy);

  000fd	4c 8b 44 24 28	 mov	 r8, QWORD PTR bytes_copy$1[rsp]
  00102	48 8b 54 24 38	 mov	 rdx, QWORD PTR row0$3[rsp]
  00107	48 8d 4c 24 60	 lea	 rcx, QWORD PTR temp$[rsp]
  0010c	e8 00 00 00 00	 call	 memcpy

; 1236 :             memcpy(row0, row1, bytes_copy);

  00111	4c 8b 44 24 28	 mov	 r8, QWORD PTR bytes_copy$1[rsp]
  00116	48 8b 54 24 40	 mov	 rdx, QWORD PTR row1$4[rsp]
  0011b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR row0$3[rsp]
  00120	e8 00 00 00 00	 call	 memcpy

; 1237 :             memcpy(row1, temp, bytes_copy);

  00125	4c 8b 44 24 28	 mov	 r8, QWORD PTR bytes_copy$1[rsp]
  0012a	48 8d 54 24 60	 lea	 rdx, QWORD PTR temp$[rsp]
  0012f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR row1$4[rsp]
  00134	e8 00 00 00 00	 call	 memcpy

; 1238 :             row0 += bytes_copy;

  00139	48 8b 44 24 28	 mov	 rax, QWORD PTR bytes_copy$1[rsp]
  0013e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR row0$3[rsp]
  00143	48 03 c8	 add	 rcx, rax
  00146	48 8b c1	 mov	 rax, rcx
  00149	48 89 44 24 38	 mov	 QWORD PTR row0$3[rsp], rax

; 1239 :             row1 += bytes_copy;

  0014e	48 8b 44 24 28	 mov	 rax, QWORD PTR bytes_copy$1[rsp]
  00153	48 8b 4c 24 40	 mov	 rcx, QWORD PTR row1$4[rsp]
  00158	48 03 c8	 add	 rcx, rax
  0015b	48 8b c1	 mov	 rax, rcx
  0015e	48 89 44 24 40	 mov	 QWORD PTR row1$4[rsp], rax

; 1240 :             bytes_left -= bytes_copy;

  00163	48 8b 44 24 28	 mov	 rax, QWORD PTR bytes_copy$1[rsp]
  00168	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bytes_left$2[rsp]
  0016d	48 2b c8	 sub	 rcx, rax
  00170	48 8b c1	 mov	 rax, rcx
  00173	48 89 44 24 30	 mov	 QWORD PTR bytes_left$2[rsp], rax

; 1241 :         }

  00178	e9 4a ff ff ff	 jmp	 $LN5@stbi__vert
$LN6@stbi__vert:

; 1242 :     }

  0017d	e9 da fe ff ff	 jmp	 $LN2@stbi__vert
$LN3@stbi__vert:

; 1243 : }

  00182	48 8b 8c 24 60
	08 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0018a	48 33 cc	 xor	 rcx, rsp
  0018d	e8 00 00 00 00	 call	 __security_check_cookie
  00192	48 81 c4 78 08
	00 00		 add	 rsp, 2168		; 00000878H
  00199	c3		 ret	 0
?stbi__vertical_flip@@YAXPEAXHHH@Z ENDP			; stbi__vertical_flip
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
i$ = 32
tv74 = 36
img_len$ = 40
enlarged$ = 48
orig$ = 80
w$ = 88
h$ = 96
channels$ = 104
?stbi__convert_8_to_16@@YAPEAGPEAEHHH@Z PROC		; stbi__convert_8_to_16

; 1206 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1207 :     int i;
; 1208 :     int img_len = w * h * channels;

  00017	8b 44 24 58	 mov	 eax, DWORD PTR w$[rsp]
  0001b	0f af 44 24 60	 imul	 eax, DWORD PTR h$[rsp]
  00020	0f af 44 24 68	 imul	 eax, DWORD PTR channels$[rsp]
  00025	89 44 24 28	 mov	 DWORD PTR img_len$[rsp], eax

; 1209 :     stbi__uint16 *enlarged;
; 1210 :     
; 1211 :     enlarged = (stbi__uint16 *) stbi__malloc(img_len*2);

  00029	8b 44 24 28	 mov	 eax, DWORD PTR img_len$[rsp]
  0002d	d1 e0		 shl	 eax, 1
  0002f	48 98		 cdqe
  00031	48 8b c8	 mov	 rcx, rax
  00034	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  00039	48 89 44 24 30	 mov	 QWORD PTR enlarged$[rsp], rax

; 1212 :     if (enlarged == NULL) return (stbi__uint16 *) stbi__errpuc("outofmem", "Out of memory");

  0003e	48 83 7c 24 30
	00		 cmp	 QWORD PTR enlarged$[rsp], 0
  00044	75 29		 jne	 SHORT $LN5@stbi__conv
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG76655
  0004d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00052	85 c0		 test	 eax, eax
  00054	74 0a		 je	 SHORT $LN7@stbi__conv
  00056	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
  0005e	eb 08		 jmp	 SHORT $LN8@stbi__conv
$LN7@stbi__conv:
  00060	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN8@stbi__conv:
  00068	48 63 44 24 24	 movsxd	 rax, DWORD PTR tv74[rsp]
  0006d	eb 5e		 jmp	 SHORT $LN1@stbi__conv
$LN5@stbi__conv:

; 1213 :     
; 1214 :     for (i = 0; i < img_len; ++i)

  0006f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00077	eb 0a		 jmp	 SHORT $LN4@stbi__conv
$LN2@stbi__conv:
  00079	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0007d	ff c0		 inc	 eax
  0007f	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__conv:
  00083	8b 44 24 28	 mov	 eax, DWORD PTR img_len$[rsp]
  00087	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0008b	7d 31		 jge	 SHORT $LN3@stbi__conv

; 1215 :         enlarged[i] = (stbi__uint16)((orig[i] << 8) + orig[i]); // replicate to high and low byte, maps 0->0, 255->0xffff

  0008d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00092	48 8b 4c 24 50	 mov	 rcx, QWORD PTR orig$[rsp]
  00097	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0009b	c1 e0 08	 shl	 eax, 8
  0009e	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000a3	48 8b 54 24 50	 mov	 rdx, QWORD PTR orig$[rsp]
  000a8	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000ac	03 c1		 add	 eax, ecx
  000ae	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000b3	48 8b 54 24 30	 mov	 rdx, QWORD PTR enlarged$[rsp]
  000b8	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax
  000bc	eb bb		 jmp	 SHORT $LN2@stbi__conv
$LN3@stbi__conv:

; 1216 :     
; 1217 :     STBI_FREE(orig);

  000be	48 8b 4c 24 50	 mov	 rcx, QWORD PTR orig$[rsp]
  000c3	e8 00 00 00 00	 call	 free

; 1218 :     return enlarged;

  000c8	48 8b 44 24 30	 mov	 rax, QWORD PTR enlarged$[rsp]
$LN1@stbi__conv:

; 1219 : }

  000cd	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000d1	c3		 ret	 0
?stbi__convert_8_to_16@@YAPEAGPEAEHHH@Z ENDP		; stbi__convert_8_to_16
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
i$ = 32
tv73 = 36
img_len$ = 40
reduced$ = 48
orig$ = 80
w$ = 88
h$ = 96
channels$ = 104
?stbi__convert_16_to_8@@YAPEAEPEAGHHH@Z PROC		; stbi__convert_16_to_8

; 1190 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1191 :     int i;
; 1192 :     int img_len = w * h * channels;

  00017	8b 44 24 58	 mov	 eax, DWORD PTR w$[rsp]
  0001b	0f af 44 24 60	 imul	 eax, DWORD PTR h$[rsp]
  00020	0f af 44 24 68	 imul	 eax, DWORD PTR channels$[rsp]
  00025	89 44 24 28	 mov	 DWORD PTR img_len$[rsp], eax

; 1193 :     stbi_uc *reduced;
; 1194 :     
; 1195 :     reduced = (stbi_uc *) stbi__malloc(img_len);

  00029	48 63 44 24 28	 movsxd	 rax, DWORD PTR img_len$[rsp]
  0002e	48 8b c8	 mov	 rcx, rax
  00031	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  00036	48 89 44 24 30	 mov	 QWORD PTR reduced$[rsp], rax

; 1196 :     if (reduced == NULL) return stbi__errpuc("outofmem", "Out of memory");

  0003b	48 83 7c 24 30
	00		 cmp	 QWORD PTR reduced$[rsp], 0
  00041	75 29		 jne	 SHORT $LN5@stbi__conv
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG76636
  0004a	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN7@stbi__conv
  00053	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
  0005b	eb 08		 jmp	 SHORT $LN8@stbi__conv
$LN7@stbi__conv:
  0005d	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN8@stbi__conv:
  00065	48 63 44 24 24	 movsxd	 rax, DWORD PTR tv73[rsp]
  0006a	eb 52		 jmp	 SHORT $LN1@stbi__conv
$LN5@stbi__conv:

; 1197 :     
; 1198 :     for (i = 0; i < img_len; ++i)

  0006c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00074	eb 0a		 jmp	 SHORT $LN4@stbi__conv
$LN2@stbi__conv:
  00076	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0007a	ff c0		 inc	 eax
  0007c	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__conv:
  00080	8b 44 24 28	 mov	 eax, DWORD PTR img_len$[rsp]
  00084	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00088	7d 25		 jge	 SHORT $LN3@stbi__conv

; 1199 :         reduced[i] = (stbi_uc)((orig[i] >> 8) & 0xFF); // top half of each byte is sufficient approx of 16->8 bit scaling

  0008a	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0008f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR orig$[rsp]
  00094	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00098	c1 f8 08	 sar	 eax, 8
  0009b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000a0	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000a5	48 8b 54 24 30	 mov	 rdx, QWORD PTR reduced$[rsp]
  000aa	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000ad	eb c7		 jmp	 SHORT $LN2@stbi__conv
$LN3@stbi__conv:

; 1200 :     
; 1201 :     STBI_FREE(orig);

  000af	48 8b 4c 24 50	 mov	 rcx, QWORD PTR orig$[rsp]
  000b4	e8 00 00 00 00	 call	 free

; 1202 :     return reduced;

  000b9	48 8b 44 24 30	 mov	 rax, QWORD PTR reduced$[rsp]
$LN1@stbi__conv:

; 1203 : }

  000be	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c2	c3		 ret	 0
?stbi__convert_16_to_8@@YAPEAEPEAGHHH@Z ENDP		; stbi__convert_16_to_8
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv185 = 64
tv203 = 68
hdr$1 = 72
s$ = 96
x$ = 104
y$ = 112
comp$ = 120
req_comp$ = 128
ri$ = 136
bpc$ = 144
?stbi__load_main@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z PROC ; stbi__load_main

; 1137 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1138 :     memset(ri, 0, sizeof(*ri)); // make sure it's initialized if we add new fields

  00018	41 b8 0c 00 00
	00		 mov	 r8d, 12
  0001e	33 d2		 xor	 edx, edx
  00020	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ri$[rsp]
  00028	e8 00 00 00 00	 call	 memset

; 1139 :     ri->bits_per_channel = 8; // default is 8 so most paths don't have to be changed

  0002d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  00035	c7 00 08 00 00
	00		 mov	 DWORD PTR [rax], 8

; 1140 :     ri->channel_order = STBI_ORDER_RGB; // all current input & output are this, but this is here so we can add BGR order

  0003b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  00043	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 1141 :     ri->num_channels = 0;

  0004a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  00052	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 1142 :     
; 1143 :     // test the formats with a very explicit header first (at least a FOURCC
; 1144 :     // or distinctive magic number first)
; 1145 : #ifndef STBI_NO_PNG
; 1146 :     if (stbi__png_test(s))  return stbi__png_load(s,x,y,comp,req_comp, ri);

  00059	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0005e	e8 00 00 00 00	 call	 ?stbi__png_test@@YAHPEAUstbi__context@@@Z ; stbi__png_test
  00063	85 c0		 test	 eax, eax
  00065	74 36		 je	 SHORT $LN2@stbi__load
  00067	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  0006f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00074	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  0007b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0007f	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  00084	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  00089	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  0008e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00093	e8 00 00 00 00	 call	 ?stbi__png_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ; stbi__png_load
  00098	e9 91 02 00 00	 jmp	 $LN1@stbi__load
$LN2@stbi__load:

; 1147 : #endif
; 1148 : #ifndef STBI_NO_BMP
; 1149 :     if (stbi__bmp_test(s))  return stbi__bmp_load(s,x,y,comp,req_comp, ri);

  0009d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000a2	e8 00 00 00 00	 call	 ?stbi__bmp_test@@YAHPEAUstbi__context@@@Z ; stbi__bmp_test
  000a7	85 c0		 test	 eax, eax
  000a9	74 36		 je	 SHORT $LN3@stbi__load
  000ab	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  000b3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000b8	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  000bf	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000c3	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  000c8	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  000cd	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  000d2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000d7	e8 00 00 00 00	 call	 ?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ; stbi__bmp_load
  000dc	e9 4d 02 00 00	 jmp	 $LN1@stbi__load
$LN3@stbi__load:

; 1150 : #endif
; 1151 : #ifndef STBI_NO_GIF
; 1152 :     if (stbi__gif_test(s))  return stbi__gif_load(s,x,y,comp,req_comp, ri);

  000e1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000e6	e8 00 00 00 00	 call	 ?stbi__gif_test@@YAHPEAUstbi__context@@@Z ; stbi__gif_test
  000eb	85 c0		 test	 eax, eax
  000ed	74 36		 je	 SHORT $LN4@stbi__load
  000ef	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  000f7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000fc	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00103	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00107	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  0010c	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  00111	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  00116	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0011b	e8 00 00 00 00	 call	 ?stbi__gif_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ; stbi__gif_load
  00120	e9 09 02 00 00	 jmp	 $LN1@stbi__load
$LN4@stbi__load:

; 1153 : #endif
; 1154 : #ifndef STBI_NO_PSD
; 1155 :     if (stbi__psd_test(s))  return stbi__psd_load(s,x,y,comp,req_comp, ri, bpc);

  00125	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0012a	e8 00 00 00 00	 call	 ?stbi__psd_test@@YAHPEAUstbi__context@@@Z ; stbi__psd_test
  0012f	85 c0		 test	 eax, eax
  00131	74 41		 je	 SHORT $LN5@stbi__load
  00133	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR bpc$[rsp]
  0013a	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0013e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  00146	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0014b	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00152	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00156	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  0015b	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  00160	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  00165	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0016a	e8 00 00 00 00	 call	 ?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z ; stbi__psd_load
  0016f	e9 ba 01 00 00	 jmp	 $LN1@stbi__load
$LN5@stbi__load:

; 1156 : #else
; 1157 :     STBI_NOTUSED(bpc);
; 1158 : #endif
; 1159 : #ifndef STBI_NO_PIC
; 1160 :     if (stbi__pic_test(s))  return stbi__pic_load(s,x,y,comp,req_comp, ri);

  00174	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00179	e8 00 00 00 00	 call	 ?stbi__pic_test@@YAHPEAUstbi__context@@@Z ; stbi__pic_test
  0017e	85 c0		 test	 eax, eax
  00180	74 36		 je	 SHORT $LN6@stbi__load
  00182	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  0018a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0018f	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00196	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0019a	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  0019f	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  001a4	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  001a9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001ae	e8 00 00 00 00	 call	 ?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ; stbi__pic_load
  001b3	e9 76 01 00 00	 jmp	 $LN1@stbi__load
$LN6@stbi__load:

; 1161 : #endif
; 1162 :     
; 1163 :     // then the formats that can end up attempting to load with just 1 or 2
; 1164 :     // bytes matching expectations; these are prone to false positives, so
; 1165 :     // try them later
; 1166 : #ifndef STBI_NO_JPEG
; 1167 :     if (stbi__jpeg_test(s)) return stbi__jpeg_load(s,x,y,comp,req_comp, ri);

  001b8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001bd	e8 00 00 00 00	 call	 ?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z ; stbi__jpeg_test
  001c2	85 c0		 test	 eax, eax
  001c4	74 36		 je	 SHORT $LN7@stbi__load
  001c6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  001ce	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001d3	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  001da	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001de	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  001e3	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  001e8	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  001ed	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001f2	e8 00 00 00 00	 call	 ?stbi__jpeg_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ; stbi__jpeg_load
  001f7	e9 32 01 00 00	 jmp	 $LN1@stbi__load
$LN7@stbi__load:

; 1168 : #endif
; 1169 : #ifndef STBI_NO_PNM
; 1170 :     if (stbi__pnm_test(s))  return stbi__pnm_load(s,x,y,comp,req_comp, ri);

  001fc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00201	e8 00 00 00 00	 call	 ?stbi__pnm_test@@YAHPEAUstbi__context@@@Z ; stbi__pnm_test
  00206	85 c0		 test	 eax, eax
  00208	74 36		 je	 SHORT $LN8@stbi__load
  0020a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  00212	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00217	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  0021e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00222	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  00227	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  0022c	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  00231	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00236	e8 00 00 00 00	 call	 ?stbi__pnm_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ; stbi__pnm_load
  0023b	e9 ee 00 00 00	 jmp	 $LN1@stbi__load
$LN8@stbi__load:

; 1171 : #endif
; 1172 :     
; 1173 : #ifndef STBI_NO_HDR
; 1174 :     if (stbi__hdr_test(s)) {

  00240	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00245	e8 00 00 00 00	 call	 ?stbi__hdr_test@@YAHPEAUstbi__context@@@Z ; stbi__hdr_test
  0024a	85 c0		 test	 eax, eax
  0024c	74 78		 je	 SHORT $LN9@stbi__load

; 1175 :         float *hdr = stbi__hdr_load(s, x,y,comp,req_comp, ri);

  0024e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  00256	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025b	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00262	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00266	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  0026b	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  00270	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  00275	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0027a	e8 00 00 00 00	 call	 ?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ; stbi__hdr_load
  0027f	48 89 44 24 48	 mov	 QWORD PTR hdr$1[rsp], rax

; 1176 :         return stbi__hdr_to_ldr(hdr, *x, *y, req_comp ? req_comp : *comp);

  00284	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  0028c	74 0d		 je	 SHORT $LN12@stbi__load
  0028e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00295	89 44 24 40	 mov	 DWORD PTR tv185[rsp], eax
  00299	eb 0b		 jmp	 SHORT $LN13@stbi__load
$LN12@stbi__load:
  0029b	48 8b 44 24 78	 mov	 rax, QWORD PTR comp$[rsp]
  002a0	8b 00		 mov	 eax, DWORD PTR [rax]
  002a2	89 44 24 40	 mov	 DWORD PTR tv185[rsp], eax
$LN13@stbi__load:
  002a6	44 8b 4c 24 40	 mov	 r9d, DWORD PTR tv185[rsp]
  002ab	48 8b 44 24 70	 mov	 rax, QWORD PTR y$[rsp]
  002b0	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  002b3	48 8b 44 24 68	 mov	 rax, QWORD PTR x$[rsp]
  002b8	8b 10		 mov	 edx, DWORD PTR [rax]
  002ba	48 8b 4c 24 48	 mov	 rcx, QWORD PTR hdr$1[rsp]
  002bf	e8 00 00 00 00	 call	 ?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z ; stbi__hdr_to_ldr
  002c4	eb 68		 jmp	 SHORT $LN1@stbi__load
$LN9@stbi__load:

; 1177 :     }
; 1178 : #endif
; 1179 :     
; 1180 : #ifndef STBI_NO_TGA
; 1181 :     // test tga last because it's a crappy test!
; 1182 :     if (stbi__tga_test(s))

  002c6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  002cb	e8 00 00 00 00	 call	 ?stbi__tga_test@@YAHPEAUstbi__context@@@Z ; stbi__tga_test
  002d0	85 c0		 test	 eax, eax
  002d2	74 33		 je	 SHORT $LN10@stbi__load

; 1183 :         return stbi__tga_load(s,x,y,comp,req_comp, ri);

  002d4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  002dc	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002e1	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  002e8	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  002ec	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  002f1	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  002f6	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  002fb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00300	e8 00 00 00 00	 call	 ?stbi__tga_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ; stbi__tga_load
  00305	eb 27		 jmp	 SHORT $LN1@stbi__load
$LN10@stbi__load:

; 1184 : #endif
; 1185 :     
; 1186 :     return stbi__errpuc("unknown image type", "Image not of any known type, or corrupt");

  00307	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG76618
  0030e	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00313	85 c0		 test	 eax, eax
  00315	74 0a		 je	 SHORT $LN14@stbi__load
  00317	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv203[rsp], 0
  0031f	eb 08		 jmp	 SHORT $LN15@stbi__load
$LN14@stbi__load:
  00321	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv203[rsp], 0
$LN15@stbi__load:
  00329	48 63 44 24 44	 movsxd	 rax, DWORD PTR tv203[rsp]
$LN1@stbi__load:

; 1187 : }

  0032e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00332	c3		 ret	 0
?stbi__load_main@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z ENDP ; stbi__load_main
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
k$ = 32
i$ = 36
z$1 = 40
z$2 = 44
tv75 = 48
n$ = 52
output$ = 56
data$ = 80
x$ = 88
y$ = 96
comp$ = 104
?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z PROC			; stbi__hdr_to_ldr

; 1884 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1885 :     int i,k,n;
; 1886 :     stbi_uc *output;
; 1887 :     if (!data) return NULL;

  00017	48 83 7c 24 50
	00		 cmp	 QWORD PTR data$[rsp], 0
  0001d	75 07		 jne	 SHORT $LN8@stbi__hdr_
  0001f	33 c0		 xor	 eax, eax
  00021	e9 f2 01 00 00	 jmp	 $LN1@stbi__hdr_
$LN8@stbi__hdr_:

; 1888 :     output = (stbi_uc *) stbi__malloc_mad3(x, y, comp, 0);

  00026	45 33 c9	 xor	 r9d, r9d
  00029	44 8b 44 24 68	 mov	 r8d, DWORD PTR comp$[rsp]
  0002e	8b 54 24 60	 mov	 edx, DWORD PTR y$[rsp]
  00032	8b 4c 24 58	 mov	 ecx, DWORD PTR x$[rsp]
  00036	e8 00 00 00 00	 call	 ?stbi__malloc_mad3@@YAPEAXHHHH@Z ; stbi__malloc_mad3
  0003b	48 89 44 24 38	 mov	 QWORD PTR output$[rsp], rax

; 1889 :     if (output == NULL) { STBI_FREE(data); return stbi__errpuc("outofmem", "Out of memory"); }

  00040	48 83 7c 24 38
	00		 cmp	 QWORD PTR output$[rsp], 0
  00046	75 36		 jne	 SHORT $LN9@stbi__hdr_
  00048	48 8b 4c 24 50	 mov	 rcx, QWORD PTR data$[rsp]
  0004d	e8 00 00 00 00	 call	 free
  00052	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG77272
  00059	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0005e	85 c0		 test	 eax, eax
  00060	74 0a		 je	 SHORT $LN18@stbi__hdr_
  00062	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
  0006a	eb 08		 jmp	 SHORT $LN19@stbi__hdr_
$LN18@stbi__hdr_:
  0006c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN19@stbi__hdr_:
  00074	48 63 44 24 30	 movsxd	 rax, DWORD PTR tv75[rsp]
  00079	e9 9a 01 00 00	 jmp	 $LN1@stbi__hdr_
$LN9@stbi__hdr_:

; 1890 :     // compute number of non-alpha components
; 1891 :     if (comp & 1) n = comp; else n = comp-1;

  0007e	8b 44 24 68	 mov	 eax, DWORD PTR comp$[rsp]
  00082	83 e0 01	 and	 eax, 1
  00085	85 c0		 test	 eax, eax
  00087	74 0a		 je	 SHORT $LN10@stbi__hdr_
  00089	8b 44 24 68	 mov	 eax, DWORD PTR comp$[rsp]
  0008d	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax
  00091	eb 0a		 jmp	 SHORT $LN11@stbi__hdr_
$LN10@stbi__hdr_:
  00093	8b 44 24 68	 mov	 eax, DWORD PTR comp$[rsp]
  00097	ff c8		 dec	 eax
  00099	89 44 24 34	 mov	 DWORD PTR n$[rsp], eax
$LN11@stbi__hdr_:

; 1892 :     for (i=0; i < x*y; ++i) {

  0009d	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000a5	eb 0a		 jmp	 SHORT $LN4@stbi__hdr_
$LN2@stbi__hdr_:
  000a7	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  000ab	ff c0		 inc	 eax
  000ad	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__hdr_:
  000b1	8b 44 24 58	 mov	 eax, DWORD PTR x$[rsp]
  000b5	0f af 44 24 60	 imul	 eax, DWORD PTR y$[rsp]
  000ba	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  000be	0f 8d 45 01 00
	00		 jge	 $LN3@stbi__hdr_

; 1893 :         for (k=0; k < n; ++k) {

  000c4	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  000cc	eb 0a		 jmp	 SHORT $LN7@stbi__hdr_
$LN5@stbi__hdr_:
  000ce	8b 44 24 20	 mov	 eax, DWORD PTR k$[rsp]
  000d2	ff c0		 inc	 eax
  000d4	89 44 24 20	 mov	 DWORD PTR k$[rsp], eax
$LN7@stbi__hdr_:
  000d8	8b 44 24 34	 mov	 eax, DWORD PTR n$[rsp]
  000dc	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  000e0	0f 8d 97 00 00
	00		 jge	 $LN6@stbi__hdr_

; 1894 :             float z = (float) pow(data[i*comp+k]*stbi__h2l_scale_i, stbi__h2l_gamma_i) * 255 + 0.5f;

  000e6	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  000ea	0f af 44 24 68	 imul	 eax, DWORD PTR comp$[rsp]
  000ef	03 44 24 20	 add	 eax, DWORD PTR k$[rsp]
  000f3	48 98		 cdqe
  000f5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR data$[rsp]
  000fa	f3 0f 10 04 81	 movss	 xmm0, DWORD PTR [rcx+rax*4]
  000ff	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR ?stbi__h2l_scale_i@@3MA
  00107	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR ?stbi__h2l_gamma_i@@3MA
  0010f	e8 00 00 00 00	 call	 ?pow@@YAMMM@Z		; pow
  00114	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0011c	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00124	f3 0f 11 44 24
	28		 movss	 DWORD PTR z$1[rsp], xmm0

; 1895 :             if (z < 0) z = 0;

  0012a	0f 57 c0	 xorps	 xmm0, xmm0
  0012d	0f 2f 44 24 28	 comiss	 xmm0, DWORD PTR z$1[rsp]
  00132	76 09		 jbe	 SHORT $LN12@stbi__hdr_
  00134	0f 57 c0	 xorps	 xmm0, xmm0
  00137	f3 0f 11 44 24
	28		 movss	 DWORD PTR z$1[rsp], xmm0
$LN12@stbi__hdr_:

; 1896 :             if (z > 255) z = 255;

  0013d	f3 0f 10 44 24
	28		 movss	 xmm0, DWORD PTR z$1[rsp]
  00143	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@437f0000
  0014a	76 0e		 jbe	 SHORT $LN13@stbi__hdr_
  0014c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@437f0000
  00154	f3 0f 11 44 24
	28		 movss	 DWORD PTR z$1[rsp], xmm0
$LN13@stbi__hdr_:

; 1897 :             output[i*comp + k] = (stbi_uc) stbi__float2int(z);

  0015a	f3 0f 2c 44 24
	28		 cvttss2si eax, DWORD PTR z$1[rsp]
  00160	8b 4c 24 24	 mov	 ecx, DWORD PTR i$[rsp]
  00164	0f af 4c 24 68	 imul	 ecx, DWORD PTR comp$[rsp]
  00169	03 4c 24 20	 add	 ecx, DWORD PTR k$[rsp]
  0016d	48 63 c9	 movsxd	 rcx, ecx
  00170	48 8b 54 24 38	 mov	 rdx, QWORD PTR output$[rsp]
  00175	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1898 :         }

  00178	e9 51 ff ff ff	 jmp	 $LN5@stbi__hdr_
$LN6@stbi__hdr_:

; 1899 :         if (k < comp) {

  0017d	8b 44 24 68	 mov	 eax, DWORD PTR comp$[rsp]
  00181	39 44 24 20	 cmp	 DWORD PTR k$[rsp], eax
  00185	7d 7d		 jge	 SHORT $LN14@stbi__hdr_

; 1900 :             float z = data[i*comp+k] * 255 + 0.5f;

  00187	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  0018b	0f af 44 24 68	 imul	 eax, DWORD PTR comp$[rsp]
  00190	03 44 24 20	 add	 eax, DWORD PTR k$[rsp]
  00194	48 98		 cdqe
  00196	48 8b 4c 24 50	 mov	 rcx, QWORD PTR data$[rsp]
  0019b	f3 0f 10 04 81	 movss	 xmm0, DWORD PTR [rcx+rax*4]
  001a0	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  001a8	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  001b0	f3 0f 11 44 24
	2c		 movss	 DWORD PTR z$2[rsp], xmm0

; 1901 :             if (z < 0) z = 0;

  001b6	0f 57 c0	 xorps	 xmm0, xmm0
  001b9	0f 2f 44 24 2c	 comiss	 xmm0, DWORD PTR z$2[rsp]
  001be	76 09		 jbe	 SHORT $LN15@stbi__hdr_
  001c0	0f 57 c0	 xorps	 xmm0, xmm0
  001c3	f3 0f 11 44 24
	2c		 movss	 DWORD PTR z$2[rsp], xmm0
$LN15@stbi__hdr_:

; 1902 :             if (z > 255) z = 255;

  001c9	f3 0f 10 44 24
	2c		 movss	 xmm0, DWORD PTR z$2[rsp]
  001cf	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@437f0000
  001d6	76 0e		 jbe	 SHORT $LN16@stbi__hdr_
  001d8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@437f0000
  001e0	f3 0f 11 44 24
	2c		 movss	 DWORD PTR z$2[rsp], xmm0
$LN16@stbi__hdr_:

; 1903 :             output[i*comp + k] = (stbi_uc) stbi__float2int(z);

  001e6	f3 0f 2c 44 24
	2c		 cvttss2si eax, DWORD PTR z$2[rsp]
  001ec	8b 4c 24 24	 mov	 ecx, DWORD PTR i$[rsp]
  001f0	0f af 4c 24 68	 imul	 ecx, DWORD PTR comp$[rsp]
  001f5	03 4c 24 20	 add	 ecx, DWORD PTR k$[rsp]
  001f9	48 63 c9	 movsxd	 rcx, ecx
  001fc	48 8b 54 24 38	 mov	 rdx, QWORD PTR output$[rsp]
  00201	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN14@stbi__hdr_:

; 1904 :         }
; 1905 :     }

  00204	e9 9e fe ff ff	 jmp	 $LN2@stbi__hdr_
$LN3@stbi__hdr_:

; 1906 :     STBI_FREE(data);

  00209	48 8b 4c 24 50	 mov	 rcx, QWORD PTR data$[rsp]
  0020e	e8 00 00 00 00	 call	 free

; 1907 :     return output;

  00213	48 8b 44 24 38	 mov	 rax, QWORD PTR output$[rsp]
$LN1@stbi__hdr_:

; 1908 : }

  00218	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0021c	c3		 ret	 0
?stbi__hdr_to_ldr@@YAPEAEPEAMHHH@Z ENDP			; stbi__hdr_to_ldr
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
i$ = 48
k$ = 52
n$ = 56
tv76 = 60
output$ = 64
data$ = 96
x$ = 104
y$ = 112
comp$ = 120
?stbi__ldr_to_hdr@@YAPEAMPEAEHHH@Z PROC			; stbi__ldr_to_hdr

; 1858 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1859 :     int i,k,n;
; 1860 :     float *output;
; 1861 :     if (!data) return NULL;

  00017	48 83 7c 24 60
	00		 cmp	 QWORD PTR data$[rsp], 0
  0001d	75 07		 jne	 SHORT $LN11@stbi__ldr_
  0001f	33 c0		 xor	 eax, eax
  00021	e9 97 01 00 00	 jmp	 $LN1@stbi__ldr_
$LN11@stbi__ldr_:

; 1862 :     output = (float *) stbi__malloc_mad4(x, y, comp, sizeof(float), 0);

  00026	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0002e	41 b9 04 00 00
	00		 mov	 r9d, 4
  00034	44 8b 44 24 78	 mov	 r8d, DWORD PTR comp$[rsp]
  00039	8b 54 24 70	 mov	 edx, DWORD PTR y$[rsp]
  0003d	8b 4c 24 68	 mov	 ecx, DWORD PTR x$[rsp]
  00041	e8 00 00 00 00	 call	 ?stbi__malloc_mad4@@YAPEAXHHHHH@Z ; stbi__malloc_mad4
  00046	48 89 44 24 40	 mov	 QWORD PTR output$[rsp], rax

; 1863 :     if (output == NULL) { STBI_FREE(data); return stbi__errpf("outofmem", "Out of memory"); }

  0004b	48 83 7c 24 40
	00		 cmp	 QWORD PTR output$[rsp], 0
  00051	75 36		 jne	 SHORT $LN12@stbi__ldr_
  00053	48 8b 4c 24 60	 mov	 rcx, QWORD PTR data$[rsp]
  00058	e8 00 00 00 00	 call	 free
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG77240
  00064	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00069	85 c0		 test	 eax, eax
  0006b	74 0a		 je	 SHORT $LN17@stbi__ldr_
  0006d	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
  00075	eb 08		 jmp	 SHORT $LN18@stbi__ldr_
$LN17@stbi__ldr_:
  00077	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN18@stbi__ldr_:
  0007f	48 63 44 24 3c	 movsxd	 rax, DWORD PTR tv76[rsp]
  00084	e9 34 01 00 00	 jmp	 $LN1@stbi__ldr_
$LN12@stbi__ldr_:

; 1864 :     // compute number of non-alpha components
; 1865 :     if (comp & 1) n = comp; else n = comp-1;

  00089	8b 44 24 78	 mov	 eax, DWORD PTR comp$[rsp]
  0008d	83 e0 01	 and	 eax, 1
  00090	85 c0		 test	 eax, eax
  00092	74 0a		 je	 SHORT $LN13@stbi__ldr_
  00094	8b 44 24 78	 mov	 eax, DWORD PTR comp$[rsp]
  00098	89 44 24 38	 mov	 DWORD PTR n$[rsp], eax
  0009c	eb 0a		 jmp	 SHORT $LN14@stbi__ldr_
$LN13@stbi__ldr_:
  0009e	8b 44 24 78	 mov	 eax, DWORD PTR comp$[rsp]
  000a2	ff c8		 dec	 eax
  000a4	89 44 24 38	 mov	 DWORD PTR n$[rsp], eax
$LN14@stbi__ldr_:

; 1866 :     for (i=0; i < x*y; ++i) {

  000a8	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000b0	eb 0a		 jmp	 SHORT $LN4@stbi__ldr_
$LN2@stbi__ldr_:
  000b2	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  000b6	ff c0		 inc	 eax
  000b8	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__ldr_:
  000bc	8b 44 24 68	 mov	 eax, DWORD PTR x$[rsp]
  000c0	0f af 44 24 70	 imul	 eax, DWORD PTR y$[rsp]
  000c5	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  000c9	7d 77		 jge	 SHORT $LN3@stbi__ldr_

; 1867 :         for (k=0; k < n; ++k) {

  000cb	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  000d3	eb 0a		 jmp	 SHORT $LN7@stbi__ldr_
$LN5@stbi__ldr_:
  000d5	8b 44 24 34	 mov	 eax, DWORD PTR k$[rsp]
  000d9	ff c0		 inc	 eax
  000db	89 44 24 34	 mov	 DWORD PTR k$[rsp], eax
$LN7@stbi__ldr_:
  000df	8b 44 24 38	 mov	 eax, DWORD PTR n$[rsp]
  000e3	39 44 24 34	 cmp	 DWORD PTR k$[rsp], eax
  000e7	7d 54		 jge	 SHORT $LN6@stbi__ldr_

; 1868 :             output[i*comp + k] = (float) (pow(data[i*comp+k]/255.0f, stbi__l2h_gamma) * stbi__l2h_scale);

  000e9	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  000ed	0f af 44 24 78	 imul	 eax, DWORD PTR comp$[rsp]
  000f2	03 44 24 34	 add	 eax, DWORD PTR k$[rsp]
  000f6	48 98		 cdqe
  000f8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR data$[rsp]
  000fd	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00101	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00105	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@437f0000
  0010d	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR ?stbi__l2h_gamma@@3MA
  00115	e8 00 00 00 00	 call	 ?pow@@YAMMM@Z		; pow
  0011a	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR ?stbi__l2h_scale@@3MA
  00122	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00126	0f af 44 24 78	 imul	 eax, DWORD PTR comp$[rsp]
  0012b	03 44 24 34	 add	 eax, DWORD PTR k$[rsp]
  0012f	48 98		 cdqe
  00131	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  00136	f3 0f 11 04 81	 movss	 DWORD PTR [rcx+rax*4], xmm0

; 1869 :         }

  0013b	eb 98		 jmp	 SHORT $LN5@stbi__ldr_
$LN6@stbi__ldr_:

; 1870 :     }

  0013d	e9 70 ff ff ff	 jmp	 $LN2@stbi__ldr_
$LN3@stbi__ldr_:

; 1871 :     if (n < comp) {

  00142	8b 44 24 78	 mov	 eax, DWORD PTR comp$[rsp]
  00146	39 44 24 38	 cmp	 DWORD PTR n$[rsp], eax
  0014a	7d 62		 jge	 SHORT $LN15@stbi__ldr_

; 1872 :         for (i=0; i < x*y; ++i) {

  0014c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00154	eb 0a		 jmp	 SHORT $LN10@stbi__ldr_
$LN8@stbi__ldr_:
  00156	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0015a	ff c0		 inc	 eax
  0015c	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@stbi__ldr_:
  00160	8b 44 24 68	 mov	 eax, DWORD PTR x$[rsp]
  00164	0f af 44 24 70	 imul	 eax, DWORD PTR y$[rsp]
  00169	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  0016d	7d 3f		 jge	 SHORT $LN9@stbi__ldr_

; 1873 :             output[i*comp + n] = data[i*comp + n]/255.0f;

  0016f	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00173	0f af 44 24 78	 imul	 eax, DWORD PTR comp$[rsp]
  00178	03 44 24 38	 add	 eax, DWORD PTR n$[rsp]
  0017c	48 98		 cdqe
  0017e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR data$[rsp]
  00183	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00187	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0018b	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@437f0000
  00193	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00197	0f af 44 24 78	 imul	 eax, DWORD PTR comp$[rsp]
  0019c	03 44 24 38	 add	 eax, DWORD PTR n$[rsp]
  001a0	48 98		 cdqe
  001a2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR output$[rsp]
  001a7	f3 0f 11 04 81	 movss	 DWORD PTR [rcx+rax*4], xmm0

; 1874 :         }

  001ac	eb a8		 jmp	 SHORT $LN8@stbi__ldr_
$LN9@stbi__ldr_:
$LN15@stbi__ldr_:

; 1875 :     }
; 1876 :     STBI_FREE(data);

  001ae	48 8b 4c 24 60	 mov	 rcx, QWORD PTR data$[rsp]
  001b3	e8 00 00 00 00	 call	 free

; 1877 :     return output;

  001b8	48 8b 44 24 40	 mov	 rax, QWORD PTR output$[rsp]
$LN1@stbi__ldr_:

; 1878 : }

  001bd	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001c1	c3		 ret	 0
?stbi__ldr_to_hdr@@YAPEAMPEAEHHH@Z ENDP			; stbi__ldr_to_hdr
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv69 = 0
tv67 = 4
tv73 = 8
tv77 = 12
tv80 = 16
a$ = 48
b$ = 56
?stbi__mul2shorts_valid@@YAHHH@Z PROC			; stbi__mul2shorts_valid

; 1078 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1079 :     if (b == 0 || b == -1) return 1; // multiplication by 0 is always 0; check for -1 so SHRT_MIN/b doesn't overflow

  0000c	83 7c 24 38 00	 cmp	 DWORD PTR b$[rsp], 0
  00011	74 07		 je	 SHORT $LN3@stbi__mul2
  00013	83 7c 24 38 ff	 cmp	 DWORD PTR b$[rsp], -1
  00018	75 0a		 jne	 SHORT $LN2@stbi__mul2
$LN3@stbi__mul2:
  0001a	b8 01 00 00 00	 mov	 eax, 1
  0001f	e9 b6 00 00 00	 jmp	 $LN1@stbi__mul2
$LN2@stbi__mul2:

; 1080 :     if ((a >= 0) == (b >= 0)) return a <= SHRT_MAX/b; // product is positive, so similar to mul2sizes_valid

  00024	83 7c 24 30 00	 cmp	 DWORD PTR a$[rsp], 0
  00029	7c 0a		 jl	 SHORT $LN7@stbi__mul2
  0002b	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR tv67[rsp], 1
  00033	eb 08		 jmp	 SHORT $LN8@stbi__mul2
$LN7@stbi__mul2:
  00035	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv67[rsp], 0
$LN8@stbi__mul2:
  0003d	83 7c 24 38 00	 cmp	 DWORD PTR b$[rsp], 0
  00042	7c 09		 jl	 SHORT $LN9@stbi__mul2
  00044	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv69[rsp], 1
  0004b	eb 07		 jmp	 SHORT $LN10@stbi__mul2
$LN9@stbi__mul2:
  0004d	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv69[rsp], 0
$LN10@stbi__mul2:
  00054	8b 04 24	 mov	 eax, DWORD PTR tv69[rsp]
  00057	39 44 24 04	 cmp	 DWORD PTR tv67[rsp], eax
  0005b	75 28		 jne	 SHORT $LN4@stbi__mul2
  0005d	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00062	99		 cdq
  00063	f7 7c 24 38	 idiv	 DWORD PTR b$[rsp]
  00067	39 44 24 30	 cmp	 DWORD PTR a$[rsp], eax
  0006b	7f 0a		 jg	 SHORT $LN11@stbi__mul2
  0006d	c7 44 24 08 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
  00075	eb 08		 jmp	 SHORT $LN12@stbi__mul2
$LN11@stbi__mul2:
  00077	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN12@stbi__mul2:
  0007f	8b 44 24 08	 mov	 eax, DWORD PTR tv73[rsp]
  00083	eb 55		 jmp	 SHORT $LN1@stbi__mul2
$LN4@stbi__mul2:

; 1081 :     if (b < 0) return a <= SHRT_MIN / b; // same as a * b >= SHRT_MIN

  00085	83 7c 24 38 00	 cmp	 DWORD PTR b$[rsp], 0
  0008a	7d 28		 jge	 SHORT $LN5@stbi__mul2
  0008c	b8 00 80 ff ff	 mov	 eax, -32768		; ffffffffffff8000H
  00091	99		 cdq
  00092	f7 7c 24 38	 idiv	 DWORD PTR b$[rsp]
  00096	39 44 24 30	 cmp	 DWORD PTR a$[rsp], eax
  0009a	7f 0a		 jg	 SHORT $LN13@stbi__mul2
  0009c	c7 44 24 0c 01
	00 00 00	 mov	 DWORD PTR tv77[rsp], 1
  000a4	eb 08		 jmp	 SHORT $LN14@stbi__mul2
$LN13@stbi__mul2:
  000a6	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR tv77[rsp], 0
$LN14@stbi__mul2:
  000ae	8b 44 24 0c	 mov	 eax, DWORD PTR tv77[rsp]
  000b2	eb 26		 jmp	 SHORT $LN1@stbi__mul2
$LN5@stbi__mul2:

; 1082 :     return a >= SHRT_MIN / b;

  000b4	b8 00 80 ff ff	 mov	 eax, -32768		; ffffffffffff8000H
  000b9	99		 cdq
  000ba	f7 7c 24 38	 idiv	 DWORD PTR b$[rsp]
  000be	39 44 24 30	 cmp	 DWORD PTR a$[rsp], eax
  000c2	7c 0a		 jl	 SHORT $LN15@stbi__mul2
  000c4	c7 44 24 10 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
  000cc	eb 08		 jmp	 SHORT $LN16@stbi__mul2
$LN15@stbi__mul2:
  000ce	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN16@stbi__mul2:
  000d6	8b 44 24 10	 mov	 eax, DWORD PTR tv80[rsp]
$LN1@stbi__mul2:

; 1083 : }

  000da	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000de	c3		 ret	 0
?stbi__mul2shorts_valid@@YAHHH@Z ENDP			; stbi__mul2shorts_valid
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv67 = 0
tv65 = 4
tv73 = 8
tv76 = 12
a$ = 32
b$ = 40
?stbi__addints_valid@@YAHHH@Z PROC			; stbi__addints_valid

; 1070 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 18	 sub	 rsp, 24

; 1071 :     if ((a >= 0) != (b >= 0)) return 1; // a and b have different signs, so no overflow

  0000c	83 7c 24 20 00	 cmp	 DWORD PTR a$[rsp], 0
  00011	7c 0a		 jl	 SHORT $LN5@stbi__addi
  00013	c7 44 24 04 01
	00 00 00	 mov	 DWORD PTR tv65[rsp], 1
  0001b	eb 08		 jmp	 SHORT $LN6@stbi__addi
$LN5@stbi__addi:
  0001d	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR tv65[rsp], 0
$LN6@stbi__addi:
  00025	83 7c 24 28 00	 cmp	 DWORD PTR b$[rsp], 0
  0002a	7c 09		 jl	 SHORT $LN7@stbi__addi
  0002c	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv67[rsp], 1
  00033	eb 07		 jmp	 SHORT $LN8@stbi__addi
$LN7@stbi__addi:
  00035	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv67[rsp], 0
$LN8@stbi__addi:
  0003c	8b 04 24	 mov	 eax, DWORD PTR tv67[rsp]
  0003f	39 44 24 04	 cmp	 DWORD PTR tv65[rsp], eax
  00043	74 07		 je	 SHORT $LN2@stbi__addi
  00045	b8 01 00 00 00	 mov	 eax, 1
  0004a	eb 5a		 jmp	 SHORT $LN1@stbi__addi
$LN2@stbi__addi:

; 1072 :     if (a < 0 && b < 0) return a >= INT_MIN - b; // same as a + b >= INT_MIN; INT_MIN - b cannot overflow since b < 0.

  0004c	83 7c 24 20 00	 cmp	 DWORD PTR a$[rsp], 0
  00051	7d 2e		 jge	 SHORT $LN3@stbi__addi
  00053	83 7c 24 28 00	 cmp	 DWORD PTR b$[rsp], 0
  00058	7d 27		 jge	 SHORT $LN3@stbi__addi
  0005a	b8 00 00 00 80	 mov	 eax, -2147483648	; ffffffff80000000H
  0005f	2b 44 24 28	 sub	 eax, DWORD PTR b$[rsp]
  00063	39 44 24 20	 cmp	 DWORD PTR a$[rsp], eax
  00067	7c 0a		 jl	 SHORT $LN9@stbi__addi
  00069	c7 44 24 08 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
  00071	eb 08		 jmp	 SHORT $LN10@stbi__addi
$LN9@stbi__addi:
  00073	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN10@stbi__addi:
  0007b	8b 44 24 08	 mov	 eax, DWORD PTR tv73[rsp]
  0007f	eb 25		 jmp	 SHORT $LN1@stbi__addi
$LN3@stbi__addi:

; 1073 :     return a <= INT_MAX - b;

  00081	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00086	2b 44 24 28	 sub	 eax, DWORD PTR b$[rsp]
  0008a	39 44 24 20	 cmp	 DWORD PTR a$[rsp], eax
  0008e	7f 0a		 jg	 SHORT $LN11@stbi__addi
  00090	c7 44 24 0c 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00098	eb 08		 jmp	 SHORT $LN12@stbi__addi
$LN11@stbi__addi:
  0009a	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN12@stbi__addi:
  000a2	8b 44 24 0c	 mov	 eax, DWORD PTR tv76[rsp]
$LN1@stbi__addi:

; 1074 : }

  000a6	48 83 c4 18	 add	 rsp, 24
  000aa	c3		 ret	 0
?stbi__addints_valid@@YAHHH@Z ENDP			; stbi__addints_valid
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
a$ = 64
b$ = 72
c$ = 80
d$ = 88
add$ = 96
?stbi__malloc_mad4@@YAPEAXHHHHH@Z PROC			; stbi__malloc_mad4

; 1062 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1063 :     if (!stbi__mad4sizes_valid(a, b, c, d, add)) return NULL;

  00016	8b 44 24 60	 mov	 eax, DWORD PTR add$[rsp]
  0001a	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0001e	44 8b 4c 24 58	 mov	 r9d, DWORD PTR d$[rsp]
  00023	44 8b 44 24 50	 mov	 r8d, DWORD PTR c$[rsp]
  00028	8b 54 24 48	 mov	 edx, DWORD PTR b$[rsp]
  0002c	8b 4c 24 40	 mov	 ecx, DWORD PTR a$[rsp]
  00030	e8 00 00 00 00	 call	 ?stbi__mad4sizes_valid@@YAHHHHHH@Z ; stbi__mad4sizes_valid
  00035	85 c0		 test	 eax, eax
  00037	75 04		 jne	 SHORT $LN2@stbi__mall
  00039	33 c0		 xor	 eax, eax
  0003b	eb 21		 jmp	 SHORT $LN1@stbi__mall
$LN2@stbi__mall:

; 1064 :     return stbi__malloc(a*b*c*d + add);

  0003d	8b 44 24 40	 mov	 eax, DWORD PTR a$[rsp]
  00041	0f af 44 24 48	 imul	 eax, DWORD PTR b$[rsp]
  00046	0f af 44 24 50	 imul	 eax, DWORD PTR c$[rsp]
  0004b	0f af 44 24 58	 imul	 eax, DWORD PTR d$[rsp]
  00050	03 44 24 60	 add	 eax, DWORD PTR add$[rsp]
  00054	48 98		 cdqe
  00056	48 8b c8	 mov	 rcx, rax
  00059	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
$LN1@stbi__mall:

; 1065 : }

  0005e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00062	c3		 ret	 0
?stbi__malloc_mad4@@YAPEAXHHHHH@Z ENDP			; stbi__malloc_mad4
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
a$ = 48
b$ = 56
c$ = 64
add$ = 72
?stbi__malloc_mad3@@YAPEAXHHHH@Z PROC			; stbi__malloc_mad3

; 1055 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1056 :     if (!stbi__mad3sizes_valid(a, b, c, add)) return NULL;

  00016	44 8b 4c 24 48	 mov	 r9d, DWORD PTR add$[rsp]
  0001b	44 8b 44 24 40	 mov	 r8d, DWORD PTR c$[rsp]
  00020	8b 54 24 38	 mov	 edx, DWORD PTR b$[rsp]
  00024	8b 4c 24 30	 mov	 ecx, DWORD PTR a$[rsp]
  00028	e8 00 00 00 00	 call	 ?stbi__mad3sizes_valid@@YAHHHHH@Z ; stbi__mad3sizes_valid
  0002d	85 c0		 test	 eax, eax
  0002f	75 04		 jne	 SHORT $LN2@stbi__mall
  00031	33 c0		 xor	 eax, eax
  00033	eb 1c		 jmp	 SHORT $LN1@stbi__mall
$LN2@stbi__mall:

; 1057 :     return stbi__malloc(a*b*c + add);

  00035	8b 44 24 30	 mov	 eax, DWORD PTR a$[rsp]
  00039	0f af 44 24 38	 imul	 eax, DWORD PTR b$[rsp]
  0003e	0f af 44 24 40	 imul	 eax, DWORD PTR c$[rsp]
  00043	03 44 24 48	 add	 eax, DWORD PTR add$[rsp]
  00047	48 98		 cdqe
  00049	48 8b c8	 mov	 rcx, rax
  0004c	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
$LN1@stbi__mall:

; 1058 : }

  00051	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00055	c3		 ret	 0
?stbi__malloc_mad3@@YAPEAXHHHH@Z ENDP			; stbi__malloc_mad3
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
a$ = 48
b$ = 56
add$ = 64
?stbi__malloc_mad2@@YAPEAXHHH@Z PROC			; stbi__malloc_mad2

; 1048 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1049 :     if (!stbi__mad2sizes_valid(a, b, add)) return NULL;

  00011	44 8b 44 24 40	 mov	 r8d, DWORD PTR add$[rsp]
  00016	8b 54 24 38	 mov	 edx, DWORD PTR b$[rsp]
  0001a	8b 4c 24 30	 mov	 ecx, DWORD PTR a$[rsp]
  0001e	e8 00 00 00 00	 call	 ?stbi__mad2sizes_valid@@YAHHHH@Z ; stbi__mad2sizes_valid
  00023	85 c0		 test	 eax, eax
  00025	75 04		 jne	 SHORT $LN2@stbi__mall
  00027	33 c0		 xor	 eax, eax
  00029	eb 17		 jmp	 SHORT $LN1@stbi__mall
$LN2@stbi__mall:

; 1050 :     return stbi__malloc(a*b + add);

  0002b	8b 44 24 30	 mov	 eax, DWORD PTR a$[rsp]
  0002f	0f af 44 24 38	 imul	 eax, DWORD PTR b$[rsp]
  00034	03 44 24 40	 add	 eax, DWORD PTR add$[rsp]
  00038	48 98		 cdqe
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
$LN1@stbi__mall:

; 1051 : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
?stbi__malloc_mad2@@YAPEAXHHH@Z ENDP			; stbi__malloc_mad2
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv86 = 32
a$ = 64
b$ = 72
c$ = 80
d$ = 88
add$ = 96
?stbi__mad4sizes_valid@@YAHHHHHH@Z PROC			; stbi__mad4sizes_valid

; 1039 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1040 :     return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

  00016	8b 54 24 48	 mov	 edx, DWORD PTR b$[rsp]
  0001a	8b 4c 24 40	 mov	 ecx, DWORD PTR a$[rsp]
  0001e	e8 00 00 00 00	 call	 ?stbi__mul2sizes_valid@@YAHHH@Z ; stbi__mul2sizes_valid
  00023	85 c0		 test	 eax, eax
  00025	74 61		 je	 SHORT $LN3@stbi__mad4
  00027	8b 44 24 40	 mov	 eax, DWORD PTR a$[rsp]
  0002b	0f af 44 24 48	 imul	 eax, DWORD PTR b$[rsp]
  00030	8b 54 24 50	 mov	 edx, DWORD PTR c$[rsp]
  00034	8b c8		 mov	 ecx, eax
  00036	e8 00 00 00 00	 call	 ?stbi__mul2sizes_valid@@YAHHH@Z ; stbi__mul2sizes_valid
  0003b	85 c0		 test	 eax, eax
  0003d	74 49		 je	 SHORT $LN3@stbi__mad4
  0003f	8b 44 24 40	 mov	 eax, DWORD PTR a$[rsp]
  00043	0f af 44 24 48	 imul	 eax, DWORD PTR b$[rsp]
  00048	0f af 44 24 50	 imul	 eax, DWORD PTR c$[rsp]
  0004d	8b 54 24 58	 mov	 edx, DWORD PTR d$[rsp]
  00051	8b c8		 mov	 ecx, eax
  00053	e8 00 00 00 00	 call	 ?stbi__mul2sizes_valid@@YAHHH@Z ; stbi__mul2sizes_valid
  00058	85 c0		 test	 eax, eax
  0005a	74 2c		 je	 SHORT $LN3@stbi__mad4
  0005c	8b 44 24 40	 mov	 eax, DWORD PTR a$[rsp]
  00060	0f af 44 24 48	 imul	 eax, DWORD PTR b$[rsp]
  00065	0f af 44 24 50	 imul	 eax, DWORD PTR c$[rsp]
  0006a	0f af 44 24 58	 imul	 eax, DWORD PTR d$[rsp]
  0006f	8b 54 24 60	 mov	 edx, DWORD PTR add$[rsp]
  00073	8b c8		 mov	 ecx, eax
  00075	e8 00 00 00 00	 call	 ?stbi__addsizes_valid@@YAHHH@Z ; stbi__addsizes_valid
  0007a	85 c0		 test	 eax, eax
  0007c	74 0a		 je	 SHORT $LN3@stbi__mad4
  0007e	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv86[rsp], 1
  00086	eb 08		 jmp	 SHORT $LN4@stbi__mad4
$LN3@stbi__mad4:
  00088	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv86[rsp], 0
$LN4@stbi__mad4:
  00090	8b 44 24 20	 mov	 eax, DWORD PTR tv86[rsp]

; 1041 :         stbi__mul2sizes_valid(a*b*c, d) && stbi__addsizes_valid(a*b*c*d, add);
; 1042 : }

  00094	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00098	c3		 ret	 0
?stbi__mad4sizes_valid@@YAHHHHHH@Z ENDP			; stbi__mad4sizes_valid
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv79 = 32
a$ = 64
b$ = 72
c$ = 80
add$ = 88
?stbi__mad3sizes_valid@@YAHHHHH@Z PROC			; stbi__mad3sizes_valid

; 1031 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1032 :     return stbi__mul2sizes_valid(a, b) && stbi__mul2sizes_valid(a*b, c) &&

  00016	8b 54 24 48	 mov	 edx, DWORD PTR b$[rsp]
  0001a	8b 4c 24 40	 mov	 ecx, DWORD PTR a$[rsp]
  0001e	e8 00 00 00 00	 call	 ?stbi__mul2sizes_valid@@YAHHH@Z ; stbi__mul2sizes_valid
  00023	85 c0		 test	 eax, eax
  00025	74 3f		 je	 SHORT $LN3@stbi__mad3
  00027	8b 44 24 40	 mov	 eax, DWORD PTR a$[rsp]
  0002b	0f af 44 24 48	 imul	 eax, DWORD PTR b$[rsp]
  00030	8b 54 24 50	 mov	 edx, DWORD PTR c$[rsp]
  00034	8b c8		 mov	 ecx, eax
  00036	e8 00 00 00 00	 call	 ?stbi__mul2sizes_valid@@YAHHH@Z ; stbi__mul2sizes_valid
  0003b	85 c0		 test	 eax, eax
  0003d	74 27		 je	 SHORT $LN3@stbi__mad3
  0003f	8b 44 24 40	 mov	 eax, DWORD PTR a$[rsp]
  00043	0f af 44 24 48	 imul	 eax, DWORD PTR b$[rsp]
  00048	0f af 44 24 50	 imul	 eax, DWORD PTR c$[rsp]
  0004d	8b 54 24 58	 mov	 edx, DWORD PTR add$[rsp]
  00051	8b c8		 mov	 ecx, eax
  00053	e8 00 00 00 00	 call	 ?stbi__addsizes_valid@@YAHHH@Z ; stbi__addsizes_valid
  00058	85 c0		 test	 eax, eax
  0005a	74 0a		 je	 SHORT $LN3@stbi__mad3
  0005c	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv79[rsp], 1
  00064	eb 08		 jmp	 SHORT $LN4@stbi__mad3
$LN3@stbi__mad3:
  00066	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN4@stbi__mad3:
  0006e	8b 44 24 20	 mov	 eax, DWORD PTR tv79[rsp]

; 1033 :         stbi__addsizes_valid(a*b*c, add);
; 1034 : }

  00072	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00076	c3		 ret	 0
?stbi__mad3sizes_valid@@YAHHHHH@Z ENDP			; stbi__mad3sizes_valid
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv73 = 32
a$ = 64
b$ = 72
add$ = 80
?stbi__mad2sizes_valid@@YAHHHH@Z PROC			; stbi__mad2sizes_valid

; 1024 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1025 :     return stbi__mul2sizes_valid(a, b) && stbi__addsizes_valid(a*b, add);

  00011	8b 54 24 48	 mov	 edx, DWORD PTR b$[rsp]
  00015	8b 4c 24 40	 mov	 ecx, DWORD PTR a$[rsp]
  00019	e8 00 00 00 00	 call	 ?stbi__mul2sizes_valid@@YAHHH@Z ; stbi__mul2sizes_valid
  0001e	85 c0		 test	 eax, eax
  00020	74 22		 je	 SHORT $LN3@stbi__mad2
  00022	8b 44 24 40	 mov	 eax, DWORD PTR a$[rsp]
  00026	0f af 44 24 48	 imul	 eax, DWORD PTR b$[rsp]
  0002b	8b 54 24 50	 mov	 edx, DWORD PTR add$[rsp]
  0002f	8b c8		 mov	 ecx, eax
  00031	e8 00 00 00 00	 call	 ?stbi__addsizes_valid@@YAHHH@Z ; stbi__addsizes_valid
  00036	85 c0		 test	 eax, eax
  00038	74 0a		 je	 SHORT $LN3@stbi__mad2
  0003a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN4@stbi__mad2
$LN3@stbi__mad2:
  00044	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN4@stbi__mad2:
  0004c	8b 44 24 20	 mov	 eax, DWORD PTR tv73[rsp]

; 1026 : }

  00050	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00054	c3		 ret	 0
?stbi__mad2sizes_valid@@YAHHHH@Z ENDP			; stbi__mad2sizes_valid
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv69 = 0
a$ = 32
b$ = 40
?stbi__mul2sizes_valid@@YAHHH@Z PROC			; stbi__mul2sizes_valid

; 1014 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 18	 sub	 rsp, 24

; 1015 :     if (a < 0 || b < 0) return 0;

  0000c	83 7c 24 20 00	 cmp	 DWORD PTR a$[rsp], 0
  00011	7c 07		 jl	 SHORT $LN3@stbi__mul2
  00013	83 7c 24 28 00	 cmp	 DWORD PTR b$[rsp], 0
  00018	7d 04		 jge	 SHORT $LN2@stbi__mul2
$LN3@stbi__mul2:
  0001a	33 c0		 xor	 eax, eax
  0001c	eb 31		 jmp	 SHORT $LN1@stbi__mul2
$LN2@stbi__mul2:

; 1016 :     if (b == 0) return 1; // mul-by-0 is always safe

  0001e	83 7c 24 28 00	 cmp	 DWORD PTR b$[rsp], 0
  00023	75 07		 jne	 SHORT $LN4@stbi__mul2
  00025	b8 01 00 00 00	 mov	 eax, 1
  0002a	eb 23		 jmp	 SHORT $LN1@stbi__mul2
$LN4@stbi__mul2:

; 1017 :     // portable way to check for no overflows in a*b
; 1018 :     return a <= INT_MAX/b;

  0002c	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00031	99		 cdq
  00032	f7 7c 24 28	 idiv	 DWORD PTR b$[rsp]
  00036	39 44 24 20	 cmp	 DWORD PTR a$[rsp], eax
  0003a	7f 09		 jg	 SHORT $LN6@stbi__mul2
  0003c	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv69[rsp], 1
  00043	eb 07		 jmp	 SHORT $LN7@stbi__mul2
$LN6@stbi__mul2:
  00045	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv69[rsp], 0
$LN7@stbi__mul2:
  0004c	8b 04 24	 mov	 eax, DWORD PTR tv69[rsp]
$LN1@stbi__mul2:

; 1019 : }

  0004f	48 83 c4 18	 add	 rsp, 24
  00053	c3		 ret	 0
?stbi__mul2sizes_valid@@YAHHH@Z ENDP			; stbi__mul2sizes_valid
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv67 = 0
a$ = 32
b$ = 40
?stbi__addsizes_valid@@YAHHH@Z PROC			; stbi__addsizes_valid

; 1002 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 18	 sub	 rsp, 24

; 1003 :     if (b < 0) return 0;

  0000c	83 7c 24 28 00	 cmp	 DWORD PTR b$[rsp], 0
  00011	7d 04		 jge	 SHORT $LN2@stbi__adds
  00013	33 c0		 xor	 eax, eax
  00015	eb 22		 jmp	 SHORT $LN1@stbi__adds
$LN2@stbi__adds:

; 1004 :     // now 0 <= b <= INT_MAX, hence also
; 1005 :     // 0 <= INT_MAX - b <= INTMAX.
; 1006 :     // And "a + b <= INT_MAX" (which might overflow) is the
; 1007 :     // same as a <= INT_MAX - b (no overflow)
; 1008 :     return a <= INT_MAX - b;

  00017	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0001c	2b 44 24 28	 sub	 eax, DWORD PTR b$[rsp]
  00020	39 44 24 20	 cmp	 DWORD PTR a$[rsp], eax
  00024	7f 09		 jg	 SHORT $LN4@stbi__adds
  00026	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv67[rsp], 1
  0002d	eb 07		 jmp	 SHORT $LN5@stbi__adds
$LN4@stbi__adds:
  0002f	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv67[rsp], 0
$LN5@stbi__adds:
  00036	8b 04 24	 mov	 eax, DWORD PTR tv67[rsp]
$LN1@stbi__adds:

; 1009 : }

  00039	48 83 c4 18	 add	 rsp, 24
  0003d	c3		 ret	 0
?stbi__addsizes_valid@@YAHHH@Z ENDP			; stbi__addsizes_valid
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
size$ = 48
?stbi__malloc@@YAPEAX_K@Z PROC				; stbi__malloc

; 985  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 986  :     return STBI_MALLOC(size);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR size$[rsp]
  0000e	e8 00 00 00 00	 call	 malloc

; 987  : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
?stbi__malloc@@YAPEAX_K@Z ENDP				; stbi__malloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
str$ = 8
?stbi__err@@YAHPEBD@Z PROC				; stbi__err

; 978  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 979  :     stbi__g_failure_reason = str;

  00005	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
  0000a	8b c0		 mov	 eax, eax
  0000c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00012	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0001b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0001f	48 8b 54 24 08	 mov	 rdx, QWORD PTR str$[rsp]
  00024	48 89 14 08	 mov	 QWORD PTR [rax+rcx], rdx

; 980  :     return 0;

  00028	33 c0		 xor	 eax, eax

; 981  : }

  0002a	c3		 ret	 0
?stbi__err@@YAHPEBD@Z ENDP				; stbi__err
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
s$ = 48
?stbi__pnm_is16@@YAHPEAUstbi__context@@@Z PROC		; stbi__pnm_is16

; 7622 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 7623 :     if (stbi__pnm_info(s, NULL, NULL, NULL) == 16)

  00009	45 33 c9	 xor	 r9d, r9d
  0000c	45 33 c0	 xor	 r8d, r8d
  0000f	33 d2		 xor	 edx, edx
  00011	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00016	e8 00 00 00 00	 call	 ?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__pnm_info
  0001b	83 f8 10	 cmp	 eax, 16
  0001e	75 07		 jne	 SHORT $LN2@stbi__pnm_

; 7624 :         return 1;

  00020	b8 01 00 00 00	 mov	 eax, 1
  00025	eb 02		 jmp	 SHORT $LN1@stbi__pnm_
$LN2@stbi__pnm_:

; 7625 :     return 0;

  00027	33 c0		 xor	 eax, eax
$LN1@stbi__pnm_:

; 7626 : }

  00029	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002d	c3		 ret	 0
?stbi__pnm_is16@@YAHPEAUstbi__context@@@Z ENDP		; stbi__pnm_is16
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
c$ = 32
t$ = 33
p$ = 34
dummy$ = 36
tv81 = 40
maxv$ = 44
s$ = 64
x$ = 72
y$ = 80
comp$ = 88
?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z PROC	; stbi__pnm_info

; 7579 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7580 :     int maxv, dummy;
; 7581 :     char c, p, t;
; 7582 :     
; 7583 :     if (!x) x = &dummy;

  00018	48 83 7c 24 48
	00		 cmp	 QWORD PTR x$[rsp], 0
  0001e	75 0a		 jne	 SHORT $LN2@stbi__pnm_
  00020	48 8d 44 24 24	 lea	 rax, QWORD PTR dummy$[rsp]
  00025	48 89 44 24 48	 mov	 QWORD PTR x$[rsp], rax
$LN2@stbi__pnm_:

; 7584 :     if (!y) y = &dummy;

  0002a	48 83 7c 24 50
	00		 cmp	 QWORD PTR y$[rsp], 0
  00030	75 0a		 jne	 SHORT $LN3@stbi__pnm_
  00032	48 8d 44 24 24	 lea	 rax, QWORD PTR dummy$[rsp]
  00037	48 89 44 24 50	 mov	 QWORD PTR y$[rsp], rax
$LN3@stbi__pnm_:

; 7585 :     if (!comp) comp = &dummy;

  0003c	48 83 7c 24 58
	00		 cmp	 QWORD PTR comp$[rsp], 0
  00042	75 0a		 jne	 SHORT $LN4@stbi__pnm_
  00044	48 8d 44 24 24	 lea	 rax, QWORD PTR dummy$[rsp]
  00049	48 89 44 24 58	 mov	 QWORD PTR comp$[rsp], rax
$LN4@stbi__pnm_:

; 7586 :     
; 7587 :     stbi__rewind(s);

  0004e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00053	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7588 :     
; 7589 :     // Get identifier
; 7590 :     p = (char) stbi__get8(s);

  00058	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0005d	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00062	88 44 24 22	 mov	 BYTE PTR p$[rsp], al

; 7591 :     t = (char) stbi__get8(s);

  00066	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0006b	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00070	88 44 24 21	 mov	 BYTE PTR t$[rsp], al

; 7592 :     if (p != 'P' || (t != '5' && t != '6')) {

  00074	0f be 44 24 22	 movsx	 eax, BYTE PTR p$[rsp]
  00079	83 f8 50	 cmp	 eax, 80			; 00000050H
  0007c	75 14		 jne	 SHORT $LN6@stbi__pnm_
  0007e	0f be 44 24 21	 movsx	 eax, BYTE PTR t$[rsp]
  00083	83 f8 35	 cmp	 eax, 53			; 00000035H
  00086	74 1b		 je	 SHORT $LN5@stbi__pnm_
  00088	0f be 44 24 21	 movsx	 eax, BYTE PTR t$[rsp]
  0008d	83 f8 36	 cmp	 eax, 54			; 00000036H
  00090	74 11		 je	 SHORT $LN5@stbi__pnm_
$LN6@stbi__pnm_:

; 7593 :         stbi__rewind(s);

  00092	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00097	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7594 :         return 0;

  0009c	33 c0		 xor	 eax, eax
  0009e	e9 06 01 00 00	 jmp	 $LN1@stbi__pnm_
$LN5@stbi__pnm_:

; 7595 :     }
; 7596 :     
; 7597 :     *comp = (t == '6') ? 3 : 1;  // '5' is 1-component .pgm; '6' is 3-component .ppm

  000a3	0f be 44 24 21	 movsx	 eax, BYTE PTR t$[rsp]
  000a8	83 f8 36	 cmp	 eax, 54			; 00000036H
  000ab	75 0a		 jne	 SHORT $LN14@stbi__pnm_
  000ad	c7 44 24 28 03
	00 00 00	 mov	 DWORD PTR tv81[rsp], 3
  000b5	eb 08		 jmp	 SHORT $LN15@stbi__pnm_
$LN14@stbi__pnm_:
  000b7	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
$LN15@stbi__pnm_:
  000bf	48 8b 44 24 58	 mov	 rax, QWORD PTR comp$[rsp]
  000c4	8b 4c 24 28	 mov	 ecx, DWORD PTR tv81[rsp]
  000c8	89 08		 mov	 DWORD PTR [rax], ecx

; 7598 :     
; 7599 :     c = (char) stbi__get8(s);

  000ca	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000cf	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  000d4	88 44 24 20	 mov	 BYTE PTR c$[rsp], al

; 7600 :     stbi__pnm_skip_whitespace(s, &c);

  000d8	48 8d 54 24 20	 lea	 rdx, QWORD PTR c$[rsp]
  000dd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000e2	e8 00 00 00 00	 call	 ?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z ; stbi__pnm_skip_whitespace

; 7601 :     
; 7602 :     *x = stbi__pnm_getinteger(s, &c); // read width

  000e7	48 8d 54 24 20	 lea	 rdx, QWORD PTR c$[rsp]
  000ec	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000f1	e8 00 00 00 00	 call	 ?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z ; stbi__pnm_getinteger
  000f6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR x$[rsp]
  000fb	89 01		 mov	 DWORD PTR [rcx], eax

; 7603 :     if(*x == 0)

  000fd	48 8b 44 24 48	 mov	 rax, QWORD PTR x$[rsp]
  00102	83 38 00	 cmp	 DWORD PTR [rax], 0
  00105	75 11		 jne	 SHORT $LN7@stbi__pnm_

; 7604 :         return stbi__err("invalid width", "PPM image header had zero or overflowing width");

  00107	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG82403
  0010e	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00113	e9 91 00 00 00	 jmp	 $LN1@stbi__pnm_
$LN7@stbi__pnm_:

; 7605 :     stbi__pnm_skip_whitespace(s, &c);

  00118	48 8d 54 24 20	 lea	 rdx, QWORD PTR c$[rsp]
  0011d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00122	e8 00 00 00 00	 call	 ?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z ; stbi__pnm_skip_whitespace

; 7606 :     
; 7607 :     *y = stbi__pnm_getinteger(s, &c); // read height

  00127	48 8d 54 24 20	 lea	 rdx, QWORD PTR c$[rsp]
  0012c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00131	e8 00 00 00 00	 call	 ?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z ; stbi__pnm_getinteger
  00136	48 8b 4c 24 50	 mov	 rcx, QWORD PTR y$[rsp]
  0013b	89 01		 mov	 DWORD PTR [rcx], eax

; 7608 :     if (*y == 0)

  0013d	48 8b 44 24 50	 mov	 rax, QWORD PTR y$[rsp]
  00142	83 38 00	 cmp	 DWORD PTR [rax], 0
  00145	75 0e		 jne	 SHORT $LN8@stbi__pnm_

; 7609 :         return stbi__err("invalid width", "PPM image header had zero or overflowing width");

  00147	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG82405
  0014e	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00153	eb 54		 jmp	 SHORT $LN1@stbi__pnm_
$LN8@stbi__pnm_:

; 7610 :     stbi__pnm_skip_whitespace(s, &c);

  00155	48 8d 54 24 20	 lea	 rdx, QWORD PTR c$[rsp]
  0015a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0015f	e8 00 00 00 00	 call	 ?stbi__pnm_skip_whitespace@@YAXPEAUstbi__context@@PEAD@Z ; stbi__pnm_skip_whitespace

; 7611 :     
; 7612 :     maxv = stbi__pnm_getinteger(s, &c);  // read max value

  00164	48 8d 54 24 20	 lea	 rdx, QWORD PTR c$[rsp]
  00169	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0016e	e8 00 00 00 00	 call	 ?stbi__pnm_getinteger@@YAHPEAUstbi__context@@PEAD@Z ; stbi__pnm_getinteger
  00173	89 44 24 2c	 mov	 DWORD PTR maxv$[rsp], eax

; 7613 :     if (maxv > 65535)

  00177	81 7c 24 2c ff
	ff 00 00	 cmp	 DWORD PTR maxv$[rsp], 65535 ; 0000ffffH
  0017f	7e 10		 jle	 SHORT $LN9@stbi__pnm_

; 7614 :         return stbi__err("max value > 65535", "PPM image supports only 8-bit and 16-bit images");

  00181	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG82408
  00188	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0018d	eb 1a		 jmp	 SHORT $LN1@stbi__pnm_
  0018f	eb 18		 jmp	 SHORT $LN10@stbi__pnm_
$LN9@stbi__pnm_:

; 7615 :     else if (maxv > 255)

  00191	81 7c 24 2c ff
	00 00 00	 cmp	 DWORD PTR maxv$[rsp], 255 ; 000000ffH
  00199	7e 09		 jle	 SHORT $LN11@stbi__pnm_

; 7616 :         return 16;

  0019b	b8 10 00 00 00	 mov	 eax, 16
  001a0	eb 07		 jmp	 SHORT $LN1@stbi__pnm_
  001a2	eb 05		 jmp	 SHORT $LN12@stbi__pnm_
$LN11@stbi__pnm_:

; 7617 :     else
; 7618 :         return 8;

  001a4	b8 08 00 00 00	 mov	 eax, 8
$LN12@stbi__pnm_:
$LN10@stbi__pnm_:
$LN1@stbi__pnm_:

; 7619 : }

  001a9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001ad	c3		 ret	 0
?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z ENDP	; stbi__pnm_info
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv80 = 48
tv87 = 52
tv140 = 56
tv157 = 60
tv176 = 64
tv164 = 68
out$ = 72
s$ = 96
x$ = 104
y$ = 112
comp$ = 120
req_comp$ = 128
ri$ = 136
?stbi__pnm_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z PROC ; stbi__pnm_load

; 7504 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 7505 :     stbi_uc *out;
; 7506 :     STBI_NOTUSED(ri);
; 7507 :     
; 7508 :     ri->bits_per_channel = stbi__pnm_info(s, (int *)&s->img_x, (int *)&s->img_y, (int *)&s->img_n);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0001d	48 83 c0 08	 add	 rax, 8
  00021	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00026	48 83 c1 04	 add	 rcx, 4
  0002a	48 8b 54 24 60	 mov	 rdx, QWORD PTR s$[rsp]
  0002f	4c 8b c8	 mov	 r9, rax
  00032	4c 8b c1	 mov	 r8, rcx
  00035	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0003a	e8 00 00 00 00	 call	 ?stbi__pnm_info@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__pnm_info
  0003f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ri$[rsp]
  00047	89 01		 mov	 DWORD PTR [rcx], eax

; 7509 :     if (ri->bits_per_channel == 0)

  00049	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  00051	83 38 00	 cmp	 DWORD PTR [rax], 0
  00054	75 07		 jne	 SHORT $LN2@stbi__pnm_

; 7510 :         return 0;

  00056	33 c0		 xor	 eax, eax
  00058	e9 b7 02 00 00	 jmp	 $LN1@stbi__pnm_
$LN2@stbi__pnm_:

; 7511 :     
; 7512 :     if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

  0005d	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00062	81 78 04 00 00
	00 01		 cmp	 DWORD PTR [rax+4], 16777216 ; 01000000H
  00069	76 2c		 jbe	 SHORT $LN3@stbi__pnm_
  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG82337
  00072	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00077	85 c0		 test	 eax, eax
  00079	74 0a		 je	 SHORT $LN14@stbi__pnm_
  0007b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
  00083	eb 08		 jmp	 SHORT $LN15@stbi__pnm_
$LN14@stbi__pnm_:
  00085	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN15@stbi__pnm_:
  0008d	48 63 44 24 30	 movsxd	 rax, DWORD PTR tv80[rsp]
  00092	e9 7d 02 00 00	 jmp	 $LN1@stbi__pnm_
$LN3@stbi__pnm_:

; 7513 :     if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

  00097	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0009c	81 38 00 00 00
	01		 cmp	 DWORD PTR [rax], 16777216 ; 01000000H
  000a2	76 2c		 jbe	 SHORT $LN4@stbi__pnm_
  000a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG82339
  000ab	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000b0	85 c0		 test	 eax, eax
  000b2	74 0a		 je	 SHORT $LN16@stbi__pnm_
  000b4	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv87[rsp], 0
  000bc	eb 08		 jmp	 SHORT $LN17@stbi__pnm_
$LN16@stbi__pnm_:
  000be	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv87[rsp], 0
$LN17@stbi__pnm_:
  000c6	48 63 44 24 34	 movsxd	 rax, DWORD PTR tv87[rsp]
  000cb	e9 44 02 00 00	 jmp	 $LN1@stbi__pnm_
$LN4@stbi__pnm_:

; 7514 :     
; 7515 :     *x = s->img_x;

  000d0	48 8b 44 24 68	 mov	 rax, QWORD PTR x$[rsp]
  000d5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000da	8b 09		 mov	 ecx, DWORD PTR [rcx]
  000dc	89 08		 mov	 DWORD PTR [rax], ecx

; 7516 :     *y = s->img_y;

  000de	48 8b 44 24 70	 mov	 rax, QWORD PTR y$[rsp]
  000e3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000e8	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  000eb	89 08		 mov	 DWORD PTR [rax], ecx

; 7517 :     if (comp) *comp = s->img_n;

  000ed	48 83 7c 24 78
	00		 cmp	 QWORD PTR comp$[rsp], 0
  000f3	74 0f		 je	 SHORT $LN5@stbi__pnm_
  000f5	48 8b 44 24 78	 mov	 rax, QWORD PTR comp$[rsp]
  000fa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000ff	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00102	89 08		 mov	 DWORD PTR [rax], ecx
$LN5@stbi__pnm_:

; 7518 :     
; 7519 :     if (!stbi__mad4sizes_valid(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0))

  00104	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  0010c	8b 00		 mov	 eax, DWORD PTR [rax]
  0010e	99		 cdq
  0010f	83 e2 07	 and	 edx, 7
  00112	03 c2		 add	 eax, edx
  00114	c1 f8 03	 sar	 eax, 3
  00117	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0011f	44 8b c8	 mov	 r9d, eax
  00122	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00127	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  0012b	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00130	8b 10		 mov	 edx, DWORD PTR [rax]
  00132	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00137	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  0013a	e8 00 00 00 00	 call	 ?stbi__mad4sizes_valid@@YAHHHHHH@Z ; stbi__mad4sizes_valid
  0013f	85 c0		 test	 eax, eax
  00141	75 2c		 jne	 SHORT $LN6@stbi__pnm_

; 7520 :         return stbi__errpuc("too large", "PNM too large");

  00143	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG82342
  0014a	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0014f	85 c0		 test	 eax, eax
  00151	74 0a		 je	 SHORT $LN18@stbi__pnm_
  00153	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv140[rsp], 0
  0015b	eb 08		 jmp	 SHORT $LN19@stbi__pnm_
$LN18@stbi__pnm_:
  0015d	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv140[rsp], 0
$LN19@stbi__pnm_:
  00165	48 63 44 24 38	 movsxd	 rax, DWORD PTR tv140[rsp]
  0016a	e9 a5 01 00 00	 jmp	 $LN1@stbi__pnm_
$LN6@stbi__pnm_:

; 7521 :     
; 7522 :     out = (stbi_uc *) stbi__malloc_mad4(s->img_n, s->img_x, s->img_y, ri->bits_per_channel / 8, 0);

  0016f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  00177	8b 00		 mov	 eax, DWORD PTR [rax]
  00179	99		 cdq
  0017a	83 e2 07	 and	 edx, 7
  0017d	03 c2		 add	 eax, edx
  0017f	c1 f8 03	 sar	 eax, 3
  00182	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0018a	44 8b c8	 mov	 r9d, eax
  0018d	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00192	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  00196	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0019b	8b 10		 mov	 edx, DWORD PTR [rax]
  0019d	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001a2	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  001a5	e8 00 00 00 00	 call	 ?stbi__malloc_mad4@@YAPEAXHHHHH@Z ; stbi__malloc_mad4
  001aa	48 89 44 24 48	 mov	 QWORD PTR out$[rsp], rax

; 7523 :     if (!out) return stbi__errpuc("outofmem", "Out of memory");

  001af	48 83 7c 24 48
	00		 cmp	 QWORD PTR out$[rsp], 0
  001b5	75 2c		 jne	 SHORT $LN7@stbi__pnm_
  001b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG82344
  001be	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  001c3	85 c0		 test	 eax, eax
  001c5	74 0a		 je	 SHORT $LN20@stbi__pnm_
  001c7	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv157[rsp], 0
  001cf	eb 08		 jmp	 SHORT $LN21@stbi__pnm_
$LN20@stbi__pnm_:
  001d1	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv157[rsp], 0
$LN21@stbi__pnm_:
  001d9	48 63 44 24 3c	 movsxd	 rax, DWORD PTR tv157[rsp]
  001de	e9 31 01 00 00	 jmp	 $LN1@stbi__pnm_
$LN7@stbi__pnm_:

; 7524 :     if (!stbi__getn(s, out, s->img_n * s->img_x * s->img_y * (ri->bits_per_channel / 8))) {

  001e3	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001e8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001ed	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  001f0	0f af 01	 imul	 eax, DWORD PTR [rcx]
  001f3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001f8	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  001fc	89 44 24 44	 mov	 DWORD PTR tv164[rsp], eax
  00200	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ri$[rsp]
  00208	8b 01		 mov	 eax, DWORD PTR [rcx]
  0020a	99		 cdq
  0020b	83 e2 07	 and	 edx, 7
  0020e	03 c2		 add	 eax, edx
  00210	c1 f8 03	 sar	 eax, 3
  00213	8b 4c 24 44	 mov	 ecx, DWORD PTR tv164[rsp]
  00217	0f af c8	 imul	 ecx, eax
  0021a	8b c1		 mov	 eax, ecx
  0021c	44 8b c0	 mov	 r8d, eax
  0021f	48 8b 54 24 48	 mov	 rdx, QWORD PTR out$[rsp]
  00224	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00229	e8 00 00 00 00	 call	 ?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z ; stbi__getn
  0022e	85 c0		 test	 eax, eax
  00230	75 36		 jne	 SHORT $LN8@stbi__pnm_

; 7525 :         STBI_FREE(out);

  00232	48 8b 4c 24 48	 mov	 rcx, QWORD PTR out$[rsp]
  00237	e8 00 00 00 00	 call	 free

; 7526 :         return stbi__errpuc("bad PNM", "PNM file truncated");

  0023c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG82346
  00243	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00248	85 c0		 test	 eax, eax
  0024a	74 0a		 je	 SHORT $LN22@stbi__pnm_
  0024c	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv176[rsp], 0
  00254	eb 08		 jmp	 SHORT $LN23@stbi__pnm_
$LN22@stbi__pnm_:
  00256	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv176[rsp], 0
$LN23@stbi__pnm_:
  0025e	48 63 44 24 40	 movsxd	 rax, DWORD PTR tv176[rsp]
  00263	e9 ac 00 00 00	 jmp	 $LN1@stbi__pnm_
$LN8@stbi__pnm_:

; 7527 :     }
; 7528 :     
; 7529 :     if (req_comp && req_comp != s->img_n) {

  00268	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  00270	0f 84 99 00 00
	00		 je	 $LN9@stbi__pnm_
  00276	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0027b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0027e	39 84 24 80 00
	00 00		 cmp	 DWORD PTR req_comp$[rsp], eax
  00285	0f 84 84 00 00
	00		 je	 $LN9@stbi__pnm_

; 7530 :         if (ri->bits_per_channel == 16) {

  0028b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  00293	83 38 10	 cmp	 DWORD PTR [rax], 16
  00296	75 35		 jne	 SHORT $LN10@stbi__pnm_

; 7531 :             out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, s->img_n, req_comp, s->img_x, s->img_y);

  00298	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0029d	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  002a0	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  002a4	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002a9	44 8b 08	 mov	 r9d, DWORD PTR [rax]
  002ac	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  002b4	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002b9	8b 50 08	 mov	 edx, DWORD PTR [rax+8]
  002bc	48 8b 4c 24 48	 mov	 rcx, QWORD PTR out$[rsp]
  002c1	e8 00 00 00 00	 call	 ?stbi__convert_format16@@YAPEAGPEAGHHII@Z ; stbi__convert_format16
  002c6	48 89 44 24 48	 mov	 QWORD PTR out$[rsp], rax

; 7532 :         } else {

  002cb	eb 33		 jmp	 SHORT $LN11@stbi__pnm_
$LN10@stbi__pnm_:

; 7533 :             out = stbi__convert_format(out, s->img_n, req_comp, s->img_x, s->img_y);

  002cd	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002d2	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  002d5	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  002d9	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002de	44 8b 08	 mov	 r9d, DWORD PTR [rax]
  002e1	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  002e9	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002ee	8b 50 08	 mov	 edx, DWORD PTR [rax+8]
  002f1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR out$[rsp]
  002f6	e8 00 00 00 00	 call	 ?stbi__convert_format@@YAPEAEPEAEHHII@Z ; stbi__convert_format
  002fb	48 89 44 24 48	 mov	 QWORD PTR out$[rsp], rax
$LN11@stbi__pnm_:

; 7534 :         }
; 7535 :         if (out == NULL) return out; // stbi__convert_format frees input on failure

  00300	48 83 7c 24 48
	00		 cmp	 QWORD PTR out$[rsp], 0
  00306	75 07		 jne	 SHORT $LN12@stbi__pnm_
  00308	48 8b 44 24 48	 mov	 rax, QWORD PTR out$[rsp]
  0030d	eb 05		 jmp	 SHORT $LN1@stbi__pnm_
$LN12@stbi__pnm_:
$LN9@stbi__pnm_:

; 7536 :     }
; 7537 :     return out;

  0030f	48 8b 44 24 48	 mov	 rax, QWORD PTR out$[rsp]
$LN1@stbi__pnm_:

; 7538 : }

  00314	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00318	c3		 ret	 0
?stbi__pnm_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ENDP ; stbi__pnm_load
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
t$ = 32
p$ = 33
s$ = 64
?stbi__pnm_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__pnm_test

; 7492 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7493 :     char p, t;
; 7494 :     p = (char) stbi__get8(s);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00013	88 44 24 21	 mov	 BYTE PTR p$[rsp], al

; 7495 :     t = (char) stbi__get8(s);

  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001c	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00021	88 44 24 20	 mov	 BYTE PTR t$[rsp], al

; 7496 :     if (p != 'P' || (t != '5' && t != '6')) {

  00025	0f be 44 24 21	 movsx	 eax, BYTE PTR p$[rsp]
  0002a	83 f8 50	 cmp	 eax, 80			; 00000050H
  0002d	75 14		 jne	 SHORT $LN3@stbi__pnm_
  0002f	0f be 44 24 20	 movsx	 eax, BYTE PTR t$[rsp]
  00034	83 f8 35	 cmp	 eax, 53			; 00000035H
  00037	74 18		 je	 SHORT $LN2@stbi__pnm_
  00039	0f be 44 24 20	 movsx	 eax, BYTE PTR t$[rsp]
  0003e	83 f8 36	 cmp	 eax, 54			; 00000036H
  00041	74 0e		 je	 SHORT $LN2@stbi__pnm_
$LN3@stbi__pnm_:

; 7497 :         stbi__rewind( s );

  00043	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00048	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7498 :         return 0;

  0004d	33 c0		 xor	 eax, eax
  0004f	eb 05		 jmp	 SHORT $LN1@stbi__pnm_
$LN2@stbi__pnm_:

; 7499 :     }
; 7500 :     return 1;

  00051	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__pnm_:

; 7501 : }

  00056	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005a	c3		 ret	 0
?stbi__pnm_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__pnm_test
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
s$ = 48
x$ = 56
y$ = 64
comp$ = 72
?stbi__gif_info@@YAHPEAUstbi__context@@PEAH11@Z PROC	; stbi__gif_info

; 7075 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 7076 :     return stbi__gif_info_raw(s,x,y,comp);

  00018	4c 8b 4c 24 48	 mov	 r9, QWORD PTR comp$[rsp]
  0001d	4c 8b 44 24 40	 mov	 r8, QWORD PTR y$[rsp]
  00022	48 8b 54 24 38	 mov	 rdx, QWORD PTR x$[rsp]
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0002c	e8 00 00 00 00	 call	 ?stbi__gif_info_raw@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__gif_info_raw

; 7077 : }

  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	c3		 ret	 0
?stbi__gif_info@@YAHPEAUstbi__context@@PEAH11@Z ENDP	; stbi__gif_info
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
layers$1 = 48
stride$2 = 52
out$3 = 56
u$4 = 64
out_size$5 = 72
delays_size$6 = 76
tv202 = 80
tmp$7 = 88
new_delays$8 = 96
two_back$9 = 104
g$10 = 112
__$ArrayPad$ = 35040
s$ = 35072
delays$ = 35080
x$ = 35088
y$ = 35096
z$ = 35104
comp$ = 35112
req_comp$ = 35120
?stbi__load_gif_main@@YAPEAXPEAUstbi__context@@PEAPEAHPEAH222H@Z PROC ; stbi__load_gif_main

; 6961 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	b8 f8 88 00 00	 mov	 eax, 35064		; 000088f8H
  00019	e8 00 00 00 00	 call	 __chkstk
  0001e	48 2b e0	 sub	 rsp, rax
  00021	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00028	48 33 c4	 xor	 rax, rsp
  0002b	48 89 84 24 e0
	88 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 6962 :     if (stbi__gif_test(s)) {

  00033	48 8b 8c 24 00
	89 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0003b	e8 00 00 00 00	 call	 ?stbi__gif_test@@YAHPEAUstbi__context@@@Z ; stbi__gif_test
  00040	85 c0		 test	 eax, eax
  00042	0f 84 66 03 00
	00		 je	 $LN5@stbi__load

; 6963 :         int layers = 0;

  00048	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR layers$1[rsp], 0

; 6964 :         stbi_uc *u = 0;

  00050	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR u$4[rsp], 0

; 6965 :         stbi_uc *out = 0;

  00059	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR out$3[rsp], 0

; 6966 :         stbi_uc *two_back = 0;

  00062	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR two_back$9[rsp], 0

; 6967 :         stbi__gif g;
; 6968 :         int stride;
; 6969 :         int out_size = 0;

  0006b	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR out_size$5[rsp], 0

; 6970 :         int delays_size = 0;

  00073	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR delays_size$6[rsp], 0

; 6971 :         
; 6972 :         STBI_NOTUSED(out_size);
; 6973 :         STBI_NOTUSED(delays_size);
; 6974 :         
; 6975 :         memset(&g, 0, sizeof(g));

  0007b	41 b8 70 88 00
	00		 mov	 r8d, 34928		; 00008870H
  00081	33 d2		 xor	 edx, edx
  00083	48 8d 4c 24 70	 lea	 rcx, QWORD PTR g$10[rsp]
  00088	e8 00 00 00 00	 call	 memset

; 6976 :         if (delays) {

  0008d	48 83 bc 24 08
	89 00 00 00	 cmp	 QWORD PTR delays$[rsp], 0
  00096	74 0f		 je	 SHORT $LN7@stbi__load

; 6977 :             *delays = 0;

  00098	48 8b 84 24 08
	89 00 00	 mov	 rax, QWORD PTR delays$[rsp]
  000a0	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN7@stbi__load:
$LN4@stbi__load:

; 6978 :         }
; 6979 :         
; 6980 :         do {
; 6981 :             u = stbi__gif_load_next(s, &g, comp, req_comp, two_back);

  000a7	48 8b 44 24 68	 mov	 rax, QWORD PTR two_back$9[rsp]
  000ac	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b1	44 8b 8c 24 30
	89 00 00	 mov	 r9d, DWORD PTR req_comp$[rsp]
  000b9	4c 8b 84 24 28
	89 00 00	 mov	 r8, QWORD PTR comp$[rsp]
  000c1	48 8d 54 24 70	 lea	 rdx, QWORD PTR g$10[rsp]
  000c6	48 8b 8c 24 00
	89 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000ce	e8 00 00 00 00	 call	 ?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHHPEAE@Z ; stbi__gif_load_next
  000d3	48 89 44 24 40	 mov	 QWORD PTR u$4[rsp], rax

; 6982 :             if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker

  000d8	48 8b 84 24 00
	89 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000e0	48 39 44 24 40	 cmp	 QWORD PTR u$4[rsp], rax
  000e5	75 09		 jne	 SHORT $LN8@stbi__load
  000e7	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR u$4[rsp], 0
$LN8@stbi__load:

; 6983 :             
; 6984 :             if (u) {

  000f0	48 83 7c 24 40
	00		 cmp	 QWORD PTR u$4[rsp], 0
  000f6	0f 84 27 02 00
	00		 je	 $LN9@stbi__load

; 6985 :                 *x = g.w;

  000fc	48 8b 84 24 10
	89 00 00	 mov	 rax, QWORD PTR x$[rsp]
  00104	8b 4c 24 70	 mov	 ecx, DWORD PTR g$10[rsp]
  00108	89 08		 mov	 DWORD PTR [rax], ecx

; 6986 :                 *y = g.h;

  0010a	48 8b 84 24 18
	89 00 00	 mov	 rax, QWORD PTR y$[rsp]
  00112	8b 4c 24 74	 mov	 ecx, DWORD PTR g$10[rsp+4]
  00116	89 08		 mov	 DWORD PTR [rax], ecx

; 6987 :                 ++layers;

  00118	8b 44 24 30	 mov	 eax, DWORD PTR layers$1[rsp]
  0011c	ff c0		 inc	 eax
  0011e	89 44 24 30	 mov	 DWORD PTR layers$1[rsp], eax

; 6988 :                 stride = g.w * g.h * 4;

  00122	8b 44 24 70	 mov	 eax, DWORD PTR g$10[rsp]
  00126	0f af 44 24 74	 imul	 eax, DWORD PTR g$10[rsp+4]
  0012b	c1 e0 02	 shl	 eax, 2
  0012e	89 44 24 34	 mov	 DWORD PTR stride$2[rsp], eax

; 6989 :                 
; 6990 :                 if (out) {

  00132	48 83 7c 24 38
	00		 cmp	 QWORD PTR out$3[rsp], 0
  00138	0f 84 cc 00 00
	00		 je	 $LN10@stbi__load

; 6991 :                     void *tmp = (stbi_uc*) STBI_REALLOC_SIZED( out, out_size, layers * stride );

  0013e	8b 44 24 30	 mov	 eax, DWORD PTR layers$1[rsp]
  00142	0f af 44 24 34	 imul	 eax, DWORD PTR stride$2[rsp]
  00147	48 98		 cdqe
  00149	48 8b d0	 mov	 rdx, rax
  0014c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$3[rsp]
  00151	e8 00 00 00 00	 call	 realloc
  00156	48 89 44 24 58	 mov	 QWORD PTR tmp$7[rsp], rax

; 6992 :                     if (!tmp)

  0015b	48 83 7c 24 58
	00		 cmp	 QWORD PTR tmp$7[rsp], 0
  00161	75 1e		 jne	 SHORT $LN12@stbi__load

; 6993 :                         return stbi__load_gif_main_outofmem(&g, out, delays);

  00163	4c 8b 84 24 08
	89 00 00	 mov	 r8, QWORD PTR delays$[rsp]
  0016b	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$3[rsp]
  00170	48 8d 4c 24 70	 lea	 rcx, QWORD PTR g$10[rsp]
  00175	e8 00 00 00 00	 call	 ?stbi__load_gif_main_outofmem@@YAPEAXPEAUstbi__gif@@PEAEPEAPEAH@Z ; stbi__load_gif_main_outofmem
  0017a	e9 56 02 00 00	 jmp	 $LN1@stbi__load
  0017f	eb 17		 jmp	 SHORT $LN13@stbi__load
$LN12@stbi__load:

; 6994 :                     else {
; 6995 :                         out = (stbi_uc*) tmp;

  00181	48 8b 44 24 58	 mov	 rax, QWORD PTR tmp$7[rsp]
  00186	48 89 44 24 38	 mov	 QWORD PTR out$3[rsp], rax

; 6996 :                         out_size = layers * stride;

  0018b	8b 44 24 30	 mov	 eax, DWORD PTR layers$1[rsp]
  0018f	0f af 44 24 34	 imul	 eax, DWORD PTR stride$2[rsp]
  00194	89 44 24 48	 mov	 DWORD PTR out_size$5[rsp], eax
$LN13@stbi__load:

; 6997 :                     }
; 6998 :                     
; 6999 :                     if (delays) {

  00198	48 83 bc 24 08
	89 00 00 00	 cmp	 QWORD PTR delays$[rsp], 0
  001a1	74 62		 je	 SHORT $LN14@stbi__load

; 7000 :                         int *new_delays = (int*) STBI_REALLOC_SIZED( *delays, delays_size, sizeof(int) * layers );

  001a3	48 63 44 24 30	 movsxd	 rax, DWORD PTR layers$1[rsp]
  001a8	48 c1 e0 02	 shl	 rax, 2
  001ac	48 8b d0	 mov	 rdx, rax
  001af	48 8b 84 24 08
	89 00 00	 mov	 rax, QWORD PTR delays$[rsp]
  001b7	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001ba	e8 00 00 00 00	 call	 realloc
  001bf	48 89 44 24 60	 mov	 QWORD PTR new_delays$8[rsp], rax

; 7001 :                         if (!new_delays)

  001c4	48 83 7c 24 60
	00		 cmp	 QWORD PTR new_delays$8[rsp], 0
  001ca	75 1c		 jne	 SHORT $LN15@stbi__load

; 7002 :                             return stbi__load_gif_main_outofmem(&g, out, delays);

  001cc	4c 8b 84 24 08
	89 00 00	 mov	 r8, QWORD PTR delays$[rsp]
  001d4	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$3[rsp]
  001d9	48 8d 4c 24 70	 lea	 rcx, QWORD PTR g$10[rsp]
  001de	e8 00 00 00 00	 call	 ?stbi__load_gif_main_outofmem@@YAPEAXPEAUstbi__gif@@PEAEPEAPEAH@Z ; stbi__load_gif_main_outofmem
  001e3	e9 ed 01 00 00	 jmp	 $LN1@stbi__load
$LN15@stbi__load:

; 7003 :                         *delays = new_delays;

  001e8	48 8b 84 24 08
	89 00 00	 mov	 rax, QWORD PTR delays$[rsp]
  001f0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR new_delays$8[rsp]
  001f5	48 89 08	 mov	 QWORD PTR [rax], rcx

; 7004 :                         delays_size = layers * sizeof(int);

  001f8	48 63 44 24 30	 movsxd	 rax, DWORD PTR layers$1[rsp]
  001fd	48 c1 e0 02	 shl	 rax, 2
  00201	89 44 24 4c	 mov	 DWORD PTR delays_size$6[rsp], eax
$LN14@stbi__load:

; 7005 :                     }
; 7006 :                 } else {

  00205	e9 a7 00 00 00	 jmp	 $LN11@stbi__load
$LN10@stbi__load:

; 7007 :                     out = (stbi_uc*)stbi__malloc( layers * stride );

  0020a	8b 44 24 30	 mov	 eax, DWORD PTR layers$1[rsp]
  0020e	0f af 44 24 34	 imul	 eax, DWORD PTR stride$2[rsp]
  00213	48 98		 cdqe
  00215	48 8b c8	 mov	 rcx, rax
  00218	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  0021d	48 89 44 24 38	 mov	 QWORD PTR out$3[rsp], rax

; 7008 :                     if (!out)

  00222	48 83 7c 24 38
	00		 cmp	 QWORD PTR out$3[rsp], 0
  00228	75 1c		 jne	 SHORT $LN16@stbi__load

; 7009 :                         return stbi__load_gif_main_outofmem(&g, out, delays);

  0022a	4c 8b 84 24 08
	89 00 00	 mov	 r8, QWORD PTR delays$[rsp]
  00232	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$3[rsp]
  00237	48 8d 4c 24 70	 lea	 rcx, QWORD PTR g$10[rsp]
  0023c	e8 00 00 00 00	 call	 ?stbi__load_gif_main_outofmem@@YAPEAXPEAUstbi__gif@@PEAEPEAPEAH@Z ; stbi__load_gif_main_outofmem
  00241	e9 8f 01 00 00	 jmp	 $LN1@stbi__load
$LN16@stbi__load:

; 7010 :                     out_size = layers * stride;

  00246	8b 44 24 30	 mov	 eax, DWORD PTR layers$1[rsp]
  0024a	0f af 44 24 34	 imul	 eax, DWORD PTR stride$2[rsp]
  0024f	89 44 24 48	 mov	 DWORD PTR out_size$5[rsp], eax

; 7011 :                     if (delays) {

  00253	48 83 bc 24 08
	89 00 00 00	 cmp	 QWORD PTR delays$[rsp], 0
  0025c	74 53		 je	 SHORT $LN17@stbi__load

; 7012 :                         *delays = (int*) stbi__malloc( layers * sizeof(int) );

  0025e	48 63 44 24 30	 movsxd	 rax, DWORD PTR layers$1[rsp]
  00263	48 c1 e0 02	 shl	 rax, 2
  00267	48 8b c8	 mov	 rcx, rax
  0026a	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  0026f	48 8b 8c 24 08
	89 00 00	 mov	 rcx, QWORD PTR delays$[rsp]
  00277	48 89 01	 mov	 QWORD PTR [rcx], rax

; 7013 :                         if (!*delays)

  0027a	48 8b 84 24 08
	89 00 00	 mov	 rax, QWORD PTR delays$[rsp]
  00282	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00286	75 1c		 jne	 SHORT $LN18@stbi__load

; 7014 :                             return stbi__load_gif_main_outofmem(&g, out, delays);

  00288	4c 8b 84 24 08
	89 00 00	 mov	 r8, QWORD PTR delays$[rsp]
  00290	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$3[rsp]
  00295	48 8d 4c 24 70	 lea	 rcx, QWORD PTR g$10[rsp]
  0029a	e8 00 00 00 00	 call	 ?stbi__load_gif_main_outofmem@@YAPEAXPEAUstbi__gif@@PEAEPEAPEAH@Z ; stbi__load_gif_main_outofmem
  0029f	e9 31 01 00 00	 jmp	 $LN1@stbi__load
$LN18@stbi__load:

; 7015 :                         delays_size = layers * sizeof(int);

  002a4	48 63 44 24 30	 movsxd	 rax, DWORD PTR layers$1[rsp]
  002a9	48 c1 e0 02	 shl	 rax, 2
  002ad	89 44 24 4c	 mov	 DWORD PTR delays_size$6[rsp], eax
$LN17@stbi__load:
$LN11@stbi__load:

; 7016 :                     }
; 7017 :                 }
; 7018 :                 memcpy( out + ((layers - 1) * stride), u, stride );

  002b1	48 63 44 24 34	 movsxd	 rax, DWORD PTR stride$2[rsp]
  002b6	8b 4c 24 30	 mov	 ecx, DWORD PTR layers$1[rsp]
  002ba	ff c9		 dec	 ecx
  002bc	0f af 4c 24 34	 imul	 ecx, DWORD PTR stride$2[rsp]
  002c1	48 63 c9	 movsxd	 rcx, ecx
  002c4	48 8b 54 24 38	 mov	 rdx, QWORD PTR out$3[rsp]
  002c9	48 03 d1	 add	 rdx, rcx
  002cc	48 8b ca	 mov	 rcx, rdx
  002cf	4c 8b c0	 mov	 r8, rax
  002d2	48 8b 54 24 40	 mov	 rdx, QWORD PTR u$4[rsp]
  002d7	e8 00 00 00 00	 call	 memcpy

; 7019 :                 if (layers >= 2) {

  002dc	83 7c 24 30 02	 cmp	 DWORD PTR layers$1[rsp], 2
  002e1	7c 18		 jl	 SHORT $LN19@stbi__load

; 7020 :                     two_back = out - 2 * stride;

  002e3	8b 44 24 34	 mov	 eax, DWORD PTR stride$2[rsp]
  002e7	d1 e0		 shl	 eax, 1
  002e9	48 98		 cdqe
  002eb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$3[rsp]
  002f0	48 2b c8	 sub	 rcx, rax
  002f3	48 8b c1	 mov	 rax, rcx
  002f6	48 89 44 24 68	 mov	 QWORD PTR two_back$9[rsp], rax
$LN19@stbi__load:

; 7021 :                 }
; 7022 :                 
; 7023 :                 if (delays) {

  002fb	48 83 bc 24 08
	89 00 00 00	 cmp	 QWORD PTR delays$[rsp], 0
  00304	74 1d		 je	 SHORT $LN20@stbi__load

; 7024 :                     (*delays)[layers - 1U] = g.delay;

  00306	8b 44 24 30	 mov	 eax, DWORD PTR layers$1[rsp]
  0030a	ff c8		 dec	 eax
  0030c	8b c0		 mov	 eax, eax
  0030e	48 8b 8c 24 08
	89 00 00	 mov	 rcx, QWORD PTR delays$[rsp]
  00316	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00319	8b 94 24 d8 88
	00 00		 mov	 edx, DWORD PTR g$10[rsp+34920]
  00320	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx
$LN20@stbi__load:
$LN9@stbi__load:

; 7025 :                 }
; 7026 :             }
; 7027 :         } while (u != 0);

  00323	48 83 7c 24 40
	00		 cmp	 QWORD PTR u$4[rsp], 0
  00329	0f 85 78 fd ff
	ff		 jne	 $LN4@stbi__load

; 7028 :         
; 7029 :         // free temp buffer;
; 7030 :         STBI_FREE(g.out);

  0032f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR g$10[rsp+8]
  00334	e8 00 00 00 00	 call	 free

; 7031 :         STBI_FREE(g.history);

  00339	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR g$10[rsp+24]
  00341	e8 00 00 00 00	 call	 free

; 7032 :         STBI_FREE(g.background);

  00346	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR g$10[rsp+16]
  0034e	e8 00 00 00 00	 call	 free

; 7033 :         
; 7034 :         // do the final conversion after loading everything;
; 7035 :         if (req_comp && req_comp != 4)

  00353	83 bc 24 30 89
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  0035b	74 3a		 je	 SHORT $LN21@stbi__load
  0035d	83 bc 24 30 89
	00 00 04	 cmp	 DWORD PTR req_comp$[rsp], 4
  00365	74 30		 je	 SHORT $LN21@stbi__load

; 7036 :             out = stbi__convert_format(out, 4, req_comp, layers * g.w, g.h);

  00367	8b 44 24 30	 mov	 eax, DWORD PTR layers$1[rsp]
  0036b	0f af 44 24 70	 imul	 eax, DWORD PTR g$10[rsp]
  00370	8b 4c 24 74	 mov	 ecx, DWORD PTR g$10[rsp+4]
  00374	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00378	44 8b c8	 mov	 r9d, eax
  0037b	44 8b 84 24 30
	89 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  00383	ba 04 00 00 00	 mov	 edx, 4
  00388	48 8b 4c 24 38	 mov	 rcx, QWORD PTR out$3[rsp]
  0038d	e8 00 00 00 00	 call	 ?stbi__convert_format@@YAPEAEPEAEHHII@Z ; stbi__convert_format
  00392	48 89 44 24 38	 mov	 QWORD PTR out$3[rsp], rax
$LN21@stbi__load:

; 7037 :         
; 7038 :         *z = layers;

  00397	48 8b 84 24 20
	89 00 00	 mov	 rax, QWORD PTR z$[rsp]
  0039f	8b 4c 24 30	 mov	 ecx, DWORD PTR layers$1[rsp]
  003a3	89 08		 mov	 DWORD PTR [rax], ecx

; 7039 :         return out;

  003a5	48 8b 44 24 38	 mov	 rax, QWORD PTR out$3[rsp]
  003aa	eb 29		 jmp	 SHORT $LN1@stbi__load

; 7040 :     } else {

  003ac	eb 27		 jmp	 SHORT $LN6@stbi__load
$LN5@stbi__load:

; 7041 :         return stbi__errpuc("not GIF", "Image was not as a gif type.");

  003ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81990
  003b5	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  003ba	85 c0		 test	 eax, eax
  003bc	74 0a		 je	 SHORT $LN23@stbi__load
  003be	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv202[rsp], 0
  003c6	eb 08		 jmp	 SHORT $LN24@stbi__load
$LN23@stbi__load:
  003c8	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv202[rsp], 0
$LN24@stbi__load:
  003d0	48 63 44 24 50	 movsxd	 rax, DWORD PTR tv202[rsp]
$LN6@stbi__load:
$LN1@stbi__load:

; 7042 :     }
; 7043 : }

  003d5	48 8b 8c 24 e0
	88 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003dd	48 33 cc	 xor	 rcx, rsp
  003e0	e8 00 00 00 00	 call	 __security_check_cookie
  003e5	48 81 c4 f8 88
	00 00		 add	 rsp, 35064		; 000088f8H
  003ec	c3		 ret	 0
?stbi__load_gif_main@@YAPEAXPEAUstbi__context@@PEAPEAHPEAH222H@Z ENDP ; stbi__load_gif_main
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
u$ = 48
g$ = 64
__$ArrayPad$ = 34992
s$ = 35024
x$ = 35032
y$ = 35040
comp$ = 35048
req_comp$ = 35056
ri$ = 35064
?stbi__gif_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z PROC ; stbi__gif_load

; 7046 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	b8 c8 88 00 00	 mov	 eax, 35016		; 000088c8H
  00019	e8 00 00 00 00	 call	 __chkstk
  0001e	48 2b e0	 sub	 rsp, rax
  00021	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00028	48 33 c4	 xor	 rax, rsp
  0002b	48 89 84 24 b0
	88 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 7047 :     stbi_uc *u = 0;

  00033	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR u$[rsp], 0

; 7048 :     stbi__gif g;
; 7049 :     memset(&g, 0, sizeof(g));

  0003c	41 b8 70 88 00
	00		 mov	 r8d, 34928		; 00008870H
  00042	33 d2		 xor	 edx, edx
  00044	48 8d 4c 24 40	 lea	 rcx, QWORD PTR g$[rsp]
  00049	e8 00 00 00 00	 call	 memset

; 7050 :     STBI_NOTUSED(ri);
; 7051 :     
; 7052 :     u = stbi__gif_load_next(s, &g, comp, req_comp, 0);

  0004e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00057	44 8b 8c 24 f0
	88 00 00	 mov	 r9d, DWORD PTR req_comp$[rsp]
  0005f	4c 8b 84 24 e8
	88 00 00	 mov	 r8, QWORD PTR comp$[rsp]
  00067	48 8d 54 24 40	 lea	 rdx, QWORD PTR g$[rsp]
  0006c	48 8b 8c 24 d0
	88 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00074	e8 00 00 00 00	 call	 ?stbi__gif_load_next@@YAPEAEPEAUstbi__context@@PEAUstbi__gif@@PEAHHPEAE@Z ; stbi__gif_load_next
  00079	48 89 44 24 30	 mov	 QWORD PTR u$[rsp], rax

; 7053 :     if (u == (stbi_uc *) s) u = 0;  // end of animated gif marker

  0007e	48 8b 84 24 d0
	88 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00086	48 39 44 24 30	 cmp	 QWORD PTR u$[rsp], rax
  0008b	75 09		 jne	 SHORT $LN2@stbi__gif_
  0008d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR u$[rsp], 0
$LN2@stbi__gif_:

; 7054 :     if (u) {

  00096	48 83 7c 24 30
	00		 cmp	 QWORD PTR u$[rsp], 0
  0009c	74 5b		 je	 SHORT $LN3@stbi__gif_

; 7055 :         *x = g.w;

  0009e	48 8b 84 24 d8
	88 00 00	 mov	 rax, QWORD PTR x$[rsp]
  000a6	8b 4c 24 40	 mov	 ecx, DWORD PTR g$[rsp]
  000aa	89 08		 mov	 DWORD PTR [rax], ecx

; 7056 :         *y = g.h;

  000ac	48 8b 84 24 e0
	88 00 00	 mov	 rax, QWORD PTR y$[rsp]
  000b4	8b 4c 24 44	 mov	 ecx, DWORD PTR g$[rsp+4]
  000b8	89 08		 mov	 DWORD PTR [rax], ecx

; 7057 :         
; 7058 :         // moved conversion to after successful load so that the same
; 7059 :         // can be done for multiple frames.
; 7060 :         if (req_comp && req_comp != 4)

  000ba	83 bc 24 f0 88
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  000c2	74 33		 je	 SHORT $LN5@stbi__gif_
  000c4	83 bc 24 f0 88
	00 00 04	 cmp	 DWORD PTR req_comp$[rsp], 4
  000cc	74 29		 je	 SHORT $LN5@stbi__gif_

; 7061 :             u = stbi__convert_format(u, 4, req_comp, g.w, g.h);

  000ce	8b 44 24 44	 mov	 eax, DWORD PTR g$[rsp+4]
  000d2	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000d6	44 8b 4c 24 40	 mov	 r9d, DWORD PTR g$[rsp]
  000db	44 8b 84 24 f0
	88 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  000e3	ba 04 00 00 00	 mov	 edx, 4
  000e8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR u$[rsp]
  000ed	e8 00 00 00 00	 call	 ?stbi__convert_format@@YAPEAEPEAEHHII@Z ; stbi__convert_format
  000f2	48 89 44 24 30	 mov	 QWORD PTR u$[rsp], rax
$LN5@stbi__gif_:
  000f7	eb 12		 jmp	 SHORT $LN4@stbi__gif_
$LN3@stbi__gif_:

; 7062 :     } else if (g.out) {

  000f9	48 83 7c 24 48
	00		 cmp	 QWORD PTR g$[rsp+8], 0
  000ff	74 0a		 je	 SHORT $LN6@stbi__gif_

; 7063 :         // if there was an error and we allocated an image buffer, free it!
; 7064 :         STBI_FREE(g.out);

  00101	48 8b 4c 24 48	 mov	 rcx, QWORD PTR g$[rsp+8]
  00106	e8 00 00 00 00	 call	 free
$LN6@stbi__gif_:
$LN4@stbi__gif_:

; 7065 :     }
; 7066 :     
; 7067 :     // free buffers needed for multiple frame loading;
; 7068 :     STBI_FREE(g.history);

  0010b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR g$[rsp+24]
  00110	e8 00 00 00 00	 call	 free

; 7069 :     STBI_FREE(g.background);

  00115	48 8b 4c 24 50	 mov	 rcx, QWORD PTR g$[rsp+16]
  0011a	e8 00 00 00 00	 call	 free

; 7070 :     
; 7071 :     return u;

  0011f	48 8b 44 24 30	 mov	 rax, QWORD PTR u$[rsp]

; 7072 : }

  00124	48 8b 8c 24 b0
	88 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0012c	48 33 cc	 xor	 rcx, rsp
  0012f	e8 00 00 00 00	 call	 __security_check_cookie
  00134	48 81 c4 c8 88
	00 00		 add	 rsp, 35016		; 000088c8H
  0013b	c3		 ret	 0
?stbi__gif_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ENDP ; stbi__gif_load
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
r$ = 32
s$ = 64
?stbi__gif_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__gif_test

; 6588 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6589 :     int r = stbi__gif_test_raw(s);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__gif_test_raw@@YAHPEAUstbi__context@@@Z ; stbi__gif_test_raw
  00013	89 44 24 20	 mov	 DWORD PTR r$[rsp], eax

; 6590 :     stbi__rewind(s);

  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001c	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 6591 :     return r;

  00021	8b 44 24 20	 mov	 eax, DWORD PTR r$[rsp]

; 6592 : }

  00025	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00029	c3		 ret	 0
?stbi__gif_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__gif_test
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
num_packets$ = 32
act_comp$ = 36
dummy$ = 40
tv152 = 44
packet$1 = 48
chained$ = 56
packets$ = 64
__$ArrayPad$ = 96
s$ = 128
x$ = 136
y$ = 144
comp$ = 152
?stbi__pic_info@@YAHPEAUstbi__context@@PEAH11@Z PROC	; stbi__pic_info

; 7421 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 7422 :     int act_comp=0,num_packets=0,chained,dummy;

  00027	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR act_comp$[rsp], 0
  0002f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR num_packets$[rsp], 0

; 7423 :     stbi__pic_packet packets[10];
; 7424 :     
; 7425 :     if (!x) x = &dummy;

  00037	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR x$[rsp], 0
  00040	75 0d		 jne	 SHORT $LN5@stbi__pic_
  00042	48 8d 44 24 28	 lea	 rax, QWORD PTR dummy$[rsp]
  00047	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR x$[rsp], rax
$LN5@stbi__pic_:

; 7426 :     if (!y) y = &dummy;

  0004f	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR y$[rsp], 0
  00058	75 0d		 jne	 SHORT $LN6@stbi__pic_
  0005a	48 8d 44 24 28	 lea	 rax, QWORD PTR dummy$[rsp]
  0005f	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR y$[rsp], rax
$LN6@stbi__pic_:

; 7427 :     if (!comp) comp = &dummy;

  00067	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR comp$[rsp], 0
  00070	75 0d		 jne	 SHORT $LN7@stbi__pic_
  00072	48 8d 44 24 28	 lea	 rax, QWORD PTR dummy$[rsp]
  00077	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR comp$[rsp], rax
$LN7@stbi__pic_:

; 7428 :     
; 7429 :     if (!stbi__pic_is4(s,"\x53\x80\xF6\x34")) {

  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG82294
  00086	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0008e	e8 00 00 00 00	 call	 ?stbi__pic_is4@@YAHPEAUstbi__context@@PEBD@Z ; stbi__pic_is4
  00093	85 c0		 test	 eax, eax
  00095	75 14		 jne	 SHORT $LN8@stbi__pic_

; 7430 :         stbi__rewind(s);

  00097	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0009f	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7431 :         return 0;

  000a4	33 c0		 xor	 eax, eax
  000a6	e9 c5 01 00 00	 jmp	 $LN1@stbi__pic_
$LN8@stbi__pic_:

; 7432 :     }
; 7433 :     
; 7434 :     stbi__skip(s, 88);

  000ab	ba 58 00 00 00	 mov	 edx, 88			; 00000058H
  000b0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000b8	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 7435 :     
; 7436 :     *x = stbi__get16be(s);

  000bd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000c5	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  000ca	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR x$[rsp]
  000d2	89 01		 mov	 DWORD PTR [rcx], eax

; 7437 :     *y = stbi__get16be(s);

  000d4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000dc	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  000e1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR y$[rsp]
  000e9	89 01		 mov	 DWORD PTR [rcx], eax

; 7438 :     if (stbi__at_eof(s)) {

  000eb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000f3	e8 00 00 00 00	 call	 ?stbi__at_eof@@YAHPEAUstbi__context@@@Z ; stbi__at_eof
  000f8	85 c0		 test	 eax, eax
  000fa	74 14		 je	 SHORT $LN9@stbi__pic_

; 7439 :         stbi__rewind( s);

  000fc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00104	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7440 :         return 0;

  00109	33 c0		 xor	 eax, eax
  0010b	e9 60 01 00 00	 jmp	 $LN1@stbi__pic_
$LN9@stbi__pic_:

; 7441 :     }
; 7442 :     if ( (*x) != 0 && (1 << 28) / (*x) < (*y)) {

  00110	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR x$[rsp]
  00118	83 38 00	 cmp	 DWORD PTR [rax], 0
  0011b	74 30		 je	 SHORT $LN10@stbi__pic_
  0011d	b8 00 00 00 10	 mov	 eax, 268435456		; 10000000H
  00122	99		 cdq
  00123	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR x$[rsp]
  0012b	f7 39		 idiv	 DWORD PTR [rcx]
  0012d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR y$[rsp]
  00135	3b 01		 cmp	 eax, DWORD PTR [rcx]
  00137	7d 14		 jge	 SHORT $LN10@stbi__pic_

; 7443 :         stbi__rewind( s );

  00139	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00141	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7444 :         return 0;

  00146	33 c0		 xor	 eax, eax
  00148	e9 23 01 00 00	 jmp	 $LN1@stbi__pic_
$LN10@stbi__pic_:

; 7445 :     }
; 7446 :     
; 7447 :     stbi__skip(s, 8);

  0014d	ba 08 00 00 00	 mov	 edx, 8
  00152	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0015a	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip
$LN4@stbi__pic_:

; 7448 :     
; 7449 :     do {
; 7450 :         stbi__pic_packet *packet;
; 7451 :         
; 7452 :         if (num_packets==sizeof(packets)/sizeof(packets[0]))

  0015f	48 63 44 24 20	 movsxd	 rax, DWORD PTR num_packets$[rsp]
  00164	48 83 f8 0a	 cmp	 rax, 10
  00168	75 07		 jne	 SHORT $LN11@stbi__pic_

; 7453 :             return 0;

  0016a	33 c0		 xor	 eax, eax
  0016c	e9 ff 00 00 00	 jmp	 $LN1@stbi__pic_
$LN11@stbi__pic_:

; 7454 :         
; 7455 :         packet = &packets[num_packets++];

  00171	48 63 44 24 20	 movsxd	 rax, DWORD PTR num_packets$[rsp]
  00176	48 6b c0 03	 imul	 rax, rax, 3
  0017a	48 8d 44 04 40	 lea	 rax, QWORD PTR packets$[rsp+rax]
  0017f	48 89 44 24 30	 mov	 QWORD PTR packet$1[rsp], rax
  00184	8b 44 24 20	 mov	 eax, DWORD PTR num_packets$[rsp]
  00188	ff c0		 inc	 eax
  0018a	89 44 24 20	 mov	 DWORD PTR num_packets$[rsp], eax

; 7456 :         chained = stbi__get8(s);

  0018e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00196	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0019b	0f b6 c0	 movzx	 eax, al
  0019e	89 44 24 38	 mov	 DWORD PTR chained$[rsp], eax

; 7457 :         packet->size    = stbi__get8(s);

  001a2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001aa	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  001af	48 8b 4c 24 30	 mov	 rcx, QWORD PTR packet$1[rsp]
  001b4	88 01		 mov	 BYTE PTR [rcx], al

; 7458 :         packet->type    = stbi__get8(s);

  001b6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001be	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  001c3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR packet$1[rsp]
  001c8	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 7459 :         packet->channel = stbi__get8(s);

  001cb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001d3	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  001d8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR packet$1[rsp]
  001dd	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 7460 :         act_comp |= packet->channel;

  001e0	48 8b 44 24 30	 mov	 rax, QWORD PTR packet$1[rsp]
  001e5	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  001e9	8b 4c 24 24	 mov	 ecx, DWORD PTR act_comp$[rsp]
  001ed	0b c8		 or	 ecx, eax
  001ef	8b c1		 mov	 eax, ecx
  001f1	89 44 24 24	 mov	 DWORD PTR act_comp$[rsp], eax

; 7461 :         
; 7462 :         if (stbi__at_eof(s)) {

  001f5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001fd	e8 00 00 00 00	 call	 ?stbi__at_eof@@YAHPEAUstbi__context@@@Z ; stbi__at_eof
  00202	85 c0		 test	 eax, eax
  00204	74 11		 je	 SHORT $LN12@stbi__pic_

; 7463 :             stbi__rewind( s );

  00206	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0020e	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7464 :             return 0;

  00213	33 c0		 xor	 eax, eax
  00215	eb 59		 jmp	 SHORT $LN1@stbi__pic_
$LN12@stbi__pic_:

; 7465 :         }
; 7466 :         if (packet->size != 8) {

  00217	48 8b 44 24 30	 mov	 rax, QWORD PTR packet$1[rsp]
  0021c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0021f	83 f8 08	 cmp	 eax, 8
  00222	74 11		 je	 SHORT $LN13@stbi__pic_

; 7467 :             stbi__rewind( s );

  00224	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0022c	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7468 :             return 0;

  00231	33 c0		 xor	 eax, eax
  00233	eb 3b		 jmp	 SHORT $LN1@stbi__pic_
$LN13@stbi__pic_:

; 7469 :         }
; 7470 :     } while (chained);

  00235	83 7c 24 38 00	 cmp	 DWORD PTR chained$[rsp], 0
  0023a	0f 85 1f ff ff
	ff		 jne	 $LN4@stbi__pic_

; 7471 :     
; 7472 :     *comp = (act_comp & 0x10 ? 4 : 3);

  00240	8b 44 24 24	 mov	 eax, DWORD PTR act_comp$[rsp]
  00244	83 e0 10	 and	 eax, 16
  00247	85 c0		 test	 eax, eax
  00249	74 0a		 je	 SHORT $LN15@stbi__pic_
  0024b	c7 44 24 2c 04
	00 00 00	 mov	 DWORD PTR tv152[rsp], 4
  00253	eb 08		 jmp	 SHORT $LN16@stbi__pic_
$LN15@stbi__pic_:
  00255	c7 44 24 2c 03
	00 00 00	 mov	 DWORD PTR tv152[rsp], 3
$LN16@stbi__pic_:
  0025d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  00265	8b 4c 24 2c	 mov	 ecx, DWORD PTR tv152[rsp]
  00269	89 08		 mov	 DWORD PTR [rax], ecx

; 7473 :     
; 7474 :     return 1;

  0026b	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__pic_:

; 7475 : }

  00270	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00275	48 33 cc	 xor	 rcx, rsp
  00278	e8 00 00 00 00	 call	 __security_check_cookie
  0027d	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00281	c3		 ret	 0
?stbi__pic_info@@YAHPEAUstbi__context@@PEAH11@Z ENDP	; stbi__pic_info
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
y$ = 48
x$ = 52
result$ = 56
i$ = 64
tv76 = 68
tv82 = 72
tv90 = 76
tv133 = 80
tv147 = 84
internal_comp$ = 88
s$ = 112
px$ = 120
py$ = 128
comp$ = 136
req_comp$ = 144
ri$ = 152
?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z PROC ; stbi__pic_load

; 6498 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 6499 :     stbi_uc *result;
; 6500 :     int i, x,y, internal_comp;
; 6501 :     STBI_NOTUSED(ri);
; 6502 :     
; 6503 :     if (!comp) comp = &internal_comp;

  00018	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR comp$[rsp], 0
  00021	75 0d		 jne	 SHORT $LN5@stbi__pic_
  00023	48 8d 44 24 58	 lea	 rax, QWORD PTR internal_comp$[rsp]
  00028	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR comp$[rsp], rax
$LN5@stbi__pic_:

; 6504 :     
; 6505 :     for (i=0; i<92; ++i)

  00030	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00038	eb 0a		 jmp	 SHORT $LN4@stbi__pic_
$LN2@stbi__pic_:
  0003a	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0003e	ff c0		 inc	 eax
  00040	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__pic_:
  00044	83 7c 24 40 5c	 cmp	 DWORD PTR i$[rsp], 92	; 0000005cH
  00049	7d 0c		 jge	 SHORT $LN3@stbi__pic_

; 6506 :         stbi__get8(s);

  0004b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00050	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00055	eb e3		 jmp	 SHORT $LN2@stbi__pic_
$LN3@stbi__pic_:

; 6507 :     
; 6508 :     x = stbi__get16be(s);

  00057	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0005c	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  00061	89 44 24 34	 mov	 DWORD PTR x$[rsp], eax

; 6509 :     y = stbi__get16be(s);

  00065	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0006a	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  0006f	89 44 24 30	 mov	 DWORD PTR y$[rsp], eax

; 6510 :     
; 6511 :     if (y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

  00073	81 7c 24 30 00
	00 00 01	 cmp	 DWORD PTR y$[rsp], 16777216 ; 01000000H
  0007b	7e 2c		 jle	 SHORT $LN6@stbi__pic_
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81637
  00084	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00089	85 c0		 test	 eax, eax
  0008b	74 0a		 je	 SHORT $LN14@stbi__pic_
  0008d	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
  00095	eb 08		 jmp	 SHORT $LN15@stbi__pic_
$LN14@stbi__pic_:
  00097	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN15@stbi__pic_:
  0009f	48 63 44 24 44	 movsxd	 rax, DWORD PTR tv76[rsp]
  000a4	e9 e2 01 00 00	 jmp	 $LN1@stbi__pic_
$LN6@stbi__pic_:

; 6512 :     if (x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

  000a9	81 7c 24 34 00
	00 00 01	 cmp	 DWORD PTR x$[rsp], 16777216 ; 01000000H
  000b1	7e 2c		 jle	 SHORT $LN7@stbi__pic_
  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81639
  000ba	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000bf	85 c0		 test	 eax, eax
  000c1	74 0a		 je	 SHORT $LN16@stbi__pic_
  000c3	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
  000cb	eb 08		 jmp	 SHORT $LN17@stbi__pic_
$LN16@stbi__pic_:
  000cd	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN17@stbi__pic_:
  000d5	48 63 44 24 48	 movsxd	 rax, DWORD PTR tv82[rsp]
  000da	e9 ac 01 00 00	 jmp	 $LN1@stbi__pic_
$LN7@stbi__pic_:

; 6513 :     
; 6514 :     if (stbi__at_eof(s))  return stbi__errpuc("bad file","file too short (pic header)");

  000df	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  000e4	e8 00 00 00 00	 call	 ?stbi__at_eof@@YAHPEAUstbi__context@@@Z ; stbi__at_eof
  000e9	85 c0		 test	 eax, eax
  000eb	74 2c		 je	 SHORT $LN8@stbi__pic_
  000ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81641
  000f4	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000f9	85 c0		 test	 eax, eax
  000fb	74 0a		 je	 SHORT $LN18@stbi__pic_
  000fd	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
  00105	eb 08		 jmp	 SHORT $LN19@stbi__pic_
$LN18@stbi__pic_:
  00107	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
$LN19@stbi__pic_:
  0010f	48 63 44 24 4c	 movsxd	 rax, DWORD PTR tv90[rsp]
  00114	e9 72 01 00 00	 jmp	 $LN1@stbi__pic_
$LN8@stbi__pic_:

; 6515 :     if (!stbi__mad3sizes_valid(x, y, 4, 0)) return stbi__errpuc("too large", "PIC image too large to decode");

  00119	45 33 c9	 xor	 r9d, r9d
  0011c	41 b8 04 00 00
	00		 mov	 r8d, 4
  00122	8b 54 24 30	 mov	 edx, DWORD PTR y$[rsp]
  00126	8b 4c 24 34	 mov	 ecx, DWORD PTR x$[rsp]
  0012a	e8 00 00 00 00	 call	 ?stbi__mad3sizes_valid@@YAHHHHH@Z ; stbi__mad3sizes_valid
  0012f	85 c0		 test	 eax, eax
  00131	75 2c		 jne	 SHORT $LN9@stbi__pic_
  00133	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81643
  0013a	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0013f	85 c0		 test	 eax, eax
  00141	74 0a		 je	 SHORT $LN20@stbi__pic_
  00143	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv133[rsp], 0
  0014b	eb 08		 jmp	 SHORT $LN21@stbi__pic_
$LN20@stbi__pic_:
  0014d	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv133[rsp], 0
$LN21@stbi__pic_:
  00155	48 63 44 24 50	 movsxd	 rax, DWORD PTR tv133[rsp]
  0015a	e9 2c 01 00 00	 jmp	 $LN1@stbi__pic_
$LN9@stbi__pic_:

; 6516 :     
; 6517 :     stbi__get32be(s); //skip `ratio'

  0015f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00164	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be

; 6518 :     stbi__get16be(s); //skip `fields'

  00169	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0016e	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 6519 :     stbi__get16be(s); //skip `pad'

  00173	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00178	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be

; 6520 :     
; 6521 :     // intermediate buffer is RGBA
; 6522 :     result = (stbi_uc *) stbi__malloc_mad3(x, y, 4, 0);

  0017d	45 33 c9	 xor	 r9d, r9d
  00180	41 b8 04 00 00
	00		 mov	 r8d, 4
  00186	8b 54 24 30	 mov	 edx, DWORD PTR y$[rsp]
  0018a	8b 4c 24 34	 mov	 ecx, DWORD PTR x$[rsp]
  0018e	e8 00 00 00 00	 call	 ?stbi__malloc_mad3@@YAPEAXHHHH@Z ; stbi__malloc_mad3
  00193	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax

; 6523 :     if (!result) return stbi__errpuc("outofmem", "Out of memory");

  00198	48 83 7c 24 38
	00		 cmp	 QWORD PTR result$[rsp], 0
  0019e	75 2c		 jne	 SHORT $LN10@stbi__pic_
  001a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81645
  001a7	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  001ac	85 c0		 test	 eax, eax
  001ae	74 0a		 je	 SHORT $LN22@stbi__pic_
  001b0	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv147[rsp], 0
  001b8	eb 08		 jmp	 SHORT $LN23@stbi__pic_
$LN22@stbi__pic_:
  001ba	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv147[rsp], 0
$LN23@stbi__pic_:
  001c2	48 63 44 24 54	 movsxd	 rax, DWORD PTR tv147[rsp]
  001c7	e9 bf 00 00 00	 jmp	 $LN1@stbi__pic_
$LN10@stbi__pic_:

; 6524 :     memset(result, 0xff, x*y*4);

  001cc	8b 44 24 34	 mov	 eax, DWORD PTR x$[rsp]
  001d0	0f af 44 24 30	 imul	 eax, DWORD PTR y$[rsp]
  001d5	c1 e0 02	 shl	 eax, 2
  001d8	48 98		 cdqe
  001da	4c 8b c0	 mov	 r8, rax
  001dd	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  001e2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR result$[rsp]
  001e7	e8 00 00 00 00	 call	 memset

; 6525 :     
; 6526 :     if (!stbi__pic_load_core(s,x,y,comp, result)) {

  001ec	48 8b 44 24 38	 mov	 rax, QWORD PTR result$[rsp]
  001f1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001f6	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  001fe	44 8b 44 24 30	 mov	 r8d, DWORD PTR y$[rsp]
  00203	8b 54 24 34	 mov	 edx, DWORD PTR x$[rsp]
  00207	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0020c	e8 00 00 00 00	 call	 ?stbi__pic_load_core@@YAPEAEPEAUstbi__context@@HHPEAHPEAE@Z ; stbi__pic_load_core
  00211	48 85 c0	 test	 rax, rax
  00214	75 13		 jne	 SHORT $LN11@stbi__pic_

; 6527 :         STBI_FREE(result);

  00216	48 8b 4c 24 38	 mov	 rcx, QWORD PTR result$[rsp]
  0021b	e8 00 00 00 00	 call	 free

; 6528 :         result=0;

  00220	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR result$[rsp], 0
$LN11@stbi__pic_:

; 6529 :     }
; 6530 :     *px = x;

  00229	48 8b 44 24 78	 mov	 rax, QWORD PTR px$[rsp]
  0022e	8b 4c 24 34	 mov	 ecx, DWORD PTR x$[rsp]
  00232	89 08		 mov	 DWORD PTR [rax], ecx

; 6531 :     *py = y;

  00234	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR py$[rsp]
  0023c	8b 4c 24 30	 mov	 ecx, DWORD PTR y$[rsp]
  00240	89 08		 mov	 DWORD PTR [rax], ecx

; 6532 :     if (req_comp == 0) req_comp = *comp;

  00242	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  0024a	75 11		 jne	 SHORT $LN12@stbi__pic_
  0024c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  00254	8b 00		 mov	 eax, DWORD PTR [rax]
  00256	89 84 24 90 00
	00 00		 mov	 DWORD PTR req_comp$[rsp], eax
$LN12@stbi__pic_:

; 6533 :     result=stbi__convert_format(result,4,req_comp,x,y);

  0025d	8b 44 24 30	 mov	 eax, DWORD PTR y$[rsp]
  00261	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00265	44 8b 4c 24 34	 mov	 r9d, DWORD PTR x$[rsp]
  0026a	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  00272	ba 04 00 00 00	 mov	 edx, 4
  00277	48 8b 4c 24 38	 mov	 rcx, QWORD PTR result$[rsp]
  0027c	e8 00 00 00 00	 call	 ?stbi__convert_format@@YAPEAEPEAEHHII@Z ; stbi__convert_format
  00281	48 89 44 24 38	 mov	 QWORD PTR result$[rsp], rax

; 6534 :     
; 6535 :     return result;

  00286	48 8b 44 24 38	 mov	 rax, QWORD PTR result$[rsp]
$LN1@stbi__pic_:

; 6536 : }

  0028b	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0028f	c3		 ret	 0
?stbi__pic_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ENDP ; stbi__pic_load
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
r$ = 32
s$ = 64
?stbi__pic_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__pic_test

; 6539 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6540 :     int r = stbi__pic_test_core(s);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__pic_test_core@@YAHPEAUstbi__context@@@Z ; stbi__pic_test_core
  00013	89 44 24 20	 mov	 DWORD PTR r$[rsp], eax

; 6541 :     stbi__rewind(s);

  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001c	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 6542 :     return r;

  00021	8b 44 24 20	 mov	 eax, DWORD PTR r$[rsp]

; 6543 : }

  00025	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00029	c3		 ret	 0
?stbi__pic_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__pic_test
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
token$ = 32
dummy$ = 40
valid$ = 44
buffer$ = 48
__$ArrayPad$ = 1072
s$ = 1104
x$ = 1112
y$ = 1120
comp$ = 1128
?stbi__hdr_info@@YAHPEAUstbi__context@@PEAH11@Z PROC	; stbi__hdr_info

; 7287 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 48 04
	00 00		 sub	 rsp, 1096		; 00000448H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 30
	04 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 7288 :     char buffer[STBI__HDR_BUFLEN];
; 7289 :     char *token;
; 7290 :     int valid = 0;

  0002d	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR valid$[rsp], 0

; 7291 :     int dummy;
; 7292 :     
; 7293 :     if (!x) x = &dummy;

  00035	48 83 bc 24 58
	04 00 00 00	 cmp	 QWORD PTR x$[rsp], 0
  0003e	75 0d		 jne	 SHORT $LN7@stbi__hdr_
  00040	48 8d 44 24 28	 lea	 rax, QWORD PTR dummy$[rsp]
  00045	48 89 84 24 58
	04 00 00	 mov	 QWORD PTR x$[rsp], rax
$LN7@stbi__hdr_:

; 7294 :     if (!y) y = &dummy;

  0004d	48 83 bc 24 60
	04 00 00 00	 cmp	 QWORD PTR y$[rsp], 0
  00056	75 0d		 jne	 SHORT $LN8@stbi__hdr_
  00058	48 8d 44 24 28	 lea	 rax, QWORD PTR dummy$[rsp]
  0005d	48 89 84 24 60
	04 00 00	 mov	 QWORD PTR y$[rsp], rax
$LN8@stbi__hdr_:

; 7295 :     if (!comp) comp = &dummy;

  00065	48 83 bc 24 68
	04 00 00 00	 cmp	 QWORD PTR comp$[rsp], 0
  0006e	75 0d		 jne	 SHORT $LN9@stbi__hdr_
  00070	48 8d 44 24 28	 lea	 rax, QWORD PTR dummy$[rsp]
  00075	48 89 84 24 68
	04 00 00	 mov	 QWORD PTR comp$[rsp], rax
$LN9@stbi__hdr_:

; 7296 :     
; 7297 :     if (stbi__hdr_test(s) == 0) {

  0007d	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00085	e8 00 00 00 00	 call	 ?stbi__hdr_test@@YAHPEAUstbi__context@@@Z ; stbi__hdr_test
  0008a	85 c0		 test	 eax, eax
  0008c	75 14		 jne	 SHORT $LN10@stbi__hdr_

; 7298 :         stbi__rewind( s );

  0008e	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00096	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7299 :         return 0;

  0009b	33 c0		 xor	 eax, eax
  0009d	e9 61 01 00 00	 jmp	 $LN1@stbi__hdr_
$LN10@stbi__hdr_:
$LN2@stbi__hdr_:

; 7300 :     }
; 7301 :     
; 7302 :     for(;;) {
; 7303 :         token = stbi__hdr_gettoken(s,buffer);

  000a2	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  000a7	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000af	e8 00 00 00 00	 call	 ?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z ; stbi__hdr_gettoken
  000b4	48 89 44 24 20	 mov	 QWORD PTR token$[rsp], rax

; 7304 :         if (token[0] == 0) break;

  000b9	b8 01 00 00 00	 mov	 eax, 1
  000be	48 6b c0 00	 imul	 rax, rax, 0
  000c2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  000c7	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  000cb	85 c0		 test	 eax, eax
  000cd	75 02		 jne	 SHORT $LN11@stbi__hdr_
  000cf	eb 1f		 jmp	 SHORT $LN3@stbi__hdr_
$LN11@stbi__hdr_:

; 7305 :         if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;

  000d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG82225
  000d8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  000dd	e8 00 00 00 00	 call	 strcmp
  000e2	85 c0		 test	 eax, eax
  000e4	75 08		 jne	 SHORT $LN12@stbi__hdr_
  000e6	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR valid$[rsp], 1
$LN12@stbi__hdr_:

; 7306 :     }

  000ee	eb b2		 jmp	 SHORT $LN2@stbi__hdr_
$LN3@stbi__hdr_:

; 7307 :     
; 7308 :     if (!valid) {

  000f0	83 7c 24 2c 00	 cmp	 DWORD PTR valid$[rsp], 0
  000f5	75 14		 jne	 SHORT $LN13@stbi__hdr_

; 7309 :         stbi__rewind( s );

  000f7	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000ff	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7310 :         return 0;

  00104	33 c0		 xor	 eax, eax
  00106	e9 f8 00 00 00	 jmp	 $LN1@stbi__hdr_
$LN13@stbi__hdr_:

; 7311 :     }
; 7312 :     token = stbi__hdr_gettoken(s,buffer);

  0010b	48 8d 54 24 30	 lea	 rdx, QWORD PTR buffer$[rsp]
  00110	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00118	e8 00 00 00 00	 call	 ?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z ; stbi__hdr_gettoken
  0011d	48 89 44 24 20	 mov	 QWORD PTR token$[rsp], rax

; 7313 :     if (strncmp(token, "-Y ", 3)) {

  00122	41 b8 03 00 00
	00		 mov	 r8d, 3
  00128	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG82228
  0012f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  00134	e8 00 00 00 00	 call	 strncmp
  00139	85 c0		 test	 eax, eax
  0013b	74 14		 je	 SHORT $LN14@stbi__hdr_

; 7314 :         stbi__rewind( s );

  0013d	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00145	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7315 :         return 0;

  0014a	33 c0		 xor	 eax, eax
  0014c	e9 b2 00 00 00	 jmp	 $LN1@stbi__hdr_
$LN14@stbi__hdr_:

; 7316 :     }
; 7317 :     token += 3;

  00151	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  00156	48 83 c0 03	 add	 rax, 3
  0015a	48 89 44 24 20	 mov	 QWORD PTR token$[rsp], rax

; 7318 :     *y = (int) strtol(token, &token, 10);

  0015f	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00165	48 8d 54 24 20	 lea	 rdx, QWORD PTR token$[rsp]
  0016a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  0016f	e8 00 00 00 00	 call	 strtol
  00174	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR y$[rsp]
  0017c	89 01		 mov	 DWORD PTR [rcx], eax
$LN5@stbi__hdr_:

; 7319 :     while (*token == ' ') ++token;

  0017e	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  00183	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00186	83 f8 20	 cmp	 eax, 32			; 00000020H
  00189	75 0f		 jne	 SHORT $LN6@stbi__hdr_
  0018b	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  00190	48 ff c0	 inc	 rax
  00193	48 89 44 24 20	 mov	 QWORD PTR token$[rsp], rax
  00198	eb e4		 jmp	 SHORT $LN5@stbi__hdr_
$LN6@stbi__hdr_:

; 7320 :     if (strncmp(token, "+X ", 3)) {

  0019a	41 b8 03 00 00
	00		 mov	 r8d, 3
  001a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG82230
  001a7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  001ac	e8 00 00 00 00	 call	 strncmp
  001b1	85 c0		 test	 eax, eax
  001b3	74 11		 je	 SHORT $LN15@stbi__hdr_

; 7321 :         stbi__rewind( s );

  001b5	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001bd	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7322 :         return 0;

  001c2	33 c0		 xor	 eax, eax
  001c4	eb 3d		 jmp	 SHORT $LN1@stbi__hdr_
$LN15@stbi__hdr_:

; 7323 :     }
; 7324 :     token += 3;

  001c6	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  001cb	48 83 c0 03	 add	 rax, 3
  001cf	48 89 44 24 20	 mov	 QWORD PTR token$[rsp], rax

; 7325 :     *x = (int) strtol(token, NULL, 10);

  001d4	41 b8 0a 00 00
	00		 mov	 r8d, 10
  001da	33 d2		 xor	 edx, edx
  001dc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  001e1	e8 00 00 00 00	 call	 strtol
  001e6	48 8b 8c 24 58
	04 00 00	 mov	 rcx, QWORD PTR x$[rsp]
  001ee	89 01		 mov	 DWORD PTR [rcx], eax

; 7326 :     *comp = 3;

  001f0	48 8b 84 24 68
	04 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  001f8	c7 00 03 00 00
	00		 mov	 DWORD PTR [rax], 3

; 7327 :     return 1;

  001fe	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__hdr_:

; 7328 : }

  00203	48 8b 8c 24 30
	04 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0020b	48 33 cc	 xor	 rcx, rsp
  0020e	e8 00 00 00 00	 call	 __security_check_cookie
  00213	48 81 c4 48 04
	00 00		 add	 rsp, 1096		; 00000448H
  0021a	c3		 ret	 0
?stbi__hdr_info@@YAHPEAUstbi__context@@PEAH11@Z ENDP	; stbi__hdr_info
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
count$ = 48
i$ = 52
width$ = 56
j$ = 60
value$ = 64
len$ = 68
z$ = 72
token$ = 80
height$ = 88
scanline$ = 96
k$ = 104
rgbe$1 = 108
hdr_data$ = 112
nleft$2 = 120
tv78 = 124
valid$ = 128
tv95 = 132
tv140 = 136
tv158 = 140
tv169 = 144
tv175 = 148
tv189 = 152
tv201 = 156
c1$ = 160
c2$ = 164
tv264 = 168
tv276 = 172
tv300 = 176
tv320 = 180
rgbe$3 = 184
headerToken$ = 192
buffer$ = 208
__$ArrayPad$ = 1232
s$ = 1264
x$ = 1272
y$ = 1280
comp$ = 1288
req_comp$ = 1296
ri$ = 1304
?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z PROC ; stbi__hdr_load

; 7156 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec e8 04
	00 00		 sub	 rsp, 1256		; 000004e8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 d0
	04 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 7157 :     char buffer[STBI__HDR_BUFLEN];
; 7158 :     char *token;
; 7159 :     int valid = 0;

  0002d	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR valid$[rsp], 0

; 7160 :     int width, height;
; 7161 :     stbi_uc *scanline;
; 7162 :     float *hdr_data;
; 7163 :     int len;
; 7164 :     unsigned char count, value;
; 7165 :     int i, j, k, c1,c2, z;
; 7166 :     const char *headerToken;
; 7167 :     STBI_NOTUSED(ri);
; 7168 :     
; 7169 :     // Check identifier
; 7170 :     headerToken = stbi__hdr_gettoken(s,buffer);

  00038	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR buffer$[rsp]
  00040	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00048	e8 00 00 00 00	 call	 ?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z ; stbi__hdr_gettoken
  0004d	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR headerToken$[rsp], rax

; 7171 :     if (strcmp(headerToken, "#?RADIANCE") != 0 && strcmp(headerToken, "#?RGBE") != 0)

  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG82159
  0005c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR headerToken$[rsp]
  00064	e8 00 00 00 00	 call	 strcmp
  00069	85 c0		 test	 eax, eax
  0006b	74 44		 je	 SHORT $LN30@stbi__hdr_
  0006d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG82160
  00074	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR headerToken$[rsp]
  0007c	e8 00 00 00 00	 call	 strcmp
  00081	85 c0		 test	 eax, eax
  00083	74 2c		 je	 SHORT $LN30@stbi__hdr_

; 7172 :         return stbi__errpf("not HDR", "Corrupt HDR image");

  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG82161
  0008c	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00091	85 c0		 test	 eax, eax
  00093	74 0a		 je	 SHORT $LN58@stbi__hdr_
  00095	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
  0009d	eb 08		 jmp	 SHORT $LN59@stbi__hdr_
$LN58@stbi__hdr_:
  0009f	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
$LN59@stbi__hdr_:
  000a7	48 63 44 24 7c	 movsxd	 rax, DWORD PTR tv78[rsp]
  000ac	e9 5c 08 00 00	 jmp	 $LN1@stbi__hdr_
$LN30@stbi__hdr_:
$LN2@stbi__hdr_:

; 7173 :     
; 7174 :     // Parse header
; 7175 :     for(;;) {
; 7176 :         token = stbi__hdr_gettoken(s,buffer);

  000b1	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR buffer$[rsp]
  000b9	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000c1	e8 00 00 00 00	 call	 ?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z ; stbi__hdr_gettoken
  000c6	48 89 44 24 50	 mov	 QWORD PTR token$[rsp], rax

; 7177 :         if (token[0] == 0) break;

  000cb	b8 01 00 00 00	 mov	 eax, 1
  000d0	48 6b c0 00	 imul	 rax, rax, 0
  000d4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR token$[rsp]
  000d9	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  000dd	85 c0		 test	 eax, eax
  000df	75 02		 jne	 SHORT $LN31@stbi__hdr_
  000e1	eb 22		 jmp	 SHORT $LN3@stbi__hdr_
$LN31@stbi__hdr_:

; 7178 :         if (strcmp(token, "FORMAT=32-bit_rle_rgbe") == 0) valid = 1;

  000e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG82164
  000ea	48 8b 4c 24 50	 mov	 rcx, QWORD PTR token$[rsp]
  000ef	e8 00 00 00 00	 call	 strcmp
  000f4	85 c0		 test	 eax, eax
  000f6	75 0b		 jne	 SHORT $LN32@stbi__hdr_
  000f8	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR valid$[rsp], 1
$LN32@stbi__hdr_:

; 7179 :     }

  00103	eb ac		 jmp	 SHORT $LN2@stbi__hdr_
$LN3@stbi__hdr_:

; 7180 :     
; 7181 :     if (!valid)    return stbi__errpf("unsupported format", "Unsupported HDR format");

  00105	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR valid$[rsp], 0
  0010d	75 35		 jne	 SHORT $LN33@stbi__hdr_
  0010f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG82166
  00116	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0011b	85 c0		 test	 eax, eax
  0011d	74 0d		 je	 SHORT $LN60@stbi__hdr_
  0011f	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv95[rsp], 0
  0012a	eb 0b		 jmp	 SHORT $LN61@stbi__hdr_
$LN60@stbi__hdr_:
  0012c	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv95[rsp], 0
$LN61@stbi__hdr_:
  00137	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR tv95[rsp]
  0013f	e9 c9 07 00 00	 jmp	 $LN1@stbi__hdr_
$LN33@stbi__hdr_:

; 7182 :     
; 7183 :     // Parse width and height
; 7184 :     // can't use sscanf() if we're not using stdio!
; 7185 :     token = stbi__hdr_gettoken(s,buffer);

  00144	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR buffer$[rsp]
  0014c	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00154	e8 00 00 00 00	 call	 ?stbi__hdr_gettoken@@YAPEADPEAUstbi__context@@PEAD@Z ; stbi__hdr_gettoken
  00159	48 89 44 24 50	 mov	 QWORD PTR token$[rsp], rax

; 7186 :     if (strncmp(token, "-Y ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");

  0015e	41 b8 03 00 00
	00		 mov	 r8d, 3
  00164	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG82168
  0016b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR token$[rsp]
  00170	e8 00 00 00 00	 call	 strncmp
  00175	85 c0		 test	 eax, eax
  00177	74 35		 je	 SHORT $LN34@stbi__hdr_
  00179	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG82169
  00180	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00185	85 c0		 test	 eax, eax
  00187	74 0d		 je	 SHORT $LN62@stbi__hdr_
  00189	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv140[rsp], 0
  00194	eb 0b		 jmp	 SHORT $LN63@stbi__hdr_
$LN62@stbi__hdr_:
  00196	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv140[rsp], 0
$LN63@stbi__hdr_:
  001a1	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR tv140[rsp]
  001a9	e9 5f 07 00 00	 jmp	 $LN1@stbi__hdr_
$LN34@stbi__hdr_:

; 7187 :     token += 3;

  001ae	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  001b3	48 83 c0 03	 add	 rax, 3
  001b7	48 89 44 24 50	 mov	 QWORD PTR token$[rsp], rax

; 7188 :     height = (int) strtol(token, &token, 10);

  001bc	41 b8 0a 00 00
	00		 mov	 r8d, 10
  001c2	48 8d 54 24 50	 lea	 rdx, QWORD PTR token$[rsp]
  001c7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR token$[rsp]
  001cc	e8 00 00 00 00	 call	 strtol
  001d1	89 44 24 58	 mov	 DWORD PTR height$[rsp], eax
$LN5@stbi__hdr_:

; 7189 :     while (*token == ' ') ++token;

  001d5	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  001da	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001dd	83 f8 20	 cmp	 eax, 32			; 00000020H
  001e0	75 0f		 jne	 SHORT $LN6@stbi__hdr_
  001e2	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  001e7	48 ff c0	 inc	 rax
  001ea	48 89 44 24 50	 mov	 QWORD PTR token$[rsp], rax
  001ef	eb e4		 jmp	 SHORT $LN5@stbi__hdr_
$LN6@stbi__hdr_:

; 7190 :     if (strncmp(token, "+X ", 3))  return stbi__errpf("unsupported data layout", "Unsupported HDR format");

  001f1	41 b8 03 00 00
	00		 mov	 r8d, 3
  001f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG82171
  001fe	48 8b 4c 24 50	 mov	 rcx, QWORD PTR token$[rsp]
  00203	e8 00 00 00 00	 call	 strncmp
  00208	85 c0		 test	 eax, eax
  0020a	74 35		 je	 SHORT $LN35@stbi__hdr_
  0020c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG82172
  00213	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00218	85 c0		 test	 eax, eax
  0021a	74 0d		 je	 SHORT $LN64@stbi__hdr_
  0021c	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv158[rsp], 0
  00227	eb 0b		 jmp	 SHORT $LN65@stbi__hdr_
$LN64@stbi__hdr_:
  00229	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv158[rsp], 0
$LN65@stbi__hdr_:
  00234	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR tv158[rsp]
  0023c	e9 cc 06 00 00	 jmp	 $LN1@stbi__hdr_
$LN35@stbi__hdr_:

; 7191 :     token += 3;

  00241	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  00246	48 83 c0 03	 add	 rax, 3
  0024a	48 89 44 24 50	 mov	 QWORD PTR token$[rsp], rax

; 7192 :     width = (int) strtol(token, NULL, 10);

  0024f	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00255	33 d2		 xor	 edx, edx
  00257	48 8b 4c 24 50	 mov	 rcx, QWORD PTR token$[rsp]
  0025c	e8 00 00 00 00	 call	 strtol
  00261	89 44 24 38	 mov	 DWORD PTR width$[rsp], eax

; 7193 :     
; 7194 :     if (height > STBI_MAX_DIMENSIONS) return stbi__errpf("too large","Very large image (corrupt?)");

  00265	81 7c 24 58 00
	00 00 01	 cmp	 DWORD PTR height$[rsp], 16777216 ; 01000000H
  0026d	7e 35		 jle	 SHORT $LN36@stbi__hdr_
  0026f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG82174
  00276	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0027b	85 c0		 test	 eax, eax
  0027d	74 0d		 je	 SHORT $LN66@stbi__hdr_
  0027f	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv169[rsp], 0
  0028a	eb 0b		 jmp	 SHORT $LN67@stbi__hdr_
$LN66@stbi__hdr_:
  0028c	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv169[rsp], 0
$LN67@stbi__hdr_:
  00297	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR tv169[rsp]
  0029f	e9 69 06 00 00	 jmp	 $LN1@stbi__hdr_
$LN36@stbi__hdr_:

; 7195 :     if (width > STBI_MAX_DIMENSIONS) return stbi__errpf("too large","Very large image (corrupt?)");

  002a4	81 7c 24 38 00
	00 00 01	 cmp	 DWORD PTR width$[rsp], 16777216 ; 01000000H
  002ac	7e 35		 jle	 SHORT $LN37@stbi__hdr_
  002ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG82176
  002b5	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  002ba	85 c0		 test	 eax, eax
  002bc	74 0d		 je	 SHORT $LN68@stbi__hdr_
  002be	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv175[rsp], 0
  002c9	eb 0b		 jmp	 SHORT $LN69@stbi__hdr_
$LN68@stbi__hdr_:
  002cb	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv175[rsp], 0
$LN69@stbi__hdr_:
  002d6	48 63 84 24 94
	00 00 00	 movsxd	 rax, DWORD PTR tv175[rsp]
  002de	e9 2a 06 00 00	 jmp	 $LN1@stbi__hdr_
$LN37@stbi__hdr_:

; 7196 :     
; 7197 :     *x = width;

  002e3	48 8b 84 24 f8
	04 00 00	 mov	 rax, QWORD PTR x$[rsp]
  002eb	8b 4c 24 38	 mov	 ecx, DWORD PTR width$[rsp]
  002ef	89 08		 mov	 DWORD PTR [rax], ecx

; 7198 :     *y = height;

  002f1	48 8b 84 24 00
	05 00 00	 mov	 rax, QWORD PTR y$[rsp]
  002f9	8b 4c 24 58	 mov	 ecx, DWORD PTR height$[rsp]
  002fd	89 08		 mov	 DWORD PTR [rax], ecx

; 7199 :     
; 7200 :     if (comp) *comp = 3;

  002ff	48 83 bc 24 08
	05 00 00 00	 cmp	 QWORD PTR comp$[rsp], 0
  00308	74 0e		 je	 SHORT $LN38@stbi__hdr_
  0030a	48 8b 84 24 08
	05 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  00312	c7 00 03 00 00
	00		 mov	 DWORD PTR [rax], 3
$LN38@stbi__hdr_:

; 7201 :     if (req_comp == 0) req_comp = 3;

  00318	83 bc 24 10 05
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  00320	75 0b		 jne	 SHORT $LN39@stbi__hdr_
  00322	c7 84 24 10 05
	00 00 03 00 00
	00		 mov	 DWORD PTR req_comp$[rsp], 3
$LN39@stbi__hdr_:

; 7202 :     
; 7203 :     if (!stbi__mad4sizes_valid(width, height, req_comp, sizeof(float), 0))

  0032d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00335	41 b9 04 00 00
	00		 mov	 r9d, 4
  0033b	44 8b 84 24 10
	05 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  00343	8b 54 24 58	 mov	 edx, DWORD PTR height$[rsp]
  00347	8b 4c 24 38	 mov	 ecx, DWORD PTR width$[rsp]
  0034b	e8 00 00 00 00	 call	 ?stbi__mad4sizes_valid@@YAHHHHHH@Z ; stbi__mad4sizes_valid
  00350	85 c0		 test	 eax, eax
  00352	75 35		 jne	 SHORT $LN40@stbi__hdr_

; 7204 :         return stbi__errpf("too large", "HDR image is too large");

  00354	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG82180
  0035b	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00360	85 c0		 test	 eax, eax
  00362	74 0d		 je	 SHORT $LN70@stbi__hdr_
  00364	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv189[rsp], 0
  0036f	eb 0b		 jmp	 SHORT $LN71@stbi__hdr_
$LN70@stbi__hdr_:
  00371	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv189[rsp], 0
$LN71@stbi__hdr_:
  0037c	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR tv189[rsp]
  00384	e9 84 05 00 00	 jmp	 $LN1@stbi__hdr_
$LN40@stbi__hdr_:

; 7205 :     
; 7206 :     // Read data
; 7207 :     hdr_data = (float *) stbi__malloc_mad4(width, height, req_comp, sizeof(float), 0);

  00389	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00391	41 b9 04 00 00
	00		 mov	 r9d, 4
  00397	44 8b 84 24 10
	05 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  0039f	8b 54 24 58	 mov	 edx, DWORD PTR height$[rsp]
  003a3	8b 4c 24 38	 mov	 ecx, DWORD PTR width$[rsp]
  003a7	e8 00 00 00 00	 call	 ?stbi__malloc_mad4@@YAPEAXHHHHH@Z ; stbi__malloc_mad4
  003ac	48 89 44 24 70	 mov	 QWORD PTR hdr_data$[rsp], rax

; 7208 :     if (!hdr_data)

  003b1	48 83 7c 24 70
	00		 cmp	 QWORD PTR hdr_data$[rsp], 0
  003b7	75 35		 jne	 SHORT $LN41@stbi__hdr_

; 7209 :         return stbi__errpf("outofmem", "Out of memory");

  003b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG82182
  003c0	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  003c5	85 c0		 test	 eax, eax
  003c7	74 0d		 je	 SHORT $LN72@stbi__hdr_
  003c9	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv201[rsp], 0
  003d4	eb 0b		 jmp	 SHORT $LN73@stbi__hdr_
$LN72@stbi__hdr_:
  003d6	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv201[rsp], 0
$LN73@stbi__hdr_:
  003e1	48 63 84 24 9c
	00 00 00	 movsxd	 rax, DWORD PTR tv201[rsp]
  003e9	e9 1f 05 00 00	 jmp	 $LN1@stbi__hdr_
$LN41@stbi__hdr_:

; 7210 :     
; 7211 :     // Load image data
; 7212 :     // image data is stored as some number of sca
; 7213 :     if ( width < 8 || width >= 32768) {

  003ee	83 7c 24 38 08	 cmp	 DWORD PTR width$[rsp], 8
  003f3	7c 0e		 jl	 SHORT $LN44@stbi__hdr_
  003f5	81 7c 24 38 00
	80 00 00	 cmp	 DWORD PTR width$[rsp], 32768 ; 00008000H
  003fd	0f 8c ae 00 00
	00		 jl	 $LN42@stbi__hdr_
$LN44@stbi__hdr_:

; 7214 :         // Read flat data
; 7215 :         for (j=0; j < height; ++j) {

  00403	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  0040b	eb 0a		 jmp	 SHORT $LN9@stbi__hdr_
$LN7@stbi__hdr_:
  0040d	8b 44 24 3c	 mov	 eax, DWORD PTR j$[rsp]
  00411	ff c0		 inc	 eax
  00413	89 44 24 3c	 mov	 DWORD PTR j$[rsp], eax
$LN9@stbi__hdr_:
  00417	8b 44 24 58	 mov	 eax, DWORD PTR height$[rsp]
  0041b	39 44 24 3c	 cmp	 DWORD PTR j$[rsp], eax
  0041f	0f 8d 87 00 00
	00		 jge	 $LN8@stbi__hdr_

; 7216 :             for (i=0; i < width; ++i) {

  00425	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0042d	eb 0a		 jmp	 SHORT $LN12@stbi__hdr_
$LN10@stbi__hdr_:
  0042f	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  00433	ff c0		 inc	 eax
  00435	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN12@stbi__hdr_:
  00439	8b 44 24 38	 mov	 eax, DWORD PTR width$[rsp]
  0043d	39 44 24 34	 cmp	 DWORD PTR i$[rsp], eax
  00441	7d 64		 jge	 SHORT $LN11@stbi__hdr_
$main_decode_loop$82:

; 7217 :                 stbi_uc rgbe[4];
; 7218 :                 main_decode_loop:
; 7219 :                 stbi__getn(s, rgbe, 4);

  00443	41 b8 04 00 00
	00		 mov	 r8d, 4
  00449	48 8d 94 24 b8
	00 00 00	 lea	 rdx, QWORD PTR rgbe$3[rsp]
  00451	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00459	e8 00 00 00 00	 call	 ?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z ; stbi__getn

; 7220 :                 stbi__hdr_convert(hdr_data + j * width * req_comp + i * req_comp, rgbe, req_comp);

  0045e	8b 44 24 3c	 mov	 eax, DWORD PTR j$[rsp]
  00462	0f af 44 24 38	 imul	 eax, DWORD PTR width$[rsp]
  00467	0f af 84 24 10
	05 00 00	 imul	 eax, DWORD PTR req_comp$[rsp]
  0046f	48 98		 cdqe
  00471	48 8b 4c 24 70	 mov	 rcx, QWORD PTR hdr_data$[rsp]
  00476	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  0047a	8b 4c 24 34	 mov	 ecx, DWORD PTR i$[rsp]
  0047e	0f af 8c 24 10
	05 00 00	 imul	 ecx, DWORD PTR req_comp$[rsp]
  00486	48 63 c9	 movsxd	 rcx, ecx
  00489	48 8d 04 88	 lea	 rax, QWORD PTR [rax+rcx*4]
  0048d	44 8b 84 24 10
	05 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  00495	48 8d 94 24 b8
	00 00 00	 lea	 rdx, QWORD PTR rgbe$3[rsp]
  0049d	48 8b c8	 mov	 rcx, rax
  004a0	e8 00 00 00 00	 call	 ?stbi__hdr_convert@@YAXPEAMPEAEH@Z ; stbi__hdr_convert

; 7221 :             }

  004a5	eb 88		 jmp	 SHORT $LN10@stbi__hdr_
$LN11@stbi__hdr_:

; 7222 :         }

  004a7	e9 61 ff ff ff	 jmp	 $LN7@stbi__hdr_
$LN8@stbi__hdr_:

; 7223 :     } else {

  004ac	e9 57 04 00 00	 jmp	 $LN43@stbi__hdr_
$LN42@stbi__hdr_:

; 7224 :         // Read RLE-encoded data
; 7225 :         scanline = NULL;

  004b1	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR scanline$[rsp], 0

; 7226 :         
; 7227 :         for (j = 0; j < height; ++j) {

  004ba	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  004c2	eb 0a		 jmp	 SHORT $LN15@stbi__hdr_
$LN13@stbi__hdr_:
  004c4	8b 44 24 3c	 mov	 eax, DWORD PTR j$[rsp]
  004c8	ff c0		 inc	 eax
  004ca	89 44 24 3c	 mov	 DWORD PTR j$[rsp], eax
$LN15@stbi__hdr_:
  004ce	8b 44 24 58	 mov	 eax, DWORD PTR height$[rsp]
  004d2	39 44 24 3c	 cmp	 DWORD PTR j$[rsp], eax
  004d6	0f 8d 1a 04 00
	00		 jge	 $LN14@stbi__hdr_

; 7228 :             c1 = stbi__get8(s);

  004dc	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004e4	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  004e9	0f b6 c0	 movzx	 eax, al
  004ec	89 84 24 a0 00
	00 00		 mov	 DWORD PTR c1$[rsp], eax

; 7229 :             c2 = stbi__get8(s);

  004f3	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004fb	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00500	0f b6 c0	 movzx	 eax, al
  00503	89 84 24 a4 00
	00 00		 mov	 DWORD PTR c2$[rsp], eax

; 7230 :             len = stbi__get8(s);

  0050a	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00512	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00517	0f b6 c0	 movzx	 eax, al
  0051a	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax

; 7231 :             if (c1 != 2 || c2 != 2 || (len & 0x80)) {

  0051e	83 bc 24 a0 00
	00 00 02	 cmp	 DWORD PTR c1$[rsp], 2
  00526	75 1b		 jne	 SHORT $LN46@stbi__hdr_
  00528	83 bc 24 a4 00
	00 00 02	 cmp	 DWORD PTR c2$[rsp], 2
  00530	75 11		 jne	 SHORT $LN46@stbi__hdr_
  00532	8b 44 24 44	 mov	 eax, DWORD PTR len$[rsp]
  00536	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0053b	85 c0		 test	 eax, eax
  0053d	0f 84 8c 00 00
	00		 je	 $LN45@stbi__hdr_
$LN46@stbi__hdr_:

; 7232 :                 // not run-length encoded, so we have to actually use THIS data as a decoded
; 7233 :                 // pixel (note this can't be a valid pixel--one of RGB must be >= 128)
; 7234 :                 stbi_uc rgbe[4];
; 7235 :                 rgbe[0] = (stbi_uc) c1;

  00543	b8 01 00 00 00	 mov	 eax, 1
  00548	48 6b c0 00	 imul	 rax, rax, 0
  0054c	0f b6 8c 24 a0
	00 00 00	 movzx	 ecx, BYTE PTR c1$[rsp]
  00554	88 4c 04 6c	 mov	 BYTE PTR rgbe$1[rsp+rax], cl

; 7236 :                 rgbe[1] = (stbi_uc) c2;

  00558	b8 01 00 00 00	 mov	 eax, 1
  0055d	48 6b c0 01	 imul	 rax, rax, 1
  00561	0f b6 8c 24 a4
	00 00 00	 movzx	 ecx, BYTE PTR c2$[rsp]
  00569	88 4c 04 6c	 mov	 BYTE PTR rgbe$1[rsp+rax], cl

; 7237 :                 rgbe[2] = (stbi_uc) len;

  0056d	b8 01 00 00 00	 mov	 eax, 1
  00572	48 6b c0 02	 imul	 rax, rax, 2
  00576	0f b6 4c 24 44	 movzx	 ecx, BYTE PTR len$[rsp]
  0057b	88 4c 04 6c	 mov	 BYTE PTR rgbe$1[rsp+rax], cl

; 7238 :                 rgbe[3] = (stbi_uc) stbi__get8(s);

  0057f	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00587	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0058c	b9 01 00 00 00	 mov	 ecx, 1
  00591	48 6b c9 03	 imul	 rcx, rcx, 3
  00595	88 44 0c 6c	 mov	 BYTE PTR rgbe$1[rsp+rcx], al

; 7239 :                 stbi__hdr_convert(hdr_data, rgbe, req_comp);

  00599	44 8b 84 24 10
	05 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  005a1	48 8d 54 24 6c	 lea	 rdx, QWORD PTR rgbe$1[rsp]
  005a6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR hdr_data$[rsp]
  005ab	e8 00 00 00 00	 call	 ?stbi__hdr_convert@@YAXPEAMPEAEH@Z ; stbi__hdr_convert

; 7240 :                 i = 1;

  005b0	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1

; 7241 :                 j = 0;

  005b8	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0

; 7242 :                 STBI_FREE(scanline);

  005c0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR scanline$[rsp]
  005c5	e8 00 00 00 00	 call	 free

; 7243 :                 goto main_decode_loop; // yes, this makes no sense

  005ca	e9 74 fe ff ff	 jmp	 $main_decode_loop$82
$LN45@stbi__hdr_:

; 7244 :             }
; 7245 :             len <<= 8;

  005cf	8b 44 24 44	 mov	 eax, DWORD PTR len$[rsp]
  005d3	c1 e0 08	 shl	 eax, 8
  005d6	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax

; 7246 :             len |= stbi__get8(s);

  005da	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005e2	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  005e7	0f b6 c0	 movzx	 eax, al
  005ea	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  005ee	0b c8		 or	 ecx, eax
  005f0	8b c1		 mov	 eax, ecx
  005f2	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax

; 7247 :             if (len != width) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("invalid decoded scanline length", "corrupt HDR"); }

  005f6	8b 44 24 38	 mov	 eax, DWORD PTR width$[rsp]
  005fa	39 44 24 44	 cmp	 DWORD PTR len$[rsp], eax
  005fe	74 49		 je	 SHORT $LN47@stbi__hdr_
  00600	48 8b 4c 24 70	 mov	 rcx, QWORD PTR hdr_data$[rsp]
  00605	e8 00 00 00 00	 call	 free
  0060a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR scanline$[rsp]
  0060f	e8 00 00 00 00	 call	 free
  00614	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG82189
  0061b	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00620	85 c0		 test	 eax, eax
  00622	74 0d		 je	 SHORT $LN74@stbi__hdr_
  00624	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv264[rsp], 0
  0062f	eb 0b		 jmp	 SHORT $LN75@stbi__hdr_
$LN74@stbi__hdr_:
  00631	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv264[rsp], 0
$LN75@stbi__hdr_:
  0063c	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR tv264[rsp]
  00644	e9 c4 02 00 00	 jmp	 $LN1@stbi__hdr_
$LN47@stbi__hdr_:

; 7248 :             if (scanline == NULL) {

  00649	48 83 7c 24 60
	00		 cmp	 QWORD PTR scanline$[rsp], 0
  0064f	75 5d		 jne	 SHORT $LN48@stbi__hdr_

; 7249 :                 scanline = (stbi_uc *) stbi__malloc_mad2(width, 4, 0);

  00651	45 33 c0	 xor	 r8d, r8d
  00654	ba 04 00 00 00	 mov	 edx, 4
  00659	8b 4c 24 38	 mov	 ecx, DWORD PTR width$[rsp]
  0065d	e8 00 00 00 00	 call	 ?stbi__malloc_mad2@@YAPEAXHHH@Z ; stbi__malloc_mad2
  00662	48 89 44 24 60	 mov	 QWORD PTR scanline$[rsp], rax

; 7250 :                 if (!scanline) {

  00667	48 83 7c 24 60
	00		 cmp	 QWORD PTR scanline$[rsp], 0
  0066d	75 3f		 jne	 SHORT $LN49@stbi__hdr_

; 7251 :                     STBI_FREE(hdr_data);

  0066f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR hdr_data$[rsp]
  00674	e8 00 00 00 00	 call	 free

; 7252 :                     return stbi__errpf("outofmem", "Out of memory");

  00679	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG82192
  00680	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00685	85 c0		 test	 eax, eax
  00687	74 0d		 je	 SHORT $LN76@stbi__hdr_
  00689	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv276[rsp], 0
  00694	eb 0b		 jmp	 SHORT $LN77@stbi__hdr_
$LN76@stbi__hdr_:
  00696	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv276[rsp], 0
$LN77@stbi__hdr_:
  006a1	48 63 84 24 ac
	00 00 00	 movsxd	 rax, DWORD PTR tv276[rsp]
  006a9	e9 5f 02 00 00	 jmp	 $LN1@stbi__hdr_
$LN49@stbi__hdr_:
$LN48@stbi__hdr_:

; 7253 :                 }
; 7254 :             }
; 7255 :             
; 7256 :             for (k = 0; k < 4; ++k) {

  006ae	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR k$[rsp], 0
  006b6	eb 0a		 jmp	 SHORT $LN18@stbi__hdr_
$LN16@stbi__hdr_:
  006b8	8b 44 24 68	 mov	 eax, DWORD PTR k$[rsp]
  006bc	ff c0		 inc	 eax
  006be	89 44 24 68	 mov	 DWORD PTR k$[rsp], eax
$LN18@stbi__hdr_:
  006c2	83 7c 24 68 04	 cmp	 DWORD PTR k$[rsp], 4
  006c7	0f 8d bf 01 00
	00		 jge	 $LN17@stbi__hdr_

; 7257 :                 int nleft;
; 7258 :                 i = 0;

  006cd	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
$LN19@stbi__hdr_:

; 7259 :                 while ((nleft = width - i) > 0) {

  006d5	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  006d9	8b 4c 24 38	 mov	 ecx, DWORD PTR width$[rsp]
  006dd	2b c8		 sub	 ecx, eax
  006df	8b c1		 mov	 eax, ecx
  006e1	89 44 24 78	 mov	 DWORD PTR nleft$2[rsp], eax
  006e5	83 7c 24 78 00	 cmp	 DWORD PTR nleft$2[rsp], 0
  006ea	0f 8e 97 01 00
	00		 jle	 $LN20@stbi__hdr_

; 7260 :                     count = stbi__get8(s);

  006f0	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006f8	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  006fd	88 44 24 30	 mov	 BYTE PTR count$[rsp], al

; 7261 :                     if (count > 128) {

  00701	0f b6 44 24 30	 movzx	 eax, BYTE PTR count$[rsp]
  00706	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0070b	0f 8e c6 00 00
	00		 jle	 $LN50@stbi__hdr_

; 7262 :                         // Run
; 7263 :                         value = stbi__get8(s);

  00711	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00719	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0071e	88 44 24 40	 mov	 BYTE PTR value$[rsp], al

; 7264 :                         count -= 128;

  00722	0f b6 44 24 30	 movzx	 eax, BYTE PTR count$[rsp]
  00727	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
  0072c	88 44 24 30	 mov	 BYTE PTR count$[rsp], al

; 7265 :                         if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }

  00730	0f b6 44 24 30	 movzx	 eax, BYTE PTR count$[rsp]
  00735	85 c0		 test	 eax, eax
  00737	74 0b		 je	 SHORT $LN53@stbi__hdr_
  00739	0f b6 44 24 30	 movzx	 eax, BYTE PTR count$[rsp]
  0073e	3b 44 24 78	 cmp	 eax, DWORD PTR nleft$2[rsp]
  00742	7e 49		 jle	 SHORT $LN52@stbi__hdr_
$LN53@stbi__hdr_:
  00744	48 8b 4c 24 70	 mov	 rcx, QWORD PTR hdr_data$[rsp]
  00749	e8 00 00 00 00	 call	 free
  0074e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR scanline$[rsp]
  00753	e8 00 00 00 00	 call	 free
  00758	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG82197
  0075f	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00764	85 c0		 test	 eax, eax
  00766	74 0d		 je	 SHORT $LN78@stbi__hdr_
  00768	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv300[rsp], 0
  00773	eb 0b		 jmp	 SHORT $LN79@stbi__hdr_
$LN78@stbi__hdr_:
  00775	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv300[rsp], 0
$LN79@stbi__hdr_:
  00780	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR tv300[rsp]
  00788	e9 80 01 00 00	 jmp	 $LN1@stbi__hdr_
$LN52@stbi__hdr_:

; 7266 :                         for (z = 0; z < count; ++z)

  0078d	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR z$[rsp], 0
  00795	eb 0a		 jmp	 SHORT $LN23@stbi__hdr_
$LN21@stbi__hdr_:
  00797	8b 44 24 48	 mov	 eax, DWORD PTR z$[rsp]
  0079b	ff c0		 inc	 eax
  0079d	89 44 24 48	 mov	 DWORD PTR z$[rsp], eax
$LN23@stbi__hdr_:
  007a1	0f b6 44 24 30	 movzx	 eax, BYTE PTR count$[rsp]
  007a6	39 44 24 48	 cmp	 DWORD PTR z$[rsp], eax
  007aa	7d 26		 jge	 SHORT $LN22@stbi__hdr_

; 7267 :                             scanline[i++ * 4 + k] = value;

  007ac	8b 44 24 68	 mov	 eax, DWORD PTR k$[rsp]
  007b0	8b 4c 24 34	 mov	 ecx, DWORD PTR i$[rsp]
  007b4	8d 04 88	 lea	 eax, DWORD PTR [rax+rcx*4]
  007b7	48 98		 cdqe
  007b9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR scanline$[rsp]
  007be	0f b6 54 24 40	 movzx	 edx, BYTE PTR value$[rsp]
  007c3	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  007c6	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  007ca	ff c0		 inc	 eax
  007cc	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
  007d0	eb c5		 jmp	 SHORT $LN21@stbi__hdr_
$LN22@stbi__hdr_:

; 7268 :                     } else {

  007d2	e9 ab 00 00 00	 jmp	 $LN51@stbi__hdr_
$LN50@stbi__hdr_:

; 7269 :                         // Dump
; 7270 :                         if ((count == 0) || (count > nleft)) { STBI_FREE(hdr_data); STBI_FREE(scanline); return stbi__errpf("corrupt", "bad RLE data in HDR"); }

  007d7	0f b6 44 24 30	 movzx	 eax, BYTE PTR count$[rsp]
  007dc	85 c0		 test	 eax, eax
  007de	74 0b		 je	 SHORT $LN55@stbi__hdr_
  007e0	0f b6 44 24 30	 movzx	 eax, BYTE PTR count$[rsp]
  007e5	3b 44 24 78	 cmp	 eax, DWORD PTR nleft$2[rsp]
  007e9	7e 49		 jle	 SHORT $LN54@stbi__hdr_
$LN55@stbi__hdr_:
  007eb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR hdr_data$[rsp]
  007f0	e8 00 00 00 00	 call	 free
  007f5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR scanline$[rsp]
  007fa	e8 00 00 00 00	 call	 free
  007ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG82200
  00806	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0080b	85 c0		 test	 eax, eax
  0080d	74 0d		 je	 SHORT $LN80@stbi__hdr_
  0080f	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv320[rsp], 0
  0081a	eb 0b		 jmp	 SHORT $LN81@stbi__hdr_
$LN80@stbi__hdr_:
  0081c	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv320[rsp], 0
$LN81@stbi__hdr_:
  00827	48 63 84 24 b4
	00 00 00	 movsxd	 rax, DWORD PTR tv320[rsp]
  0082f	e9 d9 00 00 00	 jmp	 $LN1@stbi__hdr_
$LN54@stbi__hdr_:

; 7271 :                         for (z = 0; z < count; ++z)

  00834	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR z$[rsp], 0
  0083c	eb 0a		 jmp	 SHORT $LN26@stbi__hdr_
$LN24@stbi__hdr_:
  0083e	8b 44 24 48	 mov	 eax, DWORD PTR z$[rsp]
  00842	ff c0		 inc	 eax
  00844	89 44 24 48	 mov	 DWORD PTR z$[rsp], eax
$LN26@stbi__hdr_:
  00848	0f b6 44 24 30	 movzx	 eax, BYTE PTR count$[rsp]
  0084d	39 44 24 48	 cmp	 DWORD PTR z$[rsp], eax
  00851	7d 2f		 jge	 SHORT $LN25@stbi__hdr_

; 7272 :                             scanline[i++ * 4 + k] = stbi__get8(s);

  00853	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0085b	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00860	8b 4c 24 68	 mov	 ecx, DWORD PTR k$[rsp]
  00864	8b 54 24 34	 mov	 edx, DWORD PTR i$[rsp]
  00868	8d 0c 91	 lea	 ecx, DWORD PTR [rcx+rdx*4]
  0086b	48 63 c9	 movsxd	 rcx, ecx
  0086e	48 8b 54 24 60	 mov	 rdx, QWORD PTR scanline$[rsp]
  00873	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00876	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  0087a	ff c0		 inc	 eax
  0087c	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
  00880	eb bc		 jmp	 SHORT $LN24@stbi__hdr_
$LN25@stbi__hdr_:
$LN51@stbi__hdr_:

; 7273 :                     }
; 7274 :                 }

  00882	e9 4e fe ff ff	 jmp	 $LN19@stbi__hdr_
$LN20@stbi__hdr_:

; 7275 :             }

  00887	e9 2c fe ff ff	 jmp	 $LN16@stbi__hdr_
$LN17@stbi__hdr_:

; 7276 :             for (i=0; i < width; ++i)

  0088c	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00894	eb 0a		 jmp	 SHORT $LN29@stbi__hdr_
$LN27@stbi__hdr_:
  00896	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  0089a	ff c0		 inc	 eax
  0089c	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN29@stbi__hdr_:
  008a0	8b 44 24 38	 mov	 eax, DWORD PTR width$[rsp]
  008a4	39 44 24 34	 cmp	 DWORD PTR i$[rsp], eax
  008a8	7d 47		 jge	 SHORT $LN28@stbi__hdr_

; 7277 :                 stbi__hdr_convert(hdr_data+(j*width + i)*req_comp, scanline + i*4, req_comp);

  008aa	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  008ae	c1 e0 02	 shl	 eax, 2
  008b1	48 98		 cdqe
  008b3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR scanline$[rsp]
  008b8	48 03 c8	 add	 rcx, rax
  008bb	48 8b c1	 mov	 rax, rcx
  008be	8b 4c 24 3c	 mov	 ecx, DWORD PTR j$[rsp]
  008c2	0f af 4c 24 38	 imul	 ecx, DWORD PTR width$[rsp]
  008c7	03 4c 24 34	 add	 ecx, DWORD PTR i$[rsp]
  008cb	0f af 8c 24 10
	05 00 00	 imul	 ecx, DWORD PTR req_comp$[rsp]
  008d3	48 63 c9	 movsxd	 rcx, ecx
  008d6	48 8b 54 24 70	 mov	 rdx, QWORD PTR hdr_data$[rsp]
  008db	48 8d 0c 8a	 lea	 rcx, QWORD PTR [rdx+rcx*4]
  008df	44 8b 84 24 10
	05 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  008e7	48 8b d0	 mov	 rdx, rax
  008ea	e8 00 00 00 00	 call	 ?stbi__hdr_convert@@YAXPEAMPEAEH@Z ; stbi__hdr_convert
  008ef	eb a5		 jmp	 SHORT $LN27@stbi__hdr_
$LN28@stbi__hdr_:

; 7278 :         }

  008f1	e9 ce fb ff ff	 jmp	 $LN13@stbi__hdr_
$LN14@stbi__hdr_:

; 7279 :         if (scanline)

  008f6	48 83 7c 24 60
	00		 cmp	 QWORD PTR scanline$[rsp], 0
  008fc	74 0a		 je	 SHORT $LN56@stbi__hdr_

; 7280 :             STBI_FREE(scanline);

  008fe	48 8b 4c 24 60	 mov	 rcx, QWORD PTR scanline$[rsp]
  00903	e8 00 00 00 00	 call	 free
$LN56@stbi__hdr_:
$LN43@stbi__hdr_:

; 7281 :     }
; 7282 :     
; 7283 :     return hdr_data;

  00908	48 8b 44 24 70	 mov	 rax, QWORD PTR hdr_data$[rsp]
$LN1@stbi__hdr_:

; 7284 : }

  0090d	48 8b 8c 24 d0
	04 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00915	48 33 cc	 xor	 rcx, rsp
  00918	e8 00 00 00 00	 call	 __security_check_cookie
  0091d	48 81 c4 e8 04
	00 00		 add	 rsp, 1256		; 000004e8H
  00924	c3		 ret	 0
?stbi__hdr_load@@YAPEAMPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ENDP ; stbi__hdr_load
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
r$ = 32
s$ = 64
?stbi__hdr_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__hdr_test

; 7095 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7096 :     int r = stbi__hdr_test_core(s, "#?RADIANCE\n");

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG82027
  00010	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00015	e8 00 00 00 00	 call	 ?stbi__hdr_test_core@@YAHPEAUstbi__context@@PEBD@Z ; stbi__hdr_test_core
  0001a	89 44 24 20	 mov	 DWORD PTR r$[rsp], eax

; 7097 :     stbi__rewind(s);

  0001e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00023	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7098 :     if(!r) {

  00028	83 7c 24 20 00	 cmp	 DWORD PTR r$[rsp], 0
  0002d	75 1f		 jne	 SHORT $LN2@stbi__hdr_

; 7099 :         r = stbi__hdr_test_core(s, "#?RGBE\n");

  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG82029
  00036	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0003b	e8 00 00 00 00	 call	 ?stbi__hdr_test_core@@YAHPEAUstbi__context@@PEBD@Z ; stbi__hdr_test_core
  00040	89 44 24 20	 mov	 DWORD PTR r$[rsp], eax

; 7100 :         stbi__rewind(s);

  00044	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00049	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind
$LN2@stbi__hdr_:

; 7101 :     }
; 7102 :     return r;

  0004e	8b 44 24 20	 mov	 eax, DWORD PTR r$[rsp]

; 7103 : }

  00052	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00056	c3		 ret	 0
?stbi__hdr_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__hdr_test
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
channelCount$ = 32
depth$ = 36
s$ = 64
?stbi__psd_is16@@YAHPEAUstbi__context@@@Z PROC		; stbi__psd_is16

; 7392 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7393 :     int channelCount, depth;
; 7394 :     if (stbi__get32be(s) != 0x38425053) {

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
  00013	3d 53 50 42 38	 cmp	 eax, 943870035		; 38425053H
  00018	74 11		 je	 SHORT $LN2@stbi__psd_

; 7395 :         stbi__rewind( s );

  0001a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001f	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7396 :         return 0;

  00024	33 c0		 xor	 eax, eax
  00026	e9 92 00 00 00	 jmp	 $LN1@stbi__psd_
$LN2@stbi__psd_:

; 7397 :     }
; 7398 :     if (stbi__get16be(s) != 1) {

  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00030	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  00035	83 f8 01	 cmp	 eax, 1
  00038	74 0e		 je	 SHORT $LN3@stbi__psd_

; 7399 :         stbi__rewind( s );

  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0003f	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7400 :         return 0;

  00044	33 c0		 xor	 eax, eax
  00046	eb 75		 jmp	 SHORT $LN1@stbi__psd_
$LN3@stbi__psd_:

; 7401 :     }
; 7402 :     stbi__skip(s, 6);

  00048	ba 06 00 00 00	 mov	 edx, 6
  0004d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00052	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 7403 :     channelCount = stbi__get16be(s);

  00057	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0005c	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  00061	89 44 24 20	 mov	 DWORD PTR channelCount$[rsp], eax

; 7404 :     if (channelCount < 0 || channelCount > 16) {

  00065	83 7c 24 20 00	 cmp	 DWORD PTR channelCount$[rsp], 0
  0006a	7c 07		 jl	 SHORT $LN5@stbi__psd_
  0006c	83 7c 24 20 10	 cmp	 DWORD PTR channelCount$[rsp], 16
  00071	7e 0e		 jle	 SHORT $LN4@stbi__psd_
$LN5@stbi__psd_:

; 7405 :         stbi__rewind( s );

  00073	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00078	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7406 :         return 0;

  0007d	33 c0		 xor	 eax, eax
  0007f	eb 3c		 jmp	 SHORT $LN1@stbi__psd_
$LN4@stbi__psd_:

; 7407 :     }
; 7408 :     STBI_NOTUSED(stbi__get32be(s));

  00081	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00086	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be

; 7409 :     STBI_NOTUSED(stbi__get32be(s));

  0008b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00090	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be

; 7410 :     depth = stbi__get16be(s);

  00095	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0009a	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  0009f	89 44 24 24	 mov	 DWORD PTR depth$[rsp], eax

; 7411 :     if (depth != 16) {

  000a3	83 7c 24 24 10	 cmp	 DWORD PTR depth$[rsp], 16
  000a8	74 0e		 je	 SHORT $LN6@stbi__psd_

; 7412 :         stbi__rewind( s );

  000aa	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000af	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7413 :         return 0;

  000b4	33 c0		 xor	 eax, eax
  000b6	eb 05		 jmp	 SHORT $LN1@stbi__psd_
$LN6@stbi__psd_:

; 7414 :     }
; 7415 :     return 1;

  000b8	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__psd_:

; 7416 : }

  000bd	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c1	c3		 ret	 0
?stbi__psd_is16@@YAHPEAUstbi__context@@@Z ENDP		; stbi__psd_is16
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
dummy$ = 32
channelCount$ = 36
depth$ = 40
s$ = 64
x$ = 72
y$ = 80
comp$ = 88
?stbi__psd_info@@YAHPEAUstbi__context@@PEAH11@Z PROC	; stbi__psd_info

; 7357 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7358 :     int channelCount, dummy, depth;
; 7359 :     if (!x) x = &dummy;

  00018	48 83 7c 24 48
	00		 cmp	 QWORD PTR x$[rsp], 0
  0001e	75 0a		 jne	 SHORT $LN2@stbi__psd_
  00020	48 8d 44 24 20	 lea	 rax, QWORD PTR dummy$[rsp]
  00025	48 89 44 24 48	 mov	 QWORD PTR x$[rsp], rax
$LN2@stbi__psd_:

; 7360 :     if (!y) y = &dummy;

  0002a	48 83 7c 24 50
	00		 cmp	 QWORD PTR y$[rsp], 0
  00030	75 0a		 jne	 SHORT $LN3@stbi__psd_
  00032	48 8d 44 24 20	 lea	 rax, QWORD PTR dummy$[rsp]
  00037	48 89 44 24 50	 mov	 QWORD PTR y$[rsp], rax
$LN3@stbi__psd_:

; 7361 :     if (!comp) comp = &dummy;

  0003c	48 83 7c 24 58
	00		 cmp	 QWORD PTR comp$[rsp], 0
  00042	75 0a		 jne	 SHORT $LN4@stbi__psd_
  00044	48 8d 44 24 20	 lea	 rax, QWORD PTR dummy$[rsp]
  00049	48 89 44 24 58	 mov	 QWORD PTR comp$[rsp], rax
$LN4@stbi__psd_:

; 7362 :     if (stbi__get32be(s) != 0x38425053) {

  0004e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00053	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
  00058	3d 53 50 42 38	 cmp	 eax, 943870035		; 38425053H
  0005d	74 11		 je	 SHORT $LN5@stbi__psd_

; 7363 :         stbi__rewind( s );

  0005f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00064	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7364 :         return 0;

  00069	33 c0		 xor	 eax, eax
  0006b	e9 d2 00 00 00	 jmp	 $LN1@stbi__psd_
$LN5@stbi__psd_:

; 7365 :     }
; 7366 :     if (stbi__get16be(s) != 1) {

  00070	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00075	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  0007a	83 f8 01	 cmp	 eax, 1
  0007d	74 11		 je	 SHORT $LN6@stbi__psd_

; 7367 :         stbi__rewind( s );

  0007f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00084	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7368 :         return 0;

  00089	33 c0		 xor	 eax, eax
  0008b	e9 b2 00 00 00	 jmp	 $LN1@stbi__psd_
$LN6@stbi__psd_:

; 7369 :     }
; 7370 :     stbi__skip(s, 6);

  00090	ba 06 00 00 00	 mov	 edx, 6
  00095	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0009a	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 7371 :     channelCount = stbi__get16be(s);

  0009f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000a4	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  000a9	89 44 24 24	 mov	 DWORD PTR channelCount$[rsp], eax

; 7372 :     if (channelCount < 0 || channelCount > 16) {

  000ad	83 7c 24 24 00	 cmp	 DWORD PTR channelCount$[rsp], 0
  000b2	7c 07		 jl	 SHORT $LN8@stbi__psd_
  000b4	83 7c 24 24 10	 cmp	 DWORD PTR channelCount$[rsp], 16
  000b9	7e 0e		 jle	 SHORT $LN7@stbi__psd_
$LN8@stbi__psd_:

; 7373 :         stbi__rewind( s );

  000bb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000c0	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7374 :         return 0;

  000c5	33 c0		 xor	 eax, eax
  000c7	eb 79		 jmp	 SHORT $LN1@stbi__psd_
$LN7@stbi__psd_:

; 7375 :     }
; 7376 :     *y = stbi__get32be(s);

  000c9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000ce	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
  000d3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR y$[rsp]
  000d8	89 01		 mov	 DWORD PTR [rcx], eax

; 7377 :     *x = stbi__get32be(s);

  000da	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000df	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
  000e4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR x$[rsp]
  000e9	89 01		 mov	 DWORD PTR [rcx], eax

; 7378 :     depth = stbi__get16be(s);

  000eb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000f0	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  000f5	89 44 24 28	 mov	 DWORD PTR depth$[rsp], eax

; 7379 :     if (depth != 8 && depth != 16) {

  000f9	83 7c 24 28 08	 cmp	 DWORD PTR depth$[rsp], 8
  000fe	74 15		 je	 SHORT $LN9@stbi__psd_
  00100	83 7c 24 28 10	 cmp	 DWORD PTR depth$[rsp], 16
  00105	74 0e		 je	 SHORT $LN9@stbi__psd_

; 7380 :         stbi__rewind( s );

  00107	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0010c	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7381 :         return 0;

  00111	33 c0		 xor	 eax, eax
  00113	eb 2d		 jmp	 SHORT $LN1@stbi__psd_
$LN9@stbi__psd_:

; 7382 :     }
; 7383 :     if (stbi__get16be(s) != 3) {

  00115	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0011a	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  0011f	83 f8 03	 cmp	 eax, 3
  00122	74 0e		 je	 SHORT $LN10@stbi__psd_

; 7384 :         stbi__rewind( s );

  00124	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00129	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7385 :         return 0;

  0012e	33 c0		 xor	 eax, eax
  00130	eb 10		 jmp	 SHORT $LN1@stbi__psd_
$LN10@stbi__psd_:

; 7386 :     }
; 7387 :     *comp = 4;

  00132	48 8b 44 24 58	 mov	 rax, QWORD PTR comp$[rsp]
  00137	c7 00 04 00 00
	00		 mov	 DWORD PTR [rax], 4

; 7388 :     return 1;

  0013d	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__psd_:

; 7389 : }

  00142	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00146	c3		 ret	 0
?stbi__psd_info@@YAHPEAUstbi__context@@PEAH11@Z ENDP	; stbi__psd_info
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
i$ = 48
channel$ = 52
h$ = 56
w$ = 60
out$ = 64
val$1 = 72
pixelCount$ = 76
channelCount$ = 80
bitdepth$ = 84
ra$2 = 88
ra$3 = 92
pixel$4 = 96
pixel$5 = 104
val$6 = 112
compression$ = 116
inv_a$7 = 120
inv_a$8 = 124
p$9 = 128
tv137 = 136
tv146 = 140
tv154 = 144
tv174 = 148
tv185 = 152
tv205 = 156
tv222 = 160
tv233 = 164
tv244 = 168
tv252 = 172
tv70 = 176
tv78 = 180
tv89 = 184
tv131 = 188
p$10 = 192
a$11 = 200
a$12 = 204
q$13 = 208
p$14 = 216
q$15 = 224
s$ = 256
x$ = 264
y$ = 272
comp$ = 280
req_comp$ = 288
ri$ = 296
bpc$ = 304
?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z PROC ; stbi__psd_load

; 6124 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H

; 6125 :     int pixelCount;
; 6126 :     int channelCount, compression;
; 6127 :     int channel, i;
; 6128 :     int bitdepth;
; 6129 :     int w,h;
; 6130 :     stbi_uc *out;
; 6131 :     STBI_NOTUSED(ri);
; 6132 :     
; 6133 :     // Check identifier
; 6134 :     if (stbi__get32be(s) != 0x38425053)   // "8BPS"

  0001b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00023	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
  00028	3d 53 50 42 38	 cmp	 eax, 943870035		; 38425053H
  0002d	74 35		 je	 SHORT $LN32@stbi__psd_

; 6135 :         return stbi__errpuc("not PSD", "Corrupt PSD image");

  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81402
  00036	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0003b	85 c0		 test	 eax, eax
  0003d	74 0d		 je	 SHORT $LN69@stbi__psd_
  0003f	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv70[rsp], 0
  0004a	eb 0b		 jmp	 SHORT $LN70@stbi__psd_
$LN69@stbi__psd_:
  0004c	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv70[rsp], 0
$LN70@stbi__psd_:
  00057	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR tv70[rsp]
  0005f	e9 27 0b 00 00	 jmp	 $LN1@stbi__psd_
$LN32@stbi__psd_:

; 6136 :     
; 6137 :     // Check file type version.
; 6138 :     if (stbi__get16be(s) != 1)

  00064	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0006c	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  00071	83 f8 01	 cmp	 eax, 1
  00074	74 35		 je	 SHORT $LN33@stbi__psd_

; 6139 :         return stbi__errpuc("wrong version", "Unsupported version of PSD image");

  00076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81404
  0007d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00082	85 c0		 test	 eax, eax
  00084	74 0d		 je	 SHORT $LN71@stbi__psd_
  00086	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv78[rsp], 0
  00091	eb 0b		 jmp	 SHORT $LN72@stbi__psd_
$LN71@stbi__psd_:
  00093	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv78[rsp], 0
$LN72@stbi__psd_:
  0009e	48 63 84 24 b4
	00 00 00	 movsxd	 rax, DWORD PTR tv78[rsp]
  000a6	e9 e0 0a 00 00	 jmp	 $LN1@stbi__psd_
$LN33@stbi__psd_:

; 6140 :     
; 6141 :     // Skip 6 reserved bytes.
; 6142 :     stbi__skip(s, 6 );

  000ab	ba 06 00 00 00	 mov	 edx, 6
  000b0	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000b8	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 6143 :     
; 6144 :     // Read the number of channels (R, G, B, A, etc).
; 6145 :     channelCount = stbi__get16be(s);

  000bd	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000c5	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  000ca	89 44 24 50	 mov	 DWORD PTR channelCount$[rsp], eax

; 6146 :     if (channelCount < 0 || channelCount > 16)

  000ce	83 7c 24 50 00	 cmp	 DWORD PTR channelCount$[rsp], 0
  000d3	7c 07		 jl	 SHORT $LN35@stbi__psd_
  000d5	83 7c 24 50 10	 cmp	 DWORD PTR channelCount$[rsp], 16
  000da	7e 35		 jle	 SHORT $LN34@stbi__psd_
$LN35@stbi__psd_:

; 6147 :         return stbi__errpuc("wrong channel count", "Unsupported number of channels in PSD image");

  000dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81407
  000e3	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000e8	85 c0		 test	 eax, eax
  000ea	74 0d		 je	 SHORT $LN73@stbi__psd_
  000ec	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv89[rsp], 0
  000f7	eb 0b		 jmp	 SHORT $LN74@stbi__psd_
$LN73@stbi__psd_:
  000f9	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv89[rsp], 0
$LN74@stbi__psd_:
  00104	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR tv89[rsp]
  0010c	e9 7a 0a 00 00	 jmp	 $LN1@stbi__psd_
$LN34@stbi__psd_:

; 6148 :     
; 6149 :     // Read the rows and columns of the image.
; 6150 :     h = stbi__get32be(s);

  00111	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00119	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
  0011e	89 44 24 38	 mov	 DWORD PTR h$[rsp], eax

; 6151 :     w = stbi__get32be(s);

  00122	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0012a	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
  0012f	89 44 24 3c	 mov	 DWORD PTR w$[rsp], eax

; 6152 :     
; 6153 :     if (h > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

  00133	81 7c 24 38 00
	00 00 01	 cmp	 DWORD PTR h$[rsp], 16777216 ; 01000000H
  0013b	7e 35		 jle	 SHORT $LN36@stbi__psd_
  0013d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81409
  00144	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00149	85 c0		 test	 eax, eax
  0014b	74 0d		 je	 SHORT $LN75@stbi__psd_
  0014d	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv131[rsp], 0
  00158	eb 0b		 jmp	 SHORT $LN76@stbi__psd_
$LN75@stbi__psd_:
  0015a	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv131[rsp], 0
$LN76@stbi__psd_:
  00165	48 63 84 24 bc
	00 00 00	 movsxd	 rax, DWORD PTR tv131[rsp]
  0016d	e9 19 0a 00 00	 jmp	 $LN1@stbi__psd_
$LN36@stbi__psd_:

; 6154 :     if (w > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

  00172	81 7c 24 3c 00
	00 00 01	 cmp	 DWORD PTR w$[rsp], 16777216 ; 01000000H
  0017a	7e 35		 jle	 SHORT $LN37@stbi__psd_
  0017c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81411
  00183	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00188	85 c0		 test	 eax, eax
  0018a	74 0d		 je	 SHORT $LN77@stbi__psd_
  0018c	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv137[rsp], 0
  00197	eb 0b		 jmp	 SHORT $LN78@stbi__psd_
$LN77@stbi__psd_:
  00199	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv137[rsp], 0
$LN78@stbi__psd_:
  001a4	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR tv137[rsp]
  001ac	e9 da 09 00 00	 jmp	 $LN1@stbi__psd_
$LN37@stbi__psd_:

; 6155 :     
; 6156 :     // Make sure the depth is 8 bits.
; 6157 :     bitdepth = stbi__get16be(s);

  001b1	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001b9	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  001be	89 44 24 54	 mov	 DWORD PTR bitdepth$[rsp], eax

; 6158 :     if (bitdepth != 8 && bitdepth != 16)

  001c2	83 7c 24 54 08	 cmp	 DWORD PTR bitdepth$[rsp], 8
  001c7	74 3c		 je	 SHORT $LN38@stbi__psd_
  001c9	83 7c 24 54 10	 cmp	 DWORD PTR bitdepth$[rsp], 16
  001ce	74 35		 je	 SHORT $LN38@stbi__psd_

; 6159 :         return stbi__errpuc("unsupported bit depth", "PSD bit depth is not 8 or 16 bit");

  001d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81413
  001d7	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  001dc	85 c0		 test	 eax, eax
  001de	74 0d		 je	 SHORT $LN79@stbi__psd_
  001e0	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv146[rsp], 0
  001eb	eb 0b		 jmp	 SHORT $LN80@stbi__psd_
$LN79@stbi__psd_:
  001ed	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv146[rsp], 0
$LN80@stbi__psd_:
  001f8	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR tv146[rsp]
  00200	e9 86 09 00 00	 jmp	 $LN1@stbi__psd_
$LN38@stbi__psd_:

; 6160 :     
; 6161 :     // Make sure the color mode is RGB.
; 6162 :     // Valid options are:
; 6163 :     //   0: Bitmap
; 6164 :     //   1: Grayscale
; 6165 :     //   2: Indexed color
; 6166 :     //   3: RGB color
; 6167 :     //   4: CMYK color
; 6168 :     //   7: Multichannel
; 6169 :     //   8: Duotone
; 6170 :     //   9: Lab color
; 6171 :     if (stbi__get16be(s) != 3)

  00205	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0020d	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  00212	83 f8 03	 cmp	 eax, 3
  00215	74 35		 je	 SHORT $LN39@stbi__psd_

; 6172 :         return stbi__errpuc("wrong color format", "PSD is not in RGB color format");

  00217	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81415
  0021e	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00223	85 c0		 test	 eax, eax
  00225	74 0d		 je	 SHORT $LN81@stbi__psd_
  00227	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv154[rsp], 0
  00232	eb 0b		 jmp	 SHORT $LN82@stbi__psd_
$LN81@stbi__psd_:
  00234	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv154[rsp], 0
$LN82@stbi__psd_:
  0023f	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR tv154[rsp]
  00247	e9 3f 09 00 00	 jmp	 $LN1@stbi__psd_
$LN39@stbi__psd_:

; 6173 :     
; 6174 :     // Skip the Mode Data.  (It's the palette for indexed color; other info for other modes.)
; 6175 :     stbi__skip(s,stbi__get32be(s) );

  0024c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00254	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
  00259	8b d0		 mov	 edx, eax
  0025b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00263	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 6176 :     
; 6177 :     // Skip the image resources.  (resolution, pen tool paths, etc)
; 6178 :     stbi__skip(s, stbi__get32be(s) );

  00268	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00270	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
  00275	8b d0		 mov	 edx, eax
  00277	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0027f	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 6179 :     
; 6180 :     // Skip the reserved data.
; 6181 :     stbi__skip(s, stbi__get32be(s) );

  00284	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0028c	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
  00291	8b d0		 mov	 edx, eax
  00293	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0029b	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 6182 :     
; 6183 :     // Find out if the data is compressed.
; 6184 :     // Known values:
; 6185 :     //   0: no compression
; 6186 :     //   1: RLE compressed
; 6187 :     compression = stbi__get16be(s);

  002a0	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002a8	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  002ad	89 44 24 74	 mov	 DWORD PTR compression$[rsp], eax

; 6188 :     if (compression > 1)

  002b1	83 7c 24 74 01	 cmp	 DWORD PTR compression$[rsp], 1
  002b6	7e 35		 jle	 SHORT $LN40@stbi__psd_

; 6189 :         return stbi__errpuc("bad compression", "PSD has an unknown compression format");

  002b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81417
  002bf	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  002c4	85 c0		 test	 eax, eax
  002c6	74 0d		 je	 SHORT $LN83@stbi__psd_
  002c8	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv174[rsp], 0
  002d3	eb 0b		 jmp	 SHORT $LN84@stbi__psd_
$LN83@stbi__psd_:
  002d5	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv174[rsp], 0
$LN84@stbi__psd_:
  002e0	48 63 84 24 94
	00 00 00	 movsxd	 rax, DWORD PTR tv174[rsp]
  002e8	e9 9e 08 00 00	 jmp	 $LN1@stbi__psd_
$LN40@stbi__psd_:

; 6190 :     
; 6191 :     // Check size
; 6192 :     if (!stbi__mad3sizes_valid(4, w, h, 0))

  002ed	45 33 c9	 xor	 r9d, r9d
  002f0	44 8b 44 24 38	 mov	 r8d, DWORD PTR h$[rsp]
  002f5	8b 54 24 3c	 mov	 edx, DWORD PTR w$[rsp]
  002f9	b9 04 00 00 00	 mov	 ecx, 4
  002fe	e8 00 00 00 00	 call	 ?stbi__mad3sizes_valid@@YAHHHHH@Z ; stbi__mad3sizes_valid
  00303	85 c0		 test	 eax, eax
  00305	75 35		 jne	 SHORT $LN41@stbi__psd_

; 6193 :         return stbi__errpuc("too large", "Corrupt PSD");

  00307	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81419
  0030e	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00313	85 c0		 test	 eax, eax
  00315	74 0d		 je	 SHORT $LN85@stbi__psd_
  00317	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv185[rsp], 0
  00322	eb 0b		 jmp	 SHORT $LN86@stbi__psd_
$LN85@stbi__psd_:
  00324	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv185[rsp], 0
$LN86@stbi__psd_:
  0032f	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR tv185[rsp]
  00337	e9 4f 08 00 00	 jmp	 $LN1@stbi__psd_
$LN41@stbi__psd_:

; 6194 :     
; 6195 :     // Create the destination image.
; 6196 :     
; 6197 :     if (!compression && bitdepth == 16 && bpc == 16) {

  0033c	83 7c 24 74 00	 cmp	 DWORD PTR compression$[rsp], 0
  00341	75 3c		 jne	 SHORT $LN42@stbi__psd_
  00343	83 7c 24 54 10	 cmp	 DWORD PTR bitdepth$[rsp], 16
  00348	75 35		 jne	 SHORT $LN42@stbi__psd_
  0034a	83 bc 24 30 01
	00 00 10	 cmp	 DWORD PTR bpc$[rsp], 16
  00352	75 2b		 jne	 SHORT $LN42@stbi__psd_

; 6198 :         out = (stbi_uc *) stbi__malloc_mad3(8, w, h, 0);

  00354	45 33 c9	 xor	 r9d, r9d
  00357	44 8b 44 24 38	 mov	 r8d, DWORD PTR h$[rsp]
  0035c	8b 54 24 3c	 mov	 edx, DWORD PTR w$[rsp]
  00360	b9 08 00 00 00	 mov	 ecx, 8
  00365	e8 00 00 00 00	 call	 ?stbi__malloc_mad3@@YAPEAXHHHH@Z ; stbi__malloc_mad3
  0036a	48 89 44 24 40	 mov	 QWORD PTR out$[rsp], rax

; 6199 :         ri->bits_per_channel = 16;

  0036f	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  00377	c7 00 10 00 00
	00		 mov	 DWORD PTR [rax], 16

; 6200 :     } else

  0037d	eb 1b		 jmp	 SHORT $LN43@stbi__psd_
$LN42@stbi__psd_:

; 6201 :         out = (stbi_uc *) stbi__malloc(4 * w*h);

  0037f	8b 44 24 3c	 mov	 eax, DWORD PTR w$[rsp]
  00383	c1 e0 02	 shl	 eax, 2
  00386	0f af 44 24 38	 imul	 eax, DWORD PTR h$[rsp]
  0038b	48 98		 cdqe
  0038d	48 8b c8	 mov	 rcx, rax
  00390	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  00395	48 89 44 24 40	 mov	 QWORD PTR out$[rsp], rax
$LN43@stbi__psd_:

; 6202 :     
; 6203 :     if (!out) return stbi__errpuc("outofmem", "Out of memory");

  0039a	48 83 7c 24 40
	00		 cmp	 QWORD PTR out$[rsp], 0
  003a0	75 35		 jne	 SHORT $LN44@stbi__psd_
  003a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81423
  003a9	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  003ae	85 c0		 test	 eax, eax
  003b0	74 0d		 je	 SHORT $LN87@stbi__psd_
  003b2	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv205[rsp], 0
  003bd	eb 0b		 jmp	 SHORT $LN88@stbi__psd_
$LN87@stbi__psd_:
  003bf	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv205[rsp], 0
$LN88@stbi__psd_:
  003ca	48 63 84 24 9c
	00 00 00	 movsxd	 rax, DWORD PTR tv205[rsp]
  003d2	e9 b4 07 00 00	 jmp	 $LN1@stbi__psd_
$LN44@stbi__psd_:

; 6204 :     pixelCount = w*h;

  003d7	8b 44 24 3c	 mov	 eax, DWORD PTR w$[rsp]
  003db	0f af 44 24 38	 imul	 eax, DWORD PTR h$[rsp]
  003e0	89 44 24 4c	 mov	 DWORD PTR pixelCount$[rsp], eax

; 6205 :     
; 6206 :     // Initialize the data to zero.
; 6207 :     //memset( out, 0, pixelCount * 4 );
; 6208 :     
; 6209 :     // Finally, the image data.
; 6210 :     if (compression) {

  003e4	83 7c 24 74 00	 cmp	 DWORD PTR compression$[rsp], 0
  003e9	0f 84 29 01 00
	00		 je	 $LN45@stbi__psd_

; 6211 :         // RLE as used by .PSD and .TIFF
; 6212 :         // Loop until you get the number of unpacked bytes you are expecting:
; 6213 :         //     Read the next source byte into n.
; 6214 :         //     If n is between 0 and 127 inclusive, copy the next n+1 bytes literally.
; 6215 :         //     Else if n is between -127 and -1 inclusive, copy the next byte -n+1 times.
; 6216 :         //     Else if n is 128, noop.
; 6217 :         // Endloop
; 6218 :         
; 6219 :         // The RLE-compressed data is preceded by a 2-byte data count for each row in the data,
; 6220 :         // which we're going to just skip.
; 6221 :         stbi__skip(s, h * channelCount * 2 );

  003ef	8b 44 24 38	 mov	 eax, DWORD PTR h$[rsp]
  003f3	0f af 44 24 50	 imul	 eax, DWORD PTR channelCount$[rsp]
  003f8	d1 e0		 shl	 eax, 1
  003fa	8b d0		 mov	 edx, eax
  003fc	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00404	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 6222 :         
; 6223 :         // Read the RLE data by channel.
; 6224 :         for (channel = 0; channel < 4; channel++) {

  00409	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR channel$[rsp], 0
  00411	eb 0a		 jmp	 SHORT $LN4@stbi__psd_
$LN2@stbi__psd_:
  00413	8b 44 24 34	 mov	 eax, DWORD PTR channel$[rsp]
  00417	ff c0		 inc	 eax
  00419	89 44 24 34	 mov	 DWORD PTR channel$[rsp], eax
$LN4@stbi__psd_:
  0041d	83 7c 24 34 04	 cmp	 DWORD PTR channel$[rsp], 4
  00422	0f 8d eb 00 00
	00		 jge	 $LN3@stbi__psd_

; 6225 :             stbi_uc *p;
; 6226 :             
; 6227 :             p = out+channel;

  00428	48 63 44 24 34	 movsxd	 rax, DWORD PTR channel$[rsp]
  0042d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  00432	48 03 c8	 add	 rcx, rax
  00435	48 8b c1	 mov	 rax, rcx
  00438	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR p$10[rsp], rax

; 6228 :             if (channel >= channelCount) {

  00440	8b 44 24 50	 mov	 eax, DWORD PTR channelCount$[rsp]
  00444	39 44 24 34	 cmp	 DWORD PTR channel$[rsp], eax
  00448	7c 67		 jl	 SHORT $LN47@stbi__psd_

; 6229 :                 // Fill this channel with default data.
; 6230 :                 for (i = 0; i < pixelCount; i++, p += 4)

  0044a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00452	eb 1e		 jmp	 SHORT $LN7@stbi__psd_
$LN5@stbi__psd_:
  00454	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00458	ff c0		 inc	 eax
  0045a	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  0045e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR p$10[rsp]
  00466	48 83 c0 04	 add	 rax, 4
  0046a	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR p$10[rsp], rax
$LN7@stbi__psd_:
  00472	8b 44 24 4c	 mov	 eax, DWORD PTR pixelCount$[rsp]
  00476	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  0047a	7d 33		 jge	 SHORT $LN6@stbi__psd_

; 6231 :                     *p = (channel == 3 ? 255 : 0);

  0047c	83 7c 24 34 03	 cmp	 DWORD PTR channel$[rsp], 3
  00481	75 0d		 jne	 SHORT $LN89@stbi__psd_
  00483	c7 84 24 a0 00
	00 00 ff 00 00
	00		 mov	 DWORD PTR tv222[rsp], 255 ; 000000ffH
  0048e	eb 0b		 jmp	 SHORT $LN90@stbi__psd_
$LN89@stbi__psd_:
  00490	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv222[rsp], 0
$LN90@stbi__psd_:
  0049b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR p$10[rsp]
  004a3	0f b6 8c 24 a0
	00 00 00	 movzx	 ecx, BYTE PTR tv222[rsp]
  004ab	88 08		 mov	 BYTE PTR [rax], cl
  004ad	eb a5		 jmp	 SHORT $LN5@stbi__psd_
$LN6@stbi__psd_:

; 6232 :             } else {

  004af	eb 5d		 jmp	 SHORT $LN48@stbi__psd_
$LN47@stbi__psd_:

; 6233 :                 // Read the RLE data.
; 6234 :                 if (!stbi__psd_decode_rle(s, p, pixelCount)) {

  004b1	44 8b 44 24 4c	 mov	 r8d, DWORD PTR pixelCount$[rsp]
  004b6	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR p$10[rsp]
  004be	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004c6	e8 00 00 00 00	 call	 ?stbi__psd_decode_rle@@YAHPEAUstbi__context@@PEAEH@Z ; stbi__psd_decode_rle
  004cb	85 c0		 test	 eax, eax
  004cd	75 3f		 jne	 SHORT $LN49@stbi__psd_

; 6235 :                     STBI_FREE(out);

  004cf	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  004d4	e8 00 00 00 00	 call	 free

; 6236 :                     return stbi__errpuc("corrupt", "bad RLE data");

  004d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81429
  004e0	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  004e5	85 c0		 test	 eax, eax
  004e7	74 0d		 je	 SHORT $LN91@stbi__psd_
  004e9	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv233[rsp], 0
  004f4	eb 0b		 jmp	 SHORT $LN92@stbi__psd_
$LN91@stbi__psd_:
  004f6	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv233[rsp], 0
$LN92@stbi__psd_:
  00501	48 63 84 24 a4
	00 00 00	 movsxd	 rax, DWORD PTR tv233[rsp]
  00509	e9 7d 06 00 00	 jmp	 $LN1@stbi__psd_
$LN49@stbi__psd_:
$LN48@stbi__psd_:

; 6237 :                 }
; 6238 :             }
; 6239 :         }

  0050e	e9 00 ff ff ff	 jmp	 $LN2@stbi__psd_
$LN3@stbi__psd_:

; 6240 :         
; 6241 :     } else {

  00513	e9 8f 02 00 00	 jmp	 $LN46@stbi__psd_
$LN45@stbi__psd_:

; 6242 :         // We're at the raw image data.  It's each channel in order (Red, Green, Blue, Alpha, ...)
; 6243 :         // where each channel consists of an 8-bit (or 16-bit) value for each pixel in the image.
; 6244 :         
; 6245 :         // Read the data by channel.
; 6246 :         for (channel = 0; channel < 4; channel++) {

  00518	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR channel$[rsp], 0
  00520	eb 0a		 jmp	 SHORT $LN10@stbi__psd_
$LN8@stbi__psd_:
  00522	8b 44 24 34	 mov	 eax, DWORD PTR channel$[rsp]
  00526	ff c0		 inc	 eax
  00528	89 44 24 34	 mov	 DWORD PTR channel$[rsp], eax
$LN10@stbi__psd_:
  0052c	83 7c 24 34 04	 cmp	 DWORD PTR channel$[rsp], 4
  00531	0f 8d 70 02 00
	00		 jge	 $LN9@stbi__psd_

; 6247 :             if (channel >= channelCount) {

  00537	8b 44 24 50	 mov	 eax, DWORD PTR channelCount$[rsp]
  0053b	39 44 24 34	 cmp	 DWORD PTR channel$[rsp], eax
  0053f	0f 8c 2f 01 00
	00		 jl	 $LN50@stbi__psd_

; 6248 :                 // Fill this channel with default data.
; 6249 :                 if (bitdepth == 16 && bpc == 16) {

  00545	83 7c 24 54 10	 cmp	 DWORD PTR bitdepth$[rsp], 16
  0054a	0f 85 99 00 00
	00		 jne	 $LN52@stbi__psd_
  00550	83 bc 24 30 01
	00 00 10	 cmp	 DWORD PTR bpc$[rsp], 16
  00558	0f 85 8b 00 00
	00		 jne	 $LN52@stbi__psd_

; 6250 :                     stbi__uint16 *q = ((stbi__uint16 *) out) + channel;

  0055e	48 63 44 24 34	 movsxd	 rax, DWORD PTR channel$[rsp]
  00563	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  00568	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  0056c	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR q$13[rsp], rax

; 6251 :                     stbi__uint16 val = channel == 3 ? 65535 : 0;

  00574	83 7c 24 34 03	 cmp	 DWORD PTR channel$[rsp], 3
  00579	75 0d		 jne	 SHORT $LN93@stbi__psd_
  0057b	c7 84 24 a8 00
	00 00 ff ff 00
	00		 mov	 DWORD PTR tv244[rsp], 65535 ; 0000ffffH
  00586	eb 0b		 jmp	 SHORT $LN94@stbi__psd_
$LN93@stbi__psd_:
  00588	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv244[rsp], 0
$LN94@stbi__psd_:
  00593	0f b7 84 24 a8
	00 00 00	 movzx	 eax, WORD PTR tv244[rsp]
  0059b	66 89 44 24 70	 mov	 WORD PTR val$6[rsp], ax

; 6252 :                     for (i = 0; i < pixelCount; i++, q += 4)

  005a0	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  005a8	eb 1e		 jmp	 SHORT $LN13@stbi__psd_
$LN11@stbi__psd_:
  005aa	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  005ae	ff c0		 inc	 eax
  005b0	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  005b4	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR q$13[rsp]
  005bc	48 83 c0 08	 add	 rax, 8
  005c0	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR q$13[rsp], rax
$LN13@stbi__psd_:
  005c8	8b 44 24 4c	 mov	 eax, DWORD PTR pixelCount$[rsp]
  005cc	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  005d0	7d 12		 jge	 SHORT $LN12@stbi__psd_

; 6253 :                         *q = val;

  005d2	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR q$13[rsp]
  005da	0f b7 4c 24 70	 movzx	 ecx, WORD PTR val$6[rsp]
  005df	66 89 08	 mov	 WORD PTR [rax], cx
  005e2	eb c6		 jmp	 SHORT $LN11@stbi__psd_
$LN12@stbi__psd_:

; 6254 :                 } else {

  005e4	e9 86 00 00 00	 jmp	 $LN53@stbi__psd_
$LN52@stbi__psd_:

; 6255 :                     stbi_uc *p = out+channel;

  005e9	48 63 44 24 34	 movsxd	 rax, DWORD PTR channel$[rsp]
  005ee	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  005f3	48 03 c8	 add	 rcx, rax
  005f6	48 8b c1	 mov	 rax, rcx
  005f9	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR p$14[rsp], rax

; 6256 :                     stbi_uc val = channel == 3 ? 255 : 0;

  00601	83 7c 24 34 03	 cmp	 DWORD PTR channel$[rsp], 3
  00606	75 0d		 jne	 SHORT $LN95@stbi__psd_
  00608	c7 84 24 ac 00
	00 00 ff 00 00
	00		 mov	 DWORD PTR tv252[rsp], 255 ; 000000ffH
  00613	eb 0b		 jmp	 SHORT $LN96@stbi__psd_
$LN95@stbi__psd_:
  00615	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv252[rsp], 0
$LN96@stbi__psd_:
  00620	0f b6 84 24 ac
	00 00 00	 movzx	 eax, BYTE PTR tv252[rsp]
  00628	88 44 24 48	 mov	 BYTE PTR val$1[rsp], al

; 6257 :                     for (i = 0; i < pixelCount; i++, p += 4)

  0062c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00634	eb 1e		 jmp	 SHORT $LN16@stbi__psd_
$LN14@stbi__psd_:
  00636	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0063a	ff c0		 inc	 eax
  0063c	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00640	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR p$14[rsp]
  00648	48 83 c0 04	 add	 rax, 4
  0064c	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR p$14[rsp], rax
$LN16@stbi__psd_:
  00654	8b 44 24 4c	 mov	 eax, DWORD PTR pixelCount$[rsp]
  00658	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  0065c	7d 11		 jge	 SHORT $LN15@stbi__psd_

; 6258 :                         *p = val;

  0065e	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR p$14[rsp]
  00666	0f b6 4c 24 48	 movzx	 ecx, BYTE PTR val$1[rsp]
  0066b	88 08		 mov	 BYTE PTR [rax], cl
  0066d	eb c7		 jmp	 SHORT $LN14@stbi__psd_
$LN15@stbi__psd_:
$LN53@stbi__psd_:

; 6259 :                 }
; 6260 :             } else {

  0066f	e9 2e 01 00 00	 jmp	 $LN51@stbi__psd_
$LN50@stbi__psd_:

; 6261 :                 if (ri->bits_per_channel == 16) {    // output bpc

  00674	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  0067c	83 38 10	 cmp	 DWORD PTR [rax], 16
  0067f	75 67		 jne	 SHORT $LN54@stbi__psd_

; 6262 :                     stbi__uint16 *q = ((stbi__uint16 *) out) + channel;

  00681	48 63 44 24 34	 movsxd	 rax, DWORD PTR channel$[rsp]
  00686	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  0068b	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  0068f	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR q$15[rsp], rax

; 6263 :                     for (i = 0; i < pixelCount; i++, q += 4)

  00697	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0069f	eb 1e		 jmp	 SHORT $LN19@stbi__psd_
$LN17@stbi__psd_:
  006a1	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  006a5	ff c0		 inc	 eax
  006a7	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  006ab	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR q$15[rsp]
  006b3	48 83 c0 08	 add	 rax, 8
  006b7	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR q$15[rsp], rax
$LN19@stbi__psd_:
  006bf	8b 44 24 4c	 mov	 eax, DWORD PTR pixelCount$[rsp]
  006c3	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  006c7	7d 1a		 jge	 SHORT $LN18@stbi__psd_

; 6264 :                         *q = (stbi__uint16) stbi__get16be(s);

  006c9	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006d1	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  006d6	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR q$15[rsp]
  006de	66 89 01	 mov	 WORD PTR [rcx], ax
  006e1	eb be		 jmp	 SHORT $LN17@stbi__psd_
$LN18@stbi__psd_:

; 6265 :                 } else {

  006e3	e9 ba 00 00 00	 jmp	 $LN55@stbi__psd_
$LN54@stbi__psd_:

; 6266 :                     stbi_uc *p = out+channel;

  006e8	48 63 44 24 34	 movsxd	 rax, DWORD PTR channel$[rsp]
  006ed	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  006f2	48 03 c8	 add	 rcx, rax
  006f5	48 8b c1	 mov	 rax, rcx
  006f8	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR p$9[rsp], rax

; 6267 :                     if (bitdepth == 16) {  // input bpc

  00700	83 7c 24 54 10	 cmp	 DWORD PTR bitdepth$[rsp], 16
  00705	75 50		 jne	 SHORT $LN56@stbi__psd_

; 6268 :                         for (i = 0; i < pixelCount; i++, p += 4)

  00707	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0070f	eb 1e		 jmp	 SHORT $LN22@stbi__psd_
$LN20@stbi__psd_:
  00711	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00715	ff c0		 inc	 eax
  00717	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  0071b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$9[rsp]
  00723	48 83 c0 04	 add	 rax, 4
  00727	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR p$9[rsp], rax
$LN22@stbi__psd_:
  0072f	8b 44 24 4c	 mov	 eax, DWORD PTR pixelCount$[rsp]
  00733	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00737	7d 1c		 jge	 SHORT $LN21@stbi__psd_

; 6269 :                             *p = (stbi_uc) (stbi__get16be(s) >> 8);

  00739	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00741	e8 00 00 00 00	 call	 ?stbi__get16be@@YAHPEAUstbi__context@@@Z ; stbi__get16be
  00746	c1 f8 08	 sar	 eax, 8
  00749	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR p$9[rsp]
  00751	88 01		 mov	 BYTE PTR [rcx], al
  00753	eb bc		 jmp	 SHORT $LN20@stbi__psd_
$LN21@stbi__psd_:

; 6270 :                     } else {

  00755	eb 4b		 jmp	 SHORT $LN57@stbi__psd_
$LN56@stbi__psd_:

; 6271 :                         for (i = 0; i < pixelCount; i++, p += 4)

  00757	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0075f	eb 1e		 jmp	 SHORT $LN25@stbi__psd_
$LN23@stbi__psd_:
  00761	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00765	ff c0		 inc	 eax
  00767	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  0076b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$9[rsp]
  00773	48 83 c0 04	 add	 rax, 4
  00777	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR p$9[rsp], rax
$LN25@stbi__psd_:
  0077f	8b 44 24 4c	 mov	 eax, DWORD PTR pixelCount$[rsp]
  00783	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00787	7d 19		 jge	 SHORT $LN24@stbi__psd_

; 6272 :                             *p = stbi__get8(s);

  00789	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00791	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00796	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR p$9[rsp]
  0079e	88 01		 mov	 BYTE PTR [rcx], al
  007a0	eb bf		 jmp	 SHORT $LN23@stbi__psd_
$LN24@stbi__psd_:
$LN57@stbi__psd_:
$LN55@stbi__psd_:
$LN51@stbi__psd_:

; 6273 :                     }
; 6274 :                 }
; 6275 :             }
; 6276 :         }

  007a2	e9 7b fd ff ff	 jmp	 $LN8@stbi__psd_
$LN9@stbi__psd_:
$LN46@stbi__psd_:

; 6277 :     }
; 6278 :     
; 6279 :     // remove weird white matte from PSD
; 6280 :     if (channelCount >= 4) {

  007a7	83 7c 24 50 04	 cmp	 DWORD PTR channelCount$[rsp], 4
  007ac	0f 8c 1b 03 00
	00		 jl	 $LN58@stbi__psd_

; 6281 :         if (ri->bits_per_channel == 16) {

  007b2	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  007ba	83 38 10	 cmp	 DWORD PTR [rax], 16
  007bd	0f 85 88 01 00
	00		 jne	 $LN59@stbi__psd_

; 6282 :             for (i=0; i < w*h; ++i) {

  007c3	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  007cb	eb 0a		 jmp	 SHORT $LN28@stbi__psd_
$LN26@stbi__psd_:
  007cd	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  007d1	ff c0		 inc	 eax
  007d3	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN28@stbi__psd_:
  007d7	8b 44 24 3c	 mov	 eax, DWORD PTR w$[rsp]
  007db	0f af 44 24 38	 imul	 eax, DWORD PTR h$[rsp]
  007e0	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  007e4	0f 8d 5c 01 00
	00		 jge	 $LN27@stbi__psd_

; 6283 :                 stbi__uint16 *pixel = (stbi__uint16 *) out + 4*i;

  007ea	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  007ee	c1 e0 02	 shl	 eax, 2
  007f1	48 98		 cdqe
  007f3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  007f8	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  007fc	48 89 44 24 60	 mov	 QWORD PTR pixel$4[rsp], rax

; 6284 :                 if (pixel[3] != 0 && pixel[3] != 65535) {

  00801	b8 02 00 00 00	 mov	 eax, 2
  00806	48 6b c0 03	 imul	 rax, rax, 3
  0080a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pixel$4[rsp]
  0080f	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  00813	85 c0		 test	 eax, eax
  00815	0f 84 26 01 00
	00		 je	 $LN61@stbi__psd_
  0081b	b8 02 00 00 00	 mov	 eax, 2
  00820	48 6b c0 03	 imul	 rax, rax, 3
  00824	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pixel$4[rsp]
  00829	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  0082d	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00832	0f 84 09 01 00
	00		 je	 $LN61@stbi__psd_

; 6285 :                     float a = pixel[3] / 65535.0f;

  00838	b8 02 00 00 00	 mov	 eax, 2
  0083d	48 6b c0 03	 imul	 rax, rax, 3
  00841	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pixel$4[rsp]
  00846	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  0084a	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0084e	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@477fff00
  00856	f3 0f 11 84 24
	c8 00 00 00	 movss	 DWORD PTR a$11[rsp], xmm0

; 6286 :                     float ra = 1.0f / a;

  0085f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00867	f3 0f 5e 84 24
	c8 00 00 00	 divss	 xmm0, DWORD PTR a$11[rsp]
  00870	f3 0f 11 44 24
	58		 movss	 DWORD PTR ra$2[rsp], xmm0

; 6287 :                     float inv_a = 65535.0f * (1 - ra);

  00876	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0087e	f3 0f 5c 44 24
	58		 subss	 xmm0, DWORD PTR ra$2[rsp]
  00884	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@477fff00
  0088c	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00890	0f 28 c1	 movaps	 xmm0, xmm1
  00893	f3 0f 11 44 24
	78		 movss	 DWORD PTR inv_a$7[rsp], xmm0

; 6288 :                     pixel[0] = (stbi__uint16) (pixel[0]*ra + inv_a);

  00899	b8 02 00 00 00	 mov	 eax, 2
  0089e	48 6b c0 00	 imul	 rax, rax, 0
  008a2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pixel$4[rsp]
  008a7	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  008ab	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  008af	f3 0f 59 44 24
	58		 mulss	 xmm0, DWORD PTR ra$2[rsp]
  008b5	f3 0f 58 44 24
	78		 addss	 xmm0, DWORD PTR inv_a$7[rsp]
  008bb	f3 0f 2c c0	 cvttss2si eax, xmm0
  008bf	b9 02 00 00 00	 mov	 ecx, 2
  008c4	48 6b c9 00	 imul	 rcx, rcx, 0
  008c8	48 8b 54 24 60	 mov	 rdx, QWORD PTR pixel$4[rsp]
  008cd	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax

; 6289 :                     pixel[1] = (stbi__uint16) (pixel[1]*ra + inv_a);

  008d1	b8 02 00 00 00	 mov	 eax, 2
  008d6	48 6b c0 01	 imul	 rax, rax, 1
  008da	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pixel$4[rsp]
  008df	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  008e3	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  008e7	f3 0f 59 44 24
	58		 mulss	 xmm0, DWORD PTR ra$2[rsp]
  008ed	f3 0f 58 44 24
	78		 addss	 xmm0, DWORD PTR inv_a$7[rsp]
  008f3	f3 0f 2c c0	 cvttss2si eax, xmm0
  008f7	b9 02 00 00 00	 mov	 ecx, 2
  008fc	48 6b c9 01	 imul	 rcx, rcx, 1
  00900	48 8b 54 24 60	 mov	 rdx, QWORD PTR pixel$4[rsp]
  00905	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax

; 6290 :                     pixel[2] = (stbi__uint16) (pixel[2]*ra + inv_a);

  00909	b8 02 00 00 00	 mov	 eax, 2
  0090e	48 6b c0 02	 imul	 rax, rax, 2
  00912	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pixel$4[rsp]
  00917	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  0091b	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0091f	f3 0f 59 44 24
	58		 mulss	 xmm0, DWORD PTR ra$2[rsp]
  00925	f3 0f 58 44 24
	78		 addss	 xmm0, DWORD PTR inv_a$7[rsp]
  0092b	f3 0f 2c c0	 cvttss2si eax, xmm0
  0092f	b9 02 00 00 00	 mov	 ecx, 2
  00934	48 6b c9 02	 imul	 rcx, rcx, 2
  00938	48 8b 54 24 60	 mov	 rdx, QWORD PTR pixel$4[rsp]
  0093d	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax
$LN61@stbi__psd_:

; 6291 :                 }
; 6292 :             }

  00941	e9 87 fe ff ff	 jmp	 $LN26@stbi__psd_
$LN27@stbi__psd_:

; 6293 :         } else {

  00946	e9 82 01 00 00	 jmp	 $LN60@stbi__psd_
$LN59@stbi__psd_:

; 6294 :             for (i=0; i < w*h; ++i) {

  0094b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00953	eb 0a		 jmp	 SHORT $LN31@stbi__psd_
$LN29@stbi__psd_:
  00955	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00959	ff c0		 inc	 eax
  0095b	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN31@stbi__psd_:
  0095f	8b 44 24 3c	 mov	 eax, DWORD PTR w$[rsp]
  00963	0f af 44 24 38	 imul	 eax, DWORD PTR h$[rsp]
  00968	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  0096c	0f 8d 5b 01 00
	00		 jge	 $LN30@stbi__psd_

; 6295 :                 unsigned char *pixel = out + 4*i;

  00972	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00976	c1 e0 02	 shl	 eax, 2
  00979	48 98		 cdqe
  0097b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  00980	48 03 c8	 add	 rcx, rax
  00983	48 8b c1	 mov	 rax, rcx
  00986	48 89 44 24 68	 mov	 QWORD PTR pixel$5[rsp], rax

; 6296 :                 if (pixel[3] != 0 && pixel[3] != 255) {

  0098b	b8 01 00 00 00	 mov	 eax, 1
  00990	48 6b c0 03	 imul	 rax, rax, 3
  00994	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pixel$5[rsp]
  00999	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0099d	85 c0		 test	 eax, eax
  0099f	0f 84 23 01 00
	00		 je	 $LN62@stbi__psd_
  009a5	b8 01 00 00 00	 mov	 eax, 1
  009aa	48 6b c0 03	 imul	 rax, rax, 3
  009ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pixel$5[rsp]
  009b3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  009b7	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  009bc	0f 84 06 01 00
	00		 je	 $LN62@stbi__psd_

; 6297 :                     float a = pixel[3] / 255.0f;

  009c2	b8 01 00 00 00	 mov	 eax, 1
  009c7	48 6b c0 03	 imul	 rax, rax, 3
  009cb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pixel$5[rsp]
  009d0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  009d4	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  009d8	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@437f0000
  009e0	f3 0f 11 84 24
	cc 00 00 00	 movss	 DWORD PTR a$12[rsp], xmm0

; 6298 :                     float ra = 1.0f / a;

  009e9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  009f1	f3 0f 5e 84 24
	cc 00 00 00	 divss	 xmm0, DWORD PTR a$12[rsp]
  009fa	f3 0f 11 44 24
	5c		 movss	 DWORD PTR ra$3[rsp], xmm0

; 6299 :                     float inv_a = 255.0f * (1 - ra);

  00a00	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00a08	f3 0f 5c 44 24
	5c		 subss	 xmm0, DWORD PTR ra$3[rsp]
  00a0e	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@437f0000
  00a16	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00a1a	0f 28 c1	 movaps	 xmm0, xmm1
  00a1d	f3 0f 11 44 24
	7c		 movss	 DWORD PTR inv_a$8[rsp], xmm0

; 6300 :                     pixel[0] = (unsigned char) (pixel[0]*ra + inv_a);

  00a23	b8 01 00 00 00	 mov	 eax, 1
  00a28	48 6b c0 00	 imul	 rax, rax, 0
  00a2c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pixel$5[rsp]
  00a31	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00a35	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00a39	f3 0f 59 44 24
	5c		 mulss	 xmm0, DWORD PTR ra$3[rsp]
  00a3f	f3 0f 58 44 24
	7c		 addss	 xmm0, DWORD PTR inv_a$8[rsp]
  00a45	f3 0f 2c c0	 cvttss2si eax, xmm0
  00a49	b9 01 00 00 00	 mov	 ecx, 1
  00a4e	48 6b c9 00	 imul	 rcx, rcx, 0
  00a52	48 8b 54 24 68	 mov	 rdx, QWORD PTR pixel$5[rsp]
  00a57	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 6301 :                     pixel[1] = (unsigned char) (pixel[1]*ra + inv_a);

  00a5a	b8 01 00 00 00	 mov	 eax, 1
  00a5f	48 6b c0 01	 imul	 rax, rax, 1
  00a63	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pixel$5[rsp]
  00a68	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00a6c	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00a70	f3 0f 59 44 24
	5c		 mulss	 xmm0, DWORD PTR ra$3[rsp]
  00a76	f3 0f 58 44 24
	7c		 addss	 xmm0, DWORD PTR inv_a$8[rsp]
  00a7c	f3 0f 2c c0	 cvttss2si eax, xmm0
  00a80	b9 01 00 00 00	 mov	 ecx, 1
  00a85	48 6b c9 01	 imul	 rcx, rcx, 1
  00a89	48 8b 54 24 68	 mov	 rdx, QWORD PTR pixel$5[rsp]
  00a8e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 6302 :                     pixel[2] = (unsigned char) (pixel[2]*ra + inv_a);

  00a91	b8 01 00 00 00	 mov	 eax, 1
  00a96	48 6b c0 02	 imul	 rax, rax, 2
  00a9a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pixel$5[rsp]
  00a9f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00aa3	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00aa7	f3 0f 59 44 24
	5c		 mulss	 xmm0, DWORD PTR ra$3[rsp]
  00aad	f3 0f 58 44 24
	7c		 addss	 xmm0, DWORD PTR inv_a$8[rsp]
  00ab3	f3 0f 2c c0	 cvttss2si eax, xmm0
  00ab7	b9 01 00 00 00	 mov	 ecx, 1
  00abc	48 6b c9 02	 imul	 rcx, rcx, 2
  00ac0	48 8b 54 24 68	 mov	 rdx, QWORD PTR pixel$5[rsp]
  00ac5	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN62@stbi__psd_:

; 6303 :                 }
; 6304 :             }

  00ac8	e9 88 fe ff ff	 jmp	 $LN29@stbi__psd_
$LN30@stbi__psd_:
$LN60@stbi__psd_:
$LN58@stbi__psd_:

; 6305 :         }
; 6306 :     }
; 6307 :     
; 6308 :     // convert to desired output format
; 6309 :     if (req_comp && req_comp != 4) {

  00acd	83 bc 24 20 01
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  00ad5	74 7a		 je	 SHORT $LN63@stbi__psd_
  00ad7	83 bc 24 20 01
	00 00 04	 cmp	 DWORD PTR req_comp$[rsp], 4
  00adf	74 70		 je	 SHORT $LN63@stbi__psd_

; 6310 :         if (ri->bits_per_channel == 16)

  00ae1	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  00ae9	83 38 10	 cmp	 DWORD PTR [rax], 16
  00aec	75 2b		 jne	 SHORT $LN64@stbi__psd_

; 6311 :             out = (stbi_uc *) stbi__convert_format16((stbi__uint16 *) out, 4, req_comp, w, h);

  00aee	8b 44 24 38	 mov	 eax, DWORD PTR h$[rsp]
  00af2	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00af6	44 8b 4c 24 3c	 mov	 r9d, DWORD PTR w$[rsp]
  00afb	44 8b 84 24 20
	01 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  00b03	ba 04 00 00 00	 mov	 edx, 4
  00b08	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  00b0d	e8 00 00 00 00	 call	 ?stbi__convert_format16@@YAPEAGPEAGHHII@Z ; stbi__convert_format16
  00b12	48 89 44 24 40	 mov	 QWORD PTR out$[rsp], rax
  00b17	eb 29		 jmp	 SHORT $LN65@stbi__psd_
$LN64@stbi__psd_:

; 6312 :         else
; 6313 :             out = stbi__convert_format(out, 4, req_comp, w, h);

  00b19	8b 44 24 38	 mov	 eax, DWORD PTR h$[rsp]
  00b1d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00b21	44 8b 4c 24 3c	 mov	 r9d, DWORD PTR w$[rsp]
  00b26	44 8b 84 24 20
	01 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  00b2e	ba 04 00 00 00	 mov	 edx, 4
  00b33	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  00b38	e8 00 00 00 00	 call	 ?stbi__convert_format@@YAPEAEPEAEHHII@Z ; stbi__convert_format
  00b3d	48 89 44 24 40	 mov	 QWORD PTR out$[rsp], rax
$LN65@stbi__psd_:

; 6314 :         if (out == NULL) return out; // stbi__convert_format frees input on failure

  00b42	48 83 7c 24 40
	00		 cmp	 QWORD PTR out$[rsp], 0
  00b48	75 07		 jne	 SHORT $LN66@stbi__psd_
  00b4a	48 8b 44 24 40	 mov	 rax, QWORD PTR out$[rsp]
  00b4f	eb 3a		 jmp	 SHORT $LN1@stbi__psd_
$LN66@stbi__psd_:
$LN63@stbi__psd_:

; 6315 :     }
; 6316 :     
; 6317 :     if (comp) *comp = 4;

  00b51	48 83 bc 24 18
	01 00 00 00	 cmp	 QWORD PTR comp$[rsp], 0
  00b5a	74 0e		 je	 SHORT $LN67@stbi__psd_
  00b5c	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  00b64	c7 00 04 00 00
	00		 mov	 DWORD PTR [rax], 4
$LN67@stbi__psd_:

; 6318 :     *y = h;

  00b6a	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR y$[rsp]
  00b72	8b 4c 24 38	 mov	 ecx, DWORD PTR h$[rsp]
  00b76	89 08		 mov	 DWORD PTR [rax], ecx

; 6319 :     *x = w;

  00b78	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR x$[rsp]
  00b80	8b 4c 24 3c	 mov	 ecx, DWORD PTR w$[rsp]
  00b84	89 08		 mov	 DWORD PTR [rax], ecx

; 6320 :     
; 6321 :     return out;

  00b86	48 8b 44 24 40	 mov	 rax, QWORD PTR out$[rsp]
$LN1@stbi__psd_:

; 6322 : }

  00b8b	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  00b92	c3		 ret	 0
?stbi__psd_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@H@Z ENDP ; stbi__psd_load
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv67 = 32
r$ = 36
s$ = 64
?stbi__psd_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__psd_test

; 6079 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6080 :     int r = (stbi__get32be(s) == 0x38425053);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__get32be@@YAIPEAUstbi__context@@@Z ; stbi__get32be
  00013	3d 53 50 42 38	 cmp	 eax, 943870035		; 38425053H
  00018	75 0a		 jne	 SHORT $LN3@stbi__psd_
  0001a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv67[rsp], 1
  00022	eb 08		 jmp	 SHORT $LN4@stbi__psd_
$LN3@stbi__psd_:
  00024	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv67[rsp], 0
$LN4@stbi__psd_:
  0002c	8b 44 24 20	 mov	 eax, DWORD PTR tv67[rsp]
  00030	89 44 24 24	 mov	 DWORD PTR r$[rsp], eax

; 6081 :     stbi__rewind(s);

  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00039	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 6082 :     return r;

  0003e	8b 44 24 24	 mov	 eax, DWORD PTR r$[rsp]

; 6083 : }

  00042	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00046	c3		 ret	 0
?stbi__psd_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__psd_test
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tga_image_type$ = 32
sz$ = 36
tga_colormap_bpp$ = 40
tga_bits_per_pixel$ = 44
tga_comp$ = 48
tga_colormap_type$ = 52
tv153 = 56
tga_w$ = 60
tga_h$ = 64
s$ = 96
x$ = 104
y$ = 112
comp$ = 120
?stbi__tga_info@@YAHPEAUstbi__context@@PEAH11@Z PROC	; stbi__tga_info

; 5753 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 5754 :     int tga_w, tga_h, tga_comp, tga_image_type, tga_bits_per_pixel, tga_colormap_bpp;
; 5755 :     int sz, tga_colormap_type;
; 5756 :     stbi__get8(s);                   // discard Offset

  00018	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0001d	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8

; 5757 :     tga_colormap_type = stbi__get8(s); // colormap type

  00022	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00027	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0002c	0f b6 c0	 movzx	 eax, al
  0002f	89 44 24 34	 mov	 DWORD PTR tga_colormap_type$[rsp], eax

; 5758 :     if( tga_colormap_type > 1 ) {

  00033	83 7c 24 34 01	 cmp	 DWORD PTR tga_colormap_type$[rsp], 1
  00038	7e 11		 jle	 SHORT $LN2@stbi__tga_

; 5759 :         stbi__rewind(s);

  0003a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0003f	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 5760 :         return 0;      // only RGB or indexed allowed

  00044	33 c0		 xor	 eax, eax
  00046	e9 14 02 00 00	 jmp	 $LN1@stbi__tga_
$LN2@stbi__tga_:

; 5761 :     }
; 5762 :     tga_image_type = stbi__get8(s); // image type

  0004b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00050	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00055	0f b6 c0	 movzx	 eax, al
  00058	89 44 24 20	 mov	 DWORD PTR tga_image_type$[rsp], eax

; 5763 :     if ( tga_colormap_type == 1 ) { // colormapped (paletted) image

  0005c	83 7c 24 34 01	 cmp	 DWORD PTR tga_colormap_type$[rsp], 1
  00061	0f 85 8c 00 00
	00		 jne	 $LN3@stbi__tga_

; 5764 :         if (tga_image_type != 1 && tga_image_type != 9) {

  00067	83 7c 24 20 01	 cmp	 DWORD PTR tga_image_type$[rsp], 1
  0006c	74 18		 je	 SHORT $LN5@stbi__tga_
  0006e	83 7c 24 20 09	 cmp	 DWORD PTR tga_image_type$[rsp], 9
  00073	74 11		 je	 SHORT $LN5@stbi__tga_

; 5765 :             stbi__rewind(s);

  00075	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0007a	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 5766 :             return 0;

  0007f	33 c0		 xor	 eax, eax
  00081	e9 d9 01 00 00	 jmp	 $LN1@stbi__tga_
$LN5@stbi__tga_:

; 5767 :         }
; 5768 :         stbi__skip(s,4);       // skip index of first colormap entry and number of entries

  00086	ba 04 00 00 00	 mov	 edx, 4
  0008b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00090	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 5769 :         sz = stbi__get8(s);    //   check bits per palette color entry

  00095	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0009a	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0009f	0f b6 c0	 movzx	 eax, al
  000a2	89 44 24 24	 mov	 DWORD PTR sz$[rsp], eax

; 5770 :         if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) {

  000a6	83 7c 24 24 08	 cmp	 DWORD PTR sz$[rsp], 8
  000ab	74 2d		 je	 SHORT $LN6@stbi__tga_
  000ad	83 7c 24 24 0f	 cmp	 DWORD PTR sz$[rsp], 15
  000b2	74 26		 je	 SHORT $LN6@stbi__tga_
  000b4	83 7c 24 24 10	 cmp	 DWORD PTR sz$[rsp], 16
  000b9	74 1f		 je	 SHORT $LN6@stbi__tga_
  000bb	83 7c 24 24 18	 cmp	 DWORD PTR sz$[rsp], 24
  000c0	74 18		 je	 SHORT $LN6@stbi__tga_
  000c2	83 7c 24 24 20	 cmp	 DWORD PTR sz$[rsp], 32	; 00000020H
  000c7	74 11		 je	 SHORT $LN6@stbi__tga_

; 5771 :             stbi__rewind(s);

  000c9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000ce	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 5772 :             return 0;

  000d3	33 c0		 xor	 eax, eax
  000d5	e9 85 01 00 00	 jmp	 $LN1@stbi__tga_
$LN6@stbi__tga_:

; 5773 :         }
; 5774 :         stbi__skip(s,4);       // skip image x and y origin

  000da	ba 04 00 00 00	 mov	 edx, 4
  000df	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000e4	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 5775 :         tga_colormap_bpp = sz;

  000e9	8b 44 24 24	 mov	 eax, DWORD PTR sz$[rsp]
  000ed	89 44 24 28	 mov	 DWORD PTR tga_colormap_bpp$[rsp], eax

; 5776 :     } else { // "normal" image w/o colormap - only RGB or grey allowed, +/- RLE

  000f1	eb 44		 jmp	 SHORT $LN4@stbi__tga_
$LN3@stbi__tga_:

; 5777 :         if ( (tga_image_type != 2) && (tga_image_type != 3) && (tga_image_type != 10) && (tga_image_type != 11) ) {

  000f3	83 7c 24 20 02	 cmp	 DWORD PTR tga_image_type$[rsp], 2
  000f8	74 26		 je	 SHORT $LN7@stbi__tga_
  000fa	83 7c 24 20 03	 cmp	 DWORD PTR tga_image_type$[rsp], 3
  000ff	74 1f		 je	 SHORT $LN7@stbi__tga_
  00101	83 7c 24 20 0a	 cmp	 DWORD PTR tga_image_type$[rsp], 10
  00106	74 18		 je	 SHORT $LN7@stbi__tga_
  00108	83 7c 24 20 0b	 cmp	 DWORD PTR tga_image_type$[rsp], 11
  0010d	74 11		 je	 SHORT $LN7@stbi__tga_

; 5778 :             stbi__rewind(s);

  0010f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00114	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 5779 :             return 0; // only RGB or grey allowed, +/- RLE

  00119	33 c0		 xor	 eax, eax
  0011b	e9 3f 01 00 00	 jmp	 $LN1@stbi__tga_
$LN7@stbi__tga_:

; 5780 :         }
; 5781 :         stbi__skip(s,9); // skip colormap specification and image x/y origin

  00120	ba 09 00 00 00	 mov	 edx, 9
  00125	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0012a	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 5782 :         tga_colormap_bpp = 0;

  0012f	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tga_colormap_bpp$[rsp], 0
$LN4@stbi__tga_:

; 5783 :     }
; 5784 :     tga_w = stbi__get16le(s);

  00137	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0013c	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  00141	89 44 24 3c	 mov	 DWORD PTR tga_w$[rsp], eax

; 5785 :     if( tga_w < 1 ) {

  00145	83 7c 24 3c 01	 cmp	 DWORD PTR tga_w$[rsp], 1
  0014a	7d 11		 jge	 SHORT $LN8@stbi__tga_

; 5786 :         stbi__rewind(s);

  0014c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00151	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 5787 :         return 0;   // test width

  00156	33 c0		 xor	 eax, eax
  00158	e9 02 01 00 00	 jmp	 $LN1@stbi__tga_
$LN8@stbi__tga_:

; 5788 :     }
; 5789 :     tga_h = stbi__get16le(s);

  0015d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00162	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  00167	89 44 24 40	 mov	 DWORD PTR tga_h$[rsp], eax

; 5790 :     if( tga_h < 1 ) {

  0016b	83 7c 24 40 01	 cmp	 DWORD PTR tga_h$[rsp], 1
  00170	7d 11		 jge	 SHORT $LN9@stbi__tga_

; 5791 :         stbi__rewind(s);

  00172	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00177	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 5792 :         return 0;   // test height

  0017c	33 c0		 xor	 eax, eax
  0017e	e9 dc 00 00 00	 jmp	 $LN1@stbi__tga_
$LN9@stbi__tga_:

; 5793 :     }
; 5794 :     tga_bits_per_pixel = stbi__get8(s); // bits per pixel

  00183	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00188	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0018d	0f b6 c0	 movzx	 eax, al
  00190	89 44 24 2c	 mov	 DWORD PTR tga_bits_per_pixel$[rsp], eax

; 5795 :     stbi__get8(s); // ignore alpha bits

  00194	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00199	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8

; 5796 :     if (tga_colormap_bpp != 0) {

  0019e	83 7c 24 28 00	 cmp	 DWORD PTR tga_colormap_bpp$[rsp], 0
  001a3	74 33		 je	 SHORT $LN10@stbi__tga_

; 5797 :         if((tga_bits_per_pixel != 8) && (tga_bits_per_pixel != 16)) {

  001a5	83 7c 24 2c 08	 cmp	 DWORD PTR tga_bits_per_pixel$[rsp], 8
  001aa	74 18		 je	 SHORT $LN12@stbi__tga_
  001ac	83 7c 24 2c 10	 cmp	 DWORD PTR tga_bits_per_pixel$[rsp], 16
  001b1	74 11		 je	 SHORT $LN12@stbi__tga_

; 5798 :             // when using a colormap, tga_bits_per_pixel is the size of the indexes
; 5799 :             // I don't think anything but 8 or 16bit indexes makes sense
; 5800 :             stbi__rewind(s);

  001b3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001b8	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 5801 :             return 0;

  001bd	33 c0		 xor	 eax, eax
  001bf	e9 9b 00 00 00	 jmp	 $LN1@stbi__tga_
$LN12@stbi__tga_:

; 5802 :         }
; 5803 :         tga_comp = stbi__tga_get_comp(tga_colormap_bpp, 0, NULL);

  001c4	45 33 c0	 xor	 r8d, r8d
  001c7	33 d2		 xor	 edx, edx
  001c9	8b 4c 24 28	 mov	 ecx, DWORD PTR tga_colormap_bpp$[rsp]
  001cd	e8 00 00 00 00	 call	 ?stbi__tga_get_comp@@YAHHHPEAH@Z ; stbi__tga_get_comp
  001d2	89 44 24 30	 mov	 DWORD PTR tga_comp$[rsp], eax

; 5804 :     } else {

  001d6	eb 34		 jmp	 SHORT $LN11@stbi__tga_
$LN10@stbi__tga_:

; 5805 :         tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3) || (tga_image_type == 11), NULL);

  001d8	83 7c 24 20 03	 cmp	 DWORD PTR tga_image_type$[rsp], 3
  001dd	74 11		 je	 SHORT $LN18@stbi__tga_
  001df	83 7c 24 20 0b	 cmp	 DWORD PTR tga_image_type$[rsp], 11
  001e4	74 0a		 je	 SHORT $LN18@stbi__tga_
  001e6	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv153[rsp], 0
  001ee	eb 08		 jmp	 SHORT $LN19@stbi__tga_
$LN18@stbi__tga_:
  001f0	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv153[rsp], 1
$LN19@stbi__tga_:
  001f8	45 33 c0	 xor	 r8d, r8d
  001fb	8b 54 24 38	 mov	 edx, DWORD PTR tv153[rsp]
  001ff	8b 4c 24 2c	 mov	 ecx, DWORD PTR tga_bits_per_pixel$[rsp]
  00203	e8 00 00 00 00	 call	 ?stbi__tga_get_comp@@YAHHHPEAH@Z ; stbi__tga_get_comp
  00208	89 44 24 30	 mov	 DWORD PTR tga_comp$[rsp], eax
$LN11@stbi__tga_:

; 5806 :     }
; 5807 :     if(!tga_comp) {

  0020c	83 7c 24 30 00	 cmp	 DWORD PTR tga_comp$[rsp], 0
  00211	75 0e		 jne	 SHORT $LN13@stbi__tga_

; 5808 :         stbi__rewind(s);

  00213	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00218	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 5809 :         return 0;

  0021d	33 c0		 xor	 eax, eax
  0021f	eb 3e		 jmp	 SHORT $LN1@stbi__tga_
$LN13@stbi__tga_:

; 5810 :     }
; 5811 :     if (x) *x = tga_w;

  00221	48 83 7c 24 68
	00		 cmp	 QWORD PTR x$[rsp], 0
  00227	74 0b		 je	 SHORT $LN14@stbi__tga_
  00229	48 8b 44 24 68	 mov	 rax, QWORD PTR x$[rsp]
  0022e	8b 4c 24 3c	 mov	 ecx, DWORD PTR tga_w$[rsp]
  00232	89 08		 mov	 DWORD PTR [rax], ecx
$LN14@stbi__tga_:

; 5812 :     if (y) *y = tga_h;

  00234	48 83 7c 24 70
	00		 cmp	 QWORD PTR y$[rsp], 0
  0023a	74 0b		 je	 SHORT $LN15@stbi__tga_
  0023c	48 8b 44 24 70	 mov	 rax, QWORD PTR y$[rsp]
  00241	8b 4c 24 40	 mov	 ecx, DWORD PTR tga_h$[rsp]
  00245	89 08		 mov	 DWORD PTR [rax], ecx
$LN15@stbi__tga_:

; 5813 :     if (comp) *comp = tga_comp;

  00247	48 83 7c 24 78
	00		 cmp	 QWORD PTR comp$[rsp], 0
  0024d	74 0b		 je	 SHORT $LN16@stbi__tga_
  0024f	48 8b 44 24 78	 mov	 rax, QWORD PTR comp$[rsp]
  00254	8b 4c 24 30	 mov	 ecx, DWORD PTR tga_comp$[rsp]
  00258	89 08		 mov	 DWORD PTR [rax], ecx
$LN16@stbi__tga_:

; 5814 :     return 1;                   // seems to have passed everything

  0025a	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__tga_:

; 5815 : }

  0025f	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00263	c3		 ret	 0
?stbi__tga_info@@YAHPEAUstbi__context@@PEAH11@Z ENDP	; stbi__tga_info
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tga_comp$ = 48
j$ = 52
i$ = 56
tga_width$ = 60
tga_height$ = 64
temp$1 = 68
temp$2 = 69
tga_palette_len$ = 72
tga_data$ = 80
tga_rgb16$ = 88
pal_idx$3 = 92
read_next_pixel$ = 96
tga_image_type$ = 100
tga_indexed$ = 104
raw_data$ = 108
RLE_count$ = 112
tga_inverted$ = 116
index1$4 = 120
index2$5 = 124
tga_palette$ = 128
tga_is_RLE$ = 136
tga_palette_bits$ = 140
tga_pixel$6 = 144
tv162 = 152
tv174 = 156
tv185 = 160
tv197 = 164
tv212 = 168
tv225 = 172
tv250 = 176
RLE_cmd$7 = 180
RLE_repeating$ = 184
tga_bits_per_pixel$ = 188
tv272 = 192
tga_y_origin$ = 196
tga_x_origin$ = 200
tga_palette_start$ = 204
tv134 = 208
tv140 = 212
tv155 = 216
row$8 = 220
tga_offset$ = 224
pal_entry$9 = 232
tga_row$10 = 240
s$ = 272
x$ = 280
y$ = 288
comp$ = 296
req_comp$ = 304
ri$ = 312
?stbi__tga_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z PROC ; stbi__tga_load

; 5869 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 00 01
	00 00		 sub	 rsp, 256		; 00000100H

; 5870 :     //   read in the TGA header stuff
; 5871 :     int tga_offset = stbi__get8(s);

  0001c	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00024	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00029	0f b6 c0	 movzx	 eax, al
  0002c	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tga_offset$[rsp], eax

; 5872 :     int tga_indexed = stbi__get8(s);

  00033	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0003b	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00040	0f b6 c0	 movzx	 eax, al
  00043	89 44 24 68	 mov	 DWORD PTR tga_indexed$[rsp], eax

; 5873 :     int tga_image_type = stbi__get8(s);

  00047	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0004f	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00054	0f b6 c0	 movzx	 eax, al
  00057	89 44 24 64	 mov	 DWORD PTR tga_image_type$[rsp], eax

; 5874 :     int tga_is_RLE = 0;

  0005b	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tga_is_RLE$[rsp], 0

; 5875 :     int tga_palette_start = stbi__get16le(s);

  00066	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0006e	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  00073	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tga_palette_start$[rsp], eax

; 5876 :     int tga_palette_len = stbi__get16le(s);

  0007a	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00082	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  00087	89 44 24 48	 mov	 DWORD PTR tga_palette_len$[rsp], eax

; 5877 :     int tga_palette_bits = stbi__get8(s);

  0008b	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00093	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00098	0f b6 c0	 movzx	 eax, al
  0009b	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tga_palette_bits$[rsp], eax

; 5878 :     int tga_x_origin = stbi__get16le(s);

  000a2	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000aa	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  000af	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tga_x_origin$[rsp], eax

; 5879 :     int tga_y_origin = stbi__get16le(s);

  000b6	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000be	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  000c3	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tga_y_origin$[rsp], eax

; 5880 :     int tga_width = stbi__get16le(s);

  000ca	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000d2	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  000d7	89 44 24 3c	 mov	 DWORD PTR tga_width$[rsp], eax

; 5881 :     int tga_height = stbi__get16le(s);

  000db	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000e3	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  000e8	89 44 24 40	 mov	 DWORD PTR tga_height$[rsp], eax

; 5882 :     int tga_bits_per_pixel = stbi__get8(s);

  000ec	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000f4	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  000f9	0f b6 c0	 movzx	 eax, al
  000fc	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tga_bits_per_pixel$[rsp], eax

; 5883 :     int tga_comp, tga_rgb16=0;

  00103	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tga_rgb16$[rsp], 0

; 5884 :     int tga_inverted = stbi__get8(s);

  0010b	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00113	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00118	0f b6 c0	 movzx	 eax, al
  0011b	89 44 24 74	 mov	 DWORD PTR tga_inverted$[rsp], eax

; 5885 :     // int tga_alpha_bits = tga_inverted & 15; // the 4 lowest bits - unused (useless?)
; 5886 :     //   image data
; 5887 :     unsigned char *tga_data;
; 5888 :     unsigned char *tga_palette = NULL;

  0011f	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tga_palette$[rsp], 0

; 5889 :     int i, j;
; 5890 :     unsigned char raw_data[4] = {0};

  0012b	48 8d 44 24 6c	 lea	 rax, QWORD PTR raw_data$[rsp]
  00130	48 8b f8	 mov	 rdi, rax
  00133	33 c0		 xor	 eax, eax
  00135	b9 04 00 00 00	 mov	 ecx, 4
  0013a	f3 aa		 rep stosb

; 5891 :     int RLE_count = 0;

  0013c	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR RLE_count$[rsp], 0

; 5892 :     int RLE_repeating = 0;

  00144	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR RLE_repeating$[rsp], 0

; 5893 :     int read_next_pixel = 1;

  0014f	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR read_next_pixel$[rsp], 1

; 5894 :     STBI_NOTUSED(ri);
; 5895 :     STBI_NOTUSED(tga_x_origin); // @TODO
; 5896 :     STBI_NOTUSED(tga_y_origin); // @TODO
; 5897 :     
; 5898 :     if (tga_height > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

  00157	81 7c 24 40 00
	00 00 01	 cmp	 DWORD PTR tga_height$[rsp], 16777216 ; 01000000H
  0015f	7e 35		 jle	 SHORT $LN29@stbi__tga_
  00161	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81231
  00168	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0016d	85 c0		 test	 eax, eax
  0016f	74 0d		 je	 SHORT $LN62@stbi__tga_
  00171	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv134[rsp], 0
  0017c	eb 0b		 jmp	 SHORT $LN63@stbi__tga_
$LN62@stbi__tga_:
  0017e	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv134[rsp], 0
$LN63@stbi__tga_:
  00189	48 63 84 24 d0
	00 00 00	 movsxd	 rax, DWORD PTR tv134[rsp]
  00191	e9 d8 08 00 00	 jmp	 $LN1@stbi__tga_
$LN29@stbi__tga_:

; 5899 :     if (tga_width > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

  00196	81 7c 24 3c 00
	00 00 01	 cmp	 DWORD PTR tga_width$[rsp], 16777216 ; 01000000H
  0019e	7e 35		 jle	 SHORT $LN30@stbi__tga_
  001a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81233
  001a7	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  001ac	85 c0		 test	 eax, eax
  001ae	74 0d		 je	 SHORT $LN64@stbi__tga_
  001b0	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv140[rsp], 0
  001bb	eb 0b		 jmp	 SHORT $LN65@stbi__tga_
$LN64@stbi__tga_:
  001bd	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv140[rsp], 0
$LN65@stbi__tga_:
  001c8	48 63 84 24 d4
	00 00 00	 movsxd	 rax, DWORD PTR tv140[rsp]
  001d0	e9 99 08 00 00	 jmp	 $LN1@stbi__tga_
$LN30@stbi__tga_:

; 5900 :     
; 5901 :     //   do a tiny bit of precessing
; 5902 :     if ( tga_image_type >= 8 )

  001d5	83 7c 24 64 08	 cmp	 DWORD PTR tga_image_type$[rsp], 8
  001da	7c 16		 jl	 SHORT $LN31@stbi__tga_

; 5903 :     {
; 5904 :         tga_image_type -= 8;

  001dc	8b 44 24 64	 mov	 eax, DWORD PTR tga_image_type$[rsp]
  001e0	83 e8 08	 sub	 eax, 8
  001e3	89 44 24 64	 mov	 DWORD PTR tga_image_type$[rsp], eax

; 5905 :         tga_is_RLE = 1;

  001e7	c7 84 24 88 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tga_is_RLE$[rsp], 1
$LN31@stbi__tga_:

; 5906 :     }
; 5907 :     tga_inverted = 1 - ((tga_inverted >> 5) & 1);

  001f2	8b 44 24 74	 mov	 eax, DWORD PTR tga_inverted$[rsp]
  001f6	c1 f8 05	 sar	 eax, 5
  001f9	83 e0 01	 and	 eax, 1
  001fc	b9 01 00 00 00	 mov	 ecx, 1
  00201	2b c8		 sub	 ecx, eax
  00203	8b c1		 mov	 eax, ecx
  00205	89 44 24 74	 mov	 DWORD PTR tga_inverted$[rsp], eax

; 5908 :     
; 5909 :     //   If I'm paletted, then I'll use the number of bits from the palette
; 5910 :     if ( tga_indexed ) tga_comp = stbi__tga_get_comp(tga_palette_bits, 0, &tga_rgb16);

  00209	83 7c 24 68 00	 cmp	 DWORD PTR tga_indexed$[rsp], 0
  0020e	74 19		 je	 SHORT $LN32@stbi__tga_
  00210	4c 8d 44 24 58	 lea	 r8, QWORD PTR tga_rgb16$[rsp]
  00215	33 d2		 xor	 edx, edx
  00217	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tga_palette_bits$[rsp]
  0021e	e8 00 00 00 00	 call	 ?stbi__tga_get_comp@@YAHHHPEAH@Z ; stbi__tga_get_comp
  00223	89 44 24 30	 mov	 DWORD PTR tga_comp$[rsp], eax
  00227	eb 3b		 jmp	 SHORT $LN33@stbi__tga_
$LN32@stbi__tga_:

; 5911 :     else tga_comp = stbi__tga_get_comp(tga_bits_per_pixel, (tga_image_type == 3), &tga_rgb16);

  00229	83 7c 24 64 03	 cmp	 DWORD PTR tga_image_type$[rsp], 3
  0022e	75 0d		 jne	 SHORT $LN66@stbi__tga_
  00230	c7 84 24 d8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv155[rsp], 1
  0023b	eb 0b		 jmp	 SHORT $LN67@stbi__tga_
$LN66@stbi__tga_:
  0023d	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv155[rsp], 0
$LN67@stbi__tga_:
  00248	4c 8d 44 24 58	 lea	 r8, QWORD PTR tga_rgb16$[rsp]
  0024d	8b 94 24 d8 00
	00 00		 mov	 edx, DWORD PTR tv155[rsp]
  00254	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tga_bits_per_pixel$[rsp]
  0025b	e8 00 00 00 00	 call	 ?stbi__tga_get_comp@@YAHHHPEAH@Z ; stbi__tga_get_comp
  00260	89 44 24 30	 mov	 DWORD PTR tga_comp$[rsp], eax
$LN33@stbi__tga_:

; 5912 :     
; 5913 :     if(!tga_comp) // shouldn't really happen, stbi__tga_test() should have ensured basic consistency

  00264	83 7c 24 30 00	 cmp	 DWORD PTR tga_comp$[rsp], 0
  00269	75 35		 jne	 SHORT $LN34@stbi__tga_

; 5914 :         return stbi__errpuc("bad format", "Can't find out TGA pixelformat");

  0026b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81238
  00272	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00277	85 c0		 test	 eax, eax
  00279	74 0d		 je	 SHORT $LN68@stbi__tga_
  0027b	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv162[rsp], 0
  00286	eb 0b		 jmp	 SHORT $LN69@stbi__tga_
$LN68@stbi__tga_:
  00288	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv162[rsp], 0
$LN69@stbi__tga_:
  00293	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR tv162[rsp]
  0029b	e9 ce 07 00 00	 jmp	 $LN1@stbi__tga_
$LN34@stbi__tga_:

; 5915 :     
; 5916 :     //   tga info
; 5917 :     *x = tga_width;

  002a0	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR x$[rsp]
  002a8	8b 4c 24 3c	 mov	 ecx, DWORD PTR tga_width$[rsp]
  002ac	89 08		 mov	 DWORD PTR [rax], ecx

; 5918 :     *y = tga_height;

  002ae	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR y$[rsp]
  002b6	8b 4c 24 40	 mov	 ecx, DWORD PTR tga_height$[rsp]
  002ba	89 08		 mov	 DWORD PTR [rax], ecx

; 5919 :     if (comp) *comp = tga_comp;

  002bc	48 83 bc 24 28
	01 00 00 00	 cmp	 QWORD PTR comp$[rsp], 0
  002c5	74 0e		 je	 SHORT $LN35@stbi__tga_
  002c7	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  002cf	8b 4c 24 30	 mov	 ecx, DWORD PTR tga_comp$[rsp]
  002d3	89 08		 mov	 DWORD PTR [rax], ecx
$LN35@stbi__tga_:

; 5920 :     
; 5921 :     if (!stbi__mad3sizes_valid(tga_width, tga_height, tga_comp, 0))

  002d5	45 33 c9	 xor	 r9d, r9d
  002d8	44 8b 44 24 30	 mov	 r8d, DWORD PTR tga_comp$[rsp]
  002dd	8b 54 24 40	 mov	 edx, DWORD PTR tga_height$[rsp]
  002e1	8b 4c 24 3c	 mov	 ecx, DWORD PTR tga_width$[rsp]
  002e5	e8 00 00 00 00	 call	 ?stbi__mad3sizes_valid@@YAHHHHH@Z ; stbi__mad3sizes_valid
  002ea	85 c0		 test	 eax, eax
  002ec	75 35		 jne	 SHORT $LN36@stbi__tga_

; 5922 :         return stbi__errpuc("too large", "Corrupt TGA");

  002ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81241
  002f5	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  002fa	85 c0		 test	 eax, eax
  002fc	74 0d		 je	 SHORT $LN70@stbi__tga_
  002fe	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv174[rsp], 0
  00309	eb 0b		 jmp	 SHORT $LN71@stbi__tga_
$LN70@stbi__tga_:
  0030b	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv174[rsp], 0
$LN71@stbi__tga_:
  00316	48 63 84 24 9c
	00 00 00	 movsxd	 rax, DWORD PTR tv174[rsp]
  0031e	e9 4b 07 00 00	 jmp	 $LN1@stbi__tga_
$LN36@stbi__tga_:

; 5923 :     
; 5924 :     tga_data = (unsigned char*)stbi__malloc_mad3(tga_width, tga_height, tga_comp, 0);

  00323	45 33 c9	 xor	 r9d, r9d
  00326	44 8b 44 24 30	 mov	 r8d, DWORD PTR tga_comp$[rsp]
  0032b	8b 54 24 40	 mov	 edx, DWORD PTR tga_height$[rsp]
  0032f	8b 4c 24 3c	 mov	 ecx, DWORD PTR tga_width$[rsp]
  00333	e8 00 00 00 00	 call	 ?stbi__malloc_mad3@@YAPEAXHHHH@Z ; stbi__malloc_mad3
  00338	48 89 44 24 50	 mov	 QWORD PTR tga_data$[rsp], rax

; 5925 :     if (!tga_data) return stbi__errpuc("outofmem", "Out of memory");

  0033d	48 83 7c 24 50
	00		 cmp	 QWORD PTR tga_data$[rsp], 0
  00343	75 35		 jne	 SHORT $LN37@stbi__tga_
  00345	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81243
  0034c	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00351	85 c0		 test	 eax, eax
  00353	74 0d		 je	 SHORT $LN72@stbi__tga_
  00355	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv185[rsp], 0
  00360	eb 0b		 jmp	 SHORT $LN73@stbi__tga_
$LN72@stbi__tga_:
  00362	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv185[rsp], 0
$LN73@stbi__tga_:
  0036d	48 63 84 24 a0
	00 00 00	 movsxd	 rax, DWORD PTR tv185[rsp]
  00375	e9 f4 06 00 00	 jmp	 $LN1@stbi__tga_
$LN37@stbi__tga_:

; 5926 :     
; 5927 :     // skip to the data's starting position (offset usually = 0)
; 5928 :     stbi__skip(s, tga_offset );

  0037a	8b 94 24 e0 00
	00 00		 mov	 edx, DWORD PTR tga_offset$[rsp]
  00381	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00389	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 5929 :     
; 5930 :     if ( !tga_indexed && !tga_is_RLE && !tga_rgb16 ) {

  0038e	83 7c 24 68 00	 cmp	 DWORD PTR tga_indexed$[rsp], 0
  00393	0f 85 c3 00 00
	00		 jne	 $LN38@stbi__tga_
  00399	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR tga_is_RLE$[rsp], 0
  003a1	0f 85 b5 00 00
	00		 jne	 $LN38@stbi__tga_
  003a7	83 7c 24 58 00	 cmp	 DWORD PTR tga_rgb16$[rsp], 0
  003ac	0f 85 aa 00 00
	00		 jne	 $LN38@stbi__tga_

; 5931 :         for (i=0; i < tga_height; ++i) {

  003b2	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  003ba	eb 0a		 jmp	 SHORT $LN4@stbi__tga_
$LN2@stbi__tga_:
  003bc	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  003c0	ff c0		 inc	 eax
  003c2	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__tga_:
  003c6	8b 44 24 40	 mov	 eax, DWORD PTR tga_height$[rsp]
  003ca	39 44 24 38	 cmp	 DWORD PTR i$[rsp], eax
  003ce	0f 8d 83 00 00
	00		 jge	 $LN3@stbi__tga_

; 5932 :             int row = tga_inverted ? tga_height -i - 1 : i;

  003d4	83 7c 24 74 00	 cmp	 DWORD PTR tga_inverted$[rsp], 0
  003d9	74 17		 je	 SHORT $LN74@stbi__tga_
  003db	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  003df	8b 4c 24 40	 mov	 ecx, DWORD PTR tga_height$[rsp]
  003e3	2b c8		 sub	 ecx, eax
  003e5	8b c1		 mov	 eax, ecx
  003e7	ff c8		 dec	 eax
  003e9	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv197[rsp], eax
  003f0	eb 0b		 jmp	 SHORT $LN75@stbi__tga_
$LN74@stbi__tga_:
  003f2	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  003f6	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv197[rsp], eax
$LN75@stbi__tga_:
  003fd	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR tv197[rsp]
  00404	89 84 24 dc 00
	00 00		 mov	 DWORD PTR row$8[rsp], eax

; 5933 :             stbi_uc *tga_row = tga_data + row*tga_width*tga_comp;

  0040b	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR row$8[rsp]
  00412	0f af 44 24 3c	 imul	 eax, DWORD PTR tga_width$[rsp]
  00417	0f af 44 24 30	 imul	 eax, DWORD PTR tga_comp$[rsp]
  0041c	48 98		 cdqe
  0041e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tga_data$[rsp]
  00423	48 03 c8	 add	 rcx, rax
  00426	48 8b c1	 mov	 rax, rcx
  00429	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tga_row$10[rsp], rax

; 5934 :             stbi__getn(s, tga_row, tga_width * tga_comp);

  00431	8b 44 24 3c	 mov	 eax, DWORD PTR tga_width$[rsp]
  00435	0f af 44 24 30	 imul	 eax, DWORD PTR tga_comp$[rsp]
  0043a	44 8b c0	 mov	 r8d, eax
  0043d	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR tga_row$10[rsp]
  00445	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0044d	e8 00 00 00 00	 call	 ?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z ; stbi__getn

; 5935 :         }

  00452	e9 65 ff ff ff	 jmp	 $LN2@stbi__tga_
$LN3@stbi__tga_:

; 5936 :     } else  {

  00457	e9 d0 04 00 00	 jmp	 $LN39@stbi__tga_
$LN38@stbi__tga_:

; 5937 :         //   do I need to load a palette?
; 5938 :         if ( tga_indexed)

  0045c	83 7c 24 68 00	 cmp	 DWORD PTR tga_indexed$[rsp], 0
  00461	0f 84 bc 01 00
	00		 je	 $LN40@stbi__tga_

; 5939 :         {
; 5940 :             if (tga_palette_len == 0) {  /* you have to have at least one entry! */

  00467	83 7c 24 48 00	 cmp	 DWORD PTR tga_palette_len$[rsp], 0
  0046c	75 3f		 jne	 SHORT $LN41@stbi__tga_

; 5941 :                 STBI_FREE(tga_data);

  0046e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tga_data$[rsp]
  00473	e8 00 00 00 00	 call	 free

; 5942 :                 return stbi__errpuc("bad palette", "Corrupt TGA");

  00478	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81248
  0047f	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00484	85 c0		 test	 eax, eax
  00486	74 0d		 je	 SHORT $LN76@stbi__tga_
  00488	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv212[rsp], 0
  00493	eb 0b		 jmp	 SHORT $LN77@stbi__tga_
$LN76@stbi__tga_:
  00495	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv212[rsp], 0
$LN77@stbi__tga_:
  004a0	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR tv212[rsp]
  004a8	e9 c1 05 00 00	 jmp	 $LN1@stbi__tga_
$LN41@stbi__tga_:

; 5943 :             }
; 5944 :             
; 5945 :             //   any data to skip? (offset usually = 0)
; 5946 :             stbi__skip(s, tga_palette_start );

  004ad	8b 94 24 cc 00
	00 00		 mov	 edx, DWORD PTR tga_palette_start$[rsp]
  004b4	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004bc	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 5947 :             //   load the palette
; 5948 :             tga_palette = (unsigned char*)stbi__malloc_mad2(tga_palette_len, tga_comp, 0);

  004c1	45 33 c0	 xor	 r8d, r8d
  004c4	8b 54 24 30	 mov	 edx, DWORD PTR tga_comp$[rsp]
  004c8	8b 4c 24 48	 mov	 ecx, DWORD PTR tga_palette_len$[rsp]
  004cc	e8 00 00 00 00	 call	 ?stbi__malloc_mad2@@YAPEAXHHH@Z ; stbi__malloc_mad2
  004d1	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tga_palette$[rsp], rax

; 5949 :             if (!tga_palette) {

  004d9	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR tga_palette$[rsp], 0
  004e2	75 3f		 jne	 SHORT $LN42@stbi__tga_

; 5950 :                 STBI_FREE(tga_data);

  004e4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tga_data$[rsp]
  004e9	e8 00 00 00 00	 call	 free

; 5951 :                 return stbi__errpuc("outofmem", "Out of memory");

  004ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81250
  004f5	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  004fa	85 c0		 test	 eax, eax
  004fc	74 0d		 je	 SHORT $LN78@stbi__tga_
  004fe	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv225[rsp], 0
  00509	eb 0b		 jmp	 SHORT $LN79@stbi__tga_
$LN78@stbi__tga_:
  0050b	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv225[rsp], 0
$LN79@stbi__tga_:
  00516	48 63 84 24 ac
	00 00 00	 movsxd	 rax, DWORD PTR tv225[rsp]
  0051e	e9 4b 05 00 00	 jmp	 $LN1@stbi__tga_
$LN42@stbi__tga_:

; 5952 :             }
; 5953 :             if (tga_rgb16) {

  00523	83 7c 24 58 00	 cmp	 DWORD PTR tga_rgb16$[rsp], 0
  00528	0f 84 84 00 00
	00		 je	 $LN43@stbi__tga_

; 5954 :                 stbi_uc *pal_entry = tga_palette;

  0052e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tga_palette$[rsp]
  00536	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR pal_entry$9[rsp], rax

; 5955 :                 STBI_ASSERT(tga_comp == STBI_rgb);

  0053e	83 7c 24 30 03	 cmp	 DWORD PTR tga_comp$[rsp], 3
  00543	74 1b		 je	 SHORT $LN80@stbi__tga_
  00545	41 b8 43 17 00
	00		 mov	 r8d, 5955		; 00001743H
  0054b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG81253
  00552	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81254
  00559	e8 00 00 00 00	 call	 _wassert
  0055e	33 c0		 xor	 eax, eax
$LN80@stbi__tga_:

; 5956 :                 for (i=0; i < tga_palette_len; ++i) {

  00560	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00568	eb 0a		 jmp	 SHORT $LN7@stbi__tga_
$LN5@stbi__tga_:
  0056a	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  0056e	ff c0		 inc	 eax
  00570	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
$LN7@stbi__tga_:
  00574	8b 44 24 48	 mov	 eax, DWORD PTR tga_palette_len$[rsp]
  00578	39 44 24 38	 cmp	 DWORD PTR i$[rsp], eax
  0057c	7d 32		 jge	 SHORT $LN6@stbi__tga_

; 5957 :                     stbi__tga_read_rgb16(s, pal_entry);

  0057e	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR pal_entry$9[rsp]
  00586	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0058e	e8 00 00 00 00	 call	 ?stbi__tga_read_rgb16@@YAXPEAUstbi__context@@PEAE@Z ; stbi__tga_read_rgb16

; 5958 :                     pal_entry += tga_comp;

  00593	48 63 44 24 30	 movsxd	 rax, DWORD PTR tga_comp$[rsp]
  00598	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR pal_entry$9[rsp]
  005a0	48 03 c8	 add	 rcx, rax
  005a3	48 8b c1	 mov	 rax, rcx
  005a6	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR pal_entry$9[rsp], rax

; 5959 :                 }

  005ae	eb ba		 jmp	 SHORT $LN5@stbi__tga_
$LN6@stbi__tga_:

; 5960 :             } else if (!stbi__getn(s, tga_palette, tga_palette_len * tga_comp)) {

  005b0	eb 71		 jmp	 SHORT $LN44@stbi__tga_
$LN43@stbi__tga_:
  005b2	8b 44 24 48	 mov	 eax, DWORD PTR tga_palette_len$[rsp]
  005b6	0f af 44 24 30	 imul	 eax, DWORD PTR tga_comp$[rsp]
  005bb	44 8b c0	 mov	 r8d, eax
  005be	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR tga_palette$[rsp]
  005c6	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005ce	e8 00 00 00 00	 call	 ?stbi__getn@@YAHPEAUstbi__context@@PEAEH@Z ; stbi__getn
  005d3	85 c0		 test	 eax, eax
  005d5	75 4c		 jne	 SHORT $LN45@stbi__tga_

; 5961 :                 STBI_FREE(tga_data);

  005d7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tga_data$[rsp]
  005dc	e8 00 00 00 00	 call	 free

; 5962 :                 STBI_FREE(tga_palette);

  005e1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tga_palette$[rsp]
  005e9	e8 00 00 00 00	 call	 free

; 5963 :                 return stbi__errpuc("bad palette", "Corrupt TGA");

  005ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81256
  005f5	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  005fa	85 c0		 test	 eax, eax
  005fc	74 0d		 je	 SHORT $LN81@stbi__tga_
  005fe	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv250[rsp], 0
  00609	eb 0b		 jmp	 SHORT $LN82@stbi__tga_
$LN81@stbi__tga_:
  0060b	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv250[rsp], 0
$LN82@stbi__tga_:
  00616	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR tv250[rsp]
  0061e	e9 4b 04 00 00	 jmp	 $LN1@stbi__tga_
$LN45@stbi__tga_:
$LN44@stbi__tga_:
$LN40@stbi__tga_:

; 5964 :             }
; 5965 :         }
; 5966 :         //   load the data
; 5967 :         for (i=0; i < tga_width * tga_height; ++i)

  00623	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0062b	eb 0a		 jmp	 SHORT $LN10@stbi__tga_
$LN8@stbi__tga_:
  0062d	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  00631	ff c0		 inc	 eax
  00633	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
$LN10@stbi__tga_:
  00637	8b 44 24 3c	 mov	 eax, DWORD PTR tga_width$[rsp]
  0063b	0f af 44 24 40	 imul	 eax, DWORD PTR tga_height$[rsp]
  00640	39 44 24 38	 cmp	 DWORD PTR i$[rsp], eax
  00644	0f 8d f7 01 00
	00		 jge	 $LN9@stbi__tga_

; 5968 :         {
; 5969 :             //   if I'm in RLE mode, do I need to get a RLE stbi__pngchunk?
; 5970 :             if ( tga_is_RLE )

  0064a	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR tga_is_RLE$[rsp], 0
  00652	74 5d		 je	 SHORT $LN46@stbi__tga_

; 5971 :             {
; 5972 :                 if ( RLE_count == 0 )

  00654	83 7c 24 70 00	 cmp	 DWORD PTR RLE_count$[rsp], 0
  00659	75 42		 jne	 SHORT $LN48@stbi__tga_

; 5973 :                 {
; 5974 :                     //   yep, get the next byte as a RLE command
; 5975 :                     int RLE_cmd = stbi__get8(s);

  0065b	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00663	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00668	0f b6 c0	 movzx	 eax, al
  0066b	89 84 24 b4 00
	00 00		 mov	 DWORD PTR RLE_cmd$7[rsp], eax

; 5976 :                     RLE_count = 1 + (RLE_cmd & 127);

  00672	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR RLE_cmd$7[rsp]
  00679	83 e0 7f	 and	 eax, 127		; 0000007fH
  0067c	ff c0		 inc	 eax
  0067e	89 44 24 70	 mov	 DWORD PTR RLE_count$[rsp], eax

; 5977 :                     RLE_repeating = RLE_cmd >> 7;

  00682	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR RLE_cmd$7[rsp]
  00689	c1 f8 07	 sar	 eax, 7
  0068c	89 84 24 b8 00
	00 00		 mov	 DWORD PTR RLE_repeating$[rsp], eax

; 5978 :                     read_next_pixel = 1;

  00693	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR read_next_pixel$[rsp], 1
  0069b	eb 12		 jmp	 SHORT $LN49@stbi__tga_
$LN48@stbi__tga_:

; 5979 :                 } else if ( !RLE_repeating )

  0069d	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR RLE_repeating$[rsp], 0
  006a5	75 08		 jne	 SHORT $LN50@stbi__tga_

; 5980 :                 {
; 5981 :                     read_next_pixel = 1;

  006a7	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR read_next_pixel$[rsp], 1
$LN50@stbi__tga_:
$LN49@stbi__tga_:

; 5982 :                 }
; 5983 :             } else

  006af	eb 08		 jmp	 SHORT $LN47@stbi__tga_
$LN46@stbi__tga_:

; 5984 :             {
; 5985 :                 read_next_pixel = 1;

  006b1	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR read_next_pixel$[rsp], 1
$LN47@stbi__tga_:

; 5986 :             }
; 5987 :             //   OK, if I need to read a pixel, do it now
; 5988 :             if ( read_next_pixel )

  006b9	83 7c 24 60 00	 cmp	 DWORD PTR read_next_pixel$[rsp], 0
  006be	0f 84 2c 01 00
	00		 je	 $LN51@stbi__tga_

; 5989 :             {
; 5990 :                 //   load however much data we did have
; 5991 :                 if ( tga_indexed )

  006c4	83 7c 24 68 00	 cmp	 DWORD PTR tga_indexed$[rsp], 0
  006c9	0f 84 a6 00 00
	00		 je	 $LN52@stbi__tga_

; 5992 :                 {
; 5993 :                     // read in index, then perform the lookup
; 5994 :                     int pal_idx = (tga_bits_per_pixel == 8) ? stbi__get8(s) : stbi__get16le(s);

  006cf	83 bc 24 bc 00
	00 00 08	 cmp	 DWORD PTR tga_bits_per_pixel$[rsp], 8
  006d7	75 19		 jne	 SHORT $LN83@stbi__tga_
  006d9	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006e1	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  006e6	0f b6 c0	 movzx	 eax, al
  006e9	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv272[rsp], eax
  006f0	eb 14		 jmp	 SHORT $LN84@stbi__tga_
$LN83@stbi__tga_:
  006f2	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006fa	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  006ff	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv272[rsp], eax
$LN84@stbi__tga_:
  00706	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR tv272[rsp]
  0070d	89 44 24 5c	 mov	 DWORD PTR pal_idx$3[rsp], eax

; 5995 :                     if ( pal_idx >= tga_palette_len ) {

  00711	8b 44 24 48	 mov	 eax, DWORD PTR tga_palette_len$[rsp]
  00715	39 44 24 5c	 cmp	 DWORD PTR pal_idx$3[rsp], eax
  00719	7c 08		 jl	 SHORT $LN54@stbi__tga_

; 5996 :                         // invalid index
; 5997 :                         pal_idx = 0;

  0071b	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR pal_idx$3[rsp], 0
$LN54@stbi__tga_:

; 5998 :                     }
; 5999 :                     pal_idx *= tga_comp;

  00723	8b 44 24 5c	 mov	 eax, DWORD PTR pal_idx$3[rsp]
  00727	0f af 44 24 30	 imul	 eax, DWORD PTR tga_comp$[rsp]
  0072c	89 44 24 5c	 mov	 DWORD PTR pal_idx$3[rsp], eax

; 6000 :                     for (j = 0; j < tga_comp; ++j) {

  00730	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00738	eb 0a		 jmp	 SHORT $LN13@stbi__tga_
$LN11@stbi__tga_:
  0073a	8b 44 24 34	 mov	 eax, DWORD PTR j$[rsp]
  0073e	ff c0		 inc	 eax
  00740	89 44 24 34	 mov	 DWORD PTR j$[rsp], eax
$LN13@stbi__tga_:
  00744	8b 44 24 30	 mov	 eax, DWORD PTR tga_comp$[rsp]
  00748	39 44 24 34	 cmp	 DWORD PTR j$[rsp], eax
  0074c	7d 25		 jge	 SHORT $LN12@stbi__tga_

; 6001 :                         raw_data[j] = tga_palette[pal_idx+j];

  0074e	8b 44 24 34	 mov	 eax, DWORD PTR j$[rsp]
  00752	8b 4c 24 5c	 mov	 ecx, DWORD PTR pal_idx$3[rsp]
  00756	03 c8		 add	 ecx, eax
  00758	8b c1		 mov	 eax, ecx
  0075a	48 98		 cdqe
  0075c	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR j$[rsp]
  00761	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR tga_palette$[rsp]
  00769	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  0076d	88 44 0c 6c	 mov	 BYTE PTR raw_data$[rsp+rcx], al

; 6002 :                     }

  00771	eb c7		 jmp	 SHORT $LN11@stbi__tga_
$LN12@stbi__tga_:

; 6003 :                 } else if(tga_rgb16) {

  00773	eb 73		 jmp	 SHORT $LN53@stbi__tga_
$LN52@stbi__tga_:
  00775	83 7c 24 58 00	 cmp	 DWORD PTR tga_rgb16$[rsp], 0
  0077a	74 36		 je	 SHORT $LN55@stbi__tga_

; 6004 :                     STBI_ASSERT(tga_comp == STBI_rgb);

  0077c	83 7c 24 30 03	 cmp	 DWORD PTR tga_comp$[rsp], 3
  00781	74 1b		 je	 SHORT $LN85@stbi__tga_
  00783	41 b8 74 17 00
	00		 mov	 r8d, 6004		; 00001774H
  00789	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG81268
  00790	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81269
  00797	e8 00 00 00 00	 call	 _wassert
  0079c	33 c0		 xor	 eax, eax
$LN85@stbi__tga_:

; 6005 :                     stbi__tga_read_rgb16(s, raw_data);

  0079e	48 8d 54 24 6c	 lea	 rdx, QWORD PTR raw_data$[rsp]
  007a3	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007ab	e8 00 00 00 00	 call	 ?stbi__tga_read_rgb16@@YAXPEAUstbi__context@@PEAE@Z ; stbi__tga_read_rgb16

; 6006 :                 } else {

  007b0	eb 36		 jmp	 SHORT $LN56@stbi__tga_
$LN55@stbi__tga_:

; 6007 :                     //   read in the data raw
; 6008 :                     for (j = 0; j < tga_comp; ++j) {

  007b2	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  007ba	eb 0a		 jmp	 SHORT $LN16@stbi__tga_
$LN14@stbi__tga_:
  007bc	8b 44 24 34	 mov	 eax, DWORD PTR j$[rsp]
  007c0	ff c0		 inc	 eax
  007c2	89 44 24 34	 mov	 DWORD PTR j$[rsp], eax
$LN16@stbi__tga_:
  007c6	8b 44 24 30	 mov	 eax, DWORD PTR tga_comp$[rsp]
  007ca	39 44 24 34	 cmp	 DWORD PTR j$[rsp], eax
  007ce	7d 18		 jge	 SHORT $LN15@stbi__tga_

; 6009 :                         raw_data[j] = stbi__get8(s);

  007d0	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007d8	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  007dd	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR j$[rsp]
  007e2	88 44 0c 6c	 mov	 BYTE PTR raw_data$[rsp+rcx], al

; 6010 :                     }

  007e6	eb d4		 jmp	 SHORT $LN14@stbi__tga_
$LN15@stbi__tga_:
$LN56@stbi__tga_:
$LN53@stbi__tga_:

; 6011 :                 }
; 6012 :                 //   clear the reading flag for the next pixel
; 6013 :                 read_next_pixel = 0;

  007e8	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR read_next_pixel$[rsp], 0
$LN51@stbi__tga_:

; 6014 :             } // end of reading a pixel
; 6015 :             
; 6016 :             // copy data
; 6017 :             for (j = 0; j < tga_comp; ++j)

  007f0	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  007f8	eb 0a		 jmp	 SHORT $LN19@stbi__tga_
$LN17@stbi__tga_:
  007fa	8b 44 24 34	 mov	 eax, DWORD PTR j$[rsp]
  007fe	ff c0		 inc	 eax
  00800	89 44 24 34	 mov	 DWORD PTR j$[rsp], eax
$LN19@stbi__tga_:
  00804	8b 44 24 30	 mov	 eax, DWORD PTR tga_comp$[rsp]
  00808	39 44 24 34	 cmp	 DWORD PTR j$[rsp], eax
  0080c	7d 24		 jge	 SHORT $LN18@stbi__tga_

; 6018 :                 tga_data[i*tga_comp+j] = raw_data[j];

  0080e	48 63 44 24 34	 movsxd	 rax, DWORD PTR j$[rsp]
  00813	8b 4c 24 38	 mov	 ecx, DWORD PTR i$[rsp]
  00817	0f af 4c 24 30	 imul	 ecx, DWORD PTR tga_comp$[rsp]
  0081c	03 4c 24 34	 add	 ecx, DWORD PTR j$[rsp]
  00820	48 63 c9	 movsxd	 rcx, ecx
  00823	48 8b 54 24 50	 mov	 rdx, QWORD PTR tga_data$[rsp]
  00828	0f b6 44 04 6c	 movzx	 eax, BYTE PTR raw_data$[rsp+rax]
  0082d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00830	eb c8		 jmp	 SHORT $LN17@stbi__tga_
$LN18@stbi__tga_:

; 6019 :             
; 6020 :             //   in case we're in RLE mode, keep counting down
; 6021 :             --RLE_count;

  00832	8b 44 24 70	 mov	 eax, DWORD PTR RLE_count$[rsp]
  00836	ff c8		 dec	 eax
  00838	89 44 24 70	 mov	 DWORD PTR RLE_count$[rsp], eax

; 6022 :         }

  0083c	e9 ec fd ff ff	 jmp	 $LN8@stbi__tga_
$LN9@stbi__tga_:

; 6023 :         //   do I need to invert the image?
; 6024 :         if ( tga_inverted )

  00841	83 7c 24 74 00	 cmp	 DWORD PTR tga_inverted$[rsp], 0
  00846	0f 84 c8 00 00
	00		 je	 $LN57@stbi__tga_

; 6025 :         {
; 6026 :             for (j = 0; j*2 < tga_height; ++j)

  0084c	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00854	eb 0a		 jmp	 SHORT $LN22@stbi__tga_
$LN20@stbi__tga_:
  00856	8b 44 24 34	 mov	 eax, DWORD PTR j$[rsp]
  0085a	ff c0		 inc	 eax
  0085c	89 44 24 34	 mov	 DWORD PTR j$[rsp], eax
$LN22@stbi__tga_:
  00860	8b 44 24 34	 mov	 eax, DWORD PTR j$[rsp]
  00864	d1 e0		 shl	 eax, 1
  00866	3b 44 24 40	 cmp	 eax, DWORD PTR tga_height$[rsp]
  0086a	0f 8d a4 00 00
	00		 jge	 $LN21@stbi__tga_

; 6027 :             {
; 6028 :                 int index1 = j * tga_width * tga_comp;

  00870	8b 44 24 34	 mov	 eax, DWORD PTR j$[rsp]
  00874	0f af 44 24 3c	 imul	 eax, DWORD PTR tga_width$[rsp]
  00879	0f af 44 24 30	 imul	 eax, DWORD PTR tga_comp$[rsp]
  0087e	89 44 24 78	 mov	 DWORD PTR index1$4[rsp], eax

; 6029 :                 int index2 = (tga_height - 1 - j) * tga_width * tga_comp;

  00882	8b 44 24 40	 mov	 eax, DWORD PTR tga_height$[rsp]
  00886	ff c8		 dec	 eax
  00888	2b 44 24 34	 sub	 eax, DWORD PTR j$[rsp]
  0088c	0f af 44 24 3c	 imul	 eax, DWORD PTR tga_width$[rsp]
  00891	0f af 44 24 30	 imul	 eax, DWORD PTR tga_comp$[rsp]
  00896	89 44 24 7c	 mov	 DWORD PTR index2$5[rsp], eax

; 6030 :                 for (i = tga_width * tga_comp; i > 0; --i)

  0089a	8b 44 24 3c	 mov	 eax, DWORD PTR tga_width$[rsp]
  0089e	0f af 44 24 30	 imul	 eax, DWORD PTR tga_comp$[rsp]
  008a3	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
  008a7	eb 0a		 jmp	 SHORT $LN25@stbi__tga_
$LN23@stbi__tga_:
  008a9	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  008ad	ff c8		 dec	 eax
  008af	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
$LN25@stbi__tga_:
  008b3	83 7c 24 38 00	 cmp	 DWORD PTR i$[rsp], 0
  008b8	7e 55		 jle	 SHORT $LN24@stbi__tga_

; 6031 :                 {
; 6032 :                     unsigned char temp = tga_data[index1];

  008ba	48 63 44 24 78	 movsxd	 rax, DWORD PTR index1$4[rsp]
  008bf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tga_data$[rsp]
  008c4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  008c8	88 44 24 45	 mov	 BYTE PTR temp$2[rsp], al

; 6033 :                     tga_data[index1] = tga_data[index2];

  008cc	48 63 44 24 7c	 movsxd	 rax, DWORD PTR index2$5[rsp]
  008d1	48 63 4c 24 78	 movsxd	 rcx, DWORD PTR index1$4[rsp]
  008d6	48 8b 54 24 50	 mov	 rdx, QWORD PTR tga_data$[rsp]
  008db	48 8b 7c 24 50	 mov	 rdi, QWORD PTR tga_data$[rsp]
  008e0	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  008e4	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 6034 :                     tga_data[index2] = temp;

  008e7	48 63 44 24 7c	 movsxd	 rax, DWORD PTR index2$5[rsp]
  008ec	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tga_data$[rsp]
  008f1	0f b6 54 24 45	 movzx	 edx, BYTE PTR temp$2[rsp]
  008f6	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 6035 :                     ++index1;

  008f9	8b 44 24 78	 mov	 eax, DWORD PTR index1$4[rsp]
  008fd	ff c0		 inc	 eax
  008ff	89 44 24 78	 mov	 DWORD PTR index1$4[rsp], eax

; 6036 :                     ++index2;

  00903	8b 44 24 7c	 mov	 eax, DWORD PTR index2$5[rsp]
  00907	ff c0		 inc	 eax
  00909	89 44 24 7c	 mov	 DWORD PTR index2$5[rsp], eax

; 6037 :                 }

  0090d	eb 9a		 jmp	 SHORT $LN23@stbi__tga_
$LN24@stbi__tga_:

; 6038 :             }

  0090f	e9 42 ff ff ff	 jmp	 $LN20@stbi__tga_
$LN21@stbi__tga_:
$LN57@stbi__tga_:

; 6039 :         }
; 6040 :         //   clear my palette, if I had one
; 6041 :         if ( tga_palette != NULL )

  00914	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR tga_palette$[rsp], 0
  0091d	74 0d		 je	 SHORT $LN58@stbi__tga_

; 6042 :         {
; 6043 :             STBI_FREE( tga_palette );

  0091f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tga_palette$[rsp]
  00927	e8 00 00 00 00	 call	 free
$LN58@stbi__tga_:
$LN39@stbi__tga_:

; 6044 :         }
; 6045 :     }
; 6046 :     
; 6047 :     // swap RGB - if the source data was RGB16, it already is in the right order
; 6048 :     if (tga_comp >= 3 && !tga_rgb16)

  0092c	83 7c 24 30 03	 cmp	 DWORD PTR tga_comp$[rsp], 3
  00931	0f 8c b6 00 00
	00		 jl	 $LN59@stbi__tga_
  00937	83 7c 24 58 00	 cmp	 DWORD PTR tga_rgb16$[rsp], 0
  0093c	0f 85 ab 00 00
	00		 jne	 $LN59@stbi__tga_

; 6049 :     {
; 6050 :         unsigned char* tga_pixel = tga_data;

  00942	48 8b 44 24 50	 mov	 rax, QWORD PTR tga_data$[rsp]
  00947	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tga_pixel$6[rsp], rax

; 6051 :         for (i=0; i < tga_width * tga_height; ++i)

  0094f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00957	eb 0a		 jmp	 SHORT $LN28@stbi__tga_
$LN26@stbi__tga_:
  00959	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  0095d	ff c0		 inc	 eax
  0095f	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
$LN28@stbi__tga_:
  00963	8b 44 24 3c	 mov	 eax, DWORD PTR tga_width$[rsp]
  00967	0f af 44 24 40	 imul	 eax, DWORD PTR tga_height$[rsp]
  0096c	39 44 24 38	 cmp	 DWORD PTR i$[rsp], eax
  00970	7d 7b		 jge	 SHORT $LN27@stbi__tga_

; 6052 :         {
; 6053 :             unsigned char temp = tga_pixel[0];

  00972	b8 01 00 00 00	 mov	 eax, 1
  00977	48 6b c0 00	 imul	 rax, rax, 0
  0097b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tga_pixel$6[rsp]
  00983	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00987	88 44 24 44	 mov	 BYTE PTR temp$1[rsp], al

; 6054 :             tga_pixel[0] = tga_pixel[2];

  0098b	b8 01 00 00 00	 mov	 eax, 1
  00990	48 6b c0 02	 imul	 rax, rax, 2
  00994	b9 01 00 00 00	 mov	 ecx, 1
  00999	48 6b c9 00	 imul	 rcx, rcx, 0
  0099d	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR tga_pixel$6[rsp]
  009a5	48 8b bc 24 90
	00 00 00	 mov	 rdi, QWORD PTR tga_pixel$6[rsp]
  009ad	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  009b1	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 6055 :             tga_pixel[2] = temp;

  009b4	b8 01 00 00 00	 mov	 eax, 1
  009b9	48 6b c0 02	 imul	 rax, rax, 2
  009bd	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tga_pixel$6[rsp]
  009c5	0f b6 54 24 44	 movzx	 edx, BYTE PTR temp$1[rsp]
  009ca	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 6056 :             tga_pixel += tga_comp;

  009cd	48 63 44 24 30	 movsxd	 rax, DWORD PTR tga_comp$[rsp]
  009d2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tga_pixel$6[rsp]
  009da	48 03 c8	 add	 rcx, rax
  009dd	48 8b c1	 mov	 rax, rcx
  009e0	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tga_pixel$6[rsp], rax

; 6057 :         }

  009e8	e9 6c ff ff ff	 jmp	 $LN26@stbi__tga_
$LN27@stbi__tga_:
$LN59@stbi__tga_:

; 6058 :     }
; 6059 :     
; 6060 :     // convert to target component count
; 6061 :     if (req_comp && req_comp != tga_comp)

  009ed	83 bc 24 30 01
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  009f5	74 35		 je	 SHORT $LN60@stbi__tga_
  009f7	8b 44 24 30	 mov	 eax, DWORD PTR tga_comp$[rsp]
  009fb	39 84 24 30 01
	00 00		 cmp	 DWORD PTR req_comp$[rsp], eax
  00a02	74 28		 je	 SHORT $LN60@stbi__tga_

; 6062 :         tga_data = stbi__convert_format(tga_data, tga_comp, req_comp, tga_width, tga_height);

  00a04	8b 44 24 40	 mov	 eax, DWORD PTR tga_height$[rsp]
  00a08	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00a0c	44 8b 4c 24 3c	 mov	 r9d, DWORD PTR tga_width$[rsp]
  00a11	44 8b 84 24 30
	01 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  00a19	8b 54 24 30	 mov	 edx, DWORD PTR tga_comp$[rsp]
  00a1d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tga_data$[rsp]
  00a22	e8 00 00 00 00	 call	 ?stbi__convert_format@@YAPEAEPEAEHHII@Z ; stbi__convert_format
  00a27	48 89 44 24 50	 mov	 QWORD PTR tga_data$[rsp], rax
$LN60@stbi__tga_:

; 6063 :     
; 6064 :     //   the things I do to get rid of an error message, and yet keep
; 6065 :     //   Microsoft's C compilers happy... [8^(
; 6066 :     tga_palette_start = tga_palette_len = tga_palette_bits =

  00a2c	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tga_y_origin$[rsp], 0
  00a37	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR tga_y_origin$[rsp]
  00a3e	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tga_x_origin$[rsp], eax
  00a45	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR tga_x_origin$[rsp]
  00a4c	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tga_palette_bits$[rsp], eax
  00a53	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tga_palette_bits$[rsp]
  00a5a	89 44 24 48	 mov	 DWORD PTR tga_palette_len$[rsp], eax
  00a5e	8b 44 24 48	 mov	 eax, DWORD PTR tga_palette_len$[rsp]
  00a62	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tga_palette_start$[rsp], eax

; 6067 :         tga_x_origin = tga_y_origin = 0;
; 6068 :     STBI_NOTUSED(tga_palette_start);
; 6069 :     //   OK, done
; 6070 :     return tga_data;

  00a69	48 8b 44 24 50	 mov	 rax, QWORD PTR tga_data$[rsp]
$LN1@stbi__tga_:

; 6071 : }

  00a6e	48 81 c4 00 01
	00 00		 add	 rsp, 256		; 00000100H
  00a75	5f		 pop	 rdi
  00a76	c3		 ret	 0
?stbi__tga_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ENDP ; stbi__tga_load
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
sz$ = 32
tga_color_type$ = 36
res$ = 40
s$ = 64
?stbi__tga_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__tga_test

; 5818 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 5819 :     int res = 0;

  00009	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR res$[rsp], 0

; 5820 :     int sz, tga_color_type;
; 5821 :     stbi__get8(s);      //   discard Offset

  00011	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00016	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8

; 5822 :     tga_color_type = stbi__get8(s);   //   color type

  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00020	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00025	0f b6 c0	 movzx	 eax, al
  00028	89 44 24 24	 mov	 DWORD PTR tga_color_type$[rsp], eax

; 5823 :     if ( tga_color_type > 1 ) goto errorEnd;   //   only RGB or indexed allowed

  0002c	83 7c 24 24 01	 cmp	 DWORD PTR tga_color_type$[rsp], 1
  00031	7e 0a		 jle	 SHORT $LN2@stbi__tga_
  00033	e9 47 01 00 00	 jmp	 $LN3@stbi__tga_
  00038	e9 42 01 00 00	 jmp	 $errorEnd$21
$LN2@stbi__tga_:

; 5824 :     sz = stbi__get8(s);   //   image type

  0003d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00042	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00047	0f b6 c0	 movzx	 eax, al
  0004a	89 44 24 20	 mov	 DWORD PTR sz$[rsp], eax

; 5825 :     if ( tga_color_type == 1 ) { // colormapped (paletted) image

  0004e	83 7c 24 24 01	 cmp	 DWORD PTR tga_color_type$[rsp], 1
  00053	75 76		 jne	 SHORT $LN4@stbi__tga_

; 5826 :         if (sz != 1 && sz != 9) goto errorEnd; // colortype 1 demands image type 1 or 9

  00055	83 7c 24 20 01	 cmp	 DWORD PTR sz$[rsp], 1
  0005a	74 11		 je	 SHORT $LN6@stbi__tga_
  0005c	83 7c 24 20 09	 cmp	 DWORD PTR sz$[rsp], 9
  00061	74 0a		 je	 SHORT $LN6@stbi__tga_
  00063	e9 17 01 00 00	 jmp	 $LN7@stbi__tga_
  00068	e9 12 01 00 00	 jmp	 $errorEnd$21
$LN6@stbi__tga_:

; 5827 :         stbi__skip(s,4);       // skip index of first colormap entry and number of entries

  0006d	ba 04 00 00 00	 mov	 edx, 4
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00077	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 5828 :         sz = stbi__get8(s);    //   check bits per palette color entry

  0007c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00081	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00086	0f b6 c0	 movzx	 eax, al
  00089	89 44 24 20	 mov	 DWORD PTR sz$[rsp], eax

; 5829 :         if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;

  0008d	83 7c 24 20 08	 cmp	 DWORD PTR sz$[rsp], 8
  00092	74 26		 je	 SHORT $LN8@stbi__tga_
  00094	83 7c 24 20 0f	 cmp	 DWORD PTR sz$[rsp], 15
  00099	74 1f		 je	 SHORT $LN8@stbi__tga_
  0009b	83 7c 24 20 10	 cmp	 DWORD PTR sz$[rsp], 16
  000a0	74 18		 je	 SHORT $LN8@stbi__tga_
  000a2	83 7c 24 20 18	 cmp	 DWORD PTR sz$[rsp], 24
  000a7	74 11		 je	 SHORT $LN8@stbi__tga_
  000a9	83 7c 24 20 20	 cmp	 DWORD PTR sz$[rsp], 32	; 00000020H
  000ae	74 0a		 je	 SHORT $LN8@stbi__tga_
  000b0	e9 ca 00 00 00	 jmp	 $LN9@stbi__tga_
  000b5	e9 c5 00 00 00	 jmp	 $errorEnd$21
$LN8@stbi__tga_:

; 5830 :         stbi__skip(s,4);       // skip image x and y origin

  000ba	ba 04 00 00 00	 mov	 edx, 4
  000bf	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000c4	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 5831 :     } else { // "normal" image w/o colormap

  000c9	eb 35		 jmp	 SHORT $LN5@stbi__tga_
$LN4@stbi__tga_:

; 5832 :         if ( (sz != 2) && (sz != 3) && (sz != 10) && (sz != 11) ) goto errorEnd; // only RGB or grey allowed, +/- RLE

  000cb	83 7c 24 20 02	 cmp	 DWORD PTR sz$[rsp], 2
  000d0	74 1f		 je	 SHORT $LN10@stbi__tga_
  000d2	83 7c 24 20 03	 cmp	 DWORD PTR sz$[rsp], 3
  000d7	74 18		 je	 SHORT $LN10@stbi__tga_
  000d9	83 7c 24 20 0a	 cmp	 DWORD PTR sz$[rsp], 10
  000de	74 11		 je	 SHORT $LN10@stbi__tga_
  000e0	83 7c 24 20 0b	 cmp	 DWORD PTR sz$[rsp], 11
  000e5	74 0a		 je	 SHORT $LN10@stbi__tga_
  000e7	e9 93 00 00 00	 jmp	 $LN11@stbi__tga_
  000ec	e9 8e 00 00 00	 jmp	 $errorEnd$21
$LN10@stbi__tga_:

; 5833 :         stbi__skip(s,9); // skip colormap specification and image x/y origin

  000f1	ba 09 00 00 00	 mov	 edx, 9
  000f6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000fb	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip
$LN5@stbi__tga_:

; 5834 :     }
; 5835 :     if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test width

  00100	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00105	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  0010a	83 f8 01	 cmp	 eax, 1
  0010d	7d 04		 jge	 SHORT $LN12@stbi__tga_
  0010f	eb 6e		 jmp	 SHORT $LN13@stbi__tga_
  00111	eb 6c		 jmp	 SHORT $errorEnd$21
$LN12@stbi__tga_:

; 5836 :     if ( stbi__get16le(s) < 1 ) goto errorEnd;      //   test height

  00113	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00118	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  0011d	83 f8 01	 cmp	 eax, 1
  00120	7d 04		 jge	 SHORT $LN14@stbi__tga_
  00122	eb 5b		 jmp	 SHORT $LN15@stbi__tga_
  00124	eb 59		 jmp	 SHORT $errorEnd$21
$LN14@stbi__tga_:

; 5837 :     sz = stbi__get8(s);   //   bits per pixel

  00126	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0012b	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00130	0f b6 c0	 movzx	 eax, al
  00133	89 44 24 20	 mov	 DWORD PTR sz$[rsp], eax

; 5838 :     if ( (tga_color_type == 1) && (sz != 8) && (sz != 16) ) goto errorEnd; // for colormapped images, bpp is size of an index

  00137	83 7c 24 24 01	 cmp	 DWORD PTR tga_color_type$[rsp], 1
  0013c	75 12		 jne	 SHORT $LN16@stbi__tga_
  0013e	83 7c 24 20 08	 cmp	 DWORD PTR sz$[rsp], 8
  00143	74 0b		 je	 SHORT $LN16@stbi__tga_
  00145	83 7c 24 20 10	 cmp	 DWORD PTR sz$[rsp], 16
  0014a	74 04		 je	 SHORT $LN16@stbi__tga_
  0014c	eb 31		 jmp	 SHORT $LN17@stbi__tga_
  0014e	eb 2f		 jmp	 SHORT $errorEnd$21
$LN16@stbi__tga_:

; 5839 :     if ( (sz != 8) && (sz != 15) && (sz != 16) && (sz != 24) && (sz != 32) ) goto errorEnd;

  00150	83 7c 24 20 08	 cmp	 DWORD PTR sz$[rsp], 8
  00155	74 20		 je	 SHORT $LN18@stbi__tga_
  00157	83 7c 24 20 0f	 cmp	 DWORD PTR sz$[rsp], 15
  0015c	74 19		 je	 SHORT $LN18@stbi__tga_
  0015e	83 7c 24 20 10	 cmp	 DWORD PTR sz$[rsp], 16
  00163	74 12		 je	 SHORT $LN18@stbi__tga_
  00165	83 7c 24 20 18	 cmp	 DWORD PTR sz$[rsp], 24
  0016a	74 0b		 je	 SHORT $LN18@stbi__tga_
  0016c	83 7c 24 20 20	 cmp	 DWORD PTR sz$[rsp], 32	; 00000020H
  00171	74 04		 je	 SHORT $LN18@stbi__tga_
  00173	eb 0a		 jmp	 SHORT $LN19@stbi__tga_
  00175	eb 08		 jmp	 SHORT $errorEnd$21
$LN18@stbi__tga_:

; 5840 :     
; 5841 :     res = 1; // if we got this far, everything's good and we can return 1 instead of 0

  00177	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR res$[rsp], 1
$LN3@stbi__tga_:
$LN7@stbi__tga_:
$LN9@stbi__tga_:
$LN11@stbi__tga_:
$LN13@stbi__tga_:
$LN15@stbi__tga_:
$LN17@stbi__tga_:
$LN19@stbi__tga_:
$errorEnd$21:

; 5842 :     
; 5843 :     errorEnd:
; 5844 :     stbi__rewind(s);

  0017f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00184	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 5845 :     return res;

  00189	8b 44 24 28	 mov	 eax, DWORD PTR res$[rsp]

; 5846 : }

  0018d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00191	c3		 ret	 0
?stbi__tga_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__tga_test
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv77 = 32
p$ = 40
info$ = 48
__$ArrayPad$ = 88
s$ = 112
x$ = 120
y$ = 128
comp$ = 136
?stbi__bmp_info@@YAHPEAUstbi__context@@PEAH11@Z PROC	; stbi__bmp_info

; 7333 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 7334 :     void *p;
; 7335 :     stbi__bmp_data info;
; 7336 :     
; 7337 :     info.all_a = 255;

  00027	c7 44 24 4c ff
	00 00 00	 mov	 DWORD PTR info$[rsp+28], 255 ; 000000ffH

; 7338 :     p = stbi__bmp_parse_header(s, &info);

  0002f	48 8d 54 24 30	 lea	 rdx, QWORD PTR info$[rsp]
  00034	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00039	e8 00 00 00 00	 call	 ?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z ; stbi__bmp_parse_header
  0003e	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax

; 7339 :     if (p == NULL) {

  00043	48 83 7c 24 28
	00		 cmp	 QWORD PTR p$[rsp], 0
  00049	75 11		 jne	 SHORT $LN2@stbi__bmp_

; 7340 :         stbi__rewind( s );

  0004b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00050	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 7341 :         return 0;

  00055	33 c0		 xor	 eax, eax
  00057	e9 8b 00 00 00	 jmp	 $LN1@stbi__bmp_
$LN2@stbi__bmp_:

; 7342 :     }
; 7343 :     if (x) *x = s->img_x;

  0005c	48 83 7c 24 78
	00		 cmp	 QWORD PTR x$[rsp], 0
  00062	74 0e		 je	 SHORT $LN3@stbi__bmp_
  00064	48 8b 44 24 78	 mov	 rax, QWORD PTR x$[rsp]
  00069	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0006e	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00070	89 08		 mov	 DWORD PTR [rax], ecx
$LN3@stbi__bmp_:

; 7344 :     if (y) *y = s->img_y;

  00072	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR y$[rsp], 0
  0007b	74 12		 je	 SHORT $LN4@stbi__bmp_
  0007d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR y$[rsp]
  00085	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0008a	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  0008d	89 08		 mov	 DWORD PTR [rax], ecx
$LN4@stbi__bmp_:

; 7345 :     if (comp) {

  0008f	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR comp$[rsp], 0
  00098	74 48		 je	 SHORT $LN5@stbi__bmp_

; 7346 :         if (info.bpp == 24 && info.ma == 0xff000000)

  0009a	83 7c 24 30 18	 cmp	 DWORD PTR info$[rsp], 24
  0009f	75 1a		 jne	 SHORT $LN6@stbi__bmp_
  000a1	81 7c 24 48 00
	00 00 ff	 cmp	 DWORD PTR info$[rsp+24], -16777216 ; ff000000H
  000a9	75 10		 jne	 SHORT $LN6@stbi__bmp_

; 7347 :             *comp = 3;

  000ab	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  000b3	c7 00 03 00 00
	00		 mov	 DWORD PTR [rax], 3
  000b9	eb 27		 jmp	 SHORT $LN7@stbi__bmp_
$LN6@stbi__bmp_:

; 7348 :         else
; 7349 :             *comp = info.ma ? 4 : 3;

  000bb	83 7c 24 48 00	 cmp	 DWORD PTR info$[rsp+24], 0
  000c0	74 0a		 je	 SHORT $LN9@stbi__bmp_
  000c2	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR tv77[rsp], 4
  000ca	eb 08		 jmp	 SHORT $LN10@stbi__bmp_
$LN9@stbi__bmp_:
  000cc	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR tv77[rsp], 3
$LN10@stbi__bmp_:
  000d4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  000dc	8b 4c 24 20	 mov	 ecx, DWORD PTR tv77[rsp]
  000e0	89 08		 mov	 DWORD PTR [rax], ecx
$LN7@stbi__bmp_:
$LN5@stbi__bmp_:

; 7350 :     }
; 7351 :     return 1;

  000e2	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__bmp_:

; 7352 : }

  000e7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000ec	48 33 cc	 xor	 rcx, rsp
  000ef	e8 00 00 00 00	 call	 __security_check_cookie
  000f4	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000f8	c3		 ret	 0
?stbi__bmp_info@@YAHPEAUstbi__context@@PEAH11@Z ENDP	; stbi__bmp_info
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
i$ = 48
z$1 = 52
z$2 = 56
j$ = 60
out$ = 64
target$ = 72
a$3 = 76
v$4 = 80
ma$ = 84
t$5 = 88
psize$ = 92
width$ = 96
mr$ = 100
mg$ = 104
mb$ = 108
bytes_read_so_far$6 = 112
bit_offset$7 = 116
easy$8 = 120
all_a$ = 124
v$9 = 128
pad$ = 132
color$10 = 136
rcount$11 = 140
gcount$12 = 144
bcount$13 = 148
acount$14 = 152
tv80 = 156
tv87 = 160
tv174 = 164
tv182 = 168
tv192 = 172
tv207 = 176
tv220 = 180
tv229 = 184
tv264 = 188
tv283 = 192
v$15 = 196
v2$16 = 200
tv392 = 204
tv453 = 208
tv483 = 212
tv515 = 216
tv532 = 220
rshift$17 = 224
gshift$18 = 228
bshift$19 = 232
ashift$20 = 236
tv572 = 240
a$21 = 244
tv70 = 248
extra_data_limit$22 = 252
bpp$23 = 256
flip_vertically$ = 260
header_limit$24 = 264
p1$25 = 272
p2$26 = 280
info$ = 288
pal$ = 336
__$ArrayPad$ = 1360
s$ = 1392
x$ = 1400
y$ = 1408
comp$ = 1416
req_comp$ = 1424
ri$ = 1432
?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z PROC ; stbi__bmp_load

; 5529 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 68 05
	00 00		 sub	 rsp, 1384		; 00000568H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 50
	05 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 5530 :     stbi_uc *out;
; 5531 :     unsigned int mr=0,mg=0,mb=0,ma=0, all_a;

  0002d	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR mr$[rsp], 0
  00035	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR mg$[rsp], 0
  0003d	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR mb$[rsp], 0
  00045	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR ma$[rsp], 0

; 5532 :     stbi_uc pal[256][4];
; 5533 :     int psize=0,i,j,width;

  0004d	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR psize$[rsp], 0

; 5534 :     int flip_vertically, pad, target;
; 5535 :     stbi__bmp_data info;
; 5536 :     STBI_NOTUSED(ri);
; 5537 :     
; 5538 :     info.all_a = 255;

  00055	c7 84 24 3c 01
	00 00 ff 00 00
	00		 mov	 DWORD PTR info$[rsp+28], 255 ; 000000ffH

; 5539 :     if (stbi__bmp_parse_header(s, &info) == NULL)

  00060	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR info$[rsp]
  00068	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00070	e8 00 00 00 00	 call	 ?stbi__bmp_parse_header@@YAPEAXPEAUstbi__context@@PEAUstbi__bmp_data@@@Z ; stbi__bmp_parse_header
  00075	48 85 c0	 test	 rax, rax
  00078	75 07		 jne	 SHORT $LN35@stbi__bmp_

; 5540 :         return NULL; // error code already set

  0007a	33 c0		 xor	 eax, eax
  0007c	e9 d6 11 00 00	 jmp	 $LN1@stbi__bmp_
$LN35@stbi__bmp_:

; 5541 :     
; 5542 :     flip_vertically = ((int) s->img_y) > 0;

  00081	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00089	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  0008d	7e 0d		 jle	 SHORT $LN97@stbi__bmp_
  0008f	c7 84 24 f8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv70[rsp], 1
  0009a	eb 0b		 jmp	 SHORT $LN98@stbi__bmp_
$LN97@stbi__bmp_:
  0009c	c7 84 24 f8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv70[rsp], 0
$LN98@stbi__bmp_:
  000a7	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR tv70[rsp]
  000ae	89 84 24 04 01
	00 00		 mov	 DWORD PTR flip_vertically$[rsp], eax

; 5543 :     s->img_y = abs((int) s->img_y);

  000b5	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000bd	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  000c0	e8 00 00 00 00	 call	 abs
  000c5	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  000cd	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 5544 :     
; 5545 :     if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

  000d0	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000d8	81 78 04 00 00
	00 01		 cmp	 DWORD PTR [rax+4], 16777216 ; 01000000H
  000df	76 35		 jbe	 SHORT $LN36@stbi__bmp_
  000e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80985
  000e8	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  000ed	85 c0		 test	 eax, eax
  000ef	74 0d		 je	 SHORT $LN99@stbi__bmp_
  000f1	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv80[rsp], 0
  000fc	eb 0b		 jmp	 SHORT $LN100@stbi__bmp_
$LN99@stbi__bmp_:
  000fe	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv80[rsp], 0
$LN100@stbi__bmp_:
  00109	48 63 84 24 9c
	00 00 00	 movsxd	 rax, DWORD PTR tv80[rsp]
  00111	e9 41 11 00 00	 jmp	 $LN1@stbi__bmp_
$LN36@stbi__bmp_:

; 5546 :     if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__errpuc("too large","Very large image (corrupt?)");

  00116	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0011e	81 38 00 00 00
	01		 cmp	 DWORD PTR [rax], 16777216 ; 01000000H
  00124	76 35		 jbe	 SHORT $LN37@stbi__bmp_
  00126	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80987
  0012d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00132	85 c0		 test	 eax, eax
  00134	74 0d		 je	 SHORT $LN101@stbi__bmp_
  00136	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv87[rsp], 0
  00141	eb 0b		 jmp	 SHORT $LN102@stbi__bmp_
$LN101@stbi__bmp_:
  00143	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv87[rsp], 0
$LN102@stbi__bmp_:
  0014e	48 63 84 24 a0
	00 00 00	 movsxd	 rax, DWORD PTR tv87[rsp]
  00156	e9 fc 10 00 00	 jmp	 $LN1@stbi__bmp_
$LN37@stbi__bmp_:

; 5547 :     
; 5548 :     mr = info.mr;

  0015b	8b 84 24 2c 01
	00 00		 mov	 eax, DWORD PTR info$[rsp+12]
  00162	89 44 24 64	 mov	 DWORD PTR mr$[rsp], eax

; 5549 :     mg = info.mg;

  00166	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR info$[rsp+16]
  0016d	89 44 24 68	 mov	 DWORD PTR mg$[rsp], eax

; 5550 :     mb = info.mb;

  00171	8b 84 24 34 01
	00 00		 mov	 eax, DWORD PTR info$[rsp+20]
  00178	89 44 24 6c	 mov	 DWORD PTR mb$[rsp], eax

; 5551 :     ma = info.ma;

  0017c	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR info$[rsp+24]
  00183	89 44 24 54	 mov	 DWORD PTR ma$[rsp], eax

; 5552 :     all_a = info.all_a;

  00187	8b 84 24 3c 01
	00 00		 mov	 eax, DWORD PTR info$[rsp+28]
  0018e	89 44 24 7c	 mov	 DWORD PTR all_a$[rsp], eax

; 5553 :     
; 5554 :     if (info.hsz == 12) {

  00192	83 bc 24 28 01
	00 00 0c	 cmp	 DWORD PTR info$[rsp+8], 12
  0019a	75 2d		 jne	 SHORT $LN38@stbi__bmp_

; 5555 :         if (info.bpp < 24)

  0019c	83 bc 24 20 01
	00 00 18	 cmp	 DWORD PTR info$[rsp], 24
  001a4	7d 21		 jge	 SHORT $LN40@stbi__bmp_

; 5556 :             psize = (info.offset - info.extra_read - 24) / 3;

  001a6	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR info$[rsp+32]
  001ad	8b 8c 24 24 01
	00 00		 mov	 ecx, DWORD PTR info$[rsp+4]
  001b4	2b c8		 sub	 ecx, eax
  001b6	8b c1		 mov	 eax, ecx
  001b8	83 e8 18	 sub	 eax, 24
  001bb	99		 cdq
  001bc	b9 03 00 00 00	 mov	 ecx, 3
  001c1	f7 f9		 idiv	 ecx
  001c3	89 44 24 5c	 mov	 DWORD PTR psize$[rsp], eax
$LN40@stbi__bmp_:

; 5557 :     } else {

  001c7	eb 2a		 jmp	 SHORT $LN39@stbi__bmp_
$LN38@stbi__bmp_:

; 5558 :         if (info.bpp < 16)

  001c9	83 bc 24 20 01
	00 00 10	 cmp	 DWORD PTR info$[rsp], 16
  001d1	7d 20		 jge	 SHORT $LN41@stbi__bmp_

; 5559 :             psize = (info.offset - info.extra_read - info.hsz) >> 2;

  001d3	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR info$[rsp+32]
  001da	8b 8c 24 24 01
	00 00		 mov	 ecx, DWORD PTR info$[rsp+4]
  001e1	2b c8		 sub	 ecx, eax
  001e3	8b c1		 mov	 eax, ecx
  001e5	2b 84 24 28 01
	00 00		 sub	 eax, DWORD PTR info$[rsp+8]
  001ec	c1 f8 02	 sar	 eax, 2
  001ef	89 44 24 5c	 mov	 DWORD PTR psize$[rsp], eax
$LN41@stbi__bmp_:
$LN39@stbi__bmp_:

; 5560 :     }
; 5561 :     if (psize == 0) {

  001f3	83 7c 24 5c 00	 cmp	 DWORD PTR psize$[rsp], 0
  001f8	0f 85 0c 01 00
	00		 jne	 $LN42@stbi__bmp_

; 5562 :         // accept some number of extra bytes after the header, but if the offset points either to before
; 5563 :         // the header ends or implies a large amount of extra data, reject the file as malformed
; 5564 :         int bytes_read_so_far = s->callback_already_read + (int)(s->img_buffer - s->img_buffer_original);

  001fe	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00206	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0020e	48 8b 89 d0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+208]
  00215	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0021c	48 2b c1	 sub	 rax, rcx
  0021f	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00227	03 81 b8 00 00
	00		 add	 eax, DWORD PTR [rcx+184]
  0022d	89 44 24 70	 mov	 DWORD PTR bytes_read_so_far$6[rsp], eax

; 5565 :         int header_limit = 1024; // max we actually read is below 256 bytes currently.

  00231	c7 84 24 08 01
	00 00 00 04 00
	00		 mov	 DWORD PTR header_limit$24[rsp], 1024 ; 00000400H

; 5566 :         int extra_data_limit = 256*4; // what ordinarily goes here is a palette; 256 entries*4 bytes is its max size.

  0023c	c7 84 24 fc 00
	00 00 00 04 00
	00		 mov	 DWORD PTR extra_data_limit$22[rsp], 1024 ; 00000400H

; 5567 :         if (bytes_read_so_far <= 0 || bytes_read_so_far > header_limit) {

  00247	83 7c 24 70 00	 cmp	 DWORD PTR bytes_read_so_far$6[rsp], 0
  0024c	7e 0d		 jle	 SHORT $LN44@stbi__bmp_
  0024e	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR header_limit$24[rsp]
  00255	39 44 24 70	 cmp	 DWORD PTR bytes_read_so_far$6[rsp], eax
  00259	7e 35		 jle	 SHORT $LN43@stbi__bmp_
$LN44@stbi__bmp_:

; 5568 :             return stbi__errpuc("bad header", "Corrupt BMP");

  0025b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80995
  00262	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00267	85 c0		 test	 eax, eax
  00269	74 0d		 je	 SHORT $LN103@stbi__bmp_
  0026b	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv174[rsp], 0
  00276	eb 0b		 jmp	 SHORT $LN104@stbi__bmp_
$LN103@stbi__bmp_:
  00278	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv174[rsp], 0
$LN104@stbi__bmp_:
  00283	48 63 84 24 a4
	00 00 00	 movsxd	 rax, DWORD PTR tv174[rsp]
  0028b	e9 c7 0f 00 00	 jmp	 $LN1@stbi__bmp_
$LN43@stbi__bmp_:

; 5569 :         }
; 5570 :         // we established that bytes_read_so_far is positive and sensible.
; 5571 :         // the first half of this test rejects offsets that are either too small positives, or
; 5572 :         // negative, and guarantees that info.offset >= bytes_read_so_far > 0. this in turn
; 5573 :         // ensures the number computed in the second half of the test can't overflow.
; 5574 :         if (info.offset < bytes_read_so_far || info.offset - bytes_read_so_far > extra_data_limit) {

  00290	8b 44 24 70	 mov	 eax, DWORD PTR bytes_read_so_far$6[rsp]
  00294	39 84 24 24 01
	00 00		 cmp	 DWORD PTR info$[rsp+4], eax
  0029b	7c 18		 jl	 SHORT $LN47@stbi__bmp_
  0029d	8b 44 24 70	 mov	 eax, DWORD PTR bytes_read_so_far$6[rsp]
  002a1	8b 8c 24 24 01
	00 00		 mov	 ecx, DWORD PTR info$[rsp+4]
  002a8	2b c8		 sub	 ecx, eax
  002aa	8b c1		 mov	 eax, ecx
  002ac	3b 84 24 fc 00
	00 00		 cmp	 eax, DWORD PTR extra_data_limit$22[rsp]
  002b3	7e 37		 jle	 SHORT $LN45@stbi__bmp_
$LN47@stbi__bmp_:

; 5575 :             return stbi__errpuc("bad offset", "Corrupt BMP");

  002b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG80999
  002bc	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  002c1	85 c0		 test	 eax, eax
  002c3	74 0d		 je	 SHORT $LN105@stbi__bmp_
  002c5	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv182[rsp], 0
  002d0	eb 0b		 jmp	 SHORT $LN106@stbi__bmp_
$LN105@stbi__bmp_:
  002d2	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv182[rsp], 0
$LN106@stbi__bmp_:
  002dd	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR tv182[rsp]
  002e5	e9 6d 0f 00 00	 jmp	 $LN1@stbi__bmp_

; 5576 :         } else {

  002ea	eb 1e		 jmp	 SHORT $LN46@stbi__bmp_
$LN45@stbi__bmp_:

; 5577 :             stbi__skip(s, info.offset - bytes_read_so_far);

  002ec	8b 44 24 70	 mov	 eax, DWORD PTR bytes_read_so_far$6[rsp]
  002f0	8b 8c 24 24 01
	00 00		 mov	 ecx, DWORD PTR info$[rsp+4]
  002f7	2b c8		 sub	 ecx, eax
  002f9	8b c1		 mov	 eax, ecx
  002fb	8b d0		 mov	 edx, eax
  002fd	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00305	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip
$LN46@stbi__bmp_:
$LN42@stbi__bmp_:

; 5578 :         }
; 5579 :     }
; 5580 :     
; 5581 :     if (info.bpp == 24 && ma == 0xff000000)

  0030a	83 bc 24 20 01
	00 00 18	 cmp	 DWORD PTR info$[rsp], 24
  00312	75 1b		 jne	 SHORT $LN48@stbi__bmp_
  00314	81 7c 24 54 00
	00 00 ff	 cmp	 DWORD PTR ma$[rsp], -16777216 ; ff000000H
  0031c	75 11		 jne	 SHORT $LN48@stbi__bmp_

; 5582 :         s->img_n = 3;

  0031e	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00326	c7 40 08 03 00
	00 00		 mov	 DWORD PTR [rax+8], 3
  0032d	eb 31		 jmp	 SHORT $LN49@stbi__bmp_
$LN48@stbi__bmp_:

; 5583 :     else
; 5584 :         s->img_n = ma ? 4 : 3;

  0032f	83 7c 24 54 00	 cmp	 DWORD PTR ma$[rsp], 0
  00334	74 0d		 je	 SHORT $LN107@stbi__bmp_
  00336	c7 84 24 ac 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv192[rsp], 4
  00341	eb 0b		 jmp	 SHORT $LN108@stbi__bmp_
$LN107@stbi__bmp_:
  00343	c7 84 24 ac 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv192[rsp], 3
$LN108@stbi__bmp_:
  0034e	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00356	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv192[rsp]
  0035d	89 48 08	 mov	 DWORD PTR [rax+8], ecx
$LN49@stbi__bmp_:

; 5585 :     if (req_comp && req_comp >= 3) // we can directly decode 3 or 4

  00360	83 bc 24 90 05
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  00368	74 17		 je	 SHORT $LN50@stbi__bmp_
  0036a	83 bc 24 90 05
	00 00 03	 cmp	 DWORD PTR req_comp$[rsp], 3
  00372	7c 0d		 jl	 SHORT $LN50@stbi__bmp_

; 5586 :         target = req_comp;

  00374	8b 84 24 90 05
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  0037b	89 44 24 48	 mov	 DWORD PTR target$[rsp], eax
  0037f	eb 0f		 jmp	 SHORT $LN51@stbi__bmp_
$LN50@stbi__bmp_:

; 5587 :     else
; 5588 :         target = s->img_n; // if they want monochrome, we'll post-convert

  00381	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00389	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0038c	89 44 24 48	 mov	 DWORD PTR target$[rsp], eax
$LN51@stbi__bmp_:

; 5589 :     
; 5590 :     // sanity-check size
; 5591 :     if (!stbi__mad3sizes_valid(target, s->img_x, s->img_y, 0))

  00390	45 33 c9	 xor	 r9d, r9d
  00393	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0039b	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  0039f	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003a7	8b 10		 mov	 edx, DWORD PTR [rax]
  003a9	8b 4c 24 48	 mov	 ecx, DWORD PTR target$[rsp]
  003ad	e8 00 00 00 00	 call	 ?stbi__mad3sizes_valid@@YAHHHHH@Z ; stbi__mad3sizes_valid
  003b2	85 c0		 test	 eax, eax
  003b4	75 35		 jne	 SHORT $LN52@stbi__bmp_

; 5592 :         return stbi__errpuc("too large", "Corrupt BMP");

  003b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81005
  003bd	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  003c2	85 c0		 test	 eax, eax
  003c4	74 0d		 je	 SHORT $LN109@stbi__bmp_
  003c6	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv207[rsp], 0
  003d1	eb 0b		 jmp	 SHORT $LN110@stbi__bmp_
$LN109@stbi__bmp_:
  003d3	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv207[rsp], 0
$LN110@stbi__bmp_:
  003de	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR tv207[rsp]
  003e6	e9 6c 0e 00 00	 jmp	 $LN1@stbi__bmp_
$LN52@stbi__bmp_:

; 5593 :     
; 5594 :     out = (stbi_uc *) stbi__malloc_mad3(target, s->img_x, s->img_y, 0);

  003eb	45 33 c9	 xor	 r9d, r9d
  003ee	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003f6	44 8b 40 04	 mov	 r8d, DWORD PTR [rax+4]
  003fa	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00402	8b 10		 mov	 edx, DWORD PTR [rax]
  00404	8b 4c 24 48	 mov	 ecx, DWORD PTR target$[rsp]
  00408	e8 00 00 00 00	 call	 ?stbi__malloc_mad3@@YAPEAXHHHH@Z ; stbi__malloc_mad3
  0040d	48 89 44 24 40	 mov	 QWORD PTR out$[rsp], rax

; 5595 :     if (!out) return stbi__errpuc("outofmem", "Out of memory");

  00412	48 83 7c 24 40
	00		 cmp	 QWORD PTR out$[rsp], 0
  00418	75 35		 jne	 SHORT $LN53@stbi__bmp_
  0041a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81007
  00421	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00426	85 c0		 test	 eax, eax
  00428	74 0d		 je	 SHORT $LN111@stbi__bmp_
  0042a	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv220[rsp], 0
  00435	eb 0b		 jmp	 SHORT $LN112@stbi__bmp_
$LN111@stbi__bmp_:
  00437	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv220[rsp], 0
$LN112@stbi__bmp_:
  00442	48 63 84 24 b4
	00 00 00	 movsxd	 rax, DWORD PTR tv220[rsp]
  0044a	e9 08 0e 00 00	 jmp	 $LN1@stbi__bmp_
$LN53@stbi__bmp_:

; 5596 :     if (info.bpp < 16) {

  0044f	83 bc 24 20 01
	00 00 10	 cmp	 DWORD PTR info$[rsp], 16
  00457	0f 8d 52 06 00
	00		 jge	 $LN54@stbi__bmp_

; 5597 :         int z=0;

  0045d	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR z$1[rsp], 0

; 5598 :         if (psize == 0 || psize > 256) { STBI_FREE(out); return stbi__errpuc("invalid", "Corrupt BMP"); }

  00465	83 7c 24 5c 00	 cmp	 DWORD PTR psize$[rsp], 0
  0046a	74 0a		 je	 SHORT $LN57@stbi__bmp_
  0046c	81 7c 24 5c 00
	01 00 00	 cmp	 DWORD PTR psize$[rsp], 256 ; 00000100H
  00474	7e 3f		 jle	 SHORT $LN56@stbi__bmp_
$LN57@stbi__bmp_:
  00476	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  0047b	e8 00 00 00 00	 call	 free
  00480	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81012
  00487	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0048c	85 c0		 test	 eax, eax
  0048e	74 0d		 je	 SHORT $LN113@stbi__bmp_
  00490	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv229[rsp], 0
  0049b	eb 0b		 jmp	 SHORT $LN114@stbi__bmp_
$LN113@stbi__bmp_:
  0049d	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv229[rsp], 0
$LN114@stbi__bmp_:
  004a8	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR tv229[rsp]
  004b0	e9 a2 0d 00 00	 jmp	 $LN1@stbi__bmp_
$LN56@stbi__bmp_:

; 5599 :         for (i=0; i < psize; ++i) {

  004b5	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  004bd	eb 0a		 jmp	 SHORT $LN4@stbi__bmp_
$LN2@stbi__bmp_:
  004bf	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  004c3	ff c0		 inc	 eax
  004c5	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@stbi__bmp_:
  004c9	8b 44 24 5c	 mov	 eax, DWORD PTR psize$[rsp]
  004cd	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  004d1	0f 8d a8 00 00
	00		 jge	 $LN3@stbi__bmp_

; 5600 :             pal[i][2] = stbi__get8(s);

  004d7	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  004df	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  004e4	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  004e9	48 8d 8c 8c 50
	01 00 00	 lea	 rcx, QWORD PTR pal$[rsp+rcx*4]
  004f1	ba 01 00 00 00	 mov	 edx, 1
  004f6	48 6b d2 02	 imul	 rdx, rdx, 2
  004fa	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 5601 :             pal[i][1] = stbi__get8(s);

  004fd	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00505	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0050a	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0050f	48 8d 8c 8c 50
	01 00 00	 lea	 rcx, QWORD PTR pal$[rsp+rcx*4]
  00517	ba 01 00 00 00	 mov	 edx, 1
  0051c	48 6b d2 01	 imul	 rdx, rdx, 1
  00520	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 5602 :             pal[i][0] = stbi__get8(s);

  00523	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0052b	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00530	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00535	48 8d 8c 8c 50
	01 00 00	 lea	 rcx, QWORD PTR pal$[rsp+rcx*4]
  0053d	ba 01 00 00 00	 mov	 edx, 1
  00542	48 6b d2 00	 imul	 rdx, rdx, 0
  00546	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 5603 :             if (info.hsz != 12) stbi__get8(s);

  00549	83 bc 24 28 01
	00 00 0c	 cmp	 DWORD PTR info$[rsp+8], 12
  00551	74 0d		 je	 SHORT $LN58@stbi__bmp_
  00553	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0055b	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
$LN58@stbi__bmp_:

; 5604 :             pal[i][3] = 255;

  00560	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00565	48 8d 84 84 50
	01 00 00	 lea	 rax, QWORD PTR pal$[rsp+rax*4]
  0056d	b9 01 00 00 00	 mov	 ecx, 1
  00572	48 6b c9 03	 imul	 rcx, rcx, 3
  00576	c6 04 08 ff	 mov	 BYTE PTR [rax+rcx], 255	; 000000ffH

; 5605 :         }

  0057a	e9 40 ff ff ff	 jmp	 $LN2@stbi__bmp_
$LN3@stbi__bmp_:

; 5606 :         stbi__skip(s, info.offset - info.extra_read - info.hsz - psize * (info.hsz == 12 ? 3 : 4));

  0057f	83 bc 24 28 01
	00 00 0c	 cmp	 DWORD PTR info$[rsp+8], 12
  00587	75 0d		 jne	 SHORT $LN115@stbi__bmp_
  00589	c7 84 24 bc 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv264[rsp], 3
  00594	eb 0b		 jmp	 SHORT $LN116@stbi__bmp_
$LN115@stbi__bmp_:
  00596	c7 84 24 bc 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv264[rsp], 4
$LN116@stbi__bmp_:
  005a1	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR info$[rsp+32]
  005a8	8b 8c 24 24 01
	00 00		 mov	 ecx, DWORD PTR info$[rsp+4]
  005af	2b c8		 sub	 ecx, eax
  005b1	8b c1		 mov	 eax, ecx
  005b3	2b 84 24 28 01
	00 00		 sub	 eax, DWORD PTR info$[rsp+8]
  005ba	8b 4c 24 5c	 mov	 ecx, DWORD PTR psize$[rsp]
  005be	0f af 8c 24 bc
	00 00 00	 imul	 ecx, DWORD PTR tv264[rsp]
  005c6	2b c1		 sub	 eax, ecx
  005c8	8b d0		 mov	 edx, eax
  005ca	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005d2	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 5607 :         if (info.bpp == 1) width = (s->img_x + 7) >> 3;

  005d7	83 bc 24 20 01
	00 00 01	 cmp	 DWORD PTR info$[rsp], 1
  005df	75 16		 jne	 SHORT $LN59@stbi__bmp_
  005e1	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005e9	8b 00		 mov	 eax, DWORD PTR [rax]
  005eb	83 c0 07	 add	 eax, 7
  005ee	c1 e8 03	 shr	 eax, 3
  005f1	89 44 24 60	 mov	 DWORD PTR width$[rsp], eax
  005f5	eb 77		 jmp	 SHORT $LN60@stbi__bmp_
$LN59@stbi__bmp_:

; 5608 :         else if (info.bpp == 4) width = (s->img_x + 1) >> 1;

  005f7	83 bc 24 20 01
	00 00 04	 cmp	 DWORD PTR info$[rsp], 4
  005ff	75 14		 jne	 SHORT $LN61@stbi__bmp_
  00601	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00609	8b 00		 mov	 eax, DWORD PTR [rax]
  0060b	ff c0		 inc	 eax
  0060d	d1 e8		 shr	 eax, 1
  0060f	89 44 24 60	 mov	 DWORD PTR width$[rsp], eax
  00613	eb 59		 jmp	 SHORT $LN62@stbi__bmp_
$LN61@stbi__bmp_:

; 5609 :         else if (info.bpp == 8) width = s->img_x;

  00615	83 bc 24 20 01
	00 00 08	 cmp	 DWORD PTR info$[rsp], 8
  0061d	75 10		 jne	 SHORT $LN63@stbi__bmp_
  0061f	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00627	8b 00		 mov	 eax, DWORD PTR [rax]
  00629	89 44 24 60	 mov	 DWORD PTR width$[rsp], eax
  0062d	eb 3f		 jmp	 SHORT $LN64@stbi__bmp_
$LN63@stbi__bmp_:

; 5610 :         else { STBI_FREE(out); return stbi__errpuc("bad bpp", "Corrupt BMP"); }

  0062f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  00634	e8 00 00 00 00	 call	 free
  00639	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81020
  00640	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00645	85 c0		 test	 eax, eax
  00647	74 0d		 je	 SHORT $LN117@stbi__bmp_
  00649	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv283[rsp], 0
  00654	eb 0b		 jmp	 SHORT $LN118@stbi__bmp_
$LN117@stbi__bmp_:
  00656	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv283[rsp], 0
$LN118@stbi__bmp_:
  00661	48 63 84 24 c0
	00 00 00	 movsxd	 rax, DWORD PTR tv283[rsp]
  00669	e9 e9 0b 00 00	 jmp	 $LN1@stbi__bmp_
$LN64@stbi__bmp_:
$LN62@stbi__bmp_:
$LN60@stbi__bmp_:

; 5611 :         pad = (-width)&3;

  0066e	8b 44 24 60	 mov	 eax, DWORD PTR width$[rsp]
  00672	f7 d8		 neg	 eax
  00674	83 e0 03	 and	 eax, 3
  00677	89 84 24 84 00
	00 00		 mov	 DWORD PTR pad$[rsp], eax

; 5612 :         if (info.bpp == 1) {

  0067e	83 bc 24 20 01
	00 00 01	 cmp	 DWORD PTR info$[rsp], 1
  00686	0f 85 af 01 00
	00		 jne	 $LN65@stbi__bmp_

; 5613 :             for (j=0; j < (int) s->img_y; ++j) {

  0068c	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00694	eb 0a		 jmp	 SHORT $LN7@stbi__bmp_
$LN5@stbi__bmp_:
  00696	8b 44 24 3c	 mov	 eax, DWORD PTR j$[rsp]
  0069a	ff c0		 inc	 eax
  0069c	89 44 24 3c	 mov	 DWORD PTR j$[rsp], eax
$LN7@stbi__bmp_:
  006a0	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006a8	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  006ab	39 44 24 3c	 cmp	 DWORD PTR j$[rsp], eax
  006af	0f 8d 81 01 00
	00		 jge	 $LN6@stbi__bmp_

; 5614 :                 int bit_offset = 7, v = stbi__get8(s);

  006b5	c7 44 24 74 07
	00 00 00	 mov	 DWORD PTR bit_offset$7[rsp], 7
  006bd	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  006c5	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  006ca	0f b6 c0	 movzx	 eax, al
  006cd	89 84 24 c4 00
	00 00		 mov	 DWORD PTR v$15[rsp], eax

; 5615 :                 for (i=0; i < (int) s->img_x; ++i) {

  006d4	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  006dc	eb 0a		 jmp	 SHORT $LN10@stbi__bmp_
$LN8@stbi__bmp_:
  006de	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  006e2	ff c0		 inc	 eax
  006e4	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@stbi__bmp_:
  006e8	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006f0	8b 00		 mov	 eax, DWORD PTR [rax]
  006f2	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  006f6	0f 8d 21 01 00
	00		 jge	 $LN9@stbi__bmp_

; 5616 :                     int color = (v>>bit_offset)&0x1;

  006fc	8b 44 24 74	 mov	 eax, DWORD PTR bit_offset$7[rsp]
  00700	0f b6 c8	 movzx	 ecx, al
  00703	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR v$15[rsp]
  0070a	d3 f8		 sar	 eax, cl
  0070c	83 e0 01	 and	 eax, 1
  0070f	89 84 24 88 00
	00 00		 mov	 DWORD PTR color$10[rsp], eax

; 5617 :                     out[z++] = pal[color][0];

  00716	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR color$10[rsp]
  0071e	48 8d 84 84 50
	01 00 00	 lea	 rax, QWORD PTR pal$[rsp+rax*4]
  00726	b9 01 00 00 00	 mov	 ecx, 1
  0072b	48 6b c9 00	 imul	 rcx, rcx, 0
  0072f	48 63 54 24 34	 movsxd	 rdx, DWORD PTR z$1[rsp]
  00734	4c 8b 44 24 40	 mov	 r8, QWORD PTR out$[rsp]
  00739	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0073d	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  00741	8b 44 24 34	 mov	 eax, DWORD PTR z$1[rsp]
  00745	ff c0		 inc	 eax
  00747	89 44 24 34	 mov	 DWORD PTR z$1[rsp], eax

; 5618 :                     out[z++] = pal[color][1];

  0074b	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR color$10[rsp]
  00753	48 8d 84 84 50
	01 00 00	 lea	 rax, QWORD PTR pal$[rsp+rax*4]
  0075b	b9 01 00 00 00	 mov	 ecx, 1
  00760	48 6b c9 01	 imul	 rcx, rcx, 1
  00764	48 63 54 24 34	 movsxd	 rdx, DWORD PTR z$1[rsp]
  00769	4c 8b 44 24 40	 mov	 r8, QWORD PTR out$[rsp]
  0076e	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00772	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  00776	8b 44 24 34	 mov	 eax, DWORD PTR z$1[rsp]
  0077a	ff c0		 inc	 eax
  0077c	89 44 24 34	 mov	 DWORD PTR z$1[rsp], eax

; 5619 :                     out[z++] = pal[color][2];

  00780	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR color$10[rsp]
  00788	48 8d 84 84 50
	01 00 00	 lea	 rax, QWORD PTR pal$[rsp+rax*4]
  00790	b9 01 00 00 00	 mov	 ecx, 1
  00795	48 6b c9 02	 imul	 rcx, rcx, 2
  00799	48 63 54 24 34	 movsxd	 rdx, DWORD PTR z$1[rsp]
  0079e	4c 8b 44 24 40	 mov	 r8, QWORD PTR out$[rsp]
  007a3	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  007a7	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  007ab	8b 44 24 34	 mov	 eax, DWORD PTR z$1[rsp]
  007af	ff c0		 inc	 eax
  007b1	89 44 24 34	 mov	 DWORD PTR z$1[rsp], eax

; 5620 :                     if (target == 4) out[z++] = 255;

  007b5	83 7c 24 48 04	 cmp	 DWORD PTR target$[rsp], 4
  007ba	75 18		 jne	 SHORT $LN67@stbi__bmp_
  007bc	48 63 44 24 34	 movsxd	 rax, DWORD PTR z$1[rsp]
  007c1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  007c6	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  007ca	8b 44 24 34	 mov	 eax, DWORD PTR z$1[rsp]
  007ce	ff c0		 inc	 eax
  007d0	89 44 24 34	 mov	 DWORD PTR z$1[rsp], eax
$LN67@stbi__bmp_:

; 5621 :                     if (i+1 == (int) s->img_x) break;

  007d4	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  007d8	ff c0		 inc	 eax
  007da	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007e2	3b 01		 cmp	 eax, DWORD PTR [rcx]
  007e4	75 02		 jne	 SHORT $LN68@stbi__bmp_
  007e6	eb 35		 jmp	 SHORT $LN9@stbi__bmp_
$LN68@stbi__bmp_:

; 5622 :                     if((--bit_offset) < 0) {

  007e8	8b 44 24 74	 mov	 eax, DWORD PTR bit_offset$7[rsp]
  007ec	ff c8		 dec	 eax
  007ee	89 44 24 74	 mov	 DWORD PTR bit_offset$7[rsp], eax
  007f2	83 7c 24 74 00	 cmp	 DWORD PTR bit_offset$7[rsp], 0
  007f7	7d 1f		 jge	 SHORT $LN69@stbi__bmp_

; 5623 :                         bit_offset = 7;

  007f9	c7 44 24 74 07
	00 00 00	 mov	 DWORD PTR bit_offset$7[rsp], 7

; 5624 :                         v = stbi__get8(s);

  00801	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00809	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0080e	0f b6 c0	 movzx	 eax, al
  00811	89 84 24 c4 00
	00 00		 mov	 DWORD PTR v$15[rsp], eax
$LN69@stbi__bmp_:

; 5625 :                     }
; 5626 :                 }

  00818	e9 c1 fe ff ff	 jmp	 $LN8@stbi__bmp_
$LN9@stbi__bmp_:

; 5627 :                 stbi__skip(s, pad);

  0081d	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR pad$[rsp]
  00824	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0082c	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 5628 :             }

  00831	e9 60 fe ff ff	 jmp	 $LN5@stbi__bmp_
$LN6@stbi__bmp_:

; 5629 :         } else {

  00836	e9 6f 02 00 00	 jmp	 $LN66@stbi__bmp_
$LN65@stbi__bmp_:

; 5630 :             for (j=0; j < (int) s->img_y; ++j) {

  0083b	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00843	eb 0a		 jmp	 SHORT $LN13@stbi__bmp_
$LN11@stbi__bmp_:
  00845	8b 44 24 3c	 mov	 eax, DWORD PTR j$[rsp]
  00849	ff c0		 inc	 eax
  0084b	89 44 24 3c	 mov	 DWORD PTR j$[rsp], eax
$LN13@stbi__bmp_:
  0084f	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00857	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0085a	39 44 24 3c	 cmp	 DWORD PTR j$[rsp], eax
  0085e	0f 8d 46 02 00
	00		 jge	 $LN12@stbi__bmp_

; 5631 :                 for (i=0; i < (int) s->img_x; i += 2) {

  00864	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0086c	eb 0b		 jmp	 SHORT $LN16@stbi__bmp_
$LN14@stbi__bmp_:
  0086e	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00872	83 c0 02	 add	 eax, 2
  00875	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN16@stbi__bmp_:
  00879	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00881	8b 00		 mov	 eax, DWORD PTR [rax]
  00883	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00887	0f 8d 04 02 00
	00		 jge	 $LN15@stbi__bmp_

; 5632 :                     int v=stbi__get8(s),v2=0;

  0088d	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00895	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  0089a	0f b6 c0	 movzx	 eax, al
  0089d	89 44 24 50	 mov	 DWORD PTR v$4[rsp], eax
  008a1	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR v2$16[rsp], 0

; 5633 :                     if (info.bpp == 4) {

  008ac	83 bc 24 20 01
	00 00 04	 cmp	 DWORD PTR info$[rsp], 4
  008b4	75 19		 jne	 SHORT $LN70@stbi__bmp_

; 5634 :                         v2 = v & 15;

  008b6	8b 44 24 50	 mov	 eax, DWORD PTR v$4[rsp]
  008ba	83 e0 0f	 and	 eax, 15
  008bd	89 84 24 c8 00
	00 00		 mov	 DWORD PTR v2$16[rsp], eax

; 5635 :                         v >>= 4;

  008c4	8b 44 24 50	 mov	 eax, DWORD PTR v$4[rsp]
  008c8	c1 f8 04	 sar	 eax, 4
  008cb	89 44 24 50	 mov	 DWORD PTR v$4[rsp], eax
$LN70@stbi__bmp_:

; 5636 :                     }
; 5637 :                     out[z++] = pal[v][0];

  008cf	48 63 44 24 50	 movsxd	 rax, DWORD PTR v$4[rsp]
  008d4	48 8d 84 84 50
	01 00 00	 lea	 rax, QWORD PTR pal$[rsp+rax*4]
  008dc	b9 01 00 00 00	 mov	 ecx, 1
  008e1	48 6b c9 00	 imul	 rcx, rcx, 0
  008e5	48 63 54 24 34	 movsxd	 rdx, DWORD PTR z$1[rsp]
  008ea	4c 8b 44 24 40	 mov	 r8, QWORD PTR out$[rsp]
  008ef	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  008f3	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  008f7	8b 44 24 34	 mov	 eax, DWORD PTR z$1[rsp]
  008fb	ff c0		 inc	 eax
  008fd	89 44 24 34	 mov	 DWORD PTR z$1[rsp], eax

; 5638 :                     out[z++] = pal[v][1];

  00901	48 63 44 24 50	 movsxd	 rax, DWORD PTR v$4[rsp]
  00906	48 8d 84 84 50
	01 00 00	 lea	 rax, QWORD PTR pal$[rsp+rax*4]
  0090e	b9 01 00 00 00	 mov	 ecx, 1
  00913	48 6b c9 01	 imul	 rcx, rcx, 1
  00917	48 63 54 24 34	 movsxd	 rdx, DWORD PTR z$1[rsp]
  0091c	4c 8b 44 24 40	 mov	 r8, QWORD PTR out$[rsp]
  00921	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00925	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  00929	8b 44 24 34	 mov	 eax, DWORD PTR z$1[rsp]
  0092d	ff c0		 inc	 eax
  0092f	89 44 24 34	 mov	 DWORD PTR z$1[rsp], eax

; 5639 :                     out[z++] = pal[v][2];

  00933	48 63 44 24 50	 movsxd	 rax, DWORD PTR v$4[rsp]
  00938	48 8d 84 84 50
	01 00 00	 lea	 rax, QWORD PTR pal$[rsp+rax*4]
  00940	b9 01 00 00 00	 mov	 ecx, 1
  00945	48 6b c9 02	 imul	 rcx, rcx, 2
  00949	48 63 54 24 34	 movsxd	 rdx, DWORD PTR z$1[rsp]
  0094e	4c 8b 44 24 40	 mov	 r8, QWORD PTR out$[rsp]
  00953	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00957	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  0095b	8b 44 24 34	 mov	 eax, DWORD PTR z$1[rsp]
  0095f	ff c0		 inc	 eax
  00961	89 44 24 34	 mov	 DWORD PTR z$1[rsp], eax

; 5640 :                     if (target == 4) out[z++] = 255;

  00965	83 7c 24 48 04	 cmp	 DWORD PTR target$[rsp], 4
  0096a	75 18		 jne	 SHORT $LN71@stbi__bmp_
  0096c	48 63 44 24 34	 movsxd	 rax, DWORD PTR z$1[rsp]
  00971	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  00976	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  0097a	8b 44 24 34	 mov	 eax, DWORD PTR z$1[rsp]
  0097e	ff c0		 inc	 eax
  00980	89 44 24 34	 mov	 DWORD PTR z$1[rsp], eax
$LN71@stbi__bmp_:

; 5641 :                     if (i+1 == (int) s->img_x) break;

  00984	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00988	ff c0		 inc	 eax
  0098a	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00992	3b 01		 cmp	 eax, DWORD PTR [rcx]
  00994	75 05		 jne	 SHORT $LN72@stbi__bmp_
  00996	e9 f6 00 00 00	 jmp	 $LN15@stbi__bmp_
$LN72@stbi__bmp_:

; 5642 :                     v = (info.bpp == 8) ? stbi__get8(s) : v2;

  0099b	83 bc 24 20 01
	00 00 08	 cmp	 DWORD PTR info$[rsp], 8
  009a3	75 19		 jne	 SHORT $LN119@stbi__bmp_
  009a5	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  009ad	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  009b2	0f b6 c0	 movzx	 eax, al
  009b5	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv392[rsp], eax
  009bc	eb 0e		 jmp	 SHORT $LN120@stbi__bmp_
$LN119@stbi__bmp_:
  009be	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR v2$16[rsp]
  009c5	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv392[rsp], eax
$LN120@stbi__bmp_:
  009cc	8b 84 24 cc 00
	00 00		 mov	 eax, DWORD PTR tv392[rsp]
  009d3	89 44 24 50	 mov	 DWORD PTR v$4[rsp], eax

; 5643 :                     out[z++] = pal[v][0];

  009d7	48 63 44 24 50	 movsxd	 rax, DWORD PTR v$4[rsp]
  009dc	48 8d 84 84 50
	01 00 00	 lea	 rax, QWORD PTR pal$[rsp+rax*4]
  009e4	b9 01 00 00 00	 mov	 ecx, 1
  009e9	48 6b c9 00	 imul	 rcx, rcx, 0
  009ed	48 63 54 24 34	 movsxd	 rdx, DWORD PTR z$1[rsp]
  009f2	4c 8b 44 24 40	 mov	 r8, QWORD PTR out$[rsp]
  009f7	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  009fb	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  009ff	8b 44 24 34	 mov	 eax, DWORD PTR z$1[rsp]
  00a03	ff c0		 inc	 eax
  00a05	89 44 24 34	 mov	 DWORD PTR z$1[rsp], eax

; 5644 :                     out[z++] = pal[v][1];

  00a09	48 63 44 24 50	 movsxd	 rax, DWORD PTR v$4[rsp]
  00a0e	48 8d 84 84 50
	01 00 00	 lea	 rax, QWORD PTR pal$[rsp+rax*4]
  00a16	b9 01 00 00 00	 mov	 ecx, 1
  00a1b	48 6b c9 01	 imul	 rcx, rcx, 1
  00a1f	48 63 54 24 34	 movsxd	 rdx, DWORD PTR z$1[rsp]
  00a24	4c 8b 44 24 40	 mov	 r8, QWORD PTR out$[rsp]
  00a29	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00a2d	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  00a31	8b 44 24 34	 mov	 eax, DWORD PTR z$1[rsp]
  00a35	ff c0		 inc	 eax
  00a37	89 44 24 34	 mov	 DWORD PTR z$1[rsp], eax

; 5645 :                     out[z++] = pal[v][2];

  00a3b	48 63 44 24 50	 movsxd	 rax, DWORD PTR v$4[rsp]
  00a40	48 8d 84 84 50
	01 00 00	 lea	 rax, QWORD PTR pal$[rsp+rax*4]
  00a48	b9 01 00 00 00	 mov	 ecx, 1
  00a4d	48 6b c9 02	 imul	 rcx, rcx, 2
  00a51	48 63 54 24 34	 movsxd	 rdx, DWORD PTR z$1[rsp]
  00a56	4c 8b 44 24 40	 mov	 r8, QWORD PTR out$[rsp]
  00a5b	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00a5f	41 88 04 10	 mov	 BYTE PTR [r8+rdx], al
  00a63	8b 44 24 34	 mov	 eax, DWORD PTR z$1[rsp]
  00a67	ff c0		 inc	 eax
  00a69	89 44 24 34	 mov	 DWORD PTR z$1[rsp], eax

; 5646 :                     if (target == 4) out[z++] = 255;

  00a6d	83 7c 24 48 04	 cmp	 DWORD PTR target$[rsp], 4
  00a72	75 18		 jne	 SHORT $LN73@stbi__bmp_
  00a74	48 63 44 24 34	 movsxd	 rax, DWORD PTR z$1[rsp]
  00a79	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  00a7e	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  00a82	8b 44 24 34	 mov	 eax, DWORD PTR z$1[rsp]
  00a86	ff c0		 inc	 eax
  00a88	89 44 24 34	 mov	 DWORD PTR z$1[rsp], eax
$LN73@stbi__bmp_:

; 5647 :                 }

  00a8c	e9 dd fd ff ff	 jmp	 $LN14@stbi__bmp_
$LN15@stbi__bmp_:

; 5648 :                 stbi__skip(s, pad);

  00a91	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR pad$[rsp]
  00a98	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00aa0	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 5649 :             }

  00aa5	e9 9b fd ff ff	 jmp	 $LN11@stbi__bmp_
$LN12@stbi__bmp_:
$LN66@stbi__bmp_:

; 5650 :         }
; 5651 :     } else {

  00aaa	e9 98 05 00 00	 jmp	 $LN55@stbi__bmp_
$LN54@stbi__bmp_:

; 5652 :         int rshift=0,gshift=0,bshift=0,ashift=0,rcount=0,gcount=0,bcount=0,acount=0;

  00aaf	c7 84 24 e0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR rshift$17[rsp], 0
  00aba	c7 84 24 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR gshift$18[rsp], 0
  00ac5	c7 84 24 e8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR bshift$19[rsp], 0
  00ad0	c7 84 24 ec 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ashift$20[rsp], 0
  00adb	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR rcount$11[rsp], 0
  00ae6	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR gcount$12[rsp], 0
  00af1	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR bcount$13[rsp], 0
  00afc	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR acount$14[rsp], 0

; 5653 :         int z = 0;

  00b07	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR z$2[rsp], 0

; 5654 :         int easy=0;

  00b0f	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR easy$8[rsp], 0

; 5655 :         stbi__skip(s, info.offset - info.extra_read - info.hsz);

  00b17	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR info$[rsp+32]
  00b1e	8b 8c 24 24 01
	00 00		 mov	 ecx, DWORD PTR info$[rsp+4]
  00b25	2b c8		 sub	 ecx, eax
  00b27	8b c1		 mov	 eax, ecx
  00b29	2b 84 24 28 01
	00 00		 sub	 eax, DWORD PTR info$[rsp+8]
  00b30	8b d0		 mov	 edx, eax
  00b32	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00b3a	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 5656 :         if (info.bpp == 24) width = 3 * s->img_x;

  00b3f	83 bc 24 20 01
	00 00 18	 cmp	 DWORD PTR info$[rsp], 24
  00b47	75 11		 jne	 SHORT $LN74@stbi__bmp_
  00b49	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b51	6b 00 03	 imul	 eax, DWORD PTR [rax], 3
  00b54	89 44 24 60	 mov	 DWORD PTR width$[rsp], eax
  00b58	eb 24		 jmp	 SHORT $LN75@stbi__bmp_
$LN74@stbi__bmp_:

; 5657 :         else if (info.bpp == 16) width = 2*s->img_x;

  00b5a	83 bc 24 20 01
	00 00 10	 cmp	 DWORD PTR info$[rsp], 16
  00b62	75 12		 jne	 SHORT $LN76@stbi__bmp_
  00b64	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b6c	8b 00		 mov	 eax, DWORD PTR [rax]
  00b6e	d1 e0		 shl	 eax, 1
  00b70	89 44 24 60	 mov	 DWORD PTR width$[rsp], eax
  00b74	eb 08		 jmp	 SHORT $LN77@stbi__bmp_
$LN76@stbi__bmp_:

; 5658 :         else /* bpp = 32 and pad = 0 */ width=0;

  00b76	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR width$[rsp], 0
$LN77@stbi__bmp_:
$LN75@stbi__bmp_:

; 5659 :         pad = (-width) & 3;

  00b7e	8b 44 24 60	 mov	 eax, DWORD PTR width$[rsp]
  00b82	f7 d8		 neg	 eax
  00b84	83 e0 03	 and	 eax, 3
  00b87	89 84 24 84 00
	00 00		 mov	 DWORD PTR pad$[rsp], eax

; 5660 :         if (info.bpp == 24) {

  00b8e	83 bc 24 20 01
	00 00 18	 cmp	 DWORD PTR info$[rsp], 24
  00b96	75 0a		 jne	 SHORT $LN78@stbi__bmp_

; 5661 :             easy = 1;

  00b98	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR easy$8[rsp], 1
  00ba0	eb 3a		 jmp	 SHORT $LN79@stbi__bmp_
$LN78@stbi__bmp_:

; 5662 :         } else if (info.bpp == 32) {

  00ba2	83 bc 24 20 01
	00 00 20	 cmp	 DWORD PTR info$[rsp], 32 ; 00000020H
  00baa	75 30		 jne	 SHORT $LN80@stbi__bmp_

; 5663 :             if (mb == 0xff && mg == 0xff00 && mr == 0x00ff0000 && ma == 0xff000000)

  00bac	81 7c 24 6c ff
	00 00 00	 cmp	 DWORD PTR mb$[rsp], 255	; 000000ffH
  00bb4	75 26		 jne	 SHORT $LN81@stbi__bmp_
  00bb6	81 7c 24 68 00
	ff 00 00	 cmp	 DWORD PTR mg$[rsp], 65280 ; 0000ff00H
  00bbe	75 1c		 jne	 SHORT $LN81@stbi__bmp_
  00bc0	81 7c 24 64 00
	00 ff 00	 cmp	 DWORD PTR mr$[rsp], 16711680 ; 00ff0000H
  00bc8	75 12		 jne	 SHORT $LN81@stbi__bmp_
  00bca	81 7c 24 54 00
	00 00 ff	 cmp	 DWORD PTR ma$[rsp], -16777216 ; ff000000H
  00bd2	75 08		 jne	 SHORT $LN81@stbi__bmp_

; 5664 :                 easy = 2;

  00bd4	c7 44 24 78 02
	00 00 00	 mov	 DWORD PTR easy$8[rsp], 2
$LN81@stbi__bmp_:
$LN80@stbi__bmp_:
$LN79@stbi__bmp_:

; 5665 :         }
; 5666 :         if (!easy) {

  00bdc	83 7c 24 78 00	 cmp	 DWORD PTR easy$8[rsp], 0
  00be1	0f 85 47 01 00
	00		 jne	 $LN82@stbi__bmp_

; 5667 :             if (!mr || !mg || !mb) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }

  00be7	83 7c 24 64 00	 cmp	 DWORD PTR mr$[rsp], 0
  00bec	74 0e		 je	 SHORT $LN84@stbi__bmp_
  00bee	83 7c 24 68 00	 cmp	 DWORD PTR mg$[rsp], 0
  00bf3	74 07		 je	 SHORT $LN84@stbi__bmp_
  00bf5	83 7c 24 6c 00	 cmp	 DWORD PTR mb$[rsp], 0
  00bfa	75 3f		 jne	 SHORT $LN83@stbi__bmp_
$LN84@stbi__bmp_:
  00bfc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  00c01	e8 00 00 00 00	 call	 free
  00c06	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81041
  00c0d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00c12	85 c0		 test	 eax, eax
  00c14	74 0d		 je	 SHORT $LN121@stbi__bmp_
  00c16	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv453[rsp], 0
  00c21	eb 0b		 jmp	 SHORT $LN122@stbi__bmp_
$LN121@stbi__bmp_:
  00c23	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv453[rsp], 0
$LN122@stbi__bmp_:
  00c2e	48 63 84 24 d0
	00 00 00	 movsxd	 rax, DWORD PTR tv453[rsp]
  00c36	e9 1c 06 00 00	 jmp	 $LN1@stbi__bmp_
$LN83@stbi__bmp_:

; 5668 :             // right shift amt to put high bit in position #7
; 5669 :             rshift = stbi__high_bit(mr)-7; rcount = stbi__bitcount(mr);

  00c3b	8b 4c 24 64	 mov	 ecx, DWORD PTR mr$[rsp]
  00c3f	e8 00 00 00 00	 call	 ?stbi__high_bit@@YAHI@Z	; stbi__high_bit
  00c44	83 e8 07	 sub	 eax, 7
  00c47	89 84 24 e0 00
	00 00		 mov	 DWORD PTR rshift$17[rsp], eax
  00c4e	8b 4c 24 64	 mov	 ecx, DWORD PTR mr$[rsp]
  00c52	e8 00 00 00 00	 call	 ?stbi__bitcount@@YAHI@Z	; stbi__bitcount
  00c57	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rcount$11[rsp], eax

; 5670 :             gshift = stbi__high_bit(mg)-7; gcount = stbi__bitcount(mg);

  00c5e	8b 4c 24 68	 mov	 ecx, DWORD PTR mg$[rsp]
  00c62	e8 00 00 00 00	 call	 ?stbi__high_bit@@YAHI@Z	; stbi__high_bit
  00c67	83 e8 07	 sub	 eax, 7
  00c6a	89 84 24 e4 00
	00 00		 mov	 DWORD PTR gshift$18[rsp], eax
  00c71	8b 4c 24 68	 mov	 ecx, DWORD PTR mg$[rsp]
  00c75	e8 00 00 00 00	 call	 ?stbi__bitcount@@YAHI@Z	; stbi__bitcount
  00c7a	89 84 24 90 00
	00 00		 mov	 DWORD PTR gcount$12[rsp], eax

; 5671 :             bshift = stbi__high_bit(mb)-7; bcount = stbi__bitcount(mb);

  00c81	8b 4c 24 6c	 mov	 ecx, DWORD PTR mb$[rsp]
  00c85	e8 00 00 00 00	 call	 ?stbi__high_bit@@YAHI@Z	; stbi__high_bit
  00c8a	83 e8 07	 sub	 eax, 7
  00c8d	89 84 24 e8 00
	00 00		 mov	 DWORD PTR bshift$19[rsp], eax
  00c94	8b 4c 24 6c	 mov	 ecx, DWORD PTR mb$[rsp]
  00c98	e8 00 00 00 00	 call	 ?stbi__bitcount@@YAHI@Z	; stbi__bitcount
  00c9d	89 84 24 94 00
	00 00		 mov	 DWORD PTR bcount$13[rsp], eax

; 5672 :             ashift = stbi__high_bit(ma)-7; acount = stbi__bitcount(ma);

  00ca4	8b 4c 24 54	 mov	 ecx, DWORD PTR ma$[rsp]
  00ca8	e8 00 00 00 00	 call	 ?stbi__high_bit@@YAHI@Z	; stbi__high_bit
  00cad	83 e8 07	 sub	 eax, 7
  00cb0	89 84 24 ec 00
	00 00		 mov	 DWORD PTR ashift$20[rsp], eax
  00cb7	8b 4c 24 54	 mov	 ecx, DWORD PTR ma$[rsp]
  00cbb	e8 00 00 00 00	 call	 ?stbi__bitcount@@YAHI@Z	; stbi__bitcount
  00cc0	89 84 24 98 00
	00 00		 mov	 DWORD PTR acount$14[rsp], eax

; 5673 :             if (rcount > 8 || gcount > 8 || bcount > 8 || acount > 8) { STBI_FREE(out); return stbi__errpuc("bad masks", "Corrupt BMP"); }

  00cc7	83 bc 24 8c 00
	00 00 08	 cmp	 DWORD PTR rcount$11[rsp], 8
  00ccf	7f 1e		 jg	 SHORT $LN86@stbi__bmp_
  00cd1	83 bc 24 90 00
	00 00 08	 cmp	 DWORD PTR gcount$12[rsp], 8
  00cd9	7f 14		 jg	 SHORT $LN86@stbi__bmp_
  00cdb	83 bc 24 94 00
	00 00 08	 cmp	 DWORD PTR bcount$13[rsp], 8
  00ce3	7f 0a		 jg	 SHORT $LN86@stbi__bmp_
  00ce5	83 bc 24 98 00
	00 00 08	 cmp	 DWORD PTR acount$14[rsp], 8
  00ced	7e 3f		 jle	 SHORT $LN85@stbi__bmp_
$LN86@stbi__bmp_:
  00cef	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  00cf4	e8 00 00 00 00	 call	 free
  00cf9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG81044
  00d00	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00d05	85 c0		 test	 eax, eax
  00d07	74 0d		 je	 SHORT $LN123@stbi__bmp_
  00d09	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv483[rsp], 0
  00d14	eb 0b		 jmp	 SHORT $LN124@stbi__bmp_
$LN123@stbi__bmp_:
  00d16	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv483[rsp], 0
$LN124@stbi__bmp_:
  00d21	48 63 84 24 d4
	00 00 00	 movsxd	 rax, DWORD PTR tv483[rsp]
  00d29	e9 29 05 00 00	 jmp	 $LN1@stbi__bmp_
$LN85@stbi__bmp_:
$LN82@stbi__bmp_:

; 5674 :         }
; 5675 :         for (j=0; j < (int) s->img_y; ++j) {

  00d2e	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00d36	eb 0a		 jmp	 SHORT $LN19@stbi__bmp_
$LN17@stbi__bmp_:
  00d38	8b 44 24 3c	 mov	 eax, DWORD PTR j$[rsp]
  00d3c	ff c0		 inc	 eax
  00d3e	89 44 24 3c	 mov	 DWORD PTR j$[rsp], eax
$LN19@stbi__bmp_:
  00d42	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00d4a	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00d4d	39 44 24 3c	 cmp	 DWORD PTR j$[rsp], eax
  00d51	0f 8d f0 02 00
	00		 jge	 $LN18@stbi__bmp_

; 5676 :             if (easy) {

  00d57	83 7c 24 78 00	 cmp	 DWORD PTR easy$8[rsp], 0
  00d5c	0f 84 01 01 00
	00		 je	 $LN87@stbi__bmp_

; 5677 :                 for (i=0; i < (int) s->img_x; ++i) {

  00d62	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00d6a	eb 0a		 jmp	 SHORT $LN22@stbi__bmp_
$LN20@stbi__bmp_:
  00d6c	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00d70	ff c0		 inc	 eax
  00d72	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN22@stbi__bmp_:
  00d76	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00d7e	8b 00		 mov	 eax, DWORD PTR [rax]
  00d80	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00d84	0f 8d d4 00 00
	00		 jge	 $LN21@stbi__bmp_

; 5678 :                     unsigned char a;
; 5679 :                     out[z+2] = stbi__get8(s);

  00d8a	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00d92	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00d97	8b 4c 24 38	 mov	 ecx, DWORD PTR z$2[rsp]
  00d9b	83 c1 02	 add	 ecx, 2
  00d9e	48 63 c9	 movsxd	 rcx, ecx
  00da1	48 8b 54 24 40	 mov	 rdx, QWORD PTR out$[rsp]
  00da6	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5680 :                     out[z+1] = stbi__get8(s);

  00da9	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00db1	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00db6	8b 4c 24 38	 mov	 ecx, DWORD PTR z$2[rsp]
  00dba	ff c1		 inc	 ecx
  00dbc	48 63 c9	 movsxd	 rcx, ecx
  00dbf	48 8b 54 24 40	 mov	 rdx, QWORD PTR out$[rsp]
  00dc4	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5681 :                     out[z+0] = stbi__get8(s);

  00dc7	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00dcf	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00dd4	8b 4c 24 38	 mov	 ecx, DWORD PTR z$2[rsp]
  00dd8	48 63 c9	 movsxd	 rcx, ecx
  00ddb	48 8b 54 24 40	 mov	 rdx, QWORD PTR out$[rsp]
  00de0	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 5682 :                     z += 3;

  00de3	8b 44 24 38	 mov	 eax, DWORD PTR z$2[rsp]
  00de7	83 c0 03	 add	 eax, 3
  00dea	89 44 24 38	 mov	 DWORD PTR z$2[rsp], eax

; 5683 :                     a = (easy == 2 ? stbi__get8(s) : 255);

  00dee	83 7c 24 78 02	 cmp	 DWORD PTR easy$8[rsp], 2
  00df3	75 19		 jne	 SHORT $LN125@stbi__bmp_
  00df5	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00dfd	e8 00 00 00 00	 call	 ?stbi__get8@@YAEPEAUstbi__context@@@Z ; stbi__get8
  00e02	0f b6 c0	 movzx	 eax, al
  00e05	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv515[rsp], eax
  00e0c	eb 0b		 jmp	 SHORT $LN126@stbi__bmp_
$LN125@stbi__bmp_:
  00e0e	c7 84 24 d8 00
	00 00 ff 00 00
	00		 mov	 DWORD PTR tv515[rsp], 255 ; 000000ffH
$LN126@stbi__bmp_:
  00e19	0f b6 84 24 d8
	00 00 00	 movzx	 eax, BYTE PTR tv515[rsp]
  00e21	88 44 24 4c	 mov	 BYTE PTR a$3[rsp], al

; 5684 :                     all_a |= a;

  00e25	0f b6 44 24 4c	 movzx	 eax, BYTE PTR a$3[rsp]
  00e2a	8b 4c 24 7c	 mov	 ecx, DWORD PTR all_a$[rsp]
  00e2e	0b c8		 or	 ecx, eax
  00e30	8b c1		 mov	 eax, ecx
  00e32	89 44 24 7c	 mov	 DWORD PTR all_a$[rsp], eax

; 5685 :                     if (target == 4) out[z++] = a;

  00e36	83 7c 24 48 04	 cmp	 DWORD PTR target$[rsp], 4
  00e3b	75 1c		 jne	 SHORT $LN89@stbi__bmp_
  00e3d	48 63 44 24 38	 movsxd	 rax, DWORD PTR z$2[rsp]
  00e42	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  00e47	0f b6 54 24 4c	 movzx	 edx, BYTE PTR a$3[rsp]
  00e4c	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00e4f	8b 44 24 38	 mov	 eax, DWORD PTR z$2[rsp]
  00e53	ff c0		 inc	 eax
  00e55	89 44 24 38	 mov	 DWORD PTR z$2[rsp], eax
$LN89@stbi__bmp_:

; 5686 :                 }

  00e59	e9 0e ff ff ff	 jmp	 $LN20@stbi__bmp_
$LN21@stbi__bmp_:

; 5687 :             } else {

  00e5e	e9 cb 01 00 00	 jmp	 $LN88@stbi__bmp_
$LN87@stbi__bmp_:

; 5688 :                 int bpp = info.bpp;

  00e63	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR info$[rsp]
  00e6a	89 84 24 00 01
	00 00		 mov	 DWORD PTR bpp$23[rsp], eax

; 5689 :                 for (i=0; i < (int) s->img_x; ++i) {

  00e71	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00e79	eb 0a		 jmp	 SHORT $LN25@stbi__bmp_
$LN23@stbi__bmp_:
  00e7b	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00e7f	ff c0		 inc	 eax
  00e81	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN25@stbi__bmp_:
  00e85	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00e8d	8b 00		 mov	 eax, DWORD PTR [rax]
  00e8f	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00e93	0f 8d 95 01 00
	00		 jge	 $LN24@stbi__bmp_

; 5690 :                     stbi__uint32 v = (bpp == 16 ? (stbi__uint32) stbi__get16le(s) : stbi__get32le(s));

  00e99	83 bc 24 00 01
	00 00 10	 cmp	 DWORD PTR bpp$23[rsp], 16
  00ea1	75 16		 jne	 SHORT $LN127@stbi__bmp_
  00ea3	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00eab	e8 00 00 00 00	 call	 ?stbi__get16le@@YAHPEAUstbi__context@@@Z ; stbi__get16le
  00eb0	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv532[rsp], eax
  00eb7	eb 14		 jmp	 SHORT $LN128@stbi__bmp_
$LN127@stbi__bmp_:
  00eb9	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00ec1	e8 00 00 00 00	 call	 ?stbi__get32le@@YAIPEAUstbi__context@@@Z ; stbi__get32le
  00ec6	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv532[rsp], eax
$LN128@stbi__bmp_:
  00ecd	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR tv532[rsp]
  00ed4	89 84 24 80 00
	00 00		 mov	 DWORD PTR v$9[rsp], eax

; 5691 :                     unsigned int a;
; 5692 :                     out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mr, rshift, rcount));

  00edb	8b 44 24 64	 mov	 eax, DWORD PTR mr$[rsp]
  00edf	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR v$9[rsp]
  00ee6	23 c8		 and	 ecx, eax
  00ee8	8b c1		 mov	 eax, ecx
  00eea	44 8b 84 24 8c
	00 00 00	 mov	 r8d, DWORD PTR rcount$11[rsp]
  00ef2	8b 94 24 e0 00
	00 00		 mov	 edx, DWORD PTR rshift$17[rsp]
  00ef9	8b c8		 mov	 ecx, eax
  00efb	e8 00 00 00 00	 call	 ?stbi__shiftsigned@@YAHIHH@Z ; stbi__shiftsigned
  00f00	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00f05	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR z$2[rsp]
  00f0a	48 8b 54 24 40	 mov	 rdx, QWORD PTR out$[rsp]
  00f0f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00f12	8b 44 24 38	 mov	 eax, DWORD PTR z$2[rsp]
  00f16	ff c0		 inc	 eax
  00f18	89 44 24 38	 mov	 DWORD PTR z$2[rsp], eax

; 5693 :                     out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mg, gshift, gcount));

  00f1c	8b 44 24 68	 mov	 eax, DWORD PTR mg$[rsp]
  00f20	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR v$9[rsp]
  00f27	23 c8		 and	 ecx, eax
  00f29	8b c1		 mov	 eax, ecx
  00f2b	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR gcount$12[rsp]
  00f33	8b 94 24 e4 00
	00 00		 mov	 edx, DWORD PTR gshift$18[rsp]
  00f3a	8b c8		 mov	 ecx, eax
  00f3c	e8 00 00 00 00	 call	 ?stbi__shiftsigned@@YAHIHH@Z ; stbi__shiftsigned
  00f41	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00f46	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR z$2[rsp]
  00f4b	48 8b 54 24 40	 mov	 rdx, QWORD PTR out$[rsp]
  00f50	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00f53	8b 44 24 38	 mov	 eax, DWORD PTR z$2[rsp]
  00f57	ff c0		 inc	 eax
  00f59	89 44 24 38	 mov	 DWORD PTR z$2[rsp], eax

; 5694 :                     out[z++] = STBI__BYTECAST(stbi__shiftsigned(v & mb, bshift, bcount));

  00f5d	8b 44 24 6c	 mov	 eax, DWORD PTR mb$[rsp]
  00f61	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR v$9[rsp]
  00f68	23 c8		 and	 ecx, eax
  00f6a	8b c1		 mov	 eax, ecx
  00f6c	44 8b 84 24 94
	00 00 00	 mov	 r8d, DWORD PTR bcount$13[rsp]
  00f74	8b 94 24 e8 00
	00 00		 mov	 edx, DWORD PTR bshift$19[rsp]
  00f7b	8b c8		 mov	 ecx, eax
  00f7d	e8 00 00 00 00	 call	 ?stbi__shiftsigned@@YAHIHH@Z ; stbi__shiftsigned
  00f82	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00f87	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR z$2[rsp]
  00f8c	48 8b 54 24 40	 mov	 rdx, QWORD PTR out$[rsp]
  00f91	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00f94	8b 44 24 38	 mov	 eax, DWORD PTR z$2[rsp]
  00f98	ff c0		 inc	 eax
  00f9a	89 44 24 38	 mov	 DWORD PTR z$2[rsp], eax

; 5695 :                     a = (ma ? stbi__shiftsigned(v & ma, ashift, acount) : 255);

  00f9e	83 7c 24 54 00	 cmp	 DWORD PTR ma$[rsp], 0
  00fa3	74 2e		 je	 SHORT $LN129@stbi__bmp_
  00fa5	8b 44 24 54	 mov	 eax, DWORD PTR ma$[rsp]
  00fa9	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR v$9[rsp]
  00fb0	23 c8		 and	 ecx, eax
  00fb2	8b c1		 mov	 eax, ecx
  00fb4	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR acount$14[rsp]
  00fbc	8b 94 24 ec 00
	00 00		 mov	 edx, DWORD PTR ashift$20[rsp]
  00fc3	8b c8		 mov	 ecx, eax
  00fc5	e8 00 00 00 00	 call	 ?stbi__shiftsigned@@YAHIHH@Z ; stbi__shiftsigned
  00fca	89 84 24 f0 00
	00 00		 mov	 DWORD PTR tv572[rsp], eax
  00fd1	eb 0b		 jmp	 SHORT $LN130@stbi__bmp_
$LN129@stbi__bmp_:
  00fd3	c7 84 24 f0 00
	00 00 ff 00 00
	00		 mov	 DWORD PTR tv572[rsp], 255 ; 000000ffH
$LN130@stbi__bmp_:
  00fde	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR tv572[rsp]
  00fe5	89 84 24 f4 00
	00 00		 mov	 DWORD PTR a$21[rsp], eax

; 5696 :                     all_a |= a;

  00fec	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR a$21[rsp]
  00ff3	8b 4c 24 7c	 mov	 ecx, DWORD PTR all_a$[rsp]
  00ff7	0b c8		 or	 ecx, eax
  00ff9	8b c1		 mov	 eax, ecx
  00ffb	89 44 24 7c	 mov	 DWORD PTR all_a$[rsp], eax

; 5697 :                     if (target == 4) out[z++] = STBI__BYTECAST(a);

  00fff	83 7c 24 48 04	 cmp	 DWORD PTR target$[rsp], 4
  01004	75 23		 jne	 SHORT $LN90@stbi__bmp_
  01006	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR a$21[rsp]
  0100d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01012	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR z$2[rsp]
  01017	48 8b 54 24 40	 mov	 rdx, QWORD PTR out$[rsp]
  0101c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0101f	8b 44 24 38	 mov	 eax, DWORD PTR z$2[rsp]
  01023	ff c0		 inc	 eax
  01025	89 44 24 38	 mov	 DWORD PTR z$2[rsp], eax
$LN90@stbi__bmp_:

; 5698 :                 }

  01029	e9 4d fe ff ff	 jmp	 $LN23@stbi__bmp_
$LN24@stbi__bmp_:
$LN88@stbi__bmp_:

; 5699 :             }
; 5700 :             stbi__skip(s, pad);

  0102e	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR pad$[rsp]
  01035	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0103d	e8 00 00 00 00	 call	 ?stbi__skip@@YAXPEAUstbi__context@@H@Z ; stbi__skip

; 5701 :         }

  01042	e9 f1 fc ff ff	 jmp	 $LN17@stbi__bmp_
$LN18@stbi__bmp_:
$LN55@stbi__bmp_:

; 5702 :     }
; 5703 :     
; 5704 :     // if alpha channel is all 0s, replace with all 255s
; 5705 :     if (target == 4 && all_a == 0)

  01047	83 7c 24 48 04	 cmp	 DWORD PTR target$[rsp], 4
  0104c	75 4a		 jne	 SHORT $LN91@stbi__bmp_
  0104e	83 7c 24 7c 00	 cmp	 DWORD PTR all_a$[rsp], 0
  01053	75 43		 jne	 SHORT $LN91@stbi__bmp_

; 5706 :         for (i=4*s->img_x*s->img_y-1; i >= 0; i -= 4)

  01055	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0105d	8b 00		 mov	 eax, DWORD PTR [rax]
  0105f	c1 e0 02	 shl	 eax, 2
  01062	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0106a	0f af 41 04	 imul	 eax, DWORD PTR [rcx+4]
  0106e	ff c8		 dec	 eax
  01070	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  01074	eb 0b		 jmp	 SHORT $LN28@stbi__bmp_
$LN26@stbi__bmp_:
  01076	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0107a	83 e8 04	 sub	 eax, 4
  0107d	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN28@stbi__bmp_:
  01081	83 7c 24 30 00	 cmp	 DWORD PTR i$[rsp], 0
  01086	7c 10		 jl	 SHORT $LN27@stbi__bmp_

; 5707 :         out[i] = 255;

  01088	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0108d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  01092	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH
  01096	eb de		 jmp	 SHORT $LN26@stbi__bmp_
$LN27@stbi__bmp_:
$LN91@stbi__bmp_:

; 5708 :     
; 5709 :     if (flip_vertically) {

  01098	83 bc 24 04 01
	00 00 00	 cmp	 DWORD PTR flip_vertically$[rsp], 0
  010a0	0f 84 08 01 00
	00		 je	 $LN92@stbi__bmp_

; 5710 :         stbi_uc t;
; 5711 :         for (j=0; j < (int) s->img_y>>1; ++j) {

  010a6	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  010ae	eb 0a		 jmp	 SHORT $LN31@stbi__bmp_
$LN29@stbi__bmp_:
  010b0	8b 44 24 3c	 mov	 eax, DWORD PTR j$[rsp]
  010b4	ff c0		 inc	 eax
  010b6	89 44 24 3c	 mov	 DWORD PTR j$[rsp], eax
$LN31@stbi__bmp_:
  010ba	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  010c2	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  010c5	d1 f8		 sar	 eax, 1
  010c7	39 44 24 3c	 cmp	 DWORD PTR j$[rsp], eax
  010cb	0f 8d dd 00 00
	00		 jge	 $LN30@stbi__bmp_

; 5712 :             stbi_uc *p1 = out +      j     *s->img_x*target;

  010d1	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  010d9	8b 4c 24 3c	 mov	 ecx, DWORD PTR j$[rsp]
  010dd	0f af 08	 imul	 ecx, DWORD PTR [rax]
  010e0	8b c1		 mov	 eax, ecx
  010e2	0f af 44 24 48	 imul	 eax, DWORD PTR target$[rsp]
  010e7	8b c0		 mov	 eax, eax
  010e9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  010ee	48 03 c8	 add	 rcx, rax
  010f1	48 8b c1	 mov	 rax, rcx
  010f4	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR p1$25[rsp], rax

; 5713 :             stbi_uc *p2 = out + (s->img_y-1-j)*s->img_x*target;

  010fc	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  01104	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  01107	ff c8		 dec	 eax
  01109	2b 44 24 3c	 sub	 eax, DWORD PTR j$[rsp]
  0110d	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  01115	0f af 01	 imul	 eax, DWORD PTR [rcx]
  01118	0f af 44 24 48	 imul	 eax, DWORD PTR target$[rsp]
  0111d	8b c0		 mov	 eax, eax
  0111f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  01124	48 03 c8	 add	 rcx, rax
  01127	48 8b c1	 mov	 rax, rcx
  0112a	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR p2$26[rsp], rax

; 5714 :             for (i=0; i < (int) s->img_x*target; ++i) {

  01132	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0113a	eb 0a		 jmp	 SHORT $LN34@stbi__bmp_
$LN32@stbi__bmp_:
  0113c	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  01140	ff c0		 inc	 eax
  01142	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN34@stbi__bmp_:
  01146	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0114e	8b 00		 mov	 eax, DWORD PTR [rax]
  01150	0f af 44 24 48	 imul	 eax, DWORD PTR target$[rsp]
  01155	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  01159	7d 4e		 jge	 SHORT $LN33@stbi__bmp_

; 5715 :                 t = p1[i]; p1[i] = p2[i]; p2[i] = t;

  0115b	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  01160	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR p1$25[rsp]
  01168	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0116c	88 44 24 58	 mov	 BYTE PTR t$5[rsp], al
  01170	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  01175	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0117a	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR p1$25[rsp]
  01182	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR p2$26[rsp]
  0118a	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0118f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  01192	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  01197	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR p2$26[rsp]
  0119f	0f b6 54 24 58	 movzx	 edx, BYTE PTR t$5[rsp]
  011a4	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 5716 :             }

  011a7	eb 93		 jmp	 SHORT $LN32@stbi__bmp_
$LN33@stbi__bmp_:

; 5717 :         }

  011a9	e9 02 ff ff ff	 jmp	 $LN29@stbi__bmp_
$LN30@stbi__bmp_:
$LN92@stbi__bmp_:

; 5718 :     }
; 5719 :     
; 5720 :     if (req_comp && req_comp != target) {

  011ae	83 bc 24 90 05
	00 00 00	 cmp	 DWORD PTR req_comp$[rsp], 0
  011b6	74 51		 je	 SHORT $LN93@stbi__bmp_
  011b8	8b 44 24 48	 mov	 eax, DWORD PTR target$[rsp]
  011bc	39 84 24 90 05
	00 00		 cmp	 DWORD PTR req_comp$[rsp], eax
  011c3	74 44		 je	 SHORT $LN93@stbi__bmp_

; 5721 :         out = stbi__convert_format(out, target, req_comp, s->img_x, s->img_y);

  011c5	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  011cd	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  011d0	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  011d4	48 8b 84 24 70
	05 00 00	 mov	 rax, QWORD PTR s$[rsp]
  011dc	44 8b 08	 mov	 r9d, DWORD PTR [rax]
  011df	44 8b 84 24 90
	05 00 00	 mov	 r8d, DWORD PTR req_comp$[rsp]
  011e7	8b 54 24 48	 mov	 edx, DWORD PTR target$[rsp]
  011eb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR out$[rsp]
  011f0	e8 00 00 00 00	 call	 ?stbi__convert_format@@YAPEAEPEAEHHII@Z ; stbi__convert_format
  011f5	48 89 44 24 40	 mov	 QWORD PTR out$[rsp], rax

; 5722 :         if (out == NULL) return out; // stbi__convert_format frees input on failure

  011fa	48 83 7c 24 40
	00		 cmp	 QWORD PTR out$[rsp], 0
  01200	75 07		 jne	 SHORT $LN94@stbi__bmp_
  01202	48 8b 44 24 40	 mov	 rax, QWORD PTR out$[rsp]
  01207	eb 4e		 jmp	 SHORT $LN1@stbi__bmp_
$LN94@stbi__bmp_:
$LN93@stbi__bmp_:

; 5723 :     }
; 5724 :     
; 5725 :     *x = s->img_x;

  01209	48 8b 84 24 78
	05 00 00	 mov	 rax, QWORD PTR x$[rsp]
  01211	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  01219	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0121b	89 08		 mov	 DWORD PTR [rax], ecx

; 5726 :     *y = s->img_y;

  0121d	48 8b 84 24 80
	05 00 00	 mov	 rax, QWORD PTR y$[rsp]
  01225	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0122d	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  01230	89 08		 mov	 DWORD PTR [rax], ecx

; 5727 :     if (comp) *comp = s->img_n;

  01232	48 83 bc 24 88
	05 00 00 00	 cmp	 QWORD PTR comp$[rsp], 0
  0123b	74 15		 je	 SHORT $LN95@stbi__bmp_
  0123d	48 8b 84 24 88
	05 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  01245	48 8b 8c 24 70
	05 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0124d	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  01250	89 08		 mov	 DWORD PTR [rax], ecx
$LN95@stbi__bmp_:

; 5728 :     return out;

  01252	48 8b 44 24 40	 mov	 rax, QWORD PTR out$[rsp]
$LN1@stbi__bmp_:

; 5729 : }

  01257	48 8b 8c 24 50
	05 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0125f	48 33 cc	 xor	 rcx, rsp
  01262	e8 00 00 00 00	 call	 __security_check_cookie
  01267	48 81 c4 68 05
	00 00		 add	 rsp, 1384		; 00000568H
  0126e	c3		 ret	 0
?stbi__bmp_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ENDP ; stbi__bmp_load
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
r$ = 32
s$ = 64
?stbi__bmp_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__bmp_test

; 5359 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 5360 :     int r = stbi__bmp_test_raw(s);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__bmp_test_raw@@YAHPEAUstbi__context@@@Z ; stbi__bmp_test_raw
  00013	89 44 24 20	 mov	 DWORD PTR r$[rsp], eax

; 5361 :     stbi__rewind(s);

  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001c	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 5362 :     return r;

  00021	8b 44 24 20	 mov	 eax, DWORD PTR r$[rsp]

; 5363 : }

  00025	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00029	c3		 ret	 0
?stbi__bmp_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__bmp_test
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
p$ = 32
s$ = 96
?stbi__png_is16@@YAHPEAUstbi__context@@@Z PROC		; stbi__png_is16

; 5327 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 5328 :     stbi__png p;
; 5329 :     p.s = s;

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0000e	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 5330 :     if (!stbi__png_info_raw(&p, NULL, NULL, NULL))

  00013	45 33 c9	 xor	 r9d, r9d
  00016	45 33 c0	 xor	 r8d, r8d
  00019	33 d2		 xor	 edx, edx
  0001b	48 8d 4c 24 20	 lea	 rcx, QWORD PTR p$[rsp]
  00020	e8 00 00 00 00	 call	 ?stbi__png_info_raw@@YAHPEAUstbi__png@@PEAH11@Z ; stbi__png_info_raw
  00025	85 c0		 test	 eax, eax
  00027	75 04		 jne	 SHORT $LN2@stbi__png_

; 5331 :         return 0;

  00029	33 c0		 xor	 eax, eax
  0002b	eb 1a		 jmp	 SHORT $LN1@stbi__png_
$LN2@stbi__png_:

; 5332 :     if (p.depth != 16) {

  0002d	83 7c 24 40 10	 cmp	 DWORD PTR p$[rsp+32], 16
  00032	74 0e		 je	 SHORT $LN3@stbi__png_

; 5333 :         stbi__rewind(p.s);

  00034	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  00039	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 5334 :         return 0;

  0003e	33 c0		 xor	 eax, eax
  00040	eb 05		 jmp	 SHORT $LN1@stbi__png_
$LN3@stbi__png_:

; 5335 :     }
; 5336 :     return 1;

  00042	b8 01 00 00 00	 mov	 eax, 1
$LN1@stbi__png_:

; 5337 : }

  00047	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0004b	c3		 ret	 0
?stbi__png_is16@@YAHPEAUstbi__context@@@Z ENDP		; stbi__png_is16
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
p$ = 32
s$ = 96
x$ = 104
y$ = 112
comp$ = 120
?stbi__png_info@@YAHPEAUstbi__context@@PEAH11@Z PROC	; stbi__png_info

; 5320 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 5321 :     stbi__png p;
; 5322 :     p.s = s;

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 5323 :     return stbi__png_info_raw(&p, x, y, comp);

  00022	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  00027	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  0002c	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  00031	48 8d 4c 24 20	 lea	 rcx, QWORD PTR p$[rsp]
  00036	e8 00 00 00 00	 call	 ?stbi__png_info_raw@@YAHPEAUstbi__png@@PEAH11@Z ; stbi__png_info_raw

; 5324 : }

  0003b	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0003f	c3		 ret	 0
?stbi__png_info@@YAHPEAUstbi__context@@PEAH11@Z ENDP	; stbi__png_info
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
p$ = 48
s$ = 112
x$ = 120
y$ = 128
comp$ = 136
req_comp$ = 144
ri$ = 152
?stbi__png_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z PROC ; stbi__png_load

; 5293 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 5294 :     stbi__png p;
; 5295 :     p.s = s;

  00018	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0001d	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 5296 :     return stbi__do_png(&p, x,y,comp,req_comp, ri);

  00022	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR ri$[rsp]
  0002a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0002f	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00036	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0003a	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00042	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR y$[rsp]
  0004a	48 8b 54 24 78	 mov	 rdx, QWORD PTR x$[rsp]
  0004f	48 8d 4c 24 30	 lea	 rcx, QWORD PTR p$[rsp]
  00054	e8 00 00 00 00	 call	 ?stbi__do_png@@YAPEAXPEAUstbi__png@@PEAH11HPEAUstbi__result_info@@@Z ; stbi__do_png

; 5297 : }

  00059	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0005d	c3		 ret	 0
?stbi__png_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ENDP ; stbi__png_load
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
r$ = 32
s$ = 64
?stbi__png_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__png_test

; 5300 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 5301 :     int r;
; 5302 :     r = stbi__check_png_header(s);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 ?stbi__check_png_header@@YAHPEAUstbi__context@@@Z ; stbi__check_png_header
  00013	89 44 24 20	 mov	 DWORD PTR r$[rsp], eax

; 5303 :     stbi__rewind(s);

  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001c	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 5304 :     return r;

  00021	8b 44 24 20	 mov	 eax, DWORD PTR r$[rsp]

; 5305 : }

  00025	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00029	c3		 ret	 0
?stbi__png_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__png_test
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
result$ = 32
j$ = 40
s$ = 64
x$ = 72
y$ = 80
comp$ = 88
?stbi__jpeg_info@@YAHPEAUstbi__context@@PEAH11@Z PROC	; stbi__jpeg_info

; 4068 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4069 :     int result;
; 4070 :     stbi__jpeg* j = (stbi__jpeg*) (stbi__malloc(sizeof(stbi__jpeg)));

  00018	b9 88 48 00 00	 mov	 ecx, 18568		; 00004888H
  0001d	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  00022	48 89 44 24 28	 mov	 QWORD PTR j$[rsp], rax

; 4071 :     if (!j) return stbi__err("outofmem", "Out of memory");

  00027	48 83 7c 24 28
	00		 cmp	 QWORD PTR j$[rsp], 0
  0002d	75 0e		 jne	 SHORT $LN2@stbi__jpeg
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79671
  00036	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0003b	eb 4a		 jmp	 SHORT $LN1@stbi__jpeg
$LN2@stbi__jpeg:

; 4072 :     memset(j, 0, sizeof(stbi__jpeg));

  0003d	41 b8 88 48 00
	00		 mov	 r8d, 18568		; 00004888H
  00043	33 d2		 xor	 edx, edx
  00045	48 8b 4c 24 28	 mov	 rcx, QWORD PTR j$[rsp]
  0004a	e8 00 00 00 00	 call	 memset

; 4073 :     j->s = s;

  0004f	48 8b 44 24 28	 mov	 rax, QWORD PTR j$[rsp]
  00054	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00059	48 89 08	 mov	 QWORD PTR [rax], rcx

; 4074 :     result = stbi__jpeg_info_raw(j, x, y, comp);

  0005c	4c 8b 4c 24 58	 mov	 r9, QWORD PTR comp$[rsp]
  00061	4c 8b 44 24 50	 mov	 r8, QWORD PTR y$[rsp]
  00066	48 8b 54 24 48	 mov	 rdx, QWORD PTR x$[rsp]
  0006b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR j$[rsp]
  00070	e8 00 00 00 00	 call	 ?stbi__jpeg_info_raw@@YAHPEAUstbi__jpeg@@PEAH11@Z ; stbi__jpeg_info_raw
  00075	89 44 24 20	 mov	 DWORD PTR result$[rsp], eax

; 4075 :     STBI_FREE(j);

  00079	48 8b 4c 24 28	 mov	 rcx, QWORD PTR j$[rsp]
  0007e	e8 00 00 00 00	 call	 free

; 4076 :     return result;

  00083	8b 44 24 20	 mov	 eax, DWORD PTR result$[rsp]
$LN1@stbi__jpeg:

; 4077 : }

  00087	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008b	c3		 ret	 0
?stbi__jpeg_info@@YAHPEAUstbi__context@@PEAH11@Z ENDP	; stbi__jpeg_info
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv70 = 48
j$ = 56
result$ = 64
s$ = 96
x$ = 104
y$ = 112
comp$ = 120
req_comp$ = 128
ri$ = 136
?stbi__jpeg_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z PROC ; stbi__jpeg_load

; 4028 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4029 :     unsigned char* result;
; 4030 :     stbi__jpeg* j = (stbi__jpeg*) stbi__malloc(sizeof(stbi__jpeg));

  00018	b9 88 48 00 00	 mov	 ecx, 18568		; 00004888H
  0001d	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  00022	48 89 44 24 38	 mov	 QWORD PTR j$[rsp], rax

; 4031 :     if (!j) return stbi__errpuc("outofmem", "Out of memory");

  00027	48 83 7c 24 38
	00		 cmp	 QWORD PTR j$[rsp], 0
  0002d	75 29		 jne	 SHORT $LN2@stbi__jpeg
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79638
  00036	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0003b	85 c0		 test	 eax, eax
  0003d	74 0a		 je	 SHORT $LN4@stbi__jpeg
  0003f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00047	eb 08		 jmp	 SHORT $LN5@stbi__jpeg
$LN4@stbi__jpeg:
  00049	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN5@stbi__jpeg:
  00051	48 63 44 24 30	 movsxd	 rax, DWORD PTR tv70[rsp]
  00056	eb 61		 jmp	 SHORT $LN1@stbi__jpeg
$LN2@stbi__jpeg:

; 4032 :     memset(j, 0, sizeof(stbi__jpeg));

  00058	41 b8 88 48 00
	00		 mov	 r8d, 18568		; 00004888H
  0005e	33 d2		 xor	 edx, edx
  00060	48 8b 4c 24 38	 mov	 rcx, QWORD PTR j$[rsp]
  00065	e8 00 00 00 00	 call	 memset

; 4033 :     STBI_NOTUSED(ri);
; 4034 :     j->s = s;

  0006a	48 8b 44 24 38	 mov	 rax, QWORD PTR j$[rsp]
  0006f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00074	48 89 08	 mov	 QWORD PTR [rax], rcx

; 4035 :     stbi__setup_jpeg(j);

  00077	48 8b 4c 24 38	 mov	 rcx, QWORD PTR j$[rsp]
  0007c	e8 00 00 00 00	 call	 ?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z ; stbi__setup_jpeg

; 4036 :     result = load_jpeg_image(j, x,y,comp,req_comp);

  00081	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00088	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0008c	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  00091	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  00096	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  0009b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR j$[rsp]
  000a0	e8 00 00 00 00	 call	 ?load_jpeg_image@@YAPEAEPEAUstbi__jpeg@@PEAH11H@Z ; load_jpeg_image
  000a5	48 89 44 24 40	 mov	 QWORD PTR result$[rsp], rax

; 4037 :     STBI_FREE(j);

  000aa	48 8b 4c 24 38	 mov	 rcx, QWORD PTR j$[rsp]
  000af	e8 00 00 00 00	 call	 free

; 4038 :     return result;

  000b4	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
$LN1@stbi__jpeg:

; 4039 : }

  000b9	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000bd	c3		 ret	 0
?stbi__jpeg_load@@YAPEAXPEAUstbi__context@@PEAH11HPEAUstbi__result_info@@@Z ENDP ; stbi__jpeg_load
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
r$ = 32
j$ = 40
s$ = 64
?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z PROC		; stbi__jpeg_test

; 4042 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4043 :     int r;
; 4044 :     stbi__jpeg* j = (stbi__jpeg*)stbi__malloc(sizeof(stbi__jpeg));

  00009	b9 88 48 00 00	 mov	 ecx, 18568		; 00004888H
  0000e	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  00013	48 89 44 24 28	 mov	 QWORD PTR j$[rsp], rax

; 4045 :     if (!j) return stbi__err("outofmem", "Out of memory");

  00018	48 83 7c 24 28
	00		 cmp	 QWORD PTR j$[rsp], 0
  0001e	75 0e		 jne	 SHORT $LN2@stbi__jpeg
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG79648
  00027	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  0002c	eb 54		 jmp	 SHORT $LN1@stbi__jpeg
$LN2@stbi__jpeg:

; 4046 :     memset(j, 0, sizeof(stbi__jpeg));

  0002e	41 b8 88 48 00
	00		 mov	 r8d, 18568		; 00004888H
  00034	33 d2		 xor	 edx, edx
  00036	48 8b 4c 24 28	 mov	 rcx, QWORD PTR j$[rsp]
  0003b	e8 00 00 00 00	 call	 memset

; 4047 :     j->s = s;

  00040	48 8b 44 24 28	 mov	 rax, QWORD PTR j$[rsp]
  00045	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0004a	48 89 08	 mov	 QWORD PTR [rax], rcx

; 4048 :     stbi__setup_jpeg(j);

  0004d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR j$[rsp]
  00052	e8 00 00 00 00	 call	 ?stbi__setup_jpeg@@YAXPEAUstbi__jpeg@@@Z ; stbi__setup_jpeg

; 4049 :     r = stbi__decode_jpeg_header(j, STBI__SCAN_type);

  00057	ba 01 00 00 00	 mov	 edx, 1
  0005c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR j$[rsp]
  00061	e8 00 00 00 00	 call	 ?stbi__decode_jpeg_header@@YAHPEAUstbi__jpeg@@H@Z ; stbi__decode_jpeg_header
  00066	89 44 24 20	 mov	 DWORD PTR r$[rsp], eax

; 4050 :     stbi__rewind(s);

  0006a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0006f	e8 00 00 00 00	 call	 ?stbi__rewind@@YAXPEAUstbi__context@@@Z ; stbi__rewind

; 4051 :     STBI_FREE(j);

  00074	48 8b 4c 24 28	 mov	 rcx, QWORD PTR j$[rsp]
  00079	e8 00 00 00 00	 call	 free

; 4052 :     return r;

  0007e	8b 44 24 20	 mov	 eax, DWORD PTR r$[rsp]
$LN1@stbi__jpeg:

; 4053 : }

  00082	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00086	c3		 ret	 0
?stbi__jpeg_test@@YAHPEAUstbi__context@@@Z ENDP		; stbi__jpeg_test
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
s$ = 8
?stbi__rewind@@YAXPEAUstbi__context@@@Z PROC		; stbi__rewind

; 886  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 887  :     // conceptually rewind SHOULD rewind to the beginning of the stream,
; 888  :     // but we just rewind to the beginning of the initial buffer, because
; 889  :     // we only use it after doing 'test', which only ever looks at at most 92 bytes
; 890  :     s->img_buffer = s->img_buffer_original;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR s$[rsp]
  0000a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR s$[rsp]
  0000f	48 8b 89 d0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+208]
  00016	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 891  :     s->img_buffer_end = s->img_buffer_original_end;

  0001d	48 8b 44 24 08	 mov	 rax, QWORD PTR s$[rsp]
  00022	48 8b 4c 24 08	 mov	 rcx, QWORD PTR s$[rsp]
  00027	48 8b 89 d8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+216]
  0002e	48 89 88 c8 00
	00 00		 mov	 QWORD PTR [rax+200], rcx

; 892  : }

  00035	c3		 ret	 0
?stbi__rewind@@YAXPEAUstbi__context@@@Z ENDP		; stbi__rewind
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
s$ = 48
f$ = 56
?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z PROC ; stbi__start_file

; 877  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 878  :     stbi__start_callbacks(s, &stbi__stdio_callbacks, (void *) f);

  0000e	4c 8b 44 24 38	 mov	 r8, QWORD PTR f$[rsp]
  00013	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?stbi__stdio_callbacks@@3Ustbi_io_callbacks@@A
  0001a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0001f	e8 00 00 00 00	 call	 ?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z ; stbi__start_callbacks

; 879  : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	c3		 ret	 0
?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z ENDP ; stbi__start_file
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv70 = 32
user$ = 64
?stbi__stdio_eof@@YAHPEAX@Z PROC			; stbi__stdio_eof

; 865  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 866  :     return feof((FILE*) user) || ferror((FILE *) user);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR user$[rsp]
  0000e	e8 00 00 00 00	 call	 feof
  00013	85 c0		 test	 eax, eax
  00015	75 18		 jne	 SHORT $LN3@stbi__stdi
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR user$[rsp]
  0001c	e8 00 00 00 00	 call	 ferror
  00021	85 c0		 test	 eax, eax
  00023	75 0a		 jne	 SHORT $LN3@stbi__stdi
  00025	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  0002d	eb 08		 jmp	 SHORT $LN4@stbi__stdi
$LN3@stbi__stdi:
  0002f	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
$LN4@stbi__stdi:
  00037	8b 44 24 20	 mov	 eax, DWORD PTR tv70[rsp]

; 867  : }

  0003b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003f	c3		 ret	 0
?stbi__stdio_eof@@YAHPEAX@Z ENDP			; stbi__stdio_eof
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
ch$ = 32
user$ = 64
n$ = 72
?stbi__stdio_skip@@YAXPEAXH@Z PROC			; stbi__stdio_skip

; 855  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 856  :     int ch;
; 857  :     fseek((FILE*) user, n, SEEK_CUR);

  0000d	41 b8 01 00 00
	00		 mov	 r8d, 1
  00013	8b 54 24 48	 mov	 edx, DWORD PTR n$[rsp]
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR user$[rsp]
  0001c	e8 00 00 00 00	 call	 fseek

; 858  :     ch = fgetc((FILE*) user);  /* have to read a byte to reset feof()'s flag */

  00021	48 8b 4c 24 40	 mov	 rcx, QWORD PTR user$[rsp]
  00026	e8 00 00 00 00	 call	 fgetc
  0002b	89 44 24 20	 mov	 DWORD PTR ch$[rsp], eax

; 859  :     if (ch != EOF) {

  0002f	83 7c 24 20 ff	 cmp	 DWORD PTR ch$[rsp], -1
  00034	74 0e		 je	 SHORT $LN2@stbi__stdi

; 860  :         ungetc(ch, (FILE *) user);  /* push byte back onto stream if valid. */

  00036	48 8b 54 24 40	 mov	 rdx, QWORD PTR user$[rsp]
  0003b	8b 4c 24 20	 mov	 ecx, DWORD PTR ch$[rsp]
  0003f	e8 00 00 00 00	 call	 ungetc
$LN2@stbi__stdi:

; 861  :     }
; 862  : }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
?stbi__stdio_skip@@YAXPEAXH@Z ENDP			; stbi__stdio_skip
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
user$ = 48
data$ = 56
size$ = 64
?stbi__stdio_read@@YAHPEAXPEADH@Z PROC			; stbi__stdio_read

; 850  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 851  :     return (int) fread(data,1,size,(FILE*) user);

  00013	48 63 44 24 40	 movsxd	 rax, DWORD PTR size$[rsp]
  00018	4c 8b 4c 24 30	 mov	 r9, QWORD PTR user$[rsp]
  0001d	4c 8b c0	 mov	 r8, rax
  00020	ba 01 00 00 00	 mov	 edx, 1
  00025	48 8b 4c 24 38	 mov	 rcx, QWORD PTR data$[rsp]
  0002a	e8 00 00 00 00	 call	 fread

; 852  : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
?stbi__stdio_read@@YAHPEAXPEADH@Z ENDP			; stbi__stdio_read
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv72 = 32
s$ = 80
c$ = 88
user$ = 96
?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z PROC ; stbi__start_callbacks

; 836  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 837  :     s->io = *c;

  00015	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0001a	48 8d 78 10	 lea	 rdi, QWORD PTR [rax+16]
  0001e	48 8b 74 24 58	 mov	 rsi, QWORD PTR c$[rsp]
  00023	b9 18 00 00 00	 mov	 ecx, 24
  00028	f3 a4		 rep movsb

; 838  :     s->io_user_data = user;

  0002a	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0002f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR user$[rsp]
  00034	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 839  :     s->buflen = sizeof(s->buffer_start);

  00038	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0003d	c7 40 34 80 00
	00 00		 mov	 DWORD PTR [rax+52], 128	; 00000080H

; 840  :     s->read_from_callbacks = 1;

  00044	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00049	c7 40 30 01 00
	00 00		 mov	 DWORD PTR [rax+48], 1

; 841  :     s->callback_already_read = 0;

  00050	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00055	c7 80 b8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+184], 0

; 842  :     s->img_buffer = s->img_buffer_original = s->buffer_start;

  0005f	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00064	48 83 c0 38	 add	 rax, 56			; 00000038H
  00068	48 89 44 24 20	 mov	 QWORD PTR tv72[rsp], rax
  0006d	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00072	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv72[rsp]
  00077	48 89 88 d0 00
	00 00		 mov	 QWORD PTR [rax+208], rcx
  0007e	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00083	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tv72[rsp]
  00088	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 843  :     stbi__refill_buffer(s);

  0008f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00094	e8 00 00 00 00	 call	 ?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ; stbi__refill_buffer

; 844  :     s->img_buffer_original_end = s->img_buffer_end;

  00099	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0009e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000a3	48 8b 89 c8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+200]
  000aa	48 89 88 d8 00
	00 00		 mov	 QWORD PTR [rax+216], rcx

; 845  : }

  000b1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b5	5f		 pop	 rdi
  000b6	5e		 pop	 rsi
  000b7	c3		 ret	 0
?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z ENDP ; stbi__start_callbacks
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv73 = 0
s$ = 32
buffer$ = 40
len$ = 48
?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z PROC	; stbi__start_mem

; 826  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 827  :     s->io.read = NULL;

  00013	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00018	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 828  :     s->read_from_callbacks = 0;

  00020	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00025	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 829  :     s->callback_already_read = 0;

  0002c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00031	c7 80 b8 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+184], 0

; 830  :     s->img_buffer = s->img_buffer_original = (stbi_uc *) buffer;

  0003b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00040	48 8b 4c 24 28	 mov	 rcx, QWORD PTR buffer$[rsp]
  00045	48 89 88 d0 00
	00 00		 mov	 QWORD PTR [rax+208], rcx
  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00051	48 8b 4c 24 28	 mov	 rcx, QWORD PTR buffer$[rsp]
  00056	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 831  :     s->img_buffer_end = s->img_buffer_original_end = (stbi_uc *) buffer+len;

  0005d	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00062	48 8b 4c 24 28	 mov	 rcx, QWORD PTR buffer$[rsp]
  00067	48 03 c8	 add	 rcx, rax
  0006a	48 89 0c 24	 mov	 QWORD PTR tv73[rsp], rcx
  0006e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00073	48 8b 0c 24	 mov	 rcx, QWORD PTR tv73[rsp]
  00077	48 89 88 d8 00
	00 00		 mov	 QWORD PTR [rax+216], rcx
  0007e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00083	48 8b 0c 24	 mov	 rcx, QWORD PTR tv73[rsp]
  00087	48 89 88 c8 00
	00 00		 mov	 QWORD PTR [rax+200], rcx

; 832  : }

  0008e	48 83 c4 18	 add	 rsp, 24
  00092	c3		 ret	 0
?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z ENDP	; stbi__start_mem
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
n$ = 32
s$ = 64
?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z PROC	; stbi__refill_buffer

; 1597 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1598 :     int n = (s->io.read)(s->io_user_data,(char*)s->buffer_start,s->buflen);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0000e	48 83 c0 38	 add	 rax, 56			; 00000038H
  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00017	44 8b 41 34	 mov	 r8d, DWORD PTR [rcx+52]
  0001b	48 8b d0	 mov	 rdx, rax
  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00023	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0002c	ff 50 10	 call	 QWORD PTR [rax+16]
  0002f	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax

; 1599 :     s->callback_already_read += (int) (s->img_buffer - s->img_buffer_original);

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00038	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0003d	48 8b 89 d0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+208]
  00044	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  0004b	48 2b c1	 sub	 rax, rcx
  0004e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00053	03 81 b8 00 00
	00		 add	 eax, DWORD PTR [rcx+184]
  00059	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0005e	89 81 b8 00 00
	00		 mov	 DWORD PTR [rcx+184], eax

; 1600 :     if (n == 0) {

  00064	83 7c 24 20 00	 cmp	 DWORD PTR n$[rsp], 0
  00069	75 47		 jne	 SHORT $LN2@stbi__refi

; 1601 :         // at end of file, treat same as if from memory, but need to handle case
; 1602 :         // where s->img_buffer isn't pointing to safe memory, e.g. 0-byte file
; 1603 :         s->read_from_callbacks = 0;

  0006b	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00070	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 1604 :         s->img_buffer = s->buffer_start;

  00077	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0007c	48 83 c0 38	 add	 rax, 56			; 00000038H
  00080	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00085	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax

; 1605 :         s->img_buffer_end = s->buffer_start+1;

  0008c	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00091	48 83 c0 39	 add	 rax, 57			; 00000039H
  00095	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0009a	48 89 81 c8 00
	00 00		 mov	 QWORD PTR [rcx+200], rax

; 1606 :         *s->img_buffer = 0;

  000a1	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000a6	48 8b 80 c0 00
	00 00		 mov	 rax, QWORD PTR [rax+192]
  000ad	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1607 :     } else {

  000b0	eb 30		 jmp	 SHORT $LN3@stbi__refi
$LN2@stbi__refi:

; 1608 :         s->img_buffer = s->buffer_start;

  000b2	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000b7	48 83 c0 38	 add	 rax, 56			; 00000038H
  000bb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000c0	48 89 81 c0 00
	00 00		 mov	 QWORD PTR [rcx+192], rax

; 1609 :         s->img_buffer_end = s->buffer_start + n;

  000c7	48 63 44 24 20	 movsxd	 rax, DWORD PTR n$[rsp]
  000cc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000d1	48 8d 44 01 38	 lea	 rax, QWORD PTR [rcx+rax+56]
  000d6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000db	48 89 81 c8 00
	00 00		 mov	 QWORD PTR [rcx+200], rax
$LN3@stbi__refi:

; 1610 :     }
; 1611 : }

  000e2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e6	c3		 ret	 0
?stbi__refill_buffer@@YAXPEAUstbi__context@@@Z ENDP	; stbi__refill_buffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv68 = 32
info3$ = 36
?stbi__sse2_available@@YAHXZ PROC			; stbi__sse2_available

; 754  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 755  :     int info3 = stbi__cpuid3();

  00004	e8 00 00 00 00	 call	 ?stbi__cpuid3@@YAHXZ	; stbi__cpuid3
  00009	89 44 24 24	 mov	 DWORD PTR info3$[rsp], eax

; 756  :     return ((info3 >> 26) & 1) != 0;

  0000d	8b 44 24 24	 mov	 eax, DWORD PTR info3$[rsp]
  00011	c1 f8 1a	 sar	 eax, 26
  00014	83 e0 01	 and	 eax, 1
  00017	85 c0		 test	 eax, eax
  00019	74 0a		 je	 SHORT $LN3@stbi__sse2
  0001b	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv68[rsp], 1
  00023	eb 08		 jmp	 SHORT $LN4@stbi__sse2
$LN3@stbi__sse2:
  00025	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
$LN4@stbi__sse2:
  0002d	8b 44 24 20	 mov	 eax, DWORD PTR tv68[rsp]

; 757  : }

  00031	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00035	c3		 ret	 0
?stbi__sse2_available@@YAHXZ ENDP			; stbi__sse2_available
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
info$ = 0
__$ArrayPad$ = 16
?stbi__cpuid3@@YAHXZ PROC				; stbi__cpuid3

; 732  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000d	48 33 c4	 xor	 rax, rsp
  00010	48 89 44 24 10	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 733  :     int info[4];
; 734  :     __cpuid(info,1);

  00015	b8 01 00 00 00	 mov	 eax, 1
  0001a	33 c9		 xor	 ecx, ecx
  0001c	0f a2		 cpuid
  0001e	4c 8d 04 24	 lea	 r8, QWORD PTR info$[rsp]
  00022	41 89 00	 mov	 DWORD PTR [r8], eax
  00025	41 89 58 04	 mov	 DWORD PTR [r8+4], ebx
  00029	41 89 48 08	 mov	 DWORD PTR [r8+8], ecx
  0002d	41 89 50 0c	 mov	 DWORD PTR [r8+12], edx

; 735  :     return info[3];

  00031	b8 04 00 00 00	 mov	 eax, 4
  00036	48 6b c0 03	 imul	 rax, rax, 3
  0003a	8b 04 04	 mov	 eax, DWORD PTR info$[rsp+rax]

; 736  : }

  0003d	48 8b 4c 24 10	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00042	48 33 cc	 xor	 rcx, rsp
  00045	e8 00 00 00 00	 call	 __security_check_cookie
  0004a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004e	5b		 pop	 rbx
  0004f	c3		 ret	 0
?stbi__cpuid3@@YAHXZ ENDP				; stbi__cpuid3
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
a$ = 48
__$ArrayPad$ = 4160
obuffer$ = 4192
olen$ = 4200
ibuffer$ = 4208
ilen$ = 4216
stbi_zlib_decode_noheader_buffer PROC

; 4584 : {

$LN5:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	b8 58 10 00 00	 mov	 eax, 4184		; 00001058H
  00018	e8 00 00 00 00	 call	 __chkstk
  0001d	48 2b e0	 sub	 rsp, rax
  00020	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00027	48 33 c4	 xor	 rax, rsp
  0002a	48 89 84 24 40
	10 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4585 :     stbi__zbuf a;
; 4586 :     a.zbuffer = (stbi_uc *) ibuffer;

  00032	48 8b 84 24 70
	10 00 00	 mov	 rax, QWORD PTR ibuffer$[rsp]
  0003a	48 89 44 24 30	 mov	 QWORD PTR a$[rsp], rax

; 4587 :     a.zbuffer_end = (stbi_uc *) ibuffer + ilen;

  0003f	48 63 84 24 78
	10 00 00	 movsxd	 rax, DWORD PTR ilen$[rsp]
  00047	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR ibuffer$[rsp]
  0004f	48 03 c8	 add	 rcx, rax
  00052	48 8b c1	 mov	 rax, rcx
  00055	48 89 44 24 38	 mov	 QWORD PTR a$[rsp+8], rax

; 4588 :     if (stbi__do_zlib(&a, obuffer, olen, 0, 0))

  0005a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00062	45 33 c9	 xor	 r9d, r9d
  00065	44 8b 84 24 68
	10 00 00	 mov	 r8d, DWORD PTR olen$[rsp]
  0006d	48 8b 94 24 60
	10 00 00	 mov	 rdx, QWORD PTR obuffer$[rsp]
  00075	48 8d 4c 24 30	 lea	 rcx, QWORD PTR a$[rsp]
  0007a	e8 00 00 00 00	 call	 ?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z ; stbi__do_zlib
  0007f	85 c0		 test	 eax, eax
  00081	74 14		 je	 SHORT $LN2@stbi_zlib_

; 4589 :         return (int) (a.zout - a.zout_start);

  00083	48 8b 44 24 58	 mov	 rax, QWORD PTR a$[rsp+40]
  00088	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp+32]
  0008d	48 2b c8	 sub	 rcx, rax
  00090	48 8b c1	 mov	 rax, rcx
  00093	eb 07		 jmp	 SHORT $LN1@stbi_zlib_
  00095	eb 05		 jmp	 SHORT $LN3@stbi_zlib_
$LN2@stbi_zlib_:

; 4590 :     else
; 4591 :         return -1;

  00097	b8 ff ff ff ff	 mov	 eax, -1
$LN3@stbi_zlib_:
$LN1@stbi_zlib_:

; 4592 : }

  0009c	48 8b 8c 24 40
	10 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000a4	48 33 cc	 xor	 rcx, rsp
  000a7	e8 00 00 00 00	 call	 __security_check_cookie
  000ac	48 81 c4 58 10
	00 00		 add	 rsp, 4184		; 00001058H
  000b3	c3		 ret	 0
stbi_zlib_decode_noheader_buffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
p$ = 48
a$ = 64
__$ArrayPad$ = 4176
buffer$ = 4208
len$ = 4216
outlen$ = 4224
stbi_zlib_decode_noheader_malloc PROC

; 4568 : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	b8 68 10 00 00	 mov	 eax, 4200		; 00001068H
  00013	e8 00 00 00 00	 call	 __chkstk
  00018	48 2b e0	 sub	 rsp, rax
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 50
	10 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4569 :     stbi__zbuf a;
; 4570 :     char *p = (char *) stbi__malloc(16384);

  0002d	b9 00 40 00 00	 mov	 ecx, 16384		; 00004000H
  00032	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  00037	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 4571 :     if (p == NULL) return NULL;

  0003c	48 83 7c 24 30
	00		 cmp	 QWORD PTR p$[rsp], 0
  00042	75 07		 jne	 SHORT $LN2@stbi_zlib_
  00044	33 c0		 xor	 eax, eax
  00046	e9 89 00 00 00	 jmp	 $LN1@stbi_zlib_
$LN2@stbi_zlib_:

; 4572 :     a.zbuffer = (stbi_uc *) buffer;

  0004b	48 8b 84 24 70
	10 00 00	 mov	 rax, QWORD PTR buffer$[rsp]
  00053	48 89 44 24 40	 mov	 QWORD PTR a$[rsp], rax

; 4573 :     a.zbuffer_end = (stbi_uc *) buffer+len;

  00058	48 63 84 24 78
	10 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  00060	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  00068	48 03 c8	 add	 rcx, rax
  0006b	48 8b c1	 mov	 rax, rcx
  0006e	48 89 44 24 48	 mov	 QWORD PTR a$[rsp+8], rax

; 4574 :     if (stbi__do_zlib(&a, p, 16384, 1, 0)) {

  00073	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0007b	41 b9 01 00 00
	00		 mov	 r9d, 1
  00081	41 b8 00 40 00
	00		 mov	 r8d, 16384		; 00004000H
  00087	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  0008c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR a$[rsp]
  00091	e8 00 00 00 00	 call	 ?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z ; stbi__do_zlib
  00096	85 c0		 test	 eax, eax
  00098	74 2e		 je	 SHORT $LN3@stbi_zlib_

; 4575 :         if (outlen) *outlen = (int) (a.zout - a.zout_start);

  0009a	48 83 bc 24 80
	10 00 00 00	 cmp	 QWORD PTR outlen$[rsp], 0
  000a3	74 1a		 je	 SHORT $LN5@stbi_zlib_
  000a5	48 8b 44 24 68	 mov	 rax, QWORD PTR a$[rsp+40]
  000aa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp+32]
  000af	48 2b c8	 sub	 rcx, rax
  000b2	48 8b c1	 mov	 rax, rcx
  000b5	48 8b 8c 24 80
	10 00 00	 mov	 rcx, QWORD PTR outlen$[rsp]
  000bd	89 01		 mov	 DWORD PTR [rcx], eax
$LN5@stbi_zlib_:

; 4576 :         return a.zout_start;

  000bf	48 8b 44 24 68	 mov	 rax, QWORD PTR a$[rsp+40]
  000c4	eb 0e		 jmp	 SHORT $LN1@stbi_zlib_

; 4577 :     } else {

  000c6	eb 0c		 jmp	 SHORT $LN4@stbi_zlib_
$LN3@stbi_zlib_:

; 4578 :         STBI_FREE(a.zout_start);

  000c8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR a$[rsp+40]
  000cd	e8 00 00 00 00	 call	 free

; 4579 :         return NULL;

  000d2	33 c0		 xor	 eax, eax
$LN4@stbi_zlib_:
$LN1@stbi_zlib_:

; 4580 :     }
; 4581 : }

  000d4	48 8b 8c 24 50
	10 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000dc	48 33 cc	 xor	 rcx, rsp
  000df	e8 00 00 00 00	 call	 __security_check_cookie
  000e4	48 81 c4 68 10
	00 00		 add	 rsp, 4200		; 00001068H
  000eb	c3		 ret	 0
stbi_zlib_decode_noheader_malloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
a$ = 48
__$ArrayPad$ = 4160
obuffer$ = 4192
olen$ = 4200
ibuffer$ = 4208
ilen$ = 4216
stbi_zlib_decode_buffer PROC

; 4557 : {

$LN5:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	b8 58 10 00 00	 mov	 eax, 4184		; 00001058H
  00018	e8 00 00 00 00	 call	 __chkstk
  0001d	48 2b e0	 sub	 rsp, rax
  00020	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00027	48 33 c4	 xor	 rax, rsp
  0002a	48 89 84 24 40
	10 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4558 :     stbi__zbuf a;
; 4559 :     a.zbuffer = (stbi_uc *) ibuffer;

  00032	48 8b 84 24 70
	10 00 00	 mov	 rax, QWORD PTR ibuffer$[rsp]
  0003a	48 89 44 24 30	 mov	 QWORD PTR a$[rsp], rax

; 4560 :     a.zbuffer_end = (stbi_uc *) ibuffer + ilen;

  0003f	48 63 84 24 78
	10 00 00	 movsxd	 rax, DWORD PTR ilen$[rsp]
  00047	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR ibuffer$[rsp]
  0004f	48 03 c8	 add	 rcx, rax
  00052	48 8b c1	 mov	 rax, rcx
  00055	48 89 44 24 38	 mov	 QWORD PTR a$[rsp+8], rax

; 4561 :     if (stbi__do_zlib(&a, obuffer, olen, 0, 1))

  0005a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00062	45 33 c9	 xor	 r9d, r9d
  00065	44 8b 84 24 68
	10 00 00	 mov	 r8d, DWORD PTR olen$[rsp]
  0006d	48 8b 94 24 60
	10 00 00	 mov	 rdx, QWORD PTR obuffer$[rsp]
  00075	48 8d 4c 24 30	 lea	 rcx, QWORD PTR a$[rsp]
  0007a	e8 00 00 00 00	 call	 ?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z ; stbi__do_zlib
  0007f	85 c0		 test	 eax, eax
  00081	74 14		 je	 SHORT $LN2@stbi_zlib_

; 4562 :         return (int) (a.zout - a.zout_start);

  00083	48 8b 44 24 58	 mov	 rax, QWORD PTR a$[rsp+40]
  00088	48 8b 4c 24 50	 mov	 rcx, QWORD PTR a$[rsp+32]
  0008d	48 2b c8	 sub	 rcx, rax
  00090	48 8b c1	 mov	 rax, rcx
  00093	eb 07		 jmp	 SHORT $LN1@stbi_zlib_
  00095	eb 05		 jmp	 SHORT $LN3@stbi_zlib_
$LN2@stbi_zlib_:

; 4563 :     else
; 4564 :         return -1;

  00097	b8 ff ff ff ff	 mov	 eax, -1
$LN3@stbi_zlib_:
$LN1@stbi_zlib_:

; 4565 : }

  0009c	48 8b 8c 24 40
	10 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000a4	48 33 cc	 xor	 rcx, rsp
  000a7	e8 00 00 00 00	 call	 __security_check_cookie
  000ac	48 81 c4 58 10
	00 00		 add	 rsp, 4184		; 00001058H
  000b3	c3		 ret	 0
stbi_zlib_decode_buffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
buffer$ = 48
len$ = 56
outlen$ = 64
stbi_zlib_decode_malloc PROC

; 4536 : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4537 :     return stbi_zlib_decode_malloc_guesssize(buffer, len, 16384, outlen);

  00012	4c 8b 4c 24 40	 mov	 r9, QWORD PTR outlen$[rsp]
  00017	41 b8 00 40 00
	00		 mov	 r8d, 16384		; 00004000H
  0001d	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  00021	48 8b 4c 24 30	 mov	 rcx, QWORD PTR buffer$[rsp]
  00026	e8 00 00 00 00	 call	 stbi_zlib_decode_malloc_guesssize

; 4538 : }

  0002b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002f	c3		 ret	 0
stbi_zlib_decode_malloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
p$ = 48
a$ = 64
__$ArrayPad$ = 4176
buffer$ = 4208
len$ = 4216
initial_size$ = 4224
outlen$ = 4232
parse_header$ = 4240
stbi_zlib_decode_malloc_guesssize_headerflag PROC

; 4541 : {

$LN7:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	b8 68 10 00 00	 mov	 eax, 4200		; 00001068H
  00018	e8 00 00 00 00	 call	 __chkstk
  0001d	48 2b e0	 sub	 rsp, rax
  00020	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00027	48 33 c4	 xor	 rax, rsp
  0002a	48 89 84 24 50
	10 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4542 :     stbi__zbuf a;
; 4543 :     char *p = (char *) stbi__malloc(initial_size);

  00032	48 63 84 24 80
	10 00 00	 movsxd	 rax, DWORD PTR initial_size$[rsp]
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  00042	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 4544 :     if (p == NULL) return NULL;

  00047	48 83 7c 24 30
	00		 cmp	 QWORD PTR p$[rsp], 0
  0004d	75 07		 jne	 SHORT $LN2@stbi_zlib_
  0004f	33 c0		 xor	 eax, eax
  00051	e9 8e 00 00 00	 jmp	 $LN1@stbi_zlib_
$LN2@stbi_zlib_:

; 4545 :     a.zbuffer = (stbi_uc *) buffer;

  00056	48 8b 84 24 70
	10 00 00	 mov	 rax, QWORD PTR buffer$[rsp]
  0005e	48 89 44 24 40	 mov	 QWORD PTR a$[rsp], rax

; 4546 :     a.zbuffer_end = (stbi_uc *) buffer + len;

  00063	48 63 84 24 78
	10 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  0006b	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 48	 mov	 QWORD PTR a$[rsp+8], rax

; 4547 :     if (stbi__do_zlib(&a, p, initial_size, 1, parse_header)) {

  0007e	8b 84 24 90 10
	00 00		 mov	 eax, DWORD PTR parse_header$[rsp]
  00085	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00089	41 b9 01 00 00
	00		 mov	 r9d, 1
  0008f	44 8b 84 24 80
	10 00 00	 mov	 r8d, DWORD PTR initial_size$[rsp]
  00097	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  0009c	48 8d 4c 24 40	 lea	 rcx, QWORD PTR a$[rsp]
  000a1	e8 00 00 00 00	 call	 ?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z ; stbi__do_zlib
  000a6	85 c0		 test	 eax, eax
  000a8	74 2e		 je	 SHORT $LN3@stbi_zlib_

; 4548 :         if (outlen) *outlen = (int) (a.zout - a.zout_start);

  000aa	48 83 bc 24 88
	10 00 00 00	 cmp	 QWORD PTR outlen$[rsp], 0
  000b3	74 1a		 je	 SHORT $LN5@stbi_zlib_
  000b5	48 8b 44 24 68	 mov	 rax, QWORD PTR a$[rsp+40]
  000ba	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp+32]
  000bf	48 2b c8	 sub	 rcx, rax
  000c2	48 8b c1	 mov	 rax, rcx
  000c5	48 8b 8c 24 88
	10 00 00	 mov	 rcx, QWORD PTR outlen$[rsp]
  000cd	89 01		 mov	 DWORD PTR [rcx], eax
$LN5@stbi_zlib_:

; 4549 :         return a.zout_start;

  000cf	48 8b 44 24 68	 mov	 rax, QWORD PTR a$[rsp+40]
  000d4	eb 0e		 jmp	 SHORT $LN1@stbi_zlib_

; 4550 :     } else {

  000d6	eb 0c		 jmp	 SHORT $LN4@stbi_zlib_
$LN3@stbi_zlib_:

; 4551 :         STBI_FREE(a.zout_start);

  000d8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR a$[rsp+40]
  000dd	e8 00 00 00 00	 call	 free

; 4552 :         return NULL;

  000e2	33 c0		 xor	 eax, eax
$LN4@stbi_zlib_:
$LN1@stbi_zlib_:

; 4553 :     }
; 4554 : }

  000e4	48 8b 8c 24 50
	10 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000ec	48 33 cc	 xor	 rcx, rsp
  000ef	e8 00 00 00 00	 call	 __security_check_cookie
  000f4	48 81 c4 68 10
	00 00		 add	 rsp, 4200		; 00001068H
  000fb	c3		 ret	 0
stbi_zlib_decode_malloc_guesssize_headerflag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
p$ = 48
a$ = 64
__$ArrayPad$ = 4176
buffer$ = 4208
len$ = 4216
initial_size$ = 4224
outlen$ = 4232
stbi_zlib_decode_malloc_guesssize PROC

; 4520 : {

$LN7:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	b8 68 10 00 00	 mov	 eax, 4200		; 00001068H
  00018	e8 00 00 00 00	 call	 __chkstk
  0001d	48 2b e0	 sub	 rsp, rax
  00020	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00027	48 33 c4	 xor	 rax, rsp
  0002a	48 89 84 24 50
	10 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4521 :     stbi__zbuf a;
; 4522 :     char *p = (char *) stbi__malloc(initial_size);

  00032	48 63 84 24 80
	10 00 00	 movsxd	 rax, DWORD PTR initial_size$[rsp]
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 ?stbi__malloc@@YAPEAX_K@Z ; stbi__malloc
  00042	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 4523 :     if (p == NULL) return NULL;

  00047	48 83 7c 24 30
	00		 cmp	 QWORD PTR p$[rsp], 0
  0004d	75 07		 jne	 SHORT $LN2@stbi_zlib_
  0004f	33 c0		 xor	 eax, eax
  00051	e9 8b 00 00 00	 jmp	 $LN1@stbi_zlib_
$LN2@stbi_zlib_:

; 4524 :     a.zbuffer = (stbi_uc *) buffer;

  00056	48 8b 84 24 70
	10 00 00	 mov	 rax, QWORD PTR buffer$[rsp]
  0005e	48 89 44 24 40	 mov	 QWORD PTR a$[rsp], rax

; 4525 :     a.zbuffer_end = (stbi_uc *) buffer + len;

  00063	48 63 84 24 78
	10 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  0006b	48 8b 8c 24 70
	10 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  00073	48 03 c8	 add	 rcx, rax
  00076	48 8b c1	 mov	 rax, rcx
  00079	48 89 44 24 48	 mov	 QWORD PTR a$[rsp+8], rax

; 4526 :     if (stbi__do_zlib(&a, p, initial_size, 1, 1)) {

  0007e	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00086	41 b9 01 00 00
	00		 mov	 r9d, 1
  0008c	44 8b 84 24 80
	10 00 00	 mov	 r8d, DWORD PTR initial_size$[rsp]
  00094	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  00099	48 8d 4c 24 40	 lea	 rcx, QWORD PTR a$[rsp]
  0009e	e8 00 00 00 00	 call	 ?stbi__do_zlib@@YAHPEAUstbi__zbuf@@PEADHHH@Z ; stbi__do_zlib
  000a3	85 c0		 test	 eax, eax
  000a5	74 2e		 je	 SHORT $LN3@stbi_zlib_

; 4527 :         if (outlen) *outlen = (int) (a.zout - a.zout_start);

  000a7	48 83 bc 24 88
	10 00 00 00	 cmp	 QWORD PTR outlen$[rsp], 0
  000b0	74 1a		 je	 SHORT $LN5@stbi_zlib_
  000b2	48 8b 44 24 68	 mov	 rax, QWORD PTR a$[rsp+40]
  000b7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR a$[rsp+32]
  000bc	48 2b c8	 sub	 rcx, rax
  000bf	48 8b c1	 mov	 rax, rcx
  000c2	48 8b 8c 24 88
	10 00 00	 mov	 rcx, QWORD PTR outlen$[rsp]
  000ca	89 01		 mov	 DWORD PTR [rcx], eax
$LN5@stbi_zlib_:

; 4528 :         return a.zout_start;

  000cc	48 8b 44 24 68	 mov	 rax, QWORD PTR a$[rsp+40]
  000d1	eb 0e		 jmp	 SHORT $LN1@stbi_zlib_

; 4529 :     } else {

  000d3	eb 0c		 jmp	 SHORT $LN4@stbi_zlib_
$LN3@stbi_zlib_:

; 4530 :         STBI_FREE(a.zout_start);

  000d5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR a$[rsp+40]
  000da	e8 00 00 00 00	 call	 free

; 4531 :         return NULL;

  000df	33 c0		 xor	 eax, eax
$LN4@stbi_zlib_:
$LN1@stbi_zlib_:

; 4532 :     }
; 4533 : }

  000e1	48 8b 8c 24 50
	10 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000e9	48 33 cc	 xor	 rcx, rsp
  000ec	e8 00 00 00 00	 call	 __security_check_cookie
  000f1	48 81 c4 68 10
	00 00		 add	 rsp, 4200		; 00001068H
  000f8	c3		 ret	 0
stbi_zlib_decode_malloc_guesssize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
flag_true_if_should_flip$ = 8
stbi_set_flip_vertically_on_load_thread PROC

; 1126 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 1127 :     stbi__vertically_flip_on_load_local = flag_true_if_should_flip;

  00004	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__vertically_flip_on_load_local@@3HA
  00009	8b c0		 mov	 eax, eax
  0000b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00011	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0001a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0001e	8b 54 24 08	 mov	 edx, DWORD PTR flag_true_if_should_flip$[rsp]
  00022	89 14 08	 mov	 DWORD PTR [rax+rcx], edx

; 1128 :     stbi__vertically_flip_on_load_set = 1;

  00025	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__vertically_flip_on_load_set@@3HA
  0002a	8b c0		 mov	 eax, eax
  0002c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00032	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0003b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0003f	c7 04 08 01 00
	00 00		 mov	 DWORD PTR [rax+rcx], 1

; 1129 : }

  00046	c3		 ret	 0
stbi_set_flip_vertically_on_load_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
flag_true_if_should_convert$ = 8
stbi_convert_iphone_png_to_rgb_thread PROC

; 5019 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 5020 :     stbi__de_iphone_flag_local = flag_true_if_should_convert;

  00004	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__de_iphone_flag_local@@3HA
  00009	8b c0		 mov	 eax, eax
  0000b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00011	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0001a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0001e	8b 54 24 08	 mov	 edx, DWORD PTR flag_true_if_should_convert$[rsp]
  00022	89 14 08	 mov	 DWORD PTR [rax+rcx], edx

; 5021 :     stbi__de_iphone_flag_set = 1;

  00025	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__de_iphone_flag_set@@3HA
  0002a	8b c0		 mov	 eax, eax
  0002c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00032	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0003b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0003f	c7 04 08 01 00
	00 00		 mov	 DWORD PTR [rax+rcx], 1

; 5022 : }

  00046	c3		 ret	 0
stbi_convert_iphone_png_to_rgb_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
flag_true_if_should_unpremultiply$ = 8
stbi_set_unpremultiply_on_load_thread PROC

; 5013 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 5014 :     stbi__unpremultiply_on_load_local = flag_true_if_should_unpremultiply;

  00004	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__unpremultiply_on_load_local@@3HA
  00009	8b c0		 mov	 eax, eax
  0000b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00011	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0001a	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0001e	8b 54 24 08	 mov	 edx, DWORD PTR flag_true_if_should_unpremultiply$[rsp]
  00022	89 14 08	 mov	 DWORD PTR [rax+rcx], edx

; 5015 :     stbi__unpremultiply_on_load_set = 1;

  00025	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__unpremultiply_on_load_set@@3HA
  0002a	8b c0		 mov	 eax, eax
  0002c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  00032	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  0003b	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0003f	c7 04 08 01 00
	00 00		 mov	 DWORD PTR [rax+rcx], 1

; 5016 : }

  00046	c3		 ret	 0
stbi_set_unpremultiply_on_load_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
flag_true_if_should_flip$ = 8
stbi_set_flip_vertically_on_load PROC

; 1116 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 1117 :     stbi__vertically_flip_on_load_global = flag_true_if_should_flip;

  00004	8b 44 24 08	 mov	 eax, DWORD PTR flag_true_if_should_flip$[rsp]
  00008	89 05 00 00 00
	00		 mov	 DWORD PTR ?stbi__vertically_flip_on_load_global@@3HA, eax

; 1118 : }

  0000e	c3		 ret	 0
stbi_set_flip_vertically_on_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
flag_true_if_should_convert$ = 8
stbi_convert_iphone_png_to_rgb PROC

; 5001 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 5002 :     stbi__de_iphone_flag_global = flag_true_if_should_convert;

  00004	8b 44 24 08	 mov	 eax, DWORD PTR flag_true_if_should_convert$[rsp]
  00008	89 05 00 00 00
	00		 mov	 DWORD PTR ?stbi__de_iphone_flag_global@@3HA, eax

; 5003 : }

  0000e	c3		 ret	 0
stbi_convert_iphone_png_to_rgb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
flag_true_if_should_unpremultiply$ = 8
stbi_set_unpremultiply_on_load PROC

; 4996 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 4997 :     stbi__unpremultiply_on_load_global = flag_true_if_should_unpremultiply;

  00004	8b 44 24 08	 mov	 eax, DWORD PTR flag_true_if_should_unpremultiply$[rsp]
  00008	89 05 00 00 00
	00		 mov	 DWORD PTR ?stbi__unpremultiply_on_load_global@@3HA, eax

; 4998 : }

  0000e	c3		 ret	 0
stbi_set_unpremultiply_on_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
pos$ = 32
r$ = 36
s$ = 48
__$ArrayPad$ = 272
f$ = 304
stbi_is_16_bit_from_file PROC

; 7720 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 7721 :     int r;
; 7722 :     stbi__context s;
; 7723 :     long pos = ftell(f);

  0001e	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR f$[rsp]
  00026	e8 00 00 00 00	 call	 ftell
  0002b	89 44 24 20	 mov	 DWORD PTR pos$[rsp], eax

; 7724 :     stbi__start_file(&s, f);

  0002f	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR f$[rsp]
  00037	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  0003c	e8 00 00 00 00	 call	 ?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z ; stbi__start_file

; 7725 :     r = stbi__is_16_main(&s);

  00041	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  00046	e8 00 00 00 00	 call	 ?stbi__is_16_main@@YAHPEAUstbi__context@@@Z ; stbi__is_16_main
  0004b	89 44 24 24	 mov	 DWORD PTR r$[rsp], eax

; 7726 :     fseek(f,pos,SEEK_SET);

  0004f	45 33 c0	 xor	 r8d, r8d
  00052	8b 54 24 20	 mov	 edx, DWORD PTR pos$[rsp]
  00056	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR f$[rsp]
  0005e	e8 00 00 00 00	 call	 fseek

; 7727 :     return r;

  00063	8b 44 24 24	 mov	 eax, DWORD PTR r$[rsp]

; 7728 : }

  00067	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0006f	48 33 cc	 xor	 rcx, rsp
  00072	e8 00 00 00 00	 call	 __security_check_cookie
  00077	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  0007e	c3		 ret	 0
stbi_is_16_bit_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
result$ = 32
f$ = 40
filename$ = 64
stbi_is_16_bit PROC

; 7710 : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7711 :     FILE *f = stbi__fopen(filename, "rb");

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG82462
  00010	48 8b 4c 24 40	 mov	 rcx, QWORD PTR filename$[rsp]
  00015	e8 00 00 00 00	 call	 ?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z ; stbi__fopen
  0001a	48 89 44 24 28	 mov	 QWORD PTR f$[rsp], rax

; 7712 :     int result;
; 7713 :     if (!f) return stbi__err("can't fopen", "Unable to open file");

  0001f	48 83 7c 24 28
	00		 cmp	 QWORD PTR f$[rsp], 0
  00025	75 0e		 jne	 SHORT $LN2@stbi_is_16
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG82464
  0002e	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00033	eb 1c		 jmp	 SHORT $LN1@stbi_is_16
$LN2@stbi_is_16:

; 7714 :     result = stbi_is_16_bit_from_file(f);

  00035	48 8b 4c 24 28	 mov	 rcx, QWORD PTR f$[rsp]
  0003a	e8 00 00 00 00	 call	 stbi_is_16_bit_from_file
  0003f	89 44 24 20	 mov	 DWORD PTR result$[rsp], eax

; 7715 :     fclose(f);

  00043	48 8b 4c 24 28	 mov	 rcx, QWORD PTR f$[rsp]
  00048	e8 00 00 00 00	 call	 fclose

; 7716 :     return result;

  0004d	8b 44 24 20	 mov	 eax, DWORD PTR result$[rsp]
$LN1@stbi_is_16:

; 7717 : }

  00051	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00055	c3		 ret	 0
stbi_is_16_bit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
pos$ = 32
r$ = 36
s$ = 48
__$ArrayPad$ = 272
f$ = 304
x$ = 312
y$ = 320
comp$ = 328
stbi_info_from_file PROC

; 7699 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 7700 :     int r;
; 7701 :     stbi__context s;
; 7702 :     long pos = ftell(f);

  0002d	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR f$[rsp]
  00035	e8 00 00 00 00	 call	 ftell
  0003a	89 44 24 20	 mov	 DWORD PTR pos$[rsp], eax

; 7703 :     stbi__start_file(&s, f);

  0003e	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR f$[rsp]
  00046	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  0004b	e8 00 00 00 00	 call	 ?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z ; stbi__start_file

; 7704 :     r = stbi__info_main(&s,x,y,comp);

  00050	4c 8b 8c 24 48
	01 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00058	4c 8b 84 24 40
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00060	48 8b 94 24 38
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  00068	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  0006d	e8 00 00 00 00	 call	 ?stbi__info_main@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__info_main
  00072	89 44 24 24	 mov	 DWORD PTR r$[rsp], eax

; 7705 :     fseek(f,pos,SEEK_SET);

  00076	45 33 c0	 xor	 r8d, r8d
  00079	8b 54 24 20	 mov	 edx, DWORD PTR pos$[rsp]
  0007d	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR f$[rsp]
  00085	e8 00 00 00 00	 call	 fseek

; 7706 :     return r;

  0008a	8b 44 24 24	 mov	 eax, DWORD PTR r$[rsp]

; 7707 : }

  0008e	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00096	48 33 cc	 xor	 rcx, rsp
  00099	e8 00 00 00 00	 call	 __security_check_cookie
  0009e	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  000a5	c3		 ret	 0
stbi_info_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
result$ = 32
f$ = 40
filename$ = 64
x$ = 72
y$ = 80
comp$ = 88
stbi_info PROC

; 7689 : {

$LN4:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7690 :     FILE *f = stbi__fopen(filename, "rb");

  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG82445
  0001f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR filename$[rsp]
  00024	e8 00 00 00 00	 call	 ?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z ; stbi__fopen
  00029	48 89 44 24 28	 mov	 QWORD PTR f$[rsp], rax

; 7691 :     int result;
; 7692 :     if (!f) return stbi__err("can't fopen", "Unable to open file");

  0002e	48 83 7c 24 28
	00		 cmp	 QWORD PTR f$[rsp], 0
  00034	75 0e		 jne	 SHORT $LN2@stbi_info
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG82447
  0003d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00042	eb 2b		 jmp	 SHORT $LN1@stbi_info
$LN2@stbi_info:

; 7693 :     result = stbi_info_from_file(f, x, y, comp);

  00044	4c 8b 4c 24 58	 mov	 r9, QWORD PTR comp$[rsp]
  00049	4c 8b 44 24 50	 mov	 r8, QWORD PTR y$[rsp]
  0004e	48 8b 54 24 48	 mov	 rdx, QWORD PTR x$[rsp]
  00053	48 8b 4c 24 28	 mov	 rcx, QWORD PTR f$[rsp]
  00058	e8 00 00 00 00	 call	 stbi_info_from_file
  0005d	89 44 24 20	 mov	 DWORD PTR result$[rsp], eax

; 7694 :     fclose(f);

  00061	48 8b 4c 24 28	 mov	 rcx, QWORD PTR f$[rsp]
  00066	e8 00 00 00 00	 call	 fclose

; 7695 :     return result;

  0006b	8b 44 24 20	 mov	 eax, DWORD PTR result$[rsp]
$LN1@stbi_info:

; 7696 : }

  0006f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00073	c3		 ret	 0
stbi_info ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
s$ = 32
__$ArrayPad$ = 256
c$ = 288
user$ = 296
stbi_is_16_bit_from_callbacks PROC

; 7753 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 7754 :     stbi__context s;
; 7755 :     stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);

  00023	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR user$[rsp]
  0002b	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR c$[rsp]
  00033	48 8d 4c 24 20	 lea	 rcx, QWORD PTR s$[rsp]
  00038	e8 00 00 00 00	 call	 ?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z ; stbi__start_callbacks

; 7756 :     return stbi__is_16_main(&s);

  0003d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR s$[rsp]
  00042	e8 00 00 00 00	 call	 ?stbi__is_16_main@@YAHPEAUstbi__context@@@Z ; stbi__is_16_main

; 7757 : }

  00047	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0004f	48 33 cc	 xor	 rcx, rsp
  00052	e8 00 00 00 00	 call	 __security_check_cookie
  00057	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  0005e	c3		 ret	 0
stbi_is_16_bit_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
s$ = 32
__$ArrayPad$ = 256
buffer$ = 288
len$ = 296
stbi_is_16_bit_from_memory PROC

; 7746 : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 7747 :     stbi__context s;
; 7748 :     stbi__start_mem(&s,buffer,len);

  00022	44 8b 84 24 28
	01 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  0002a	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR buffer$[rsp]
  00032	48 8d 4c 24 20	 lea	 rcx, QWORD PTR s$[rsp]
  00037	e8 00 00 00 00	 call	 ?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z ; stbi__start_mem

; 7749 :     return stbi__is_16_main(&s);

  0003c	48 8d 4c 24 20	 lea	 rcx, QWORD PTR s$[rsp]
  00041	e8 00 00 00 00	 call	 ?stbi__is_16_main@@YAHPEAUstbi__context@@@Z ; stbi__is_16_main

; 7750 : }

  00046	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0004e	48 33 cc	 xor	 rcx, rsp
  00051	e8 00 00 00 00	 call	 __security_check_cookie
  00056	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  0005d	c3		 ret	 0
stbi_is_16_bit_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
s$ = 32
__$ArrayPad$ = 256
c$ = 288
user$ = 296
x$ = 304
y$ = 312
comp$ = 320
stbi_info_from_callbacks PROC

; 7739 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 7740 :     stbi__context s;
; 7741 :     stbi__start_callbacks(&s, (stbi_io_callbacks *) c, user);

  0002d	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR user$[rsp]
  00035	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR c$[rsp]
  0003d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR s$[rsp]
  00042	e8 00 00 00 00	 call	 ?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z ; stbi__start_callbacks

; 7742 :     return stbi__info_main(&s,x,y,comp);

  00047	4c 8b 8c 24 40
	01 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  0004f	4c 8b 84 24 38
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00057	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  0005f	48 8d 4c 24 20	 lea	 rcx, QWORD PTR s$[rsp]
  00064	e8 00 00 00 00	 call	 ?stbi__info_main@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__info_main

; 7743 : }

  00069	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00071	48 33 cc	 xor	 rcx, rsp
  00074	e8 00 00 00 00	 call	 __security_check_cookie
  00079	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  00080	c3		 ret	 0
stbi_info_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
s$ = 32
__$ArrayPad$ = 256
buffer$ = 288
len$ = 296
x$ = 304
y$ = 312
comp$ = 320
stbi_info_from_memory PROC

; 7732 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 7733 :     stbi__context s;
; 7734 :     stbi__start_mem(&s,buffer,len);

  0002c	44 8b 84 24 28
	01 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  00034	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR buffer$[rsp]
  0003c	48 8d 4c 24 20	 lea	 rcx, QWORD PTR s$[rsp]
  00041	e8 00 00 00 00	 call	 ?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z ; stbi__start_mem

; 7735 :     return stbi__info_main(&s,x,y,comp);

  00046	4c 8b 8c 24 40
	01 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  0004e	4c 8b 84 24 38
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00056	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  0005e	48 8d 4c 24 20	 lea	 rcx, QWORD PTR s$[rsp]
  00063	e8 00 00 00 00	 call	 ?stbi__info_main@@YAHPEAUstbi__context@@PEAH11@Z ; stbi__info_main

; 7736 : }

  00068	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00070	48 33 cc	 xor	 rcx, rsp
  00073	e8 00 00 00 00	 call	 __security_check_cookie
  00078	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  0007f	c3		 ret	 0
stbi_info_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
retval_from_stbi_load$ = 48
stbi_image_free PROC

; 1101 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1102 :     STBI_FREE(retval_from_stbi_load);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR retval_from_stbi_load$[rsp]
  0000e	e8 00 00 00 00	 call	 free

; 1103 : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
stbi_image_free ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
stbi_failure_reason PROC

; 973  :     return stbi__g_failure_reason;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__g_failure_reason@@3PEBDEB
  00005	8b c0		 mov	 eax, eax
  00007	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0000d	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  00016	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0001a	48 8b 04 08	 mov	 rax, QWORD PTR [rax+rcx]

; 974  : }

  0001e	c3		 ret	 0
stbi_failure_reason ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
pos$ = 32
res$ = 36
s$ = 48
__$ArrayPad$ = 272
f$ = 304
stbi_is_hdr_from_file PROC

; 1542 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1543 : #ifndef STBI_NO_HDR
; 1544 :     long pos = ftell(f);

  0001e	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR f$[rsp]
  00026	e8 00 00 00 00	 call	 ftell
  0002b	89 44 24 20	 mov	 DWORD PTR pos$[rsp], eax

; 1545 :     int res;
; 1546 :     stbi__context s;
; 1547 :     stbi__start_file(&s,f);

  0002f	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR f$[rsp]
  00037	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  0003c	e8 00 00 00 00	 call	 ?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z ; stbi__start_file

; 1548 :     res = stbi__hdr_test(&s);

  00041	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  00046	e8 00 00 00 00	 call	 ?stbi__hdr_test@@YAHPEAUstbi__context@@@Z ; stbi__hdr_test
  0004b	89 44 24 24	 mov	 DWORD PTR res$[rsp], eax

; 1549 :     fseek(f, pos, SEEK_SET);

  0004f	45 33 c0	 xor	 r8d, r8d
  00052	8b 54 24 20	 mov	 edx, DWORD PTR pos$[rsp]
  00056	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR f$[rsp]
  0005e	e8 00 00 00 00	 call	 fseek

; 1550 :     return res;

  00063	8b 44 24 24	 mov	 eax, DWORD PTR res$[rsp]

; 1551 : #else
; 1552 :     STBI_NOTUSED(f);
; 1553 :     return 0;
; 1554 : #endif
; 1555 : }

  00067	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0006f	48 33 cc	 xor	 rcx, rsp
  00072	e8 00 00 00 00	 call	 __security_check_cookie
  00077	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  0007e	c3		 ret	 0
stbi_is_hdr_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
result$ = 32
f$ = 40
filename$ = 64
stbi_is_hdr PROC

; 1531 : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1532 :     FILE *f = stbi__fopen(filename, "rb");

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG76917
  00010	48 8b 4c 24 40	 mov	 rcx, QWORD PTR filename$[rsp]
  00015	e8 00 00 00 00	 call	 ?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z ; stbi__fopen
  0001a	48 89 44 24 28	 mov	 QWORD PTR f$[rsp], rax

; 1533 :     int result=0;

  0001f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR result$[rsp], 0

; 1534 :     if (f) {

  00027	48 83 7c 24 28
	00		 cmp	 QWORD PTR f$[rsp], 0
  0002d	74 18		 je	 SHORT $LN2@stbi_is_hd

; 1535 :         result = stbi_is_hdr_from_file(f);

  0002f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR f$[rsp]
  00034	e8 00 00 00 00	 call	 stbi_is_hdr_from_file
  00039	89 44 24 20	 mov	 DWORD PTR result$[rsp], eax

; 1536 :         fclose(f);

  0003d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR f$[rsp]
  00042	e8 00 00 00 00	 call	 fclose
$LN2@stbi_is_hd:

; 1537 :     }
; 1538 :     return result;

  00047	8b 44 24 20	 mov	 eax, DWORD PTR result$[rsp]

; 1539 : }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
stbi_is_hdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
s$ = 32
__$ArrayPad$ = 256
buffer$ = 288
len$ = 296
stbi_is_hdr_from_memory PROC

; 1517 : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1518 : #ifndef STBI_NO_HDR
; 1519 :     stbi__context s;
; 1520 :     stbi__start_mem(&s,buffer,len);

  00022	44 8b 84 24 28
	01 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  0002a	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR buffer$[rsp]
  00032	48 8d 4c 24 20	 lea	 rcx, QWORD PTR s$[rsp]
  00037	e8 00 00 00 00	 call	 ?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z ; stbi__start_mem

; 1521 :     return stbi__hdr_test(&s);

  0003c	48 8d 4c 24 20	 lea	 rcx, QWORD PTR s$[rsp]
  00041	e8 00 00 00 00	 call	 ?stbi__hdr_test@@YAHPEAUstbi__context@@@Z ; stbi__hdr_test

; 1522 : #else
; 1523 :     STBI_NOTUSED(buffer);
; 1524 :     STBI_NOTUSED(len);
; 1525 :     return 0;
; 1526 : #endif
; 1527 : }

  00046	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0004e	48 33 cc	 xor	 rcx, rsp
  00051	e8 00 00 00 00	 call	 __security_check_cookie
  00056	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  0005d	c3		 ret	 0
stbi_is_hdr_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
s$ = 32
__$ArrayPad$ = 256
clbk$ = 288
user$ = 296
stbi_is_hdr_from_callbacks PROC

; 1559 : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1560 : #ifndef STBI_NO_HDR
; 1561 :     stbi__context s;
; 1562 :     stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);

  00023	4c 8b 84 24 28
	01 00 00	 mov	 r8, QWORD PTR user$[rsp]
  0002b	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR clbk$[rsp]
  00033	48 8d 4c 24 20	 lea	 rcx, QWORD PTR s$[rsp]
  00038	e8 00 00 00 00	 call	 ?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z ; stbi__start_callbacks

; 1563 :     return stbi__hdr_test(&s);

  0003d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR s$[rsp]
  00042	e8 00 00 00 00	 call	 ?stbi__hdr_test@@YAHPEAUstbi__context@@@Z ; stbi__hdr_test

; 1564 : #else
; 1565 :     STBI_NOTUSED(clbk);
; 1566 :     STBI_NOTUSED(user);
; 1567 :     return 0;
; 1568 : #endif
; 1569 : }

  00047	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0004f	48 33 cc	 xor	 rcx, rsp
  00052	e8 00 00 00 00	 call	 __security_check_cookie
  00057	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  0005e	c3		 ret	 0
stbi_is_hdr_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
scale$ = 8
stbi_ldr_to_hdr_scale PROC

; 1575 : STBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }

  00000	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00006	f3 0f 10 44 24
	08		 movss	 xmm0, DWORD PTR scale$[rsp]
  0000c	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?stbi__l2h_scale@@3MA, xmm0
  00014	c3		 ret	 0
stbi_ldr_to_hdr_scale ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
gamma$ = 8
stbi_ldr_to_hdr_gamma PROC

; 1574 : STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }

  00000	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00006	f3 0f 10 44 24
	08		 movss	 xmm0, DWORD PTR gamma$[rsp]
  0000c	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?stbi__l2h_gamma@@3MA, xmm0
  00014	c3		 ret	 0
stbi_ldr_to_hdr_gamma ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
scale$ = 8
stbi_hdr_to_ldr_scale PROC

; 1581 : STBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1/scale; }

  00000	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00006	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0000e	f3 0f 5e 44 24
	08		 divss	 xmm0, DWORD PTR scale$[rsp]
  00014	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?stbi__h2l_scale_i@@3MA, xmm0
  0001c	c3		 ret	 0
stbi_hdr_to_ldr_scale ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
gamma$ = 8
stbi_hdr_to_ldr_gamma PROC

; 1580 : STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1/gamma; }

  00000	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00006	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0000e	f3 0f 5e 44 24
	08		 divss	 xmm0, DWORD PTR gamma$[rsp]
  00014	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?stbi__h2l_gamma_i@@3MA, xmm0
  0001c	c3		 ret	 0
stbi_hdr_to_ldr_gamma ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
s$ = 48
__$ArrayPad$ = 272
f$ = 304
x$ = 312
y$ = 320
comp$ = 328
req_comp$ = 336
stbi_loadf_from_file PROC

; 1503 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1504 :     stbi__context s;
; 1505 :     stbi__start_file(&s,f);

  0002d	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR f$[rsp]
  00035	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  0003a	e8 00 00 00 00	 call	 ?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z ; stbi__start_file

; 1506 :     return stbi__loadf_main(&s,x,y,comp,req_comp);

  0003f	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00046	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0004a	4c 8b 8c 24 48
	01 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00052	4c 8b 84 24 40
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  0005a	48 8b 94 24 38
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  00062	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  00067	e8 00 00 00 00	 call	 ?stbi__loadf_main@@YAPEAMPEAUstbi__context@@PEAH11H@Z ; stbi__loadf_main

; 1507 : }

  0006c	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00074	48 33 cc	 xor	 rcx, rsp
  00077	e8 00 00 00 00	 call	 __security_check_cookie
  0007c	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  00083	c3		 ret	 0
stbi_loadf_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv71 = 48
f$ = 56
result$ = 64
filename$ = 96
x$ = 104
y$ = 112
comp$ = 120
req_comp$ = 128
stbi_loadf PROC

; 1493 : {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1494 :     float *result;
; 1495 :     FILE *f = stbi__fopen(filename, "rb");

  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG76896
  0001f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR filename$[rsp]
  00024	e8 00 00 00 00	 call	 ?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z ; stbi__fopen
  00029	48 89 44 24 38	 mov	 QWORD PTR f$[rsp], rax

; 1496 :     if (!f) return stbi__errpf("can't fopen", "Unable to open file");

  0002e	48 83 7c 24 38
	00		 cmp	 QWORD PTR f$[rsp], 0
  00034	75 29		 jne	 SHORT $LN2@stbi_loadf
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG76898
  0003d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00042	85 c0		 test	 eax, eax
  00044	74 0a		 je	 SHORT $LN4@stbi_loadf
  00046	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
  0004e	eb 08		 jmp	 SHORT $LN5@stbi_loadf
$LN4@stbi_loadf:
  00050	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
$LN5@stbi_loadf:
  00058	48 63 44 24 30	 movsxd	 rax, DWORD PTR tv71[rsp]
  0005d	eb 38		 jmp	 SHORT $LN1@stbi_loadf
$LN2@stbi_loadf:

; 1497 :     result = stbi_loadf_from_file(f,x,y,comp,req_comp);

  0005f	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00066	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0006a	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  0006f	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  00074	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  00079	48 8b 4c 24 38	 mov	 rcx, QWORD PTR f$[rsp]
  0007e	e8 00 00 00 00	 call	 stbi_loadf_from_file
  00083	48 89 44 24 40	 mov	 QWORD PTR result$[rsp], rax

; 1498 :     fclose(f);

  00088	48 8b 4c 24 38	 mov	 rcx, QWORD PTR f$[rsp]
  0008d	e8 00 00 00 00	 call	 fclose

; 1499 :     return result;

  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
$LN1@stbi_loadf:

; 1500 : }

  00097	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0009b	c3		 ret	 0
stbi_loadf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
s$ = 48
__$ArrayPad$ = 272
clbk$ = 304
user$ = 312
x$ = 320
y$ = 328
comp$ = 336
req_comp$ = 344
stbi_loadf_from_callbacks PROC

; 1485 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1486 :     stbi__context s;
; 1487 :     stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);

  0002d	4c 8b 84 24 38
	01 00 00	 mov	 r8, QWORD PTR user$[rsp]
  00035	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR clbk$[rsp]
  0003d	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  00042	e8 00 00 00 00	 call	 ?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z ; stbi__start_callbacks

; 1488 :     return stbi__loadf_main(&s,x,y,comp,req_comp);

  00047	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  0004e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00052	4c 8b 8c 24 50
	01 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  0005a	4c 8b 84 24 48
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00062	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  0006a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  0006f	e8 00 00 00 00	 call	 ?stbi__loadf_main@@YAPEAMPEAUstbi__context@@PEAH11H@Z ; stbi__loadf_main

; 1489 : }

  00074	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007c	48 33 cc	 xor	 rcx, rsp
  0007f	e8 00 00 00 00	 call	 __security_check_cookie
  00084	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  0008b	c3		 ret	 0
stbi_loadf_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
s$ = 48
__$ArrayPad$ = 272
buffer$ = 304
len$ = 312
x$ = 320
y$ = 328
comp$ = 336
req_comp$ = 344
stbi_loadf_from_memory PROC

; 1478 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1479 :     stbi__context s;
; 1480 :     stbi__start_mem(&s,buffer,len);

  0002c	44 8b 84 24 38
	01 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  00034	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR buffer$[rsp]
  0003c	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  00041	e8 00 00 00 00	 call	 ?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z ; stbi__start_mem

; 1481 :     return stbi__loadf_main(&s,x,y,comp,req_comp);

  00046	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  0004d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00051	4c 8b 8c 24 50
	01 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00059	4c 8b 84 24 48
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00061	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  00069	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  0006e	e8 00 00 00 00	 call	 ?stbi__loadf_main@@YAPEAMPEAUstbi__context@@PEAH11H@Z ; stbi__loadf_main

; 1482 : }

  00073	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007b	48 33 cc	 xor	 rcx, rsp
  0007e	e8 00 00 00 00	 call	 __security_check_cookie
  00083	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  0008a	c3		 ret	 0
stbi_loadf_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
result$ = 48
s$ = 64
__$ArrayPad$ = 288
f$ = 320
x$ = 328
y$ = 336
comp$ = 344
req_comp$ = 352
stbi_load_from_file_16 PROC

; 1389 : {

$LN4:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1390 :     stbi__uint16 *result;
; 1391 :     stbi__context s;
; 1392 :     stbi__start_file(&s,f);

  0002d	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR f$[rsp]
  00035	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  0003a	e8 00 00 00 00	 call	 ?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z ; stbi__start_file

; 1393 :     result = stbi__load_and_postprocess_16bit(&s,x,y,comp,req_comp);

  0003f	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00046	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0004a	4c 8b 8c 24 58
	01 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00052	4c 8b 84 24 50
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  0005a	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  00062	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  00067	e8 00 00 00 00	 call	 ?stbi__load_and_postprocess_16bit@@YAPEAGPEAUstbi__context@@PEAH11H@Z ; stbi__load_and_postprocess_16bit
  0006c	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 1394 :     if (result) {

  00071	48 83 7c 24 30
	00		 cmp	 QWORD PTR result$[rsp], 0
  00077	74 2d		 je	 SHORT $LN2@stbi_load_

; 1395 :         // need to 'unget' all the characters in the IO buffer
; 1396 :         fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);

  00079	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR s$[rsp+192]
  00081	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp+200]
  00089	48 2b c8	 sub	 rcx, rax
  0008c	48 8b c1	 mov	 rax, rcx
  0008f	f7 d8		 neg	 eax
  00091	41 b8 01 00 00
	00		 mov	 r8d, 1
  00097	8b d0		 mov	 edx, eax
  00099	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR f$[rsp]
  000a1	e8 00 00 00 00	 call	 fseek
$LN2@stbi_load_:

; 1397 :     }
; 1398 :     return result;

  000a6	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]

; 1399 : }

  000ab	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000b3	48 33 cc	 xor	 rcx, rsp
  000b6	e8 00 00 00 00	 call	 __security_check_cookie
  000bb	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  000c2	c3		 ret	 0
stbi_load_from_file_16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv71 = 48
f$ = 56
result$ = 64
filename$ = 96
x$ = 104
y$ = 112
comp$ = 120
req_comp$ = 128
stbi_load_16 PROC

; 1402 : {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1403 :     FILE *f = stbi__fopen(filename, "rb");

  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG76795
  0001f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR filename$[rsp]
  00024	e8 00 00 00 00	 call	 ?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z ; stbi__fopen
  00029	48 89 44 24 38	 mov	 QWORD PTR f$[rsp], rax

; 1404 :     stbi__uint16 *result;
; 1405 :     if (!f) return (stbi_us *) stbi__errpuc("can't fopen", "Unable to open file");

  0002e	48 83 7c 24 38
	00		 cmp	 QWORD PTR f$[rsp], 0
  00034	75 29		 jne	 SHORT $LN2@stbi_load_
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG76797
  0003d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00042	85 c0		 test	 eax, eax
  00044	74 0a		 je	 SHORT $LN4@stbi_load_
  00046	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
  0004e	eb 08		 jmp	 SHORT $LN5@stbi_load_
$LN4@stbi_load_:
  00050	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
$LN5@stbi_load_:
  00058	48 63 44 24 30	 movsxd	 rax, DWORD PTR tv71[rsp]
  0005d	eb 38		 jmp	 SHORT $LN1@stbi_load_
$LN2@stbi_load_:

; 1406 :     result = stbi_load_from_file_16(f,x,y,comp,req_comp);

  0005f	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00066	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0006a	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  0006f	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  00074	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  00079	48 8b 4c 24 38	 mov	 rcx, QWORD PTR f$[rsp]
  0007e	e8 00 00 00 00	 call	 stbi_load_from_file_16
  00083	48 89 44 24 40	 mov	 QWORD PTR result$[rsp], rax

; 1407 :     fclose(f);

  00088	48 8b 4c 24 38	 mov	 rcx, QWORD PTR f$[rsp]
  0008d	e8 00 00 00 00	 call	 fclose

; 1408 :     return result;

  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
$LN1@stbi_load_:

; 1409 : }

  00097	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0009b	c3		 ret	 0
stbi_load_16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
s$ = 48
__$ArrayPad$ = 272
clbk$ = 304
user$ = 312
x$ = 320
y$ = 328
channels_in_file$ = 336
desired_channels$ = 344
stbi_load_16_from_callbacks PROC

; 1422 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1423 :     stbi__context s;
; 1424 :     stbi__start_callbacks(&s, (stbi_io_callbacks *)clbk, user);

  0002d	4c 8b 84 24 38
	01 00 00	 mov	 r8, QWORD PTR user$[rsp]
  00035	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR clbk$[rsp]
  0003d	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  00042	e8 00 00 00 00	 call	 ?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z ; stbi__start_callbacks

; 1425 :     return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);

  00047	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR desired_channels$[rsp]
  0004e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00052	4c 8b 8c 24 50
	01 00 00	 mov	 r9, QWORD PTR channels_in_file$[rsp]
  0005a	4c 8b 84 24 48
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00062	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  0006a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  0006f	e8 00 00 00 00	 call	 ?stbi__load_and_postprocess_16bit@@YAPEAGPEAUstbi__context@@PEAH11H@Z ; stbi__load_and_postprocess_16bit

; 1426 : }

  00074	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007c	48 33 cc	 xor	 rcx, rsp
  0007f	e8 00 00 00 00	 call	 __security_check_cookie
  00084	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  0008b	c3		 ret	 0
stbi_load_16_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
s$ = 48
__$ArrayPad$ = 272
buffer$ = 304
len$ = 312
x$ = 320
y$ = 328
channels_in_file$ = 336
desired_channels$ = 344
stbi_load_16_from_memory PROC

; 1415 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1416 :     stbi__context s;
; 1417 :     stbi__start_mem(&s,buffer,len);

  0002c	44 8b 84 24 38
	01 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  00034	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR buffer$[rsp]
  0003c	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  00041	e8 00 00 00 00	 call	 ?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z ; stbi__start_mem

; 1418 :     return stbi__load_and_postprocess_16bit(&s,x,y,channels_in_file,desired_channels);

  00046	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR desired_channels$[rsp]
  0004d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00051	4c 8b 8c 24 50
	01 00 00	 mov	 r9, QWORD PTR channels_in_file$[rsp]
  00059	4c 8b 84 24 48
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00061	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  00069	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  0006e	e8 00 00 00 00	 call	 ?stbi__load_and_postprocess_16bit@@YAPEAGPEAUstbi__context@@PEAH11H@Z ; stbi__load_and_postprocess_16bit

; 1419 : }

  00073	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007b	48 33 cc	 xor	 rcx, rsp
  0007e	e8 00 00 00 00	 call	 __security_check_cookie
  00083	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  0008a	c3		 ret	 0
stbi_load_16_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv88 = 64
result$ = 72
s$ = 80
__$ArrayPad$ = 304
buffer$ = 336
len$ = 344
delays$ = 352
x$ = 360
y$ = 368
z$ = 376
comp$ = 384
req_comp$ = 392
stbi_load_gif_from_memory PROC

; 1444 : {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1445 :     unsigned char *result;
; 1446 :     stbi__context s;
; 1447 :     stbi__start_mem(&s,buffer,len);

  0002c	44 8b 84 24 58
	01 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  00034	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR buffer$[rsp]
  0003c	48 8d 4c 24 50	 lea	 rcx, QWORD PTR s$[rsp]
  00041	e8 00 00 00 00	 call	 ?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z ; stbi__start_mem

; 1448 :     
; 1449 :     result = (unsigned char*) stbi__load_gif_main(&s, delays, x, y, z, comp, req_comp);

  00046	8b 84 24 88 01
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  0004d	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00051	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  00059	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0005e	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  00066	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006b	4c 8b 8c 24 70
	01 00 00	 mov	 r9, QWORD PTR y$[rsp]
  00073	4c 8b 84 24 68
	01 00 00	 mov	 r8, QWORD PTR x$[rsp]
  0007b	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR delays$[rsp]
  00083	48 8d 4c 24 50	 lea	 rcx, QWORD PTR s$[rsp]
  00088	e8 00 00 00 00	 call	 ?stbi__load_gif_main@@YAPEAXPEAUstbi__context@@PEAPEAHPEAH222H@Z ; stbi__load_gif_main
  0008d	48 89 44 24 48	 mov	 QWORD PTR result$[rsp], rax

; 1450 :     if (stbi__vertically_flip_on_load) {

  00092	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__vertically_flip_on_load_set@@3HA
  00097	8b c0		 mov	 eax, eax
  00099	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  0009f	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000a8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  000ac	83 3c 08 00	 cmp	 DWORD PTR [rax+rcx], 0
  000b0	74 23		 je	 SHORT $LN4@stbi_load_
  000b2	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?stbi__vertically_flip_on_load_local@@3HA
  000b7	8b c0		 mov	 eax, eax
  000b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tls_index
  000bf	65 48 8b 14 25
	58 00 00 00	 mov	 rdx, QWORD PTR gs:88
  000c8	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  000cc	8b 04 08	 mov	 eax, DWORD PTR [rax+rcx]
  000cf	89 44 24 40	 mov	 DWORD PTR tv88[rsp], eax
  000d3	eb 0a		 jmp	 SHORT $LN5@stbi_load_
$LN4@stbi_load_:
  000d5	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?stbi__vertically_flip_on_load_global@@3HA
  000db	89 44 24 40	 mov	 DWORD PTR tv88[rsp], eax
$LN5@stbi_load_:
  000df	83 7c 24 40 00	 cmp	 DWORD PTR tv88[rsp], 0
  000e4	74 38		 je	 SHORT $LN2@stbi_load_

; 1451 :         stbi__vertical_flip_slices( result, *x, *y, *z, *comp );

  000e6	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR comp$[rsp]
  000ee	8b 00		 mov	 eax, DWORD PTR [rax]
  000f0	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000f4	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR z$[rsp]
  000fc	44 8b 08	 mov	 r9d, DWORD PTR [rax]
  000ff	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR y$[rsp]
  00107	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  0010a	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR x$[rsp]
  00112	8b 10		 mov	 edx, DWORD PTR [rax]
  00114	48 8b 4c 24 48	 mov	 rcx, QWORD PTR result$[rsp]
  00119	e8 00 00 00 00	 call	 ?stbi__vertical_flip_slices@@YAXPEAXHHHH@Z ; stbi__vertical_flip_slices
$LN2@stbi_load_:

; 1452 :     }
; 1453 :     
; 1454 :     return result;

  0011e	48 8b 44 24 48	 mov	 rax, QWORD PTR result$[rsp]

; 1455 : }

  00123	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0012b	48 33 cc	 xor	 rcx, rsp
  0012e	e8 00 00 00 00	 call	 __security_check_cookie
  00133	48 81 c4 48 01
	00 00		 add	 rsp, 328		; 00000148H
  0013a	c3		 ret	 0
stbi_load_gif_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
result$ = 48
s$ = 64
__$ArrayPad$ = 288
f$ = 320
x$ = 328
y$ = 336
comp$ = 344
req_comp$ = 352
stbi_load_from_file PROC

; 1376 : {

$LN4:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1377 :     unsigned char *result;
; 1378 :     stbi__context s;
; 1379 :     stbi__start_file(&s,f);

  0002d	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR f$[rsp]
  00035	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  0003a	e8 00 00 00 00	 call	 ?stbi__start_file@@YAXPEAUstbi__context@@PEAU_iobuf@@@Z ; stbi__start_file

; 1380 :     result = stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);

  0003f	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00046	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0004a	4c 8b 8c 24 58
	01 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00052	4c 8b 84 24 50
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  0005a	48 8b 94 24 48
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  00062	48 8d 4c 24 40	 lea	 rcx, QWORD PTR s$[rsp]
  00067	e8 00 00 00 00	 call	 ?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z ; stbi__load_and_postprocess_8bit
  0006c	48 89 44 24 30	 mov	 QWORD PTR result$[rsp], rax

; 1381 :     if (result) {

  00071	48 83 7c 24 30
	00		 cmp	 QWORD PTR result$[rsp], 0
  00077	74 2d		 je	 SHORT $LN2@stbi_load_

; 1382 :         // need to 'unget' all the characters in the IO buffer
; 1383 :         fseek(f, - (int) (s.img_buffer_end - s.img_buffer), SEEK_CUR);

  00079	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR s$[rsp+192]
  00081	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR s$[rsp+200]
  00089	48 2b c8	 sub	 rcx, rax
  0008c	48 8b c1	 mov	 rax, rcx
  0008f	f7 d8		 neg	 eax
  00091	41 b8 01 00 00
	00		 mov	 r8d, 1
  00097	8b d0		 mov	 edx, eax
  00099	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR f$[rsp]
  000a1	e8 00 00 00 00	 call	 fseek
$LN2@stbi_load_:

; 1384 :     }
; 1385 :     return result;

  000a6	48 8b 44 24 30	 mov	 rax, QWORD PTR result$[rsp]

; 1386 : }

  000ab	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000b3	48 33 cc	 xor	 rcx, rsp
  000b6	e8 00 00 00 00	 call	 __security_check_cookie
  000bb	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  000c2	c3		 ret	 0
stbi_load_from_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
tv71 = 48
f$ = 56
result$ = 64
filename$ = 96
x$ = 104
y$ = 112
comp$ = 120
req_comp$ = 128
stbi_load PROC

; 1366 : {

$LN6:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1367 :     FILE *f = stbi__fopen(filename, "rb");

  00018	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG76758
  0001f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR filename$[rsp]
  00024	e8 00 00 00 00	 call	 ?stbi__fopen@@YAPEAU_iobuf@@PEBD0@Z ; stbi__fopen
  00029	48 89 44 24 38	 mov	 QWORD PTR f$[rsp], rax

; 1368 :     unsigned char *result;
; 1369 :     if (!f) return stbi__errpuc("can't fopen", "Unable to open file");

  0002e	48 83 7c 24 38
	00		 cmp	 QWORD PTR f$[rsp], 0
  00034	75 29		 jne	 SHORT $LN2@stbi_load
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG76760
  0003d	e8 00 00 00 00	 call	 ?stbi__err@@YAHPEBD@Z	; stbi__err
  00042	85 c0		 test	 eax, eax
  00044	74 0a		 je	 SHORT $LN4@stbi_load
  00046	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
  0004e	eb 08		 jmp	 SHORT $LN5@stbi_load
$LN4@stbi_load:
  00050	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
$LN5@stbi_load:
  00058	48 63 44 24 30	 movsxd	 rax, DWORD PTR tv71[rsp]
  0005d	eb 38		 jmp	 SHORT $LN1@stbi_load
$LN2@stbi_load:

; 1370 :     result = stbi_load_from_file(f,x,y,comp,req_comp);

  0005f	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  00066	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0006a	4c 8b 4c 24 78	 mov	 r9, QWORD PTR comp$[rsp]
  0006f	4c 8b 44 24 70	 mov	 r8, QWORD PTR y$[rsp]
  00074	48 8b 54 24 68	 mov	 rdx, QWORD PTR x$[rsp]
  00079	48 8b 4c 24 38	 mov	 rcx, QWORD PTR f$[rsp]
  0007e	e8 00 00 00 00	 call	 stbi_load_from_file
  00083	48 89 44 24 40	 mov	 QWORD PTR result$[rsp], rax

; 1371 :     fclose(f);

  00088	48 8b 4c 24 38	 mov	 rcx, QWORD PTR f$[rsp]
  0008d	e8 00 00 00 00	 call	 fclose

; 1372 :     return result;

  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
$LN1@stbi_load:

; 1373 : }

  00097	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0009b	c3		 ret	 0
stbi_load ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
s$ = 48
__$ArrayPad$ = 272
clbk$ = 304
user$ = 312
x$ = 320
y$ = 328
comp$ = 336
req_comp$ = 344
stbi_load_from_callbacks PROC

; 1436 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1437 :     stbi__context s;
; 1438 :     stbi__start_callbacks(&s, (stbi_io_callbacks *) clbk, user);

  0002d	4c 8b 84 24 38
	01 00 00	 mov	 r8, QWORD PTR user$[rsp]
  00035	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR clbk$[rsp]
  0003d	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  00042	e8 00 00 00 00	 call	 ?stbi__start_callbacks@@YAXPEAUstbi__context@@PEAUstbi_io_callbacks@@PEAX@Z ; stbi__start_callbacks

; 1439 :     return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);

  00047	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  0004e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00052	4c 8b 8c 24 50
	01 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  0005a	4c 8b 84 24 48
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00062	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  0006a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  0006f	e8 00 00 00 00	 call	 ?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z ; stbi__load_and_postprocess_8bit

; 1440 : }

  00074	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007c	48 33 cc	 xor	 rcx, rsp
  0007f	e8 00 00 00 00	 call	 __security_check_cookie
  00084	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  0008b	c3		 ret	 0
stbi_load_from_callbacks ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\stb_image.h
_TEXT	SEGMENT
s$ = 48
__$ArrayPad$ = 272
buffer$ = 304
len$ = 312
x$ = 320
y$ = 328
comp$ = 336
req_comp$ = 344
stbi_load_from_memory PROC

; 1429 : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1430 :     stbi__context s;
; 1431 :     stbi__start_mem(&s,buffer,len);

  0002c	44 8b 84 24 38
	01 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  00034	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR buffer$[rsp]
  0003c	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  00041	e8 00 00 00 00	 call	 ?stbi__start_mem@@YAXPEAUstbi__context@@PEBEH@Z ; stbi__start_mem

; 1432 :     return stbi__load_and_postprocess_8bit(&s,x,y,comp,req_comp);

  00046	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR req_comp$[rsp]
  0004d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00051	4c 8b 8c 24 50
	01 00 00	 mov	 r9, QWORD PTR comp$[rsp]
  00059	4c 8b 84 24 48
	01 00 00	 mov	 r8, QWORD PTR y$[rsp]
  00061	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR x$[rsp]
  00069	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  0006e	e8 00 00 00 00	 call	 ?stbi__load_and_postprocess_8bit@@YAPEAEPEAUstbi__context@@PEAH11H@Z ; stbi__load_and_postprocess_8bit

; 1433 : }

  00073	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0007b	48 33 cc	 xor	 rcx, rsp
  0007e	e8 00 00 00 00	 call	 __security_check_cookie
  00083	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  0008a	c3		 ret	 0
stbi_load_from_memory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\stack.h
_TEXT	SEGMENT
base$ = 32
head$ = 40
element$ = 48
base_ptr$ = 80
item_count$ = 88
item_size$ = 96
?_stack_push@@YAPEAXPEAPEAXII@Z PROC			; _stack_push

; 78   : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 79   :     void *base = _stack_fit(base_ptr, item_count, item_size);

  00012	44 8b 44 24 60	 mov	 r8d, DWORD PTR item_size$[rsp]
  00017	8b 54 24 58	 mov	 edx, DWORD PTR item_count$[rsp]
  0001b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR base_ptr$[rsp]
  00020	e8 00 00 00 00	 call	 ?_stack_fit@@YAPEAXPEAPEAXII@Z ; _stack_fit
  00025	48 89 44 24 20	 mov	 QWORD PTR base$[rsp], rax

; 80   :     if(base == NULL) return NULL;

  0002a	48 83 7c 24 20
	00		 cmp	 QWORD PTR base$[rsp], 0
  00030	75 04		 jne	 SHORT $LN2@stack_push
  00032	33 c0		 xor	 eax, eax
  00034	eb 62		 jmp	 SHORT $LN1@stack_push
$LN2@stack_push:

; 81   :     stack_header_t *head = get_stack_header(base);

  00036	48 8b 44 24 20	 mov	 rax, QWORD PTR base$[rsp]
  0003b	48 83 e8 08	 sub	 rax, 8
  0003f	48 89 44 24 28	 mov	 QWORD PTR head$[rsp], rax

; 82   :     
; 83   :     void *element = (void *)((u8 *)base + item_size*head->count);

  00044	48 8b 44 24 28	 mov	 rax, QWORD PTR head$[rsp]
  00049	8b 4c 24 60	 mov	 ecx, DWORD PTR item_size$[rsp]
  0004d	0f af 48 04	 imul	 ecx, DWORD PTR [rax+4]
  00051	8b c1		 mov	 eax, ecx
  00053	8b c0		 mov	 eax, eax
  00055	48 8b 4c 24 20	 mov	 rcx, QWORD PTR base$[rsp]
  0005a	48 03 c8	 add	 rcx, rax
  0005d	48 8b c1	 mov	 rax, rcx
  00060	48 89 44 24 30	 mov	 QWORD PTR element$[rsp], rax

; 84   :     memset(element, 0, item_count*item_size);

  00065	8b 44 24 58	 mov	 eax, DWORD PTR item_count$[rsp]
  00069	0f af 44 24 60	 imul	 eax, DWORD PTR item_size$[rsp]
  0006e	8b c0		 mov	 eax, eax
  00070	44 8b c0	 mov	 r8d, eax
  00073	33 d2		 xor	 edx, edx
  00075	48 8b 4c 24 30	 mov	 rcx, QWORD PTR element$[rsp]
  0007a	e8 00 00 00 00	 call	 memset

; 85   :     head->count += item_count;

  0007f	48 8b 44 24 28	 mov	 rax, QWORD PTR head$[rsp]
  00084	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00087	03 44 24 58	 add	 eax, DWORD PTR item_count$[rsp]
  0008b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR head$[rsp]
  00090	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 86   :     return element;

  00093	48 8b 44 24 30	 mov	 rax, QWORD PTR element$[rsp]
$LN1@stack_push:

; 87   : }

  00098	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009c	c3		 ret	 0
?_stack_push@@YAPEAXPEAPEAXII@Z ENDP			; _stack_push
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\stack.h
_TEXT	SEGMENT
new_count$ = 32
new_cap$1 = 36
tv75 = 40
base$ = 48
head$ = 56
base_ptr$ = 80
item_count$ = 88
item_size$ = 96
?_stack_fit@@YAPEAXPEAPEAXII@Z PROC			; _stack_fit

; 48   : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 49   :     void *base = *base_ptr;

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR base_ptr$[rsp]
  00017	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001a	48 89 44 24 30	 mov	 QWORD PTR base$[rsp], rax

; 50   :     u32 new_count = item_count;

  0001f	8b 44 24 58	 mov	 eax, DWORD PTR item_count$[rsp]
  00023	89 44 24 20	 mov	 DWORD PTR new_count$[rsp], eax

; 51   :     
; 52   :     if(base == NULL) goto resize;

  00027	48 83 7c 24 30
	00		 cmp	 QWORD PTR base$[rsp], 0
  0002d	75 04		 jne	 SHORT $LN2@stack_fit
  0002f	eb 31		 jmp	 SHORT $LN3@stack_fit
  00031	eb 2f		 jmp	 SHORT $resize$10
$LN2@stack_fit:

; 53   :     
; 54   :     stack_header_t *head = get_stack_header(base);

  00033	48 8b 44 24 30	 mov	 rax, QWORD PTR base$[rsp]
  00038	48 83 e8 08	 sub	 rax, 8
  0003c	48 89 44 24 38	 mov	 QWORD PTR head$[rsp], rax

; 55   :     new_count += head->count;

  00041	48 8b 44 24 38	 mov	 rax, QWORD PTR head$[rsp]
  00046	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00049	8b 4c 24 20	 mov	 ecx, DWORD PTR new_count$[rsp]
  0004d	03 c8		 add	 ecx, eax
  0004f	8b c1		 mov	 eax, ecx
  00051	89 44 24 20	 mov	 DWORD PTR new_count$[rsp], eax

; 56   :     
; 57   :     if(new_count > head->cap)

  00055	48 8b 44 24 38	 mov	 rax, QWORD PTR head$[rsp]
  0005a	8b 00		 mov	 eax, DWORD PTR [rax]
  0005c	39 44 24 20	 cmp	 DWORD PTR new_count$[rsp], eax
  00060	76 5e		 jbe	 SHORT $LN4@stack_fit
$LN3@stack_fit:
$resize$10:

; 58   :     {
; 59   :         resize: {}
; 60   :         
; 61   :         u32 new_cap = (base != NULL && head->cap) ? head->cap * 2 : STACK_INITIAL_CAP;

  00062	48 83 7c 24 30
	00		 cmp	 QWORD PTR base$[rsp], 0
  00068	74 19		 je	 SHORT $LN8@stack_fit
  0006a	48 8b 44 24 38	 mov	 rax, QWORD PTR head$[rsp]
  0006f	83 38 00	 cmp	 DWORD PTR [rax], 0
  00072	74 0f		 je	 SHORT $LN8@stack_fit
  00074	48 8b 44 24 38	 mov	 rax, QWORD PTR head$[rsp]
  00079	8b 00		 mov	 eax, DWORD PTR [rax]
  0007b	d1 e0		 shl	 eax, 1
  0007d	89 44 24 28	 mov	 DWORD PTR tv75[rsp], eax
  00081	eb 08		 jmp	 SHORT $LN9@stack_fit
$LN8@stack_fit:
  00083	c7 44 24 28 10
	00 00 00	 mov	 DWORD PTR tv75[rsp], 16
$LN9@stack_fit:
  0008b	8b 44 24 28	 mov	 eax, DWORD PTR tv75[rsp]
  0008f	89 44 24 24	 mov	 DWORD PTR new_cap$1[rsp], eax

; 62   :         
; 63   :         if(new_count > new_cap)

  00093	8b 44 24 24	 mov	 eax, DWORD PTR new_cap$1[rsp]
  00097	39 44 24 20	 cmp	 DWORD PTR new_count$[rsp], eax
  0009b	76 08		 jbe	 SHORT $LN5@stack_fit

; 64   :             new_cap = new_count;

  0009d	8b 44 24 20	 mov	 eax, DWORD PTR new_count$[rsp]
  000a1	89 44 24 24	 mov	 DWORD PTR new_cap$1[rsp], eax
$LN5@stack_fit:

; 65   :         
; 66   :         if(!_stack_resize(&base, new_cap, item_size)) return NULL;

  000a5	44 8b 44 24 60	 mov	 r8d, DWORD PTR item_size$[rsp]
  000aa	8b 54 24 24	 mov	 edx, DWORD PTR new_cap$1[rsp]
  000ae	48 8d 4c 24 30	 lea	 rcx, QWORD PTR base$[rsp]
  000b3	e8 00 00 00 00	 call	 ?_stack_resize@@YAHPEAPEAXII@Z ; _stack_resize
  000b8	85 c0		 test	 eax, eax
  000ba	75 04		 jne	 SHORT $LN6@stack_fit
  000bc	33 c0		 xor	 eax, eax
  000be	eb 12		 jmp	 SHORT $LN1@stack_fit
$LN6@stack_fit:
$LN4@stack_fit:

; 67   :     }
; 68   :     
; 69   :     *base_ptr = base;

  000c0	48 8b 44 24 50	 mov	 rax, QWORD PTR base_ptr$[rsp]
  000c5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR base$[rsp]
  000ca	48 89 08	 mov	 QWORD PTR [rax], rcx

; 70   :     return base;

  000cd	48 8b 44 24 30	 mov	 rax, QWORD PTR base$[rsp]
$LN1@stack_fit:

; 71   : }

  000d2	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000d6	c3		 ret	 0
?_stack_fit@@YAPEAXPEAPEAXII@Z ENDP			; _stack_fit
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\src\stack.h
_TEXT	SEGMENT
was_uninitialized$ = 32
base$ = 40
tv68 = 48
tv74 = 52
head$ = 56
cap$ = 64
new_size$ = 68
tv90 = 72
size$ = 80
base_ptr$ = 112
new_cap$ = 120
item_size$ = 128
?_stack_resize@@YAHPEAPEAXII@Z PROC			; _stack_resize

; 22   : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 23   :     void *base = *base_ptr;

  00012	48 8b 44 24 70	 mov	 rax, QWORD PTR base_ptr$[rsp]
  00017	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001a	48 89 44 24 28	 mov	 QWORD PTR base$[rsp], rax

; 24   :     if(new_cap == 0) new_cap = STACK_INITIAL_CAP;

  0001f	83 7c 24 78 00	 cmp	 DWORD PTR new_cap$[rsp], 0
  00024	75 08		 jne	 SHORT $LN2@stack_resi
  00026	c7 44 24 78 10
	00 00 00	 mov	 DWORD PTR new_cap$[rsp], 16
$LN2@stack_resi:

; 25   :     u32 cap = get_stack_cap(base);

  0002e	48 83 7c 24 28
	00		 cmp	 QWORD PTR base$[rsp], 0
  00034	74 0e		 je	 SHORT $LN8@stack_resi
  00036	48 8b 44 24 28	 mov	 rax, QWORD PTR base$[rsp]
  0003b	8b 40 f8	 mov	 eax, DWORD PTR [rax-8]
  0003e	89 44 24 30	 mov	 DWORD PTR tv68[rsp], eax
  00042	eb 08		 jmp	 SHORT $LN9@stack_resi
$LN8@stack_resi:
  00044	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
$LN9@stack_resi:
  0004c	8b 44 24 30	 mov	 eax, DWORD PTR tv68[rsp]
  00050	89 44 24 40	 mov	 DWORD PTR cap$[rsp], eax

; 26   :     if(new_cap == cap) return 1;

  00054	8b 44 24 40	 mov	 eax, DWORD PTR cap$[rsp]
  00058	39 44 24 78	 cmp	 DWORD PTR new_cap$[rsp], eax
  0005c	75 0a		 jne	 SHORT $LN3@stack_resi
  0005e	b8 01 00 00 00	 mov	 eax, 1
  00063	e9 d5 00 00 00	 jmp	 $LN1@stack_resi
$LN3@stack_resi:

; 27   :     
; 28   :     u32 size = _get_stack_size(base, item_size)+sizeof(stack_header_t);

  00068	48 83 7c 24 28
	00		 cmp	 QWORD PTR base$[rsp], 0
  0006e	74 16		 je	 SHORT $LN10@stack_resi
  00070	48 8b 44 24 28	 mov	 rax, QWORD PTR base$[rsp]
  00075	8b 40 fc	 mov	 eax, DWORD PTR [rax-4]
  00078	0f af 84 24 80
	00 00 00	 imul	 eax, DWORD PTR item_size$[rsp]
  00080	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
  00084	eb 08		 jmp	 SHORT $LN11@stack_resi
$LN10@stack_resi:
  00086	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN11@stack_resi:
  0008e	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]
  00092	48 83 c0 08	 add	 rax, 8
  00096	89 44 24 50	 mov	 DWORD PTR size$[rsp], eax

; 29   :     u32 new_size = item_size*new_cap+sizeof(stack_header_t);

  0009a	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR item_size$[rsp]
  000a1	0f af 44 24 78	 imul	 eax, DWORD PTR new_cap$[rsp]
  000a6	8b c0		 mov	 eax, eax
  000a8	48 83 c0 08	 add	 rax, 8
  000ac	89 44 24 44	 mov	 DWORD PTR new_size$[rsp], eax

; 30   :     
; 31   :     u32 was_uninitialized = 0;

  000b0	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR was_uninitialized$[rsp], 0

; 32   :     if(base == NULL) was_uninitialized = 1;

  000b8	48 83 7c 24 28
	00		 cmp	 QWORD PTR base$[rsp], 0
  000be	75 08		 jne	 SHORT $LN4@stack_resi
  000c0	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR was_uninitialized$[rsp], 1
$LN4@stack_resi:

; 33   :     
; 34   :     stack_header_t *head = (stack_header_t *)realloc(was_uninitialized ? NULL : get_stack_header(base), new_size);

  000c8	83 7c 24 20 00	 cmp	 DWORD PTR was_uninitialized$[rsp], 0
  000cd	74 0b		 je	 SHORT $LN12@stack_resi
  000cf	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR tv90[rsp], 0
  000d8	eb 0e		 jmp	 SHORT $LN13@stack_resi
$LN12@stack_resi:
  000da	48 8b 44 24 28	 mov	 rax, QWORD PTR base$[rsp]
  000df	48 83 e8 08	 sub	 rax, 8
  000e3	48 89 44 24 48	 mov	 QWORD PTR tv90[rsp], rax
$LN13@stack_resi:
  000e8	8b 44 24 44	 mov	 eax, DWORD PTR new_size$[rsp]
  000ec	8b d0		 mov	 edx, eax
  000ee	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv90[rsp]
  000f3	e8 00 00 00 00	 call	 realloc
  000f8	48 89 44 24 38	 mov	 QWORD PTR head$[rsp], rax

; 35   :     if(head == NULL) return 0;

  000fd	48 83 7c 24 38
	00		 cmp	 QWORD PTR head$[rsp], 0
  00103	75 04		 jne	 SHORT $LN5@stack_resi
  00105	33 c0		 xor	 eax, eax
  00107	eb 34		 jmp	 SHORT $LN1@stack_resi
$LN5@stack_resi:

; 36   :     
; 37   :     head->cap = new_cap;

  00109	48 8b 44 24 38	 mov	 rax, QWORD PTR head$[rsp]
  0010e	8b 4c 24 78	 mov	 ecx, DWORD PTR new_cap$[rsp]
  00112	89 08		 mov	 DWORD PTR [rax], ecx

; 38   :     if(was_uninitialized) { head->count = 0; };

  00114	83 7c 24 20 00	 cmp	 DWORD PTR was_uninitialized$[rsp], 0
  00119	74 0c		 je	 SHORT $LN6@stack_resi
  0011b	48 8b 44 24 38	 mov	 rax, QWORD PTR head$[rsp]
  00120	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0
$LN6@stack_resi:

; 39   :     
; 40   :     *base_ptr = (void *)((u8 *)head + sizeof(*head));

  00127	48 8b 44 24 38	 mov	 rax, QWORD PTR head$[rsp]
  0012c	48 83 c0 08	 add	 rax, 8
  00130	48 8b 4c 24 70	 mov	 rcx, QWORD PTR base_ptr$[rsp]
  00135	48 89 01	 mov	 QWORD PTR [rcx], rax

; 41   :     
; 42   :     return 1;

  00138	b8 01 00 00 00	 mov	 eax, 1
$LN1@stack_resi:

; 43   : }

  0013d	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00141	c3		 ret	 0
?_stack_resize@@YAHPEAPEAXII@Z ENDP			; _stack_resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath
;	COMDAT ?sin@@YAMM@Z
_TEXT	SEGMENT
_Xx$ = 48
?sin@@YAMM@Z PROC					; sin, COMDAT

; 222  : _NODISCARD _Check_return_ inline float sin(_In_ float _Xx) noexcept /* strengthened */ {

$LN3:
  00000	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00006	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 223  :     return _CSTD sinf(_Xx);

  0000a	f3 0f 10 44 24
	30		 movss	 xmm0, DWORD PTR _Xx$[rsp]
  00010	e8 00 00 00 00	 call	 sinf

; 224  : }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
?sin@@YAMM@Z ENDP					; sin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath
;	COMDAT ?pow@@YAMMM@Z
_TEXT	SEGMENT
_Xx$ = 48
_Yx$ = 56
?pow@@YAMMM@Z PROC					; pow, COMDAT

; 194  : _NODISCARD _Check_return_ inline float pow(_In_ float _Xx, _In_ float _Yx) noexcept /* strengthened */ {

$LN3:
  00000	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00006	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 195  :     return _CSTD powf(_Xx, _Yx);

  00010	f3 0f 10 4c 24
	38		 movss	 xmm1, DWORD PTR _Yx$[rsp]
  00016	f3 0f 10 44 24
	30		 movss	 xmm0, DWORD PTR _Xx$[rsp]
  0001c	e8 00 00 00 00	 call	 powf

; 196  : }

  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	c3		 ret	 0
?pow@@YAMMM@Z ENDP					; pow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath
;	COMDAT ?ldexp@@YAMMH@Z
_TEXT	SEGMENT
_Xx$ = 48
_Yx$ = 56
?ldexp@@YAMMH@Z PROC					; ldexp, COMDAT

; 134  : _NODISCARD _Check_return_ inline float ldexp(_In_ float _Xx, _In_ int _Yx) noexcept /* strengthened */ {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 135  :     return _CSTD ldexpf(_Xx, _Yx);

  0000e	8b 54 24 38	 mov	 edx, DWORD PTR _Yx$[rsp]
  00012	f3 0f 10 44 24
	30		 movss	 xmm0, DWORD PTR _Xx$[rsp]
  00018	e8 00 00 00 00	 call	 ldexpf

; 136  : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
?ldexp@@YAMMH@Z ENDP					; ldexp
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath
;	COMDAT ?cos@@YAMM@Z
_TEXT	SEGMENT
_Xx$ = 48
?cos@@YAMM@Z PROC					; cos, COMDAT

; 66   : _NODISCARD _Check_return_ inline float cos(_In_ float _Xx) noexcept /* strengthened */ {

$LN3:
  00000	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00006	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 67   :     return _CSTD cosf(_Xx);

  0000a	f3 0f 10 44 24
	30		 movss	 xmm0, DWORD PTR _Xx$[rsp]
  00010	e8 00 00 00 00	 call	 cosf

; 68   : }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
?cos@@YAMM@Z ENDP					; cos
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sprintf	PROC						; COMDAT

; 1781 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1782 :         int _Result;
; 1783 :         va_list _ArgList;
; 1784 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 1785 : 
; 1786 :         #pragma warning(push)
; 1787 :         #pragma warning(disable: 4996) // Deprecation
; 1788 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsprintf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 1789 :         #pragma warning(pop)
; 1790 : 
; 1791 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 1792 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 1793 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1459 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1460 :         #pragma warning(push)
; 1461 :         #pragma warning(disable: 4996) // Deprecation
; 1462 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  00027	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  0002c	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00038	e8 00 00 00 00	 call	 _vsnprintf_l

; 1463 :         #pragma warning(pop)
; 1464 :     }

  0003d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00041	c3		 ret	 0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1389 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00020	48 83 c8 01	 or	 rax, 1
  00024	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00029	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0002e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00033	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00038	4c 8b 4c 24 60	 mov	 r9, QWORD PTR _Format$[rsp]
  0003d	4c 8b 44 24 58	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00042	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00047	48 8b c8	 mov	 rcx, rax
  0004a	e8 00 00 00 00	 call	 __stdio_common_vsprintf
  0004f	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  00053	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00058	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  0005a	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00062	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00064	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  00068	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  0006c	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1395 :     }

  00070	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00074	c3		 ret	 0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT fprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Stream$ = 64
_Format$ = 72
fprintf	PROC						; COMDAT

; 835  :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Stream$[rsp]
  00034	e8 00 00 00 00	 call	 _vfprintf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 840  :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 841  :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 842  :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
fprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 642  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00031	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	e8 00 00 00 00	 call	 __stdio_common_vfprintf

; 644  :     }

  0003e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00042	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\HandmadeMath.h
_TEXT	SEGMENT
$T1 = 48
$T2 = 64
$T3 = 80
$T4 = 96
$T5 = 112
$T6 = 128
$T7 = 144
$T8 = 160
$T9 = 176
$T10 = 192
$T11 = 208
$T12 = 224
$T13 = 240
$T14 = 256
$T15 = 272
$T16 = 288
$T17 = 304
$T18 = 320
F$ = 384
S$ = 400
$T19 = 416
$T20 = 432
$T21 = 448
$T22 = 464
$T23 = 480
U$ = 496
$T24 = 512
__$ArrayPad$ = 576
$T25 = 624
Eye$ = 632
Center$ = 640
Up$ = 648
HMM_LookAt_RH PROC

; 2043 :     {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 58 02
	00 00		 sub	 rsp, 600		; 00000258H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2044 :         ASSERT_COVERED(HMM_LookAt_RH);
; 2045 :         
; 2046 :         HMM_Vec3 F = HMM_NormV3(HMM_SubV3(Center, Eye));

  0002f	48 8d 44 24 30	 lea	 rax, QWORD PTR $T1[rsp]
  00034	48 8b f8	 mov	 rdi, rax
  00037	48 8b b4 24 78
	02 00 00	 mov	 rsi, QWORD PTR Eye$[rsp]
  0003f	b9 0c 00 00 00	 mov	 ecx, 12
  00044	f3 a4		 rep movsb
  00046	48 8d 44 24 40	 lea	 rax, QWORD PTR $T2[rsp]
  0004b	48 8b f8	 mov	 rdi, rax
  0004e	48 8b b4 24 80
	02 00 00	 mov	 rsi, QWORD PTR Center$[rsp]
  00056	b9 0c 00 00 00	 mov	 ecx, 12
  0005b	f3 a4		 rep movsb
  0005d	4c 8d 44 24 30	 lea	 r8, QWORD PTR $T1[rsp]
  00062	48 8d 54 24 40	 lea	 rdx, QWORD PTR $T2[rsp]
  00067	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR $T13[rsp]
  0006f	e8 00 00 00 00	 call	 HMM_SubV3
  00074	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR $T19[rsp]
  0007c	48 8b f9	 mov	 rdi, rcx
  0007f	48 8b f0	 mov	 rsi, rax
  00082	b9 0c 00 00 00	 mov	 ecx, 12
  00087	f3 a4		 rep movsb
  00089	48 8d 44 24 50	 lea	 rax, QWORD PTR $T3[rsp]
  0008e	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR $T19[rsp]
  00096	48 8b f8	 mov	 rdi, rax
  00099	48 8b f1	 mov	 rsi, rcx
  0009c	b9 0c 00 00 00	 mov	 ecx, 12
  000a1	f3 a4		 rep movsb
  000a3	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T3[rsp]
  000a8	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR $T14[rsp]
  000b0	e8 00 00 00 00	 call	 HMM_NormV3
  000b5	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR $T20[rsp]
  000bd	48 8b f9	 mov	 rdi, rcx
  000c0	48 8b f0	 mov	 rsi, rax
  000c3	b9 0c 00 00 00	 mov	 ecx, 12
  000c8	f3 a4		 rep movsb
  000ca	48 8d 84 24 80
	01 00 00	 lea	 rax, QWORD PTR F$[rsp]
  000d2	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR $T20[rsp]
  000da	48 8b f8	 mov	 rdi, rax
  000dd	48 8b f1	 mov	 rsi, rcx
  000e0	b9 0c 00 00 00	 mov	 ecx, 12
  000e5	f3 a4		 rep movsb

; 2047 :         HMM_Vec3 S = HMM_NormV3(HMM_Cross(F, Up));

  000e7	48 8d 44 24 60	 lea	 rax, QWORD PTR $T4[rsp]
  000ec	48 8b f8	 mov	 rdi, rax
  000ef	48 8b b4 24 88
	02 00 00	 mov	 rsi, QWORD PTR Up$[rsp]
  000f7	b9 0c 00 00 00	 mov	 ecx, 12
  000fc	f3 a4		 rep movsb
  000fe	48 8d 44 24 70	 lea	 rax, QWORD PTR $T5[rsp]
  00103	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR F$[rsp]
  0010b	48 8b f8	 mov	 rdi, rax
  0010e	48 8b f1	 mov	 rsi, rcx
  00111	b9 0c 00 00 00	 mov	 ecx, 12
  00116	f3 a4		 rep movsb
  00118	4c 8d 44 24 60	 lea	 r8, QWORD PTR $T4[rsp]
  0011d	48 8d 54 24 70	 lea	 rdx, QWORD PTR $T5[rsp]
  00122	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR $T15[rsp]
  0012a	e8 00 00 00 00	 call	 HMM_Cross
  0012f	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR $T21[rsp]
  00137	48 8b f9	 mov	 rdi, rcx
  0013a	48 8b f0	 mov	 rsi, rax
  0013d	b9 0c 00 00 00	 mov	 ecx, 12
  00142	f3 a4		 rep movsb
  00144	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR $T6[rsp]
  0014c	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR $T21[rsp]
  00154	48 8b f8	 mov	 rdi, rax
  00157	48 8b f1	 mov	 rsi, rcx
  0015a	b9 0c 00 00 00	 mov	 ecx, 12
  0015f	f3 a4		 rep movsb
  00161	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR $T6[rsp]
  00169	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR $T16[rsp]
  00171	e8 00 00 00 00	 call	 HMM_NormV3
  00176	48 8d 8c 24 d0
	01 00 00	 lea	 rcx, QWORD PTR $T22[rsp]
  0017e	48 8b f9	 mov	 rdi, rcx
  00181	48 8b f0	 mov	 rsi, rax
  00184	b9 0c 00 00 00	 mov	 ecx, 12
  00189	f3 a4		 rep movsb
  0018b	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR S$[rsp]
  00193	48 8d 8c 24 d0
	01 00 00	 lea	 rcx, QWORD PTR $T22[rsp]
  0019b	48 8b f8	 mov	 rdi, rax
  0019e	48 8b f1	 mov	 rsi, rcx
  001a1	b9 0c 00 00 00	 mov	 ecx, 12
  001a6	f3 a4		 rep movsb

; 2048 :         HMM_Vec3 U = HMM_Cross(S, F);

  001a8	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR $T7[rsp]
  001b0	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR F$[rsp]
  001b8	48 8b f8	 mov	 rdi, rax
  001bb	48 8b f1	 mov	 rsi, rcx
  001be	b9 0c 00 00 00	 mov	 ecx, 12
  001c3	f3 a4		 rep movsb
  001c5	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR $T8[rsp]
  001cd	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR S$[rsp]
  001d5	48 8b f8	 mov	 rdi, rax
  001d8	48 8b f1	 mov	 rsi, rcx
  001db	b9 0c 00 00 00	 mov	 ecx, 12
  001e0	f3 a4		 rep movsb
  001e2	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR $T7[rsp]
  001ea	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR $T8[rsp]
  001f2	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR $T17[rsp]
  001fa	e8 00 00 00 00	 call	 HMM_Cross
  001ff	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR $T23[rsp]
  00207	48 8b f9	 mov	 rdi, rcx
  0020a	48 8b f0	 mov	 rsi, rax
  0020d	b9 0c 00 00 00	 mov	 ecx, 12
  00212	f3 a4		 rep movsb
  00214	48 8d 84 24 f0
	01 00 00	 lea	 rax, QWORD PTR U$[rsp]
  0021c	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR $T23[rsp]
  00224	48 8b f8	 mov	 rdi, rax
  00227	48 8b f1	 mov	 rsi, rcx
  0022a	b9 0c 00 00 00	 mov	 ecx, 12
  0022f	f3 a4		 rep movsb

; 2049 :         
; 2050 :         return _HMM_LookAt(F, S, U, Eye);

  00231	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR $T9[rsp]
  00239	48 8b f8	 mov	 rdi, rax
  0023c	48 8b b4 24 78
	02 00 00	 mov	 rsi, QWORD PTR Eye$[rsp]
  00244	b9 0c 00 00 00	 mov	 ecx, 12
  00249	f3 a4		 rep movsb
  0024b	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR $T10[rsp]
  00253	48 8d 8c 24 f0
	01 00 00	 lea	 rcx, QWORD PTR U$[rsp]
  0025b	48 8b f8	 mov	 rdi, rax
  0025e	48 8b f1	 mov	 rsi, rcx
  00261	b9 0c 00 00 00	 mov	 ecx, 12
  00266	f3 a4		 rep movsb
  00268	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR $T11[rsp]
  00270	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR S$[rsp]
  00278	48 8b f8	 mov	 rdi, rax
  0027b	48 8b f1	 mov	 rsi, rcx
  0027e	b9 0c 00 00 00	 mov	 ecx, 12
  00283	f3 a4		 rep movsb
  00285	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR $T12[rsp]
  0028d	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR F$[rsp]
  00295	48 8b f8	 mov	 rdi, rax
  00298	48 8b f1	 mov	 rsi, rcx
  0029b	b9 0c 00 00 00	 mov	 ecx, 12
  002a0	f3 a4		 rep movsb
  002a2	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR $T9[rsp]
  002aa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002af	4c 8d 8c 24 c0
	00 00 00	 lea	 r9, QWORD PTR $T10[rsp]
  002b7	4c 8d 84 24 d0
	00 00 00	 lea	 r8, QWORD PTR $T11[rsp]
  002bf	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR $T12[rsp]
  002c7	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR $T18[rsp]
  002cf	e8 00 00 00 00	 call	 _HMM_LookAt
  002d4	48 8d 8c 24 00
	02 00 00	 lea	 rcx, QWORD PTR $T24[rsp]
  002dc	48 8b f9	 mov	 rdi, rcx
  002df	48 8b f0	 mov	 rsi, rax
  002e2	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  002e7	f3 a4		 rep movsb
  002e9	48 8d 84 24 00
	02 00 00	 lea	 rax, QWORD PTR $T24[rsp]
  002f1	48 8b bc 24 70
	02 00 00	 mov	 rdi, QWORD PTR $T25[rsp]
  002f9	48 8b f0	 mov	 rsi, rax
  002fc	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00301	f3 a4		 rep movsb
  00303	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR $T25[rsp]

; 2051 :     }

  0030b	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00313	48 33 cc	 xor	 rcx, rsp
  00316	e8 00 00 00 00	 call	 __security_check_cookie
  0031b	48 81 c4 58 02
	00 00		 add	 rsp, 600		; 00000258H
  00322	5f		 pop	 rdi
  00323	5e		 pop	 rsi
  00324	c3		 ret	 0
HMM_LookAt_RH ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\HandmadeMath.h
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
$T3 = 64
$T4 = 80
$T5 = 96
$T6 = 112
Result$ = 128
__$ArrayPad$ = 192
$T7 = 240
F$ = 248
S$ = 256
U$ = 264
Eye$ = 272
_HMM_LookAt PROC

; 2015 :     {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2016 :         HMM_Mat4 Result;
; 2017 :         
; 2018 :         Result.Elements[0][0] = S.X;

  0002f	b8 10 00 00 00	 mov	 eax, 16
  00034	48 6b c0 00	 imul	 rax, rax, 0
  00038	48 8d 84 04 80
	00 00 00	 lea	 rax, QWORD PTR Result$[rsp+rax]
  00040	b9 04 00 00 00	 mov	 ecx, 4
  00045	48 6b c9 00	 imul	 rcx, rcx, 0
  00049	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR S$[rsp]
  00051	f3 0f 10 02	 movss	 xmm0, DWORD PTR [rdx]
  00055	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 2019 :         Result.Elements[0][1] = U.X;

  0005a	b8 10 00 00 00	 mov	 eax, 16
  0005f	48 6b c0 00	 imul	 rax, rax, 0
  00063	48 8d 84 04 80
	00 00 00	 lea	 rax, QWORD PTR Result$[rsp+rax]
  0006b	b9 04 00 00 00	 mov	 ecx, 4
  00070	48 6b c9 01	 imul	 rcx, rcx, 1
  00074	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR U$[rsp]
  0007c	f3 0f 10 02	 movss	 xmm0, DWORD PTR [rdx]
  00080	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 2020 :         Result.Elements[0][2] = -F.X;

  00085	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR F$[rsp]
  0008d	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00091	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00098	b8 10 00 00 00	 mov	 eax, 16
  0009d	48 6b c0 00	 imul	 rax, rax, 0
  000a1	48 8d 84 04 80
	00 00 00	 lea	 rax, QWORD PTR Result$[rsp+rax]
  000a9	b9 04 00 00 00	 mov	 ecx, 4
  000ae	48 6b c9 02	 imul	 rcx, rcx, 2
  000b2	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 2021 :         Result.Elements[0][3] = 0.0f;

  000b7	b8 10 00 00 00	 mov	 eax, 16
  000bc	48 6b c0 00	 imul	 rax, rax, 0
  000c0	48 8d 84 04 80
	00 00 00	 lea	 rax, QWORD PTR Result$[rsp+rax]
  000c8	b9 04 00 00 00	 mov	 ecx, 4
  000cd	48 6b c9 03	 imul	 rcx, rcx, 3
  000d1	0f 57 c0	 xorps	 xmm0, xmm0
  000d4	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 2022 :         
; 2023 :         Result.Elements[1][0] = S.Y;

  000d9	b8 10 00 00 00	 mov	 eax, 16
  000de	48 6b c0 01	 imul	 rax, rax, 1
  000e2	48 8d 84 04 80
	00 00 00	 lea	 rax, QWORD PTR Result$[rsp+rax]
  000ea	b9 04 00 00 00	 mov	 ecx, 4
  000ef	48 6b c9 00	 imul	 rcx, rcx, 0
  000f3	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR S$[rsp]
  000fb	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [rdx+4]
  00100	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 2024 :         Result.Elements[1][1] = U.Y;

  00105	b8 10 00 00 00	 mov	 eax, 16
  0010a	48 6b c0 01	 imul	 rax, rax, 1
  0010e	48 8d 84 04 80
	00 00 00	 lea	 rax, QWORD PTR Result$[rsp+rax]
  00116	b9 04 00 00 00	 mov	 ecx, 4
  0011b	48 6b c9 01	 imul	 rcx, rcx, 1
  0011f	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR U$[rsp]
  00127	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [rdx+4]
  0012c	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 2025 :         Result.Elements[1][2] = -F.Y;

  00131	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR F$[rsp]
  00139	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  0013e	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00145	b8 10 00 00 00	 mov	 eax, 16
  0014a	48 6b c0 01	 imul	 rax, rax, 1
  0014e	48 8d 84 04 80
	00 00 00	 lea	 rax, QWORD PTR Result$[rsp+rax]
  00156	b9 04 00 00 00	 mov	 ecx, 4
  0015b	48 6b c9 02	 imul	 rcx, rcx, 2
  0015f	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 2026 :         Result.Elements[1][3] = 0.0f;

  00164	b8 10 00 00 00	 mov	 eax, 16
  00169	48 6b c0 01	 imul	 rax, rax, 1
  0016d	48 8d 84 04 80
	00 00 00	 lea	 rax, QWORD PTR Result$[rsp+rax]
  00175	b9 04 00 00 00	 mov	 ecx, 4
  0017a	48 6b c9 03	 imul	 rcx, rcx, 3
  0017e	0f 57 c0	 xorps	 xmm0, xmm0
  00181	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 2027 :         
; 2028 :         Result.Elements[2][0] = S.Z;

  00186	b8 10 00 00 00	 mov	 eax, 16
  0018b	48 6b c0 02	 imul	 rax, rax, 2
  0018f	48 8d 84 04 80
	00 00 00	 lea	 rax, QWORD PTR Result$[rsp+rax]
  00197	b9 04 00 00 00	 mov	 ecx, 4
  0019c	48 6b c9 00	 imul	 rcx, rcx, 0
  001a0	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR S$[rsp]
  001a8	f3 0f 10 42 08	 movss	 xmm0, DWORD PTR [rdx+8]
  001ad	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 2029 :         Result.Elements[2][1] = U.Z;

  001b2	b8 10 00 00 00	 mov	 eax, 16
  001b7	48 6b c0 02	 imul	 rax, rax, 2
  001bb	48 8d 84 04 80
	00 00 00	 lea	 rax, QWORD PTR Result$[rsp+rax]
  001c3	b9 04 00 00 00	 mov	 ecx, 4
  001c8	48 6b c9 01	 imul	 rcx, rcx, 1
  001cc	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR U$[rsp]
  001d4	f3 0f 10 42 08	 movss	 xmm0, DWORD PTR [rdx+8]
  001d9	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 2030 :         Result.Elements[2][2] = -F.Z;

  001de	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR F$[rsp]
  001e6	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  001eb	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  001f2	b8 10 00 00 00	 mov	 eax, 16
  001f7	48 6b c0 02	 imul	 rax, rax, 2
  001fb	48 8d 84 04 80
	00 00 00	 lea	 rax, QWORD PTR Result$[rsp+rax]
  00203	b9 04 00 00 00	 mov	 ecx, 4
  00208	48 6b c9 02	 imul	 rcx, rcx, 2
  0020c	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 2031 :         Result.Elements[2][3] = 0.0f;

  00211	b8 10 00 00 00	 mov	 eax, 16
  00216	48 6b c0 02	 imul	 rax, rax, 2
  0021a	48 8d 84 04 80
	00 00 00	 lea	 rax, QWORD PTR Result$[rsp+rax]
  00222	b9 04 00 00 00	 mov	 ecx, 4
  00227	48 6b c9 03	 imul	 rcx, rcx, 3
  0022b	0f 57 c0	 xorps	 xmm0, xmm0
  0022e	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 2032 :         
; 2033 :         Result.Elements[3][0] = -HMM_DotV3(S, Eye);

  00233	48 8d 44 24 20	 lea	 rax, QWORD PTR $T1[rsp]
  00238	48 8b f8	 mov	 rdi, rax
  0023b	48 8b b4 24 10
	01 00 00	 mov	 rsi, QWORD PTR Eye$[rsp]
  00243	b9 0c 00 00 00	 mov	 ecx, 12
  00248	f3 a4		 rep movsb
  0024a	48 8d 44 24 30	 lea	 rax, QWORD PTR $T2[rsp]
  0024f	48 8b f8	 mov	 rdi, rax
  00252	48 8b b4 24 00
	01 00 00	 mov	 rsi, QWORD PTR S$[rsp]
  0025a	b9 0c 00 00 00	 mov	 ecx, 12
  0025f	f3 a4		 rep movsb
  00261	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  00266	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T2[rsp]
  0026b	e8 00 00 00 00	 call	 HMM_DotV3
  00270	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00277	b8 10 00 00 00	 mov	 eax, 16
  0027c	48 6b c0 03	 imul	 rax, rax, 3
  00280	48 8d 84 04 80
	00 00 00	 lea	 rax, QWORD PTR Result$[rsp+rax]
  00288	b9 04 00 00 00	 mov	 ecx, 4
  0028d	48 6b c9 00	 imul	 rcx, rcx, 0
  00291	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 2034 :         Result.Elements[3][1] = -HMM_DotV3(U, Eye);

  00296	48 8d 44 24 40	 lea	 rax, QWORD PTR $T3[rsp]
  0029b	48 8b f8	 mov	 rdi, rax
  0029e	48 8b b4 24 10
	01 00 00	 mov	 rsi, QWORD PTR Eye$[rsp]
  002a6	b9 0c 00 00 00	 mov	 ecx, 12
  002ab	f3 a4		 rep movsb
  002ad	48 8d 44 24 50	 lea	 rax, QWORD PTR $T4[rsp]
  002b2	48 8b f8	 mov	 rdi, rax
  002b5	48 8b b4 24 08
	01 00 00	 mov	 rsi, QWORD PTR U$[rsp]
  002bd	b9 0c 00 00 00	 mov	 ecx, 12
  002c2	f3 a4		 rep movsb
  002c4	48 8d 54 24 40	 lea	 rdx, QWORD PTR $T3[rsp]
  002c9	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T4[rsp]
  002ce	e8 00 00 00 00	 call	 HMM_DotV3
  002d3	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  002da	b8 10 00 00 00	 mov	 eax, 16
  002df	48 6b c0 03	 imul	 rax, rax, 3
  002e3	48 8d 84 04 80
	00 00 00	 lea	 rax, QWORD PTR Result$[rsp+rax]
  002eb	b9 04 00 00 00	 mov	 ecx, 4
  002f0	48 6b c9 01	 imul	 rcx, rcx, 1
  002f4	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 2035 :         Result.Elements[3][2] = HMM_DotV3(F, Eye);

  002f9	48 8d 44 24 60	 lea	 rax, QWORD PTR $T5[rsp]
  002fe	48 8b f8	 mov	 rdi, rax
  00301	48 8b b4 24 10
	01 00 00	 mov	 rsi, QWORD PTR Eye$[rsp]
  00309	b9 0c 00 00 00	 mov	 ecx, 12
  0030e	f3 a4		 rep movsb
  00310	48 8d 44 24 70	 lea	 rax, QWORD PTR $T6[rsp]
  00315	48 8b f8	 mov	 rdi, rax
  00318	48 8b b4 24 f8
	00 00 00	 mov	 rsi, QWORD PTR F$[rsp]
  00320	b9 0c 00 00 00	 mov	 ecx, 12
  00325	f3 a4		 rep movsb
  00327	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T5[rsp]
  0032c	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T6[rsp]
  00331	e8 00 00 00 00	 call	 HMM_DotV3
  00336	b8 10 00 00 00	 mov	 eax, 16
  0033b	48 6b c0 03	 imul	 rax, rax, 3
  0033f	48 8d 84 04 80
	00 00 00	 lea	 rax, QWORD PTR Result$[rsp+rax]
  00347	b9 04 00 00 00	 mov	 ecx, 4
  0034c	48 6b c9 02	 imul	 rcx, rcx, 2
  00350	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 2036 :         Result.Elements[3][3] = 1.0f;

  00355	b8 10 00 00 00	 mov	 eax, 16
  0035a	48 6b c0 03	 imul	 rax, rax, 3
  0035e	48 8d 84 04 80
	00 00 00	 lea	 rax, QWORD PTR Result$[rsp+rax]
  00366	b9 04 00 00 00	 mov	 ecx, 4
  0036b	48 6b c9 03	 imul	 rcx, rcx, 3
  0036f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00377	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 2037 :         
; 2038 :         return Result;

  0037c	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR Result$[rsp]
  00384	48 8b bc 24 f0
	00 00 00	 mov	 rdi, QWORD PTR $T7[rsp]
  0038c	48 8b f0	 mov	 rsi, rax
  0038f	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00394	f3 a4		 rep movsb
  00396	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR $T7[rsp]

; 2039 :     }

  0039e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003a6	48 33 cc	 xor	 rcx, rsp
  003a9	e8 00 00 00 00	 call	 __security_check_cookie
  003ae	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  003b5	5f		 pop	 rdi
  003b6	5e		 pop	 rsi
  003b7	c3		 ret	 0
_HMM_LookAt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\HandmadeMath.h
_TEXT	SEGMENT
$T1 = 32
Result$ = 96
$T2 = 160
__$ArrayPad$ = 224
$T3 = 272
Scale$ = 280
HMM_Scale PROC

; 1990 :     {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1991 :         ASSERT_COVERED(HMM_Scale);
; 1992 :         
; 1993 :         HMM_Mat4 Result = HMM_M4D(1.0f);

  00025	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  0002d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  00032	e8 00 00 00 00	 call	 HMM_M4D
  00037	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR $T2[rsp]
  0003f	48 8b f9	 mov	 rdi, rcx
  00042	48 8b f0	 mov	 rsi, rax
  00045	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0004a	f3 a4		 rep movsb
  0004c	48 8d 44 24 60	 lea	 rax, QWORD PTR Result$[rsp]
  00051	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR $T2[rsp]
  00059	48 8b f8	 mov	 rdi, rax
  0005c	48 8b f1	 mov	 rsi, rcx
  0005f	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00064	f3 a4		 rep movsb

; 1994 :         Result.Elements[0][0] = Scale.X;

  00066	b8 10 00 00 00	 mov	 eax, 16
  0006b	48 6b c0 00	 imul	 rax, rax, 0
  0006f	48 8d 44 04 60	 lea	 rax, QWORD PTR Result$[rsp+rax]
  00074	b9 04 00 00 00	 mov	 ecx, 4
  00079	48 6b c9 00	 imul	 rcx, rcx, 0
  0007d	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR Scale$[rsp]
  00085	f3 0f 10 02	 movss	 xmm0, DWORD PTR [rdx]
  00089	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 1995 :         Result.Elements[1][1] = Scale.Y;

  0008e	b8 10 00 00 00	 mov	 eax, 16
  00093	48 6b c0 01	 imul	 rax, rax, 1
  00097	48 8d 44 04 60	 lea	 rax, QWORD PTR Result$[rsp+rax]
  0009c	b9 04 00 00 00	 mov	 ecx, 4
  000a1	48 6b c9 01	 imul	 rcx, rcx, 1
  000a5	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR Scale$[rsp]
  000ad	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [rdx+4]
  000b2	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 1996 :         Result.Elements[2][2] = Scale.Z;

  000b7	b8 10 00 00 00	 mov	 eax, 16
  000bc	48 6b c0 02	 imul	 rax, rax, 2
  000c0	48 8d 44 04 60	 lea	 rax, QWORD PTR Result$[rsp+rax]
  000c5	b9 04 00 00 00	 mov	 ecx, 4
  000ca	48 6b c9 02	 imul	 rcx, rcx, 2
  000ce	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR Scale$[rsp]
  000d6	f3 0f 10 42 08	 movss	 xmm0, DWORD PTR [rdx+8]
  000db	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 1997 :         
; 1998 :         return Result;

  000e0	48 8d 44 24 60	 lea	 rax, QWORD PTR Result$[rsp]
  000e5	48 8b bc 24 10
	01 00 00	 mov	 rdi, QWORD PTR $T3[rsp]
  000ed	48 8b f0	 mov	 rsi, rax
  000f0	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000f5	f3 a4		 rep movsb
  000f7	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR $T3[rsp]

; 1999 :     }

  000ff	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00107	48 33 cc	 xor	 rcx, rsp
  0010a	e8 00 00 00 00	 call	 __security_check_cookie
  0010f	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  00116	5f		 pop	 rdi
  00117	5e		 pop	 rsi
  00118	c3		 ret	 0
HMM_Scale ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\HandmadeMath.h
_TEXT	SEGMENT
CosValue$ = 32
SinTheta$ = 36
CosTheta$ = 40
$T1 = 48
$T2 = 64
$T3 = 80
Result$ = 144
$T4 = 208
$T5 = 224
__$ArrayPad$ = 288
$T6 = 336
Angle$ = 344
Axis$ = 352
HMM_Rotate_RH PROC

; 1947 :     {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1948 :         ASSERT_COVERED(HMM_Rotate_RH);
; 1949 :         
; 1950 :         HMM_Mat4 Result = HMM_M4D(1.0f);

  0002b	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00033	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T3[rsp]
  00038	e8 00 00 00 00	 call	 HMM_M4D
  0003d	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR $T5[rsp]
  00045	48 8b f9	 mov	 rdi, rcx
  00048	48 8b f0	 mov	 rsi, rax
  0004b	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00050	f3 a4		 rep movsb
  00052	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR Result$[rsp]
  0005a	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR $T5[rsp]
  00062	48 8b f8	 mov	 rdi, rax
  00065	48 8b f1	 mov	 rsi, rcx
  00068	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0006d	f3 a4		 rep movsb

; 1951 :         
; 1952 :         Axis = HMM_NormV3(Axis);

  0006f	48 8d 44 24 30	 lea	 rax, QWORD PTR $T1[rsp]
  00074	48 8b f8	 mov	 rdi, rax
  00077	48 8b b4 24 60
	01 00 00	 mov	 rsi, QWORD PTR Axis$[rsp]
  0007f	b9 0c 00 00 00	 mov	 ecx, 12
  00084	f3 a4		 rep movsb
  00086	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T1[rsp]
  0008b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR $T2[rsp]
  00090	e8 00 00 00 00	 call	 HMM_NormV3
  00095	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR $T4[rsp]
  0009d	48 8b f9	 mov	 rdi, rcx
  000a0	48 8b f0	 mov	 rsi, rax
  000a3	b9 0c 00 00 00	 mov	 ecx, 12
  000a8	f3 a4		 rep movsb
  000aa	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR $T4[rsp]
  000b2	48 8b bc 24 60
	01 00 00	 mov	 rdi, QWORD PTR Axis$[rsp]
  000ba	48 8b f0	 mov	 rsi, rax
  000bd	b9 0c 00 00 00	 mov	 ecx, 12
  000c2	f3 a4		 rep movsb

; 1953 :         
; 1954 :         float SinTheta = HMM_SinF(Angle);

  000c4	f3 0f 10 84 24
	58 01 00 00	 movss	 xmm0, DWORD PTR Angle$[rsp]
  000cd	e8 00 00 00 00	 call	 HMM_SinF
  000d2	f3 0f 11 44 24
	24		 movss	 DWORD PTR SinTheta$[rsp], xmm0

; 1955 :         float CosTheta = HMM_CosF(Angle);

  000d8	f3 0f 10 84 24
	58 01 00 00	 movss	 xmm0, DWORD PTR Angle$[rsp]
  000e1	e8 00 00 00 00	 call	 HMM_CosF
  000e6	f3 0f 11 44 24
	28		 movss	 DWORD PTR CosTheta$[rsp], xmm0

; 1956 :         float CosValue = 1.0f - CosTheta;

  000ec	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000f4	f3 0f 5c 44 24
	28		 subss	 xmm0, DWORD PTR CosTheta$[rsp]
  000fa	f3 0f 11 44 24
	20		 movss	 DWORD PTR CosValue$[rsp], xmm0

; 1957 :         
; 1958 :         Result.Elements[0][0] = (Axis.X * Axis.X * CosValue) + CosTheta;

  00100	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR Axis$[rsp]
  00108	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR Axis$[rsp]
  00110	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00114	f3 0f 59 01	 mulss	 xmm0, DWORD PTR [rcx]
  00118	f3 0f 59 44 24
	20		 mulss	 xmm0, DWORD PTR CosValue$[rsp]
  0011e	f3 0f 58 44 24
	28		 addss	 xmm0, DWORD PTR CosTheta$[rsp]
  00124	b8 10 00 00 00	 mov	 eax, 16
  00129	48 6b c0 00	 imul	 rax, rax, 0
  0012d	48 8d 84 04 90
	00 00 00	 lea	 rax, QWORD PTR Result$[rsp+rax]
  00135	b9 04 00 00 00	 mov	 ecx, 4
  0013a	48 6b c9 00	 imul	 rcx, rcx, 0
  0013e	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 1959 :         Result.Elements[0][1] = (Axis.X * Axis.Y * CosValue) + (Axis.Z * SinTheta);

  00143	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR Axis$[rsp]
  0014b	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR Axis$[rsp]
  00153	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00157	f3 0f 59 41 04	 mulss	 xmm0, DWORD PTR [rcx+4]
  0015c	f3 0f 59 44 24
	20		 mulss	 xmm0, DWORD PTR CosValue$[rsp]
  00162	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR Axis$[rsp]
  0016a	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [rax+8]
  0016f	f3 0f 59 4c 24
	24		 mulss	 xmm1, DWORD PTR SinTheta$[rsp]
  00175	f3 0f 58 c1	 addss	 xmm0, xmm1
  00179	b8 10 00 00 00	 mov	 eax, 16
  0017e	48 6b c0 00	 imul	 rax, rax, 0
  00182	48 8d 84 04 90
	00 00 00	 lea	 rax, QWORD PTR Result$[rsp+rax]
  0018a	b9 04 00 00 00	 mov	 ecx, 4
  0018f	48 6b c9 01	 imul	 rcx, rcx, 1
  00193	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 1960 :         Result.Elements[0][2] = (Axis.X * Axis.Z * CosValue) - (Axis.Y * SinTheta);

  00198	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR Axis$[rsp]
  001a0	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR Axis$[rsp]
  001a8	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  001ac	f3 0f 59 41 08	 mulss	 xmm0, DWORD PTR [rcx+8]
  001b1	f3 0f 59 44 24
	20		 mulss	 xmm0, DWORD PTR CosValue$[rsp]
  001b7	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR Axis$[rsp]
  001bf	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [rax+4]
  001c4	f3 0f 59 4c 24
	24		 mulss	 xmm1, DWORD PTR SinTheta$[rsp]
  001ca	f3 0f 5c c1	 subss	 xmm0, xmm1
  001ce	b8 10 00 00 00	 mov	 eax, 16
  001d3	48 6b c0 00	 imul	 rax, rax, 0
  001d7	48 8d 84 04 90
	00 00 00	 lea	 rax, QWORD PTR Result$[rsp+rax]
  001df	b9 04 00 00 00	 mov	 ecx, 4
  001e4	48 6b c9 02	 imul	 rcx, rcx, 2
  001e8	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 1961 :         
; 1962 :         Result.Elements[1][0] = (Axis.Y * Axis.X * CosValue) - (Axis.Z * SinTheta);

  001ed	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR Axis$[rsp]
  001f5	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR Axis$[rsp]
  001fd	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  00202	f3 0f 59 01	 mulss	 xmm0, DWORD PTR [rcx]
  00206	f3 0f 59 44 24
	20		 mulss	 xmm0, DWORD PTR CosValue$[rsp]
  0020c	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR Axis$[rsp]
  00214	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [rax+8]
  00219	f3 0f 59 4c 24
	24		 mulss	 xmm1, DWORD PTR SinTheta$[rsp]
  0021f	f3 0f 5c c1	 subss	 xmm0, xmm1
  00223	b8 10 00 00 00	 mov	 eax, 16
  00228	48 6b c0 01	 imul	 rax, rax, 1
  0022c	48 8d 84 04 90
	00 00 00	 lea	 rax, QWORD PTR Result$[rsp+rax]
  00234	b9 04 00 00 00	 mov	 ecx, 4
  00239	48 6b c9 00	 imul	 rcx, rcx, 0
  0023d	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 1963 :         Result.Elements[1][1] = (Axis.Y * Axis.Y * CosValue) + CosTheta;

  00242	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR Axis$[rsp]
  0024a	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR Axis$[rsp]
  00252	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  00257	f3 0f 59 41 04	 mulss	 xmm0, DWORD PTR [rcx+4]
  0025c	f3 0f 59 44 24
	20		 mulss	 xmm0, DWORD PTR CosValue$[rsp]
  00262	f3 0f 58 44 24
	28		 addss	 xmm0, DWORD PTR CosTheta$[rsp]
  00268	b8 10 00 00 00	 mov	 eax, 16
  0026d	48 6b c0 01	 imul	 rax, rax, 1
  00271	48 8d 84 04 90
	00 00 00	 lea	 rax, QWORD PTR Result$[rsp+rax]
  00279	b9 04 00 00 00	 mov	 ecx, 4
  0027e	48 6b c9 01	 imul	 rcx, rcx, 1
  00282	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 1964 :         Result.Elements[1][2] = (Axis.Y * Axis.Z * CosValue) + (Axis.X * SinTheta);

  00287	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR Axis$[rsp]
  0028f	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR Axis$[rsp]
  00297	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  0029c	f3 0f 59 41 08	 mulss	 xmm0, DWORD PTR [rcx+8]
  002a1	f3 0f 59 44 24
	20		 mulss	 xmm0, DWORD PTR CosValue$[rsp]
  002a7	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR Axis$[rsp]
  002af	f3 0f 10 08	 movss	 xmm1, DWORD PTR [rax]
  002b3	f3 0f 59 4c 24
	24		 mulss	 xmm1, DWORD PTR SinTheta$[rsp]
  002b9	f3 0f 58 c1	 addss	 xmm0, xmm1
  002bd	b8 10 00 00 00	 mov	 eax, 16
  002c2	48 6b c0 01	 imul	 rax, rax, 1
  002c6	48 8d 84 04 90
	00 00 00	 lea	 rax, QWORD PTR Result$[rsp+rax]
  002ce	b9 04 00 00 00	 mov	 ecx, 4
  002d3	48 6b c9 02	 imul	 rcx, rcx, 2
  002d7	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 1965 :         
; 1966 :         Result.Elements[2][0] = (Axis.Z * Axis.X * CosValue) + (Axis.Y * SinTheta);

  002dc	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR Axis$[rsp]
  002e4	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR Axis$[rsp]
  002ec	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  002f1	f3 0f 59 01	 mulss	 xmm0, DWORD PTR [rcx]
  002f5	f3 0f 59 44 24
	20		 mulss	 xmm0, DWORD PTR CosValue$[rsp]
  002fb	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR Axis$[rsp]
  00303	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [rax+4]
  00308	f3 0f 59 4c 24
	24		 mulss	 xmm1, DWORD PTR SinTheta$[rsp]
  0030e	f3 0f 58 c1	 addss	 xmm0, xmm1
  00312	b8 10 00 00 00	 mov	 eax, 16
  00317	48 6b c0 02	 imul	 rax, rax, 2
  0031b	48 8d 84 04 90
	00 00 00	 lea	 rax, QWORD PTR Result$[rsp+rax]
  00323	b9 04 00 00 00	 mov	 ecx, 4
  00328	48 6b c9 00	 imul	 rcx, rcx, 0
  0032c	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 1967 :         Result.Elements[2][1] = (Axis.Z * Axis.Y * CosValue) - (Axis.X * SinTheta);

  00331	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR Axis$[rsp]
  00339	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR Axis$[rsp]
  00341	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  00346	f3 0f 59 41 04	 mulss	 xmm0, DWORD PTR [rcx+4]
  0034b	f3 0f 59 44 24
	20		 mulss	 xmm0, DWORD PTR CosValue$[rsp]
  00351	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR Axis$[rsp]
  00359	f3 0f 10 08	 movss	 xmm1, DWORD PTR [rax]
  0035d	f3 0f 59 4c 24
	24		 mulss	 xmm1, DWORD PTR SinTheta$[rsp]
  00363	f3 0f 5c c1	 subss	 xmm0, xmm1
  00367	b8 10 00 00 00	 mov	 eax, 16
  0036c	48 6b c0 02	 imul	 rax, rax, 2
  00370	48 8d 84 04 90
	00 00 00	 lea	 rax, QWORD PTR Result$[rsp+rax]
  00378	b9 04 00 00 00	 mov	 ecx, 4
  0037d	48 6b c9 01	 imul	 rcx, rcx, 1
  00381	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 1968 :         Result.Elements[2][2] = (Axis.Z * Axis.Z * CosValue) + CosTheta;

  00386	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR Axis$[rsp]
  0038e	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR Axis$[rsp]
  00396	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  0039b	f3 0f 59 41 08	 mulss	 xmm0, DWORD PTR [rcx+8]
  003a0	f3 0f 59 44 24
	20		 mulss	 xmm0, DWORD PTR CosValue$[rsp]
  003a6	f3 0f 58 44 24
	28		 addss	 xmm0, DWORD PTR CosTheta$[rsp]
  003ac	b8 10 00 00 00	 mov	 eax, 16
  003b1	48 6b c0 02	 imul	 rax, rax, 2
  003b5	48 8d 84 04 90
	00 00 00	 lea	 rax, QWORD PTR Result$[rsp+rax]
  003bd	b9 04 00 00 00	 mov	 ecx, 4
  003c2	48 6b c9 02	 imul	 rcx, rcx, 2
  003c6	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 1969 :         
; 1970 :         return Result;

  003cb	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR Result$[rsp]
  003d3	48 8b bc 24 50
	01 00 00	 mov	 rdi, QWORD PTR $T6[rsp]
  003db	48 8b f0	 mov	 rsi, rax
  003de	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  003e3	f3 a4		 rep movsb
  003e5	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR $T6[rsp]

; 1971 :     }

  003ed	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003f5	48 33 cc	 xor	 rcx, rsp
  003f8	e8 00 00 00 00	 call	 __security_check_cookie
  003fd	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  00404	5f		 pop	 rdi
  00405	5e		 pop	 rsi
  00406	c3		 ret	 0
HMM_Rotate_RH ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\HandmadeMath.h
_TEXT	SEGMENT
$T1 = 32
Result$ = 96
$T2 = 160
__$ArrayPad$ = 224
$T3 = 272
Translation$ = 280
HMM_Translate PROC

; 1921 :     {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1922 :         ASSERT_COVERED(HMM_Translate);
; 1923 :         
; 1924 :         HMM_Mat4 Result = HMM_M4D(1.0f);

  00025	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  0002d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  00032	e8 00 00 00 00	 call	 HMM_M4D
  00037	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR $T2[rsp]
  0003f	48 8b f9	 mov	 rdi, rcx
  00042	48 8b f0	 mov	 rsi, rax
  00045	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0004a	f3 a4		 rep movsb
  0004c	48 8d 44 24 60	 lea	 rax, QWORD PTR Result$[rsp]
  00051	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR $T2[rsp]
  00059	48 8b f8	 mov	 rdi, rax
  0005c	48 8b f1	 mov	 rsi, rcx
  0005f	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00064	f3 a4		 rep movsb

; 1925 :         Result.Elements[3][0] = Translation.X;

  00066	b8 10 00 00 00	 mov	 eax, 16
  0006b	48 6b c0 03	 imul	 rax, rax, 3
  0006f	48 8d 44 04 60	 lea	 rax, QWORD PTR Result$[rsp+rax]
  00074	b9 04 00 00 00	 mov	 ecx, 4
  00079	48 6b c9 00	 imul	 rcx, rcx, 0
  0007d	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR Translation$[rsp]
  00085	f3 0f 10 02	 movss	 xmm0, DWORD PTR [rdx]
  00089	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 1926 :         Result.Elements[3][1] = Translation.Y;

  0008e	b8 10 00 00 00	 mov	 eax, 16
  00093	48 6b c0 03	 imul	 rax, rax, 3
  00097	48 8d 44 04 60	 lea	 rax, QWORD PTR Result$[rsp+rax]
  0009c	b9 04 00 00 00	 mov	 ecx, 4
  000a1	48 6b c9 01	 imul	 rcx, rcx, 1
  000a5	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR Translation$[rsp]
  000ad	f3 0f 10 42 04	 movss	 xmm0, DWORD PTR [rdx+4]
  000b2	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 1927 :         Result.Elements[3][2] = Translation.Z;

  000b7	b8 10 00 00 00	 mov	 eax, 16
  000bc	48 6b c0 03	 imul	 rax, rax, 3
  000c0	48 8d 44 04 60	 lea	 rax, QWORD PTR Result$[rsp+rax]
  000c5	b9 04 00 00 00	 mov	 ecx, 4
  000ca	48 6b c9 02	 imul	 rcx, rcx, 2
  000ce	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR Translation$[rsp]
  000d6	f3 0f 10 42 08	 movss	 xmm0, DWORD PTR [rdx+8]
  000db	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 1928 :         
; 1929 :         return Result;

  000e0	48 8d 44 24 60	 lea	 rax, QWORD PTR Result$[rsp]
  000e5	48 8b bc 24 10
	01 00 00	 mov	 rdi, QWORD PTR $T3[rsp]
  000ed	48 8b f0	 mov	 rsi, rax
  000f0	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000f5	f3 a4		 rep movsb
  000f7	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR $T3[rsp]

; 1930 :     }

  000ff	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00107	48 33 cc	 xor	 rcx, rsp
  0010a	e8 00 00 00 00	 call	 __security_check_cookie
  0010f	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  00116	5f		 pop	 rdi
  00117	5e		 pop	 rsi
  00118	c3		 ret	 0
HMM_Translate ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\HandmadeMath.h
_TEXT	SEGMENT
Cotangent$ = 32
Result$ = 48
__$ArrayPad$ = 112
$T1 = 160
FOV$ = 168
AspectRatio$ = 176
Near$ = 184
Far$ = 192
HMM_Perspective_RH_NO PROC

; 1823 :     {

  00000	f3 0f 11 5c 24
	20		 movss	 DWORD PTR [rsp+32], xmm3
  00006	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000c	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00012	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00017	56		 push	 rsi
  00018	57		 push	 rdi
  00019	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00020	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00027	48 33 c4	 xor	 rax, rsp
  0002a	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1824 :         ASSERT_COVERED(HMM_Perspective_RH_NO);
; 1825 :         
; 1826 :         HMM_Mat4 Result = {0};

  0002f	0f 57 c0	 xorps	 xmm0, xmm0
  00032	f3 0f 11 44 24
	30		 movss	 DWORD PTR Result$[rsp], xmm0
  00038	48 8d 44 24 34	 lea	 rax, QWORD PTR Result$[rsp+4]
  0003d	48 8b f8	 mov	 rdi, rax
  00040	33 c0		 xor	 eax, eax
  00042	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00047	f3 aa		 rep stosb

; 1827 :         
; 1828 :         // See https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml
; 1829 :         
; 1830 :         float Cotangent = 1.0f / HMM_TanF(FOV / 2.0f);

  00049	f3 0f 10 84 24
	a8 00 00 00	 movss	 xmm0, DWORD PTR FOV$[rsp]
  00052	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  0005a	e8 00 00 00 00	 call	 HMM_TanF
  0005f	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00067	f3 0f 5e c8	 divss	 xmm1, xmm0
  0006b	0f 28 c1	 movaps	 xmm0, xmm1
  0006e	f3 0f 11 44 24
	20		 movss	 DWORD PTR Cotangent$[rsp], xmm0

; 1831 :         Result.Elements[0][0] = Cotangent / AspectRatio;

  00074	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR Cotangent$[rsp]
  0007a	f3 0f 5e 84 24
	b0 00 00 00	 divss	 xmm0, DWORD PTR AspectRatio$[rsp]
  00083	b8 10 00 00 00	 mov	 eax, 16
  00088	48 6b c0 00	 imul	 rax, rax, 0
  0008c	48 8d 44 04 30	 lea	 rax, QWORD PTR Result$[rsp+rax]
  00091	b9 04 00 00 00	 mov	 ecx, 4
  00096	48 6b c9 00	 imul	 rcx, rcx, 0
  0009a	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 1832 :         Result.Elements[1][1] = Cotangent;

  0009f	b8 10 00 00 00	 mov	 eax, 16
  000a4	48 6b c0 01	 imul	 rax, rax, 1
  000a8	48 8d 44 04 30	 lea	 rax, QWORD PTR Result$[rsp+rax]
  000ad	b9 04 00 00 00	 mov	 ecx, 4
  000b2	48 6b c9 01	 imul	 rcx, rcx, 1
  000b6	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR Cotangent$[rsp]
  000bc	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 1833 :         Result.Elements[2][3] = -1.0f;

  000c1	b8 10 00 00 00	 mov	 eax, 16
  000c6	48 6b c0 02	 imul	 rax, rax, 2
  000ca	48 8d 44 04 30	 lea	 rax, QWORD PTR Result$[rsp+rax]
  000cf	b9 04 00 00 00	 mov	 ecx, 4
  000d4	48 6b c9 03	 imul	 rcx, rcx, 3
  000d8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  000e0	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 1834 :         
; 1835 :         Result.Elements[2][2] = (Near + Far) / (Near - Far);

  000e5	f3 0f 10 84 24
	b8 00 00 00	 movss	 xmm0, DWORD PTR Near$[rsp]
  000ee	f3 0f 58 84 24
	c0 00 00 00	 addss	 xmm0, DWORD PTR Far$[rsp]
  000f7	f3 0f 10 8c 24
	b8 00 00 00	 movss	 xmm1, DWORD PTR Near$[rsp]
  00100	f3 0f 5c 8c 24
	c0 00 00 00	 subss	 xmm1, DWORD PTR Far$[rsp]
  00109	f3 0f 5e c1	 divss	 xmm0, xmm1
  0010d	b8 10 00 00 00	 mov	 eax, 16
  00112	48 6b c0 02	 imul	 rax, rax, 2
  00116	48 8d 44 04 30	 lea	 rax, QWORD PTR Result$[rsp+rax]
  0011b	b9 04 00 00 00	 mov	 ecx, 4
  00120	48 6b c9 02	 imul	 rcx, rcx, 2
  00124	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 1836 :         Result.Elements[3][2] = (2.0f * Near * Far) / (Near - Far);

  00129	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  00131	f3 0f 59 84 24
	b8 00 00 00	 mulss	 xmm0, DWORD PTR Near$[rsp]
  0013a	f3 0f 59 84 24
	c0 00 00 00	 mulss	 xmm0, DWORD PTR Far$[rsp]
  00143	f3 0f 10 8c 24
	b8 00 00 00	 movss	 xmm1, DWORD PTR Near$[rsp]
  0014c	f3 0f 5c 8c 24
	c0 00 00 00	 subss	 xmm1, DWORD PTR Far$[rsp]
  00155	f3 0f 5e c1	 divss	 xmm0, xmm1
  00159	b8 10 00 00 00	 mov	 eax, 16
  0015e	48 6b c0 03	 imul	 rax, rax, 3
  00162	48 8d 44 04 30	 lea	 rax, QWORD PTR Result$[rsp+rax]
  00167	b9 04 00 00 00	 mov	 ecx, 4
  0016c	48 6b c9 02	 imul	 rcx, rcx, 2
  00170	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 1837 :         
; 1838 :         return Result;

  00175	48 8d 44 24 30	 lea	 rax, QWORD PTR Result$[rsp]
  0017a	48 8b bc 24 a0
	00 00 00	 mov	 rdi, QWORD PTR $T1[rsp]
  00182	48 8b f0	 mov	 rsi, rax
  00185	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0018a	f3 a4		 rep movsb
  0018c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR $T1[rsp]

; 1839 :     }

  00194	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00199	48 33 cc	 xor	 rcx, rsp
  0019c	e8 00 00 00 00	 call	 __security_check_cookie
  001a1	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001a8	5f		 pop	 rdi
  001a9	5e		 pop	 rsi
  001aa	c3		 ret	 0
HMM_Perspective_RH_NO ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\HandmadeMath.h
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
$T3 = 64
$T4 = 128
__$ArrayPad$ = 144
$T5 = 192
Matrix$ = 200
Vector$ = 208
HMM_MulM4V4 PROC

; 1639 :     {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1640 :         ASSERT_COVERED(HMM_MulM4V4);
; 1641 :         return HMM_LinearCombineV4M4(Vector, Matrix);

  0002a	48 8d 44 24 40	 lea	 rax, QWORD PTR $T3[rsp]
  0002f	48 8b f8	 mov	 rdi, rax
  00032	48 8b b4 24 c8
	00 00 00	 mov	 rsi, QWORD PTR Matrix$[rsp]
  0003a	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0003f	f3 a4		 rep movsb
  00041	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR Vector$[rsp]
  00049	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  0004c	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR $T1[rsp], xmm0
  00052	4c 8d 44 24 40	 lea	 r8, QWORD PTR $T3[rsp]
  00057	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  0005c	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T2[rsp]
  00061	e8 00 00 00 00	 call	 HMM_LinearCombineV4M4
  00066	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00069	66 0f 7f 84 24
	80 00 00 00	 movdqa	 XMMWORD PTR $T4[rsp], xmm0
  00072	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR $T5[rsp]
  0007a	0f 28 84 24 80
	00 00 00	 movaps	 xmm0, XMMWORD PTR $T4[rsp]
  00082	66 0f 7f 00	 movdqa	 XMMWORD PTR [rax], xmm0
  00086	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR $T5[rsp]

; 1642 :     }

  0008e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00096	48 33 cc	 xor	 rcx, rsp
  00099	e8 00 00 00 00	 call	 __security_check_cookie
  0009e	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  000a5	5f		 pop	 rdi
  000a6	5e		 pop	 rsi
  000a7	c3		 ret	 0
HMM_MulM4V4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\HandmadeMath.h
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
$T3 = 64
$T4 = 80
$T5 = 96
$T6 = 112
$T7 = 128
$T8 = 144
$T9 = 160
$T10 = 224
$T11 = 288
$T12 = 352
$T13 = 416
$T14 = 432
$T15 = 448
$T16 = 464
Result$ = 480
__$ArrayPad$ = 544
$T17 = 592
Left$ = 600
Right$ = 608
HMM_MulM4 PROC

; 1584 :     {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 38 02
	00 00		 sub	 rsp, 568		; 00000238H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 20
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1585 :         ASSERT_COVERED(HMM_MulM4);
; 1586 :         
; 1587 :         HMM_Mat4 Result;
; 1588 :         Result.Columns[0] = HMM_LinearCombineV4M4(Right.Columns[0], Left);

  0002a	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR $T9[rsp]
  00032	48 8b f8	 mov	 rdi, rax
  00035	48 8b b4 24 58
	02 00 00	 mov	 rsi, QWORD PTR Left$[rsp]
  0003d	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00042	f3 a4		 rep movsb
  00044	b8 10 00 00 00	 mov	 eax, 16
  00049	48 6b c0 00	 imul	 rax, rax, 0
  0004d	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR Right$[rsp]
  00055	0f 10 04 01	 movups	 xmm0, XMMWORD PTR [rcx+rax]
  00059	66 0f 7f 44 24
	20		 movdqa	 XMMWORD PTR $T1[rsp], xmm0
  0005f	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR $T9[rsp]
  00067	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  0006c	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T5[rsp]
  00071	e8 00 00 00 00	 call	 HMM_LinearCombineV4M4
  00076	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00079	66 0f 7f 84 24
	a0 01 00 00	 movdqa	 XMMWORD PTR $T13[rsp], xmm0
  00082	b8 10 00 00 00	 mov	 eax, 16
  00087	48 6b c0 00	 imul	 rax, rax, 0
  0008b	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR $T13[rsp]
  00093	48 8d bc 04 e0
	01 00 00	 lea	 rdi, QWORD PTR Result$[rsp+rax]
  0009b	48 8b f1	 mov	 rsi, rcx
  0009e	b9 10 00 00 00	 mov	 ecx, 16
  000a3	f3 a4		 rep movsb

; 1589 :         Result.Columns[1] = HMM_LinearCombineV4M4(Right.Columns[1], Left);

  000a5	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR $T10[rsp]
  000ad	48 8b f8	 mov	 rdi, rax
  000b0	48 8b b4 24 58
	02 00 00	 mov	 rsi, QWORD PTR Left$[rsp]
  000b8	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000bd	f3 a4		 rep movsb
  000bf	b8 10 00 00 00	 mov	 eax, 16
  000c4	48 6b c0 01	 imul	 rax, rax, 1
  000c8	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR Right$[rsp]
  000d0	0f 10 04 01	 movups	 xmm0, XMMWORD PTR [rcx+rax]
  000d4	66 0f 7f 44 24
	30		 movdqa	 XMMWORD PTR $T2[rsp], xmm0
  000da	4c 8d 84 24 e0
	00 00 00	 lea	 r8, QWORD PTR $T10[rsp]
  000e2	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T2[rsp]
  000e7	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T6[rsp]
  000ec	e8 00 00 00 00	 call	 HMM_LinearCombineV4M4
  000f1	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  000f4	66 0f 7f 84 24
	b0 01 00 00	 movdqa	 XMMWORD PTR $T14[rsp], xmm0
  000fd	b8 10 00 00 00	 mov	 eax, 16
  00102	48 6b c0 01	 imul	 rax, rax, 1
  00106	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR $T14[rsp]
  0010e	48 8d bc 04 e0
	01 00 00	 lea	 rdi, QWORD PTR Result$[rsp+rax]
  00116	48 8b f1	 mov	 rsi, rcx
  00119	b9 10 00 00 00	 mov	 ecx, 16
  0011e	f3 a4		 rep movsb

; 1590 :         Result.Columns[2] = HMM_LinearCombineV4M4(Right.Columns[2], Left);

  00120	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR $T11[rsp]
  00128	48 8b f8	 mov	 rdi, rax
  0012b	48 8b b4 24 58
	02 00 00	 mov	 rsi, QWORD PTR Left$[rsp]
  00133	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00138	f3 a4		 rep movsb
  0013a	b8 10 00 00 00	 mov	 eax, 16
  0013f	48 6b c0 02	 imul	 rax, rax, 2
  00143	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR Right$[rsp]
  0014b	0f 10 04 01	 movups	 xmm0, XMMWORD PTR [rcx+rax]
  0014f	66 0f 7f 44 24
	40		 movdqa	 XMMWORD PTR $T3[rsp], xmm0
  00155	4c 8d 84 24 20
	01 00 00	 lea	 r8, QWORD PTR $T11[rsp]
  0015d	48 8d 54 24 40	 lea	 rdx, QWORD PTR $T3[rsp]
  00162	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR $T7[rsp]
  0016a	e8 00 00 00 00	 call	 HMM_LinearCombineV4M4
  0016f	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00172	66 0f 7f 84 24
	c0 01 00 00	 movdqa	 XMMWORD PTR $T15[rsp], xmm0
  0017b	b8 10 00 00 00	 mov	 eax, 16
  00180	48 6b c0 02	 imul	 rax, rax, 2
  00184	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR $T15[rsp]
  0018c	48 8d bc 04 e0
	01 00 00	 lea	 rdi, QWORD PTR Result$[rsp+rax]
  00194	48 8b f1	 mov	 rsi, rcx
  00197	b9 10 00 00 00	 mov	 ecx, 16
  0019c	f3 a4		 rep movsb

; 1591 :         Result.Columns[3] = HMM_LinearCombineV4M4(Right.Columns[3], Left);

  0019e	48 8d 84 24 60
	01 00 00	 lea	 rax, QWORD PTR $T12[rsp]
  001a6	48 8b f8	 mov	 rdi, rax
  001a9	48 8b b4 24 58
	02 00 00	 mov	 rsi, QWORD PTR Left$[rsp]
  001b1	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  001b6	f3 a4		 rep movsb
  001b8	b8 10 00 00 00	 mov	 eax, 16
  001bd	48 6b c0 03	 imul	 rax, rax, 3
  001c1	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR Right$[rsp]
  001c9	0f 10 04 01	 movups	 xmm0, XMMWORD PTR [rcx+rax]
  001cd	66 0f 7f 44 24
	50		 movdqa	 XMMWORD PTR $T4[rsp], xmm0
  001d3	4c 8d 84 24 60
	01 00 00	 lea	 r8, QWORD PTR $T12[rsp]
  001db	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T4[rsp]
  001e0	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR $T8[rsp]
  001e8	e8 00 00 00 00	 call	 HMM_LinearCombineV4M4
  001ed	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  001f0	66 0f 7f 84 24
	d0 01 00 00	 movdqa	 XMMWORD PTR $T16[rsp], xmm0
  001f9	b8 10 00 00 00	 mov	 eax, 16
  001fe	48 6b c0 03	 imul	 rax, rax, 3
  00202	48 8d 8c 24 d0
	01 00 00	 lea	 rcx, QWORD PTR $T16[rsp]
  0020a	48 8d bc 04 e0
	01 00 00	 lea	 rdi, QWORD PTR Result$[rsp+rax]
  00212	48 8b f1	 mov	 rsi, rcx
  00215	b9 10 00 00 00	 mov	 ecx, 16
  0021a	f3 a4		 rep movsb

; 1592 :         
; 1593 :         return Result;

  0021c	48 8d 84 24 e0
	01 00 00	 lea	 rax, QWORD PTR Result$[rsp]
  00224	48 8b bc 24 50
	02 00 00	 mov	 rdi, QWORD PTR $T17[rsp]
  0022c	48 8b f0	 mov	 rsi, rax
  0022f	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00234	f3 a4		 rep movsb
  00236	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR $T17[rsp]

; 1594 :     }

  0023e	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00246	48 33 cc	 xor	 rcx, rsp
  00249	e8 00 00 00 00	 call	 __security_check_cookie
  0024e	48 81 c4 38 02
	00 00		 add	 rsp, 568		; 00000238H
  00255	5f		 pop	 rdi
  00256	5e		 pop	 rsi
  00257	c3		 ret	 0
HMM_MulM4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\HandmadeMath.h
_TEXT	SEGMENT
Result$ = 0
__$ArrayPad$ = 64
$T1 = 112
Diagonal$ = 120
HMM_M4D	PROC

; 1503 :     {

  00000	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00006	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1504 :         ASSERT_COVERED(HMM_M4D);
; 1505 :         
; 1506 :         HMM_Mat4 Result = {0};

  00020	0f 57 c0	 xorps	 xmm0, xmm0
  00023	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0
  00028	48 8d 44 24 04	 lea	 rax, QWORD PTR Result$[rsp+4]
  0002d	48 8b f8	 mov	 rdi, rax
  00030	33 c0		 xor	 eax, eax
  00032	b9 3c 00 00 00	 mov	 ecx, 60			; 0000003cH
  00037	f3 aa		 rep stosb

; 1507 :         Result.Elements[0][0] = Diagonal;

  00039	b8 10 00 00 00	 mov	 eax, 16
  0003e	48 6b c0 00	 imul	 rax, rax, 0
  00042	48 8d 04 04	 lea	 rax, QWORD PTR Result$[rsp+rax]
  00046	b9 04 00 00 00	 mov	 ecx, 4
  0004b	48 6b c9 00	 imul	 rcx, rcx, 0
  0004f	f3 0f 10 44 24
	78		 movss	 xmm0, DWORD PTR Diagonal$[rsp]
  00055	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 1508 :         Result.Elements[1][1] = Diagonal;

  0005a	b8 10 00 00 00	 mov	 eax, 16
  0005f	48 6b c0 01	 imul	 rax, rax, 1
  00063	48 8d 04 04	 lea	 rax, QWORD PTR Result$[rsp+rax]
  00067	b9 04 00 00 00	 mov	 ecx, 4
  0006c	48 6b c9 01	 imul	 rcx, rcx, 1
  00070	f3 0f 10 44 24
	78		 movss	 xmm0, DWORD PTR Diagonal$[rsp]
  00076	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 1509 :         Result.Elements[2][2] = Diagonal;

  0007b	b8 10 00 00 00	 mov	 eax, 16
  00080	48 6b c0 02	 imul	 rax, rax, 2
  00084	48 8d 04 04	 lea	 rax, QWORD PTR Result$[rsp+rax]
  00088	b9 04 00 00 00	 mov	 ecx, 4
  0008d	48 6b c9 02	 imul	 rcx, rcx, 2
  00091	f3 0f 10 44 24
	78		 movss	 xmm0, DWORD PTR Diagonal$[rsp]
  00097	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 1510 :         Result.Elements[3][3] = Diagonal;

  0009c	b8 10 00 00 00	 mov	 eax, 16
  000a1	48 6b c0 03	 imul	 rax, rax, 3
  000a5	48 8d 04 04	 lea	 rax, QWORD PTR Result$[rsp+rax]
  000a9	b9 04 00 00 00	 mov	 ecx, 4
  000ae	48 6b c9 03	 imul	 rcx, rcx, 3
  000b2	f3 0f 10 44 24
	78		 movss	 xmm0, DWORD PTR Diagonal$[rsp]
  000b8	f3 0f 11 04 08	 movss	 DWORD PTR [rax+rcx], xmm0

; 1511 :         
; 1512 :         return Result;

  000bd	48 8d 04 24	 lea	 rax, QWORD PTR Result$[rsp]
  000c1	48 8b 7c 24 70	 mov	 rdi, QWORD PTR $T1[rsp]
  000c6	48 8b f0	 mov	 rsi, rax
  000c9	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000ce	f3 a4		 rep movsb
  000d0	48 8b 44 24 70	 mov	 rax, QWORD PTR $T1[rsp]

; 1513 :     }

  000d5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000da	48 33 cc	 xor	 rcx, rsp
  000dd	e8 00 00 00 00	 call	 __security_check_cookie
  000e2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000e6	5f		 pop	 rdi
  000e7	5e		 pop	 rsi
  000e8	c3		 ret	 0
HMM_M4D	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\HandmadeMath.h
_TEXT	SEGMENT
$T1 = 0
$T2 = 16
$T3 = 32
$T4 = 48
$T5 = 64
$T6 = 80
$T7 = 96
$T8 = 112
$T9 = 128
$T10 = 144
$T11 = 160
Result$ = 176
__$ArrayPad$ = 192
$T12 = 224
Left$ = 232
Right$ = 240
HMM_LinearCombineV4M4 PROC

; 1112 :     {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1113 :         ASSERT_COVERED(HMM_LinearCombineV4M4);
; 1114 :         
; 1115 :         HMM_Vec4 Result;
; 1116 : #ifdef HANDMADE_MATH__USE_SSE
; 1117 :         Result.SSE = _mm_mul_ps(_mm_shuffle_ps(Left.SSE, Left.SSE, 0x00), Right.Columns[0].SSE);

  00028	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR Left$[rsp]
  00030	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR Left$[rsp]
  00038	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  0003b	0f c6 01 00	 shufps	 xmm0, XMMWORD PTR [rcx], 0
  0003f	0f 29 04 24	 movaps	 XMMWORD PTR $T1[rsp], xmm0
  00043	b8 10 00 00 00	 mov	 eax, 16
  00048	48 6b c0 00	 imul	 rax, rax, 0
  0004c	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR Right$[rsp]
  00054	0f 28 04 24	 movaps	 xmm0, XMMWORD PTR $T1[rsp]
  00058	0f 59 04 01	 mulps	 xmm0, XMMWORD PTR [rcx+rax]
  0005c	0f 29 44 24 10	 movaps	 XMMWORD PTR $T2[rsp], xmm0
  00061	0f 28 44 24 10	 movaps	 xmm0, XMMWORD PTR $T2[rsp]
  00066	0f 29 84 24 b0
	00 00 00	 movaps	 XMMWORD PTR Result$[rsp], xmm0

; 1118 :         Result.SSE = _mm_add_ps(Result.SSE, _mm_mul_ps(_mm_shuffle_ps(Left.SSE, Left.SSE, 0x55), Right.Columns[1].SSE));

  0006e	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR Left$[rsp]
  00076	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR Left$[rsp]
  0007e	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00081	0f c6 01 55	 shufps	 xmm0, XMMWORD PTR [rcx], 85 ; 00000055H
  00085	0f 29 44 24 20	 movaps	 XMMWORD PTR $T3[rsp], xmm0
  0008a	b8 10 00 00 00	 mov	 eax, 16
  0008f	48 6b c0 01	 imul	 rax, rax, 1
  00093	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR Right$[rsp]
  0009b	0f 28 44 24 20	 movaps	 xmm0, XMMWORD PTR $T3[rsp]
  000a0	0f 59 04 01	 mulps	 xmm0, XMMWORD PTR [rcx+rax]
  000a4	0f 29 44 24 30	 movaps	 XMMWORD PTR $T4[rsp], xmm0
  000a9	0f 28 84 24 b0
	00 00 00	 movaps	 xmm0, XMMWORD PTR Result$[rsp]
  000b1	0f 58 44 24 30	 addps	 xmm0, XMMWORD PTR $T4[rsp]
  000b6	0f 29 44 24 40	 movaps	 XMMWORD PTR $T5[rsp], xmm0
  000bb	0f 28 44 24 40	 movaps	 xmm0, XMMWORD PTR $T5[rsp]
  000c0	0f 29 84 24 b0
	00 00 00	 movaps	 XMMWORD PTR Result$[rsp], xmm0

; 1119 :         Result.SSE = _mm_add_ps(Result.SSE, _mm_mul_ps(_mm_shuffle_ps(Left.SSE, Left.SSE, 0xaa), Right.Columns[2].SSE));

  000c8	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR Left$[rsp]
  000d0	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR Left$[rsp]
  000d8	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  000db	0f c6 01 aa	 shufps	 xmm0, XMMWORD PTR [rcx], 170 ; 000000aaH
  000df	0f 29 44 24 50	 movaps	 XMMWORD PTR $T6[rsp], xmm0
  000e4	b8 10 00 00 00	 mov	 eax, 16
  000e9	48 6b c0 02	 imul	 rax, rax, 2
  000ed	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR Right$[rsp]
  000f5	0f 28 44 24 50	 movaps	 xmm0, XMMWORD PTR $T6[rsp]
  000fa	0f 59 04 01	 mulps	 xmm0, XMMWORD PTR [rcx+rax]
  000fe	0f 29 44 24 60	 movaps	 XMMWORD PTR $T7[rsp], xmm0
  00103	0f 28 84 24 b0
	00 00 00	 movaps	 xmm0, XMMWORD PTR Result$[rsp]
  0010b	0f 58 44 24 60	 addps	 xmm0, XMMWORD PTR $T7[rsp]
  00110	0f 29 44 24 70	 movaps	 XMMWORD PTR $T8[rsp], xmm0
  00115	0f 28 44 24 70	 movaps	 xmm0, XMMWORD PTR $T8[rsp]
  0011a	0f 29 84 24 b0
	00 00 00	 movaps	 XMMWORD PTR Result$[rsp], xmm0

; 1120 :         Result.SSE = _mm_add_ps(Result.SSE, _mm_mul_ps(_mm_shuffle_ps(Left.SSE, Left.SSE, 0xff), Right.Columns[3].SSE));

  00122	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR Left$[rsp]
  0012a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR Left$[rsp]
  00132	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00135	0f c6 01 ff	 shufps	 xmm0, XMMWORD PTR [rcx], 255 ; 000000ffH
  00139	0f 29 84 24 80
	00 00 00	 movaps	 XMMWORD PTR $T9[rsp], xmm0
  00141	b8 10 00 00 00	 mov	 eax, 16
  00146	48 6b c0 03	 imul	 rax, rax, 3
  0014a	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR Right$[rsp]
  00152	0f 28 84 24 80
	00 00 00	 movaps	 xmm0, XMMWORD PTR $T9[rsp]
  0015a	0f 59 04 01	 mulps	 xmm0, XMMWORD PTR [rcx+rax]
  0015e	0f 29 84 24 90
	00 00 00	 movaps	 XMMWORD PTR $T10[rsp], xmm0
  00166	0f 28 84 24 b0
	00 00 00	 movaps	 xmm0, XMMWORD PTR Result$[rsp]
  0016e	0f 58 84 24 90
	00 00 00	 addps	 xmm0, XMMWORD PTR $T10[rsp]
  00176	0f 29 84 24 a0
	00 00 00	 movaps	 XMMWORD PTR $T11[rsp], xmm0
  0017e	0f 28 84 24 a0
	00 00 00	 movaps	 xmm0, XMMWORD PTR $T11[rsp]
  00186	0f 29 84 24 b0
	00 00 00	 movaps	 XMMWORD PTR Result$[rsp], xmm0

; 1121 : #elif defined(HANDMADE_MATH__USE_NEON)
; 1122 :         Result.NEON = vmulq_laneq_f32(Right.Columns[0].NEON, Left.NEON, 0);
; 1123 :         Result.NEON = vfmaq_laneq_f32(Result.NEON, Right.Columns[1].NEON, Left.NEON, 1);
; 1124 :         Result.NEON = vfmaq_laneq_f32(Result.NEON, Right.Columns[2].NEON, Left.NEON, 2);
; 1125 :         Result.NEON = vfmaq_laneq_f32(Result.NEON, Right.Columns[3].NEON, Left.NEON, 3);
; 1126 : #else
; 1127 :         Result.X = Left.Elements[0] * Right.Columns[0].X;
; 1128 :         Result.Y = Left.Elements[0] * Right.Columns[0].Y;
; 1129 :         Result.Z = Left.Elements[0] * Right.Columns[0].Z;
; 1130 :         Result.W = Left.Elements[0] * Right.Columns[0].W;
; 1131 :         
; 1132 :         Result.X += Left.Elements[1] * Right.Columns[1].X;
; 1133 :         Result.Y += Left.Elements[1] * Right.Columns[1].Y;
; 1134 :         Result.Z += Left.Elements[1] * Right.Columns[1].Z;
; 1135 :         Result.W += Left.Elements[1] * Right.Columns[1].W;
; 1136 :         
; 1137 :         Result.X += Left.Elements[2] * Right.Columns[2].X;
; 1138 :         Result.Y += Left.Elements[2] * Right.Columns[2].Y;
; 1139 :         Result.Z += Left.Elements[2] * Right.Columns[2].Z;
; 1140 :         Result.W += Left.Elements[2] * Right.Columns[2].W;
; 1141 :         
; 1142 :         Result.X += Left.Elements[3] * Right.Columns[3].X;
; 1143 :         Result.Y += Left.Elements[3] * Right.Columns[3].Y;
; 1144 :         Result.Z += Left.Elements[3] * Right.Columns[3].Z;
; 1145 :         Result.W += Left.Elements[3] * Right.Columns[3].W;
; 1146 : #endif
; 1147 :         
; 1148 :         return Result;

  0018e	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR $T12[rsp]
  00196	0f 28 84 24 b0
	00 00 00	 movaps	 xmm0, XMMWORD PTR Result$[rsp]
  0019e	f3 0f 7f 00	 movdqu	 XMMWORD PTR [rax], xmm0
  001a2	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR $T12[rsp]

; 1149 :     }

  001aa	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001b2	48 33 cc	 xor	 rcx, rsp
  001b5	e8 00 00 00 00	 call	 __security_check_cookie
  001ba	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  001c1	c3		 ret	 0
HMM_LinearCombineV4M4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\HandmadeMath.h
_TEXT	SEGMENT
$T1 = 32
$T2 = 48
$T3 = 64
$T4 = 80
$T5 = 96
__$ArrayPad$ = 112
$T6 = 160
A$ = 168
HMM_NormV3 PROC

; 1069 :     {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1070 :         ASSERT_COVERED(HMM_NormV3);
; 1071 :         return HMM_MulV3F(A, HMM_InvSqrtF(HMM_DotV3(A, A)));

  00022	48 8d 44 24 20	 lea	 rax, QWORD PTR $T1[rsp]
  00027	48 8b f8	 mov	 rdi, rax
  0002a	48 8b b4 24 a8
	00 00 00	 mov	 rsi, QWORD PTR A$[rsp]
  00032	b9 0c 00 00 00	 mov	 ecx, 12
  00037	f3 a4		 rep movsb
  00039	48 8d 44 24 30	 lea	 rax, QWORD PTR $T2[rsp]
  0003e	48 8b f8	 mov	 rdi, rax
  00041	48 8b b4 24 a8
	00 00 00	 mov	 rsi, QWORD PTR A$[rsp]
  00049	b9 0c 00 00 00	 mov	 ecx, 12
  0004e	f3 a4		 rep movsb
  00050	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  00055	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T2[rsp]
  0005a	e8 00 00 00 00	 call	 HMM_DotV3
  0005f	e8 00 00 00 00	 call	 HMM_InvSqrtF
  00064	48 8d 44 24 40	 lea	 rax, QWORD PTR $T3[rsp]
  00069	48 8b f8	 mov	 rdi, rax
  0006c	48 8b b4 24 a8
	00 00 00	 mov	 rsi, QWORD PTR A$[rsp]
  00074	b9 0c 00 00 00	 mov	 ecx, 12
  00079	f3 a4		 rep movsb
  0007b	0f 28 d0	 movaps	 xmm2, xmm0
  0007e	48 8d 54 24 40	 lea	 rdx, QWORD PTR $T3[rsp]
  00083	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T4[rsp]
  00088	e8 00 00 00 00	 call	 HMM_MulV3F
  0008d	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T5[rsp]
  00092	48 8b f9	 mov	 rdi, rcx
  00095	48 8b f0	 mov	 rsi, rax
  00098	b9 0c 00 00 00	 mov	 ecx, 12
  0009d	f3 a4		 rep movsb
  0009f	48 8d 44 24 60	 lea	 rax, QWORD PTR $T5[rsp]
  000a4	48 8b bc 24 a0
	00 00 00	 mov	 rdi, QWORD PTR $T6[rsp]
  000ac	48 8b f0	 mov	 rsi, rax
  000af	b9 0c 00 00 00	 mov	 ecx, 12
  000b4	f3 a4		 rep movsb
  000b6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR $T6[rsp]

; 1072 :     }

  000be	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000c3	48 33 cc	 xor	 rcx, rsp
  000c6	e8 00 00 00 00	 call	 __security_check_cookie
  000cb	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  000d2	5f		 pop	 rdi
  000d3	5e		 pop	 rsi
  000d4	c3		 ret	 0
HMM_NormV3 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\HandmadeMath.h
_TEXT	SEGMENT
Result$ = 0
__$ArrayPad$ = 16
$T1 = 64
Left$ = 72
Right$ = 80
HMM_Cross PROC

; 1002 :     {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 44 24 10	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1003 :         ASSERT_COVERED(HMM_Cross);
; 1004 :         
; 1005 :         HMM_Vec3 Result;
; 1006 :         Result.X = (Left.Y * Right.Z) - (Left.Z * Right.Y);

  00024	48 8b 44 24 48	 mov	 rax, QWORD PTR Left$[rsp]
  00029	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Right$[rsp]
  0002e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  00033	f3 0f 59 41 08	 mulss	 xmm0, DWORD PTR [rcx+8]
  00038	48 8b 44 24 48	 mov	 rax, QWORD PTR Left$[rsp]
  0003d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Right$[rsp]
  00042	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [rax+8]
  00047	f3 0f 59 49 04	 mulss	 xmm1, DWORD PTR [rcx+4]
  0004c	f3 0f 5c c1	 subss	 xmm0, xmm1
  00050	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0

; 1007 :         Result.Y = (Left.Z * Right.X) - (Left.X * Right.Z);

  00055	48 8b 44 24 48	 mov	 rax, QWORD PTR Left$[rsp]
  0005a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Right$[rsp]
  0005f	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  00064	f3 0f 59 01	 mulss	 xmm0, DWORD PTR [rcx]
  00068	48 8b 44 24 48	 mov	 rax, QWORD PTR Left$[rsp]
  0006d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Right$[rsp]
  00072	f3 0f 10 08	 movss	 xmm1, DWORD PTR [rax]
  00076	f3 0f 59 49 08	 mulss	 xmm1, DWORD PTR [rcx+8]
  0007b	f3 0f 5c c1	 subss	 xmm0, xmm1
  0007f	f3 0f 11 44 24
	04		 movss	 DWORD PTR Result$[rsp+4], xmm0

; 1008 :         Result.Z = (Left.X * Right.Y) - (Left.Y * Right.X);

  00085	48 8b 44 24 48	 mov	 rax, QWORD PTR Left$[rsp]
  0008a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Right$[rsp]
  0008f	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00093	f3 0f 59 41 04	 mulss	 xmm0, DWORD PTR [rcx+4]
  00098	48 8b 44 24 48	 mov	 rax, QWORD PTR Left$[rsp]
  0009d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Right$[rsp]
  000a2	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [rax+4]
  000a7	f3 0f 59 09	 mulss	 xmm1, DWORD PTR [rcx]
  000ab	f3 0f 5c c1	 subss	 xmm0, xmm1
  000af	f3 0f 11 44 24
	08		 movss	 DWORD PTR Result$[rsp+8], xmm0

; 1009 :         
; 1010 :         return Result;

  000b5	48 8d 04 24	 lea	 rax, QWORD PTR Result$[rsp]
  000b9	48 8b 7c 24 40	 mov	 rdi, QWORD PTR $T1[rsp]
  000be	48 8b f0	 mov	 rsi, rax
  000c1	b9 0c 00 00 00	 mov	 ecx, 12
  000c6	f3 a4		 rep movsb
  000c8	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]

; 1011 :     }

  000cd	48 8b 4c 24 10	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000d2	48 33 cc	 xor	 rcx, rsp
  000d5	e8 00 00 00 00	 call	 __security_check_cookie
  000da	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000de	5f		 pop	 rdi
  000df	5e		 pop	 rsi
  000e0	c3		 ret	 0
HMM_Cross ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\HandmadeMath.h
_TEXT	SEGMENT
Left$ = 8
Right$ = 16
HMM_DotV3 PROC

; 966  :     {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 967  :         ASSERT_COVERED(HMM_DotV3);
; 968  :         return (Left.X * Right.X) + (Left.Y * Right.Y) + (Left.Z * Right.Z);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR Left$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Right$[rsp]
  00014	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00018	f3 0f 59 01	 mulss	 xmm0, DWORD PTR [rcx]
  0001c	48 8b 44 24 08	 mov	 rax, QWORD PTR Left$[rsp]
  00021	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Right$[rsp]
  00026	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [rax+4]
  0002b	f3 0f 59 49 04	 mulss	 xmm1, DWORD PTR [rcx+4]
  00030	f3 0f 58 c1	 addss	 xmm0, xmm1
  00034	48 8b 44 24 08	 mov	 rax, QWORD PTR Left$[rsp]
  00039	48 8b 4c 24 10	 mov	 rcx, QWORD PTR Right$[rsp]
  0003e	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [rax+8]
  00043	f3 0f 59 49 08	 mulss	 xmm1, DWORD PTR [rcx+8]
  00048	f3 0f 58 c1	 addss	 xmm0, xmm1

; 969  :     }

  0004c	c3		 ret	 0
HMM_DotV3 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\HandmadeMath.h
_TEXT	SEGMENT
Result$ = 0
__$ArrayPad$ = 16
$T1 = 64
Left$ = 72
Right$ = 80
HMM_DivV3F PROC

; 881  :     {

  00000	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  00006	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 44 24 10	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 882  :         ASSERT_COVERED(HMM_DivV3F);
; 883  :         
; 884  :         HMM_Vec3 Result;
; 885  :         Result.X = Left.X / Right;

  00025	48 8b 44 24 48	 mov	 rax, QWORD PTR Left$[rsp]
  0002a	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  0002e	f3 0f 5e 44 24
	50		 divss	 xmm0, DWORD PTR Right$[rsp]
  00034	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0

; 886  :         Result.Y = Left.Y / Right;

  00039	48 8b 44 24 48	 mov	 rax, QWORD PTR Left$[rsp]
  0003e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  00043	f3 0f 5e 44 24
	50		 divss	 xmm0, DWORD PTR Right$[rsp]
  00049	f3 0f 11 44 24
	04		 movss	 DWORD PTR Result$[rsp+4], xmm0

; 887  :         Result.Z = Left.Z / Right;

  0004f	48 8b 44 24 48	 mov	 rax, QWORD PTR Left$[rsp]
  00054	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  00059	f3 0f 5e 44 24
	50		 divss	 xmm0, DWORD PTR Right$[rsp]
  0005f	f3 0f 11 44 24
	08		 movss	 DWORD PTR Result$[rsp+8], xmm0

; 888  :         
; 889  :         return Result;

  00065	48 8d 04 24	 lea	 rax, QWORD PTR Result$[rsp]
  00069	48 8b 7c 24 40	 mov	 rdi, QWORD PTR $T1[rsp]
  0006e	48 8b f0	 mov	 rsi, rax
  00071	b9 0c 00 00 00	 mov	 ecx, 12
  00076	f3 a4		 rep movsb
  00078	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]

; 890  :     }

  0007d	48 8b 4c 24 10	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00082	48 33 cc	 xor	 rcx, rsp
  00085	e8 00 00 00 00	 call	 __security_check_cookie
  0008a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008e	5f		 pop	 rdi
  0008f	5e		 pop	 rsi
  00090	c3		 ret	 0
HMM_DivV3F ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\HandmadeMath.h
_TEXT	SEGMENT
Result$ = 0
__$ArrayPad$ = 16
$T1 = 64
Left$ = 72
Right$ = 80
HMM_MulV3F PROC

; 788  :     {

  00000	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  00006	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 44 24 10	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 789  :         ASSERT_COVERED(HMM_MulV3F);
; 790  :         
; 791  :         HMM_Vec3 Result;
; 792  :         Result.X = Left.X * Right;

  00025	48 8b 44 24 48	 mov	 rax, QWORD PTR Left$[rsp]
  0002a	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  0002e	f3 0f 59 44 24
	50		 mulss	 xmm0, DWORD PTR Right$[rsp]
  00034	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0

; 793  :         Result.Y = Left.Y * Right;

  00039	48 8b 44 24 48	 mov	 rax, QWORD PTR Left$[rsp]
  0003e	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  00043	f3 0f 59 44 24
	50		 mulss	 xmm0, DWORD PTR Right$[rsp]
  00049	f3 0f 11 44 24
	04		 movss	 DWORD PTR Result$[rsp+4], xmm0

; 794  :         Result.Z = Left.Z * Right;

  0004f	48 8b 44 24 48	 mov	 rax, QWORD PTR Left$[rsp]
  00054	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  00059	f3 0f 59 44 24
	50		 mulss	 xmm0, DWORD PTR Right$[rsp]
  0005f	f3 0f 11 44 24
	08		 movss	 DWORD PTR Result$[rsp+8], xmm0

; 795  :         
; 796  :         return Result;

  00065	48 8d 04 24	 lea	 rax, QWORD PTR Result$[rsp]
  00069	48 8b 7c 24 40	 mov	 rdi, QWORD PTR $T1[rsp]
  0006e	48 8b f0	 mov	 rsi, rax
  00071	b9 0c 00 00 00	 mov	 ecx, 12
  00076	f3 a4		 rep movsb
  00078	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]

; 797  :     }

  0007d	48 8b 4c 24 10	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00082	48 33 cc	 xor	 rcx, rsp
  00085	e8 00 00 00 00	 call	 __security_check_cookie
  0008a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0008e	5f		 pop	 rdi
  0008f	5e		 pop	 rsi
  00090	c3		 ret	 0
HMM_MulV3F ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\HandmadeMath.h
_TEXT	SEGMENT
Result$ = 0
__$ArrayPad$ = 16
$T1 = 64
Left$ = 72
Right$ = 80
HMM_SubV3 PROC

; 717  :     {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 44 24 10	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 718  :         ASSERT_COVERED(HMM_SubV3);
; 719  :         
; 720  :         HMM_Vec3 Result;
; 721  :         Result.X = Left.X - Right.X;

  00024	48 8b 44 24 48	 mov	 rax, QWORD PTR Left$[rsp]
  00029	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Right$[rsp]
  0002e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00032	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [rcx]
  00036	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0

; 722  :         Result.Y = Left.Y - Right.Y;

  0003b	48 8b 44 24 48	 mov	 rax, QWORD PTR Left$[rsp]
  00040	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Right$[rsp]
  00045	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  0004a	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [rcx+4]
  0004f	f3 0f 11 44 24
	04		 movss	 DWORD PTR Result$[rsp+4], xmm0

; 723  :         Result.Z = Left.Z - Right.Z;

  00055	48 8b 44 24 48	 mov	 rax, QWORD PTR Left$[rsp]
  0005a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Right$[rsp]
  0005f	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  00064	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [rcx+8]
  00069	f3 0f 11 44 24
	08		 movss	 DWORD PTR Result$[rsp+8], xmm0

; 724  :         
; 725  :         return Result;

  0006f	48 8d 04 24	 lea	 rax, QWORD PTR Result$[rsp]
  00073	48 8b 7c 24 40	 mov	 rdi, QWORD PTR $T1[rsp]
  00078	48 8b f0	 mov	 rsi, rax
  0007b	b9 0c 00 00 00	 mov	 ecx, 12
  00080	f3 a4		 rep movsb
  00082	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]

; 726  :     }

  00087	48 8b 4c 24 10	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0008c	48 33 cc	 xor	 rcx, rsp
  0008f	e8 00 00 00 00	 call	 __security_check_cookie
  00094	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00098	5f		 pop	 rdi
  00099	5e		 pop	 rsi
  0009a	c3		 ret	 0
HMM_SubV3 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\HandmadeMath.h
_TEXT	SEGMENT
Result$ = 0
__$ArrayPad$ = 16
$T1 = 64
Left$ = 72
Right$ = 80
HMM_AddV3 PROC

; 671  :     {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 44 24 10	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 672  :         ASSERT_COVERED(HMM_AddV3);
; 673  :         
; 674  :         HMM_Vec3 Result;
; 675  :         Result.X = Left.X + Right.X;

  00024	48 8b 44 24 48	 mov	 rax, QWORD PTR Left$[rsp]
  00029	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Right$[rsp]
  0002e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [rax]
  00032	f3 0f 58 01	 addss	 xmm0, DWORD PTR [rcx]
  00036	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0

; 676  :         Result.Y = Left.Y + Right.Y;

  0003b	48 8b 44 24 48	 mov	 rax, QWORD PTR Left$[rsp]
  00040	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Right$[rsp]
  00045	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [rax+4]
  0004a	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [rcx+4]
  0004f	f3 0f 11 44 24
	04		 movss	 DWORD PTR Result$[rsp+4], xmm0

; 677  :         Result.Z = Left.Z + Right.Z;

  00055	48 8b 44 24 48	 mov	 rax, QWORD PTR Left$[rsp]
  0005a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR Right$[rsp]
  0005f	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [rax+8]
  00064	f3 0f 58 41 08	 addss	 xmm0, DWORD PTR [rcx+8]
  00069	f3 0f 11 44 24
	08		 movss	 DWORD PTR Result$[rsp+8], xmm0

; 678  :         
; 679  :         return Result;

  0006f	48 8d 04 24	 lea	 rax, QWORD PTR Result$[rsp]
  00073	48 8b 7c 24 40	 mov	 rdi, QWORD PTR $T1[rsp]
  00078	48 8b f0	 mov	 rsi, rax
  0007b	b9 0c 00 00 00	 mov	 ecx, 12
  00080	f3 a4		 rep movsb
  00082	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]

; 680  :     }

  00087	48 8b 4c 24 10	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0008c	48 33 cc	 xor	 rcx, rsp
  0008f	e8 00 00 00 00	 call	 __security_check_cookie
  00094	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00098	5f		 pop	 rdi
  00099	5e		 pop	 rsi
  0009a	c3		 ret	 0
HMM_AddV3 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\HandmadeMath.h
_TEXT	SEGMENT
$T1 = 0
Result$ = 16
__$ArrayPad$ = 32
$T2 = 64
Vector$ = 72
W$ = 80
HMM_V4V	PROC

; 634  :     {

  00000	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  00006	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 44 24 20	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 635  :         ASSERT_COVERED(HMM_V4V);
; 636  :         
; 637  :         HMM_Vec4 Result;
; 638  :         
; 639  : #ifdef HANDMADE_MATH__USE_SSE
; 640  :         Result.SSE = _mm_setr_ps(Vector.X, Vector.Y, Vector.Z, W);

  00023	f3 0f 10 44 24
	50		 movss	 xmm0, DWORD PTR W$[rsp]
  00029	48 8b 44 24 48	 mov	 rax, QWORD PTR Vector$[rsp]
  0002e	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [rax+8]
  00033	48 8b 44 24 48	 mov	 rax, QWORD PTR Vector$[rsp]
  00038	f3 0f 10 50 04	 movss	 xmm2, DWORD PTR [rax+4]
  0003d	48 8b 44 24 48	 mov	 rax, QWORD PTR Vector$[rsp]
  00042	f3 0f 10 18	 movss	 xmm3, DWORD PTR [rax]
  00046	0f 14 c8	 unpcklps xmm1, xmm0
  00049	0f 14 da	 unpcklps xmm3, xmm2
  0004c	0f 28 c3	 movaps	 xmm0, xmm3
  0004f	0f 16 c1	 movlhps xmm0, xmm1
  00052	0f 29 04 24	 movaps	 XMMWORD PTR $T1[rsp], xmm0
  00056	0f 28 04 24	 movaps	 xmm0, XMMWORD PTR $T1[rsp]
  0005a	0f 29 44 24 10	 movaps	 XMMWORD PTR Result$[rsp], xmm0

; 641  : #elif defined(HANDMADE_MATH__USE_NEON)
; 642  :         float32x4_t v = {Vector.X, Vector.Y, Vector.Z, W};
; 643  :         Result.NEON = v;
; 644  : #else
; 645  :         Result.XYZ = Vector;
; 646  :         Result.W = W;
; 647  : #endif
; 648  :         
; 649  :         return Result;

  0005f	48 8b 44 24 40	 mov	 rax, QWORD PTR $T2[rsp]
  00064	0f 28 44 24 10	 movaps	 xmm0, XMMWORD PTR Result$[rsp]
  00069	f3 0f 7f 00	 movdqu	 XMMWORD PTR [rax], xmm0
  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR $T2[rsp]

; 650  :     }

  00072	48 8b 4c 24 20	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00077	48 33 cc	 xor	 rcx, rsp
  0007a	e8 00 00 00 00	 call	 __security_check_cookie
  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
HMM_V4V	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\HandmadeMath.h
_TEXT	SEGMENT
Result$ = 0
__$ArrayPad$ = 16
$T1 = 64
X$ = 72
Y$ = 80
Z$ = 88
HMM_V3	PROC

; 599  :     {

  00000	f3 0f 11 5c 24
	20		 movss	 DWORD PTR [rsp+32], xmm3
  00006	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000c	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00012	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00017	56		 push	 rsi
  00018	57		 push	 rdi
  00019	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 44 24 10	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 600  :         ASSERT_COVERED(HMM_V3);
; 601  :         
; 602  :         HMM_Vec3 Result;
; 603  :         Result.X = X;

  0002c	f3 0f 10 44 24
	48		 movss	 xmm0, DWORD PTR X$[rsp]
  00032	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0

; 604  :         Result.Y = Y;

  00037	f3 0f 10 44 24
	50		 movss	 xmm0, DWORD PTR Y$[rsp]
  0003d	f3 0f 11 44 24
	04		 movss	 DWORD PTR Result$[rsp+4], xmm0

; 605  :         Result.Z = Z;

  00043	f3 0f 10 44 24
	58		 movss	 xmm0, DWORD PTR Z$[rsp]
  00049	f3 0f 11 44 24
	08		 movss	 DWORD PTR Result$[rsp+8], xmm0

; 606  :         
; 607  :         return Result;

  0004f	48 8d 04 24	 lea	 rax, QWORD PTR Result$[rsp]
  00053	48 8b 7c 24 40	 mov	 rdi, QWORD PTR $T1[rsp]
  00058	48 8b f0	 mov	 rsi, rax
  0005b	b9 0c 00 00 00	 mov	 ecx, 12
  00060	f3 a4		 rep movsb
  00062	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]

; 608  :     }

  00067	48 8b 4c 24 10	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0006c	48 33 cc	 xor	 rcx, rsp
  0006f	e8 00 00 00 00	 call	 __security_check_cookie
  00074	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00078	5f		 pop	 rdi
  00079	5e		 pop	 rsi
  0007a	c3		 ret	 0
HMM_V3	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\HandmadeMath.h
_TEXT	SEGMENT
Result$ = 0
__$ArrayPad$ = 8
X$ = 32
Y$ = 40
HMM_V2	PROC

; 587  :     {

  00000	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00006	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  0000c	48 83 ec 18	 sub	 rsp, 24
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 08	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 588  :         ASSERT_COVERED(HMM_V2);
; 589  :         
; 590  :         HMM_Vec2 Result;
; 591  :         Result.X = X;

  0001f	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR X$[rsp]
  00025	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0

; 592  :         Result.Y = Y;

  0002a	f3 0f 10 44 24
	28		 movss	 xmm0, DWORD PTR Y$[rsp]
  00030	f3 0f 11 44 24
	04		 movss	 DWORD PTR Result$[rsp+4], xmm0

; 593  :         
; 594  :         return Result;

  00036	48 8b 04 24	 mov	 rax, QWORD PTR Result$[rsp]

; 595  :     }

  0003a	48 8b 4c 24 08	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0003f	48 33 cc	 xor	 rcx, rsp
  00042	e8 00 00 00 00	 call	 __security_check_cookie
  00047	48 83 c4 18	 add	 rsp, 24
  0004b	c3		 ret	 0
HMM_V2	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\HandmadeMath.h
_TEXT	SEGMENT
Result$ = 32
Float$ = 64
HMM_InvSqrtF PROC

; 538  :     {

  00000	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00006	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 539  :         ASSERT_COVERED(HMM_InvSqrtF);
; 540  :         
; 541  :         float Result;
; 542  :         
; 543  :         Result = 1.0f/HMM_SqrtF(Float);

  0000a	f3 0f 10 44 24
	40		 movss	 xmm0, DWORD PTR Float$[rsp]
  00010	e8 00 00 00 00	 call	 HMM_SqrtF
  00015	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  0001d	f3 0f 5e c8	 divss	 xmm1, xmm0
  00021	0f 28 c1	 movaps	 xmm0, xmm1
  00024	f3 0f 11 44 24
	20		 movss	 DWORD PTR Result$[rsp], xmm0

; 544  :         
; 545  :         return Result;

  0002a	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR Result$[rsp]

; 546  :     }

  00030	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00034	c3		 ret	 0
HMM_InvSqrtF ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\HandmadeMath.h
_TEXT	SEGMENT
tv70 = 0
Result$ = 4
$T1 = 16
In$ = 32
$T2 = 48
Out$ = 64
Float$ = 96
HMM_SqrtF PROC

; 516  :     {

  00000	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00006	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 517  :         ASSERT_COVERED(HMM_SqrtF);
; 518  :         
; 519  :         float Result;
; 520  :         
; 521  : #ifdef HANDMADE_MATH__USE_SSE
; 522  :         __m128 In = _mm_set_ss(Float);

  0000a	f3 0f 10 44 24
	60		 movss	 xmm0, DWORD PTR Float$[rsp]
  00010	0f 57 c9	 xorps	 xmm1, xmm1
  00013	f3 0f 10 c8	 movss	 xmm1, xmm0
  00017	0f 28 c1	 movaps	 xmm0, xmm1
  0001a	0f 29 44 24 10	 movaps	 XMMWORD PTR $T1[rsp], xmm0
  0001f	0f 28 44 24 10	 movaps	 xmm0, XMMWORD PTR $T1[rsp]
  00024	0f 29 44 24 20	 movaps	 XMMWORD PTR In$[rsp], xmm0

; 523  :         __m128 Out = _mm_sqrt_ss(In);

  00029	0f 28 44 24 20	 movaps	 xmm0, XMMWORD PTR In$[rsp]
  0002e	f3 0f 51 c0	 sqrtss	 xmm0, xmm0
  00032	0f 29 44 24 30	 movaps	 XMMWORD PTR $T2[rsp], xmm0
  00037	0f 28 44 24 30	 movaps	 xmm0, XMMWORD PTR $T2[rsp]
  0003c	0f 29 44 24 40	 movaps	 XMMWORD PTR Out$[rsp], xmm0

; 524  :         Result = _mm_cvtss_f32(Out);

  00041	0f 28 44 24 40	 movaps	 xmm0, XMMWORD PTR Out$[rsp]
  00046	f3 0f 11 04 24	 movss	 DWORD PTR tv70[rsp], xmm0
  0004b	f3 0f 10 04 24	 movss	 xmm0, DWORD PTR tv70[rsp]
  00050	f3 0f 11 44 24
	04		 movss	 DWORD PTR Result$[rsp], xmm0

; 525  : #elif defined(HANDMADE_MATH__USE_NEON)
; 526  :         float32x4_t In = vdupq_n_f32(Float);
; 527  :         float32x4_t Out = vsqrtq_f32(In);
; 528  :         Result = vgetq_lane_f32(Out, 0);
; 529  : #else
; 530  :         Result = HMM_SQRTF(Float);
; 531  : #endif
; 532  :         
; 533  :         return Result;

  00056	f3 0f 10 44 24
	04		 movss	 xmm0, DWORD PTR Result$[rsp]

; 534  :     }

  0005c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00060	c3		 ret	 0
HMM_SqrtF ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\HandmadeMath.h
_TEXT	SEGMENT
Angle$ = 48
HMM_TanF PROC

; 502  :     {

  00000	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00006	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 503  :         ASSERT_COVERED(HMM_TanF);
; 504  :         return HMM_TANF(HMM_ANGLE_USER_TO_INTERNAL(Angle));

  0000a	f3 0f 10 44 24
	30		 movss	 xmm0, DWORD PTR Angle$[rsp]
  00010	e8 00 00 00 00	 call	 tanf

; 505  :     }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
HMM_TanF ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\HandmadeMath.h
_TEXT	SEGMENT
Angle$ = 48
HMM_CosF PROC

; 495  :     {

  00000	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00006	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 496  :         ASSERT_COVERED(HMM_CosF);
; 497  :         return HMM_COSF(HMM_ANGLE_USER_TO_INTERNAL(Angle));

  0000a	f3 0f 10 44 24
	30		 movss	 xmm0, DWORD PTR Angle$[rsp]
  00010	e8 00 00 00 00	 call	 cosf

; 498  :     }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
HMM_CosF ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\HandmadeMath.h
_TEXT	SEGMENT
Angle$ = 48
HMM_SinF PROC

; 488  :     {

  00000	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00006	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 489  :         ASSERT_COVERED(HMM_SinF);
; 490  :         return HMM_SINF(HMM_ANGLE_USER_TO_INTERNAL(Angle));

  0000a	f3 0f 10 44 24
	30		 movss	 xmm0, DWORD PTR Angle$[rsp]
  00010	e8 00 00 00 00	 call	 sinf

; 491  :     }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
HMM_SinF ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\HandmadeMath.h
_TEXT	SEGMENT
Result$ = 0
Angle$ = 32
HMM_ToRad PROC

; 444  :     {

  00000	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  00006	48 83 ec 18	 sub	 rsp, 24

; 445  : #if defined(HANDMADE_MATH_USE_RADIANS)
; 446  :         float Result = Angle;
; 447  : #elif defined(HANDMADE_MATH_USE_DEGREES)
; 448  :         float Result = Angle * HMM_DegToRad;

  0000a	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR Angle$[rsp]
  00010	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3c8efa35
  00018	f3 0f 11 04 24	 movss	 DWORD PTR Result$[rsp], xmm0

; 449  : #elif defined(HANDMADE_MATH_USE_TURNS)
; 450  :         float Result = Angle * HMM_TurnToRad;
; 451  : #endif
; 452  :         
; 453  :         return Result;

  0001d	f3 0f 10 04 24	 movss	 xmm0, DWORD PTR Result$[rsp]

; 454  :     }

  00022	48 83 c4 18	 add	 rsp, 24
  00026	c3		 ret	 0
HMM_ToRad ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.18362.0\ucrt\corecrt_math.h
;	COMDAT ldexpf
_TEXT	SEGMENT
_X$ = 48
_Y$ = 56
ldexpf	PROC						; COMDAT

; 707  :     {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	f3 0f 11 44 24
	08		 movss	 DWORD PTR [rsp+8], xmm0
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 708  :         return (float)ldexp(_X, _Y);

  0000e	f3 0f 5a 44 24
	30		 cvtss2sd xmm0, DWORD PTR _X$[rsp]
  00014	8b 54 24 38	 mov	 edx, DWORD PTR _Y$[rsp]
  00018	e8 00 00 00 00	 call	 ldexp
  0001d	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0

; 709  :     }

  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	c3		 ret	 0
ldexpf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0ImGuiIO@@QEAA@AEBU0@@Z
_TEXT	SEGMENT
this$ = 64
__that$ = 72
??0ImGuiIO@@QEAA@AEBU0@@Z PROC				; ImGuiIO::ImGuiIO, COMDAT
$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00015	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  0001a	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0001c	89 08		 mov	 DWORD PTR [rax], ecx
  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00023	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00028	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  0002b	89 48 04	 mov	 DWORD PTR [rax+4], ecx
  0002e	48 8b 44 24 48	 mov	 rax, QWORD PTR __that$[rsp]
  00033	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00037	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0003c	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00040	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00045	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  0004a	f3 0f 10 41 10	 movss	 xmm0, DWORD PTR [rcx+16]
  0004f	f3 0f 11 40 10	 movss	 DWORD PTR [rax+16], xmm0
  00054	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00059	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  0005e	f3 0f 10 41 14	 movss	 xmm0, DWORD PTR [rcx+20]
  00063	f3 0f 11 40 14	 movss	 DWORD PTR [rax+20], xmm0
  00068	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0006d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00072	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00076	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx
  0007a	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0007f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00084	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00088	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx
  0008c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00091	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00096	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0009a	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx
  0009e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000a3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  000a8	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  000ac	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx
  000b0	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000b5	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  000ba	f3 0f 10 41 38	 movss	 xmm0, DWORD PTR [rcx+56]
  000bf	f3 0f 11 40 38	 movss	 DWORD PTR [rax+56], xmm0
  000c4	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000c9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  000ce	0f b6 49 3c	 movzx	 ecx, BYTE PTR [rcx+60]
  000d2	88 48 3c	 mov	 BYTE PTR [rax+60], cl
  000d5	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000da	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  000df	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  000e3	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx
  000e7	48 8b 44 24 48	 mov	 rax, QWORD PTR __that$[rsp]
  000ec	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  000f0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  000f5	48 89 41 48	 mov	 QWORD PTR [rcx+72], rax
  000f9	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  000fe	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00103	0f b6 49 50	 movzx	 ecx, BYTE PTR [rcx+80]
  00107	88 48 50	 mov	 BYTE PTR [rax+80], cl
  0010a	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0010f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00114	0f b6 49 51	 movzx	 ecx, BYTE PTR [rcx+81]
  00118	88 48 51	 mov	 BYTE PTR [rax+81], cl
  0011b	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00120	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00125	0f b6 49 52	 movzx	 ecx, BYTE PTR [rcx+82]
  00129	88 48 52	 mov	 BYTE PTR [rax+82], cl
  0012c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00131	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00136	0f b6 49 53	 movzx	 ecx, BYTE PTR [rcx+83]
  0013a	88 48 53	 mov	 BYTE PTR [rax+83], cl
  0013d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00142	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00147	0f b6 49 54	 movzx	 ecx, BYTE PTR [rcx+84]
  0014b	88 48 54	 mov	 BYTE PTR [rax+84], cl
  0014e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00153	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00158	0f b6 49 55	 movzx	 ecx, BYTE PTR [rcx+85]
  0015c	88 48 55	 mov	 BYTE PTR [rax+85], cl
  0015f	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00164	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00169	0f b6 49 56	 movzx	 ecx, BYTE PTR [rcx+86]
  0016d	88 48 56	 mov	 BYTE PTR [rax+86], cl
  00170	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00175	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  0017a	0f b6 49 57	 movzx	 ecx, BYTE PTR [rcx+87]
  0017e	88 48 57	 mov	 BYTE PTR [rax+87], cl
  00181	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00186	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  0018b	0f b6 49 58	 movzx	 ecx, BYTE PTR [rcx+88]
  0018f	88 48 58	 mov	 BYTE PTR [rax+88], cl
  00192	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00197	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  0019c	0f b6 49 59	 movzx	 ecx, BYTE PTR [rcx+89]
  001a0	88 48 59	 mov	 BYTE PTR [rax+89], cl
  001a3	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  001a8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  001ad	0f b6 49 5a	 movzx	 ecx, BYTE PTR [rcx+90]
  001b1	88 48 5a	 mov	 BYTE PTR [rax+90], cl
  001b4	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  001b9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  001be	0f b6 49 5b	 movzx	 ecx, BYTE PTR [rcx+91]
  001c2	88 48 5b	 mov	 BYTE PTR [rax+91], cl
  001c5	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  001ca	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  001cf	0f b6 49 5c	 movzx	 ecx, BYTE PTR [rcx+92]
  001d3	88 48 5c	 mov	 BYTE PTR [rax+92], cl
  001d6	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  001db	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  001e0	0f b6 49 5d	 movzx	 ecx, BYTE PTR [rcx+93]
  001e4	88 48 5d	 mov	 BYTE PTR [rax+93], cl
  001e7	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  001ec	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  001f1	0f b6 49 5e	 movzx	 ecx, BYTE PTR [rcx+94]
  001f5	88 48 5e	 mov	 BYTE PTR [rax+94], cl
  001f8	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  001fd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00202	0f b6 49 5f	 movzx	 ecx, BYTE PTR [rcx+95]
  00206	88 48 5f	 mov	 BYTE PTR [rax+95], cl
  00209	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0020e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00213	f3 0f 10 41 60	 movss	 xmm0, DWORD PTR [rcx+96]
  00218	f3 0f 11 40 60	 movss	 DWORD PTR [rax+96], xmm0
  0021d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00222	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00227	f3 0f 10 41 64	 movss	 xmm0, DWORD PTR [rcx+100]
  0022c	f3 0f 11 40 64	 movss	 DWORD PTR [rax+100], xmm0
  00231	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00236	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  0023b	f3 0f 10 41 68	 movss	 xmm0, DWORD PTR [rcx+104]
  00240	f3 0f 11 40 68	 movss	 DWORD PTR [rax+104], xmm0
  00245	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0024a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  0024f	f3 0f 10 41 6c	 movss	 xmm0, DWORD PTR [rcx+108]
  00254	f3 0f 11 40 6c	 movss	 DWORD PTR [rax+108], xmm0
  00259	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0025e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00263	f3 0f 10 41 70	 movss	 xmm0, DWORD PTR [rcx+112]
  00268	f3 0f 11 40 70	 movss	 DWORD PTR [rax+112], xmm0
  0026d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00272	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00277	f3 0f 10 41 74	 movss	 xmm0, DWORD PTR [rcx+116]
  0027c	f3 0f 11 40 74	 movss	 DWORD PTR [rax+116], xmm0
  00281	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00286	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  0028b	0f b6 49 78	 movzx	 ecx, BYTE PTR [rcx+120]
  0028f	88 48 78	 mov	 BYTE PTR [rax+120], cl
  00292	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00297	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  0029c	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  002a0	88 48 79	 mov	 BYTE PTR [rax+121], cl
  002a3	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  002a8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  002ad	0f b6 49 7a	 movzx	 ecx, BYTE PTR [rcx+122]
  002b1	88 48 7a	 mov	 BYTE PTR [rax+122], cl
  002b4	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  002b9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  002be	0f b6 49 7b	 movzx	 ecx, BYTE PTR [rcx+123]
  002c2	88 48 7b	 mov	 BYTE PTR [rax+123], cl
  002c5	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  002ca	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  002cf	0f b6 49 7c	 movzx	 ecx, BYTE PTR [rcx+124]
  002d3	88 48 7c	 mov	 BYTE PTR [rax+124], cl
  002d6	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  002db	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  002e0	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  002e7	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx
  002ee	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  002f3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  002f8	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  002ff	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx
  00306	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0030b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00310	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  00317	48 89 88 90 00
	00 00		 mov	 QWORD PTR [rax+144], rcx
  0031e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00323	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00328	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  0032f	48 89 88 98 00
	00 00		 mov	 QWORD PTR [rax+152], rcx
  00336	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0033b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00340	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00347	48 89 88 a0 00
	00 00		 mov	 QWORD PTR [rax+160], rcx
  0034e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00353	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00358	48 8b 89 a8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+168]
  0035f	48 89 88 a8 00
	00 00		 mov	 QWORD PTR [rax+168], rcx
  00366	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0036b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00370	48 8b 89 b0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+176]
  00377	48 89 88 b0 00
	00 00		 mov	 QWORD PTR [rax+176], rcx
  0037e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00383	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00388	48 8b 89 b8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+184]
  0038f	48 89 88 b8 00
	00 00		 mov	 QWORD PTR [rax+184], rcx
  00396	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0039b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  003a0	48 8b 89 c0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+192]
  003a7	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx
  003ae	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  003b3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  003b8	0f b7 89 c8 00
	00 00		 movzx	 ecx, WORD PTR [rcx+200]
  003bf	66 89 88 c8 00
	00 00		 mov	 WORD PTR [rax+200], cx
  003c6	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  003cb	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  003d0	0f b6 89 ca 00
	00 00		 movzx	 ecx, BYTE PTR [rcx+202]
  003d7	88 88 ca 00 00
	00		 mov	 BYTE PTR [rax+202], cl
  003dd	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  003e2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  003e7	0f b6 89 cb 00
	00 00		 movzx	 ecx, BYTE PTR [rcx+203]
  003ee	88 88 cb 00 00
	00		 mov	 BYTE PTR [rax+203], cl
  003f4	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  003f9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  003fe	0f b6 89 cc 00
	00 00		 movzx	 ecx, BYTE PTR [rcx+204]
  00405	88 88 cc 00 00
	00		 mov	 BYTE PTR [rax+204], cl
  0040b	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00410	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00415	0f b6 89 cd 00
	00 00		 movzx	 ecx, BYTE PTR [rcx+205]
  0041c	88 88 cd 00 00
	00		 mov	 BYTE PTR [rax+205], cl
  00422	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00427	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  0042c	0f b6 89 ce 00
	00 00		 movzx	 ecx, BYTE PTR [rcx+206]
  00433	88 88 ce 00 00
	00		 mov	 BYTE PTR [rax+206], cl
  00439	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0043e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00443	0f b6 89 cf 00
	00 00		 movzx	 ecx, BYTE PTR [rcx+207]
  0044a	88 88 cf 00 00
	00		 mov	 BYTE PTR [rax+207], cl
  00450	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00455	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  0045a	0f b6 89 d0 00
	00 00		 movzx	 ecx, BYTE PTR [rcx+208]
  00461	88 88 d0 00 00
	00		 mov	 BYTE PTR [rax+208], cl
  00467	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0046c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00471	f3 0f 10 81 d4
	00 00 00	 movss	 xmm0, DWORD PTR [rcx+212]
  00479	f3 0f 11 80 d4
	00 00 00	 movss	 DWORD PTR [rax+212], xmm0
  00481	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00486	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  0048b	8b 89 d8 00 00
	00		 mov	 ecx, DWORD PTR [rcx+216]
  00491	89 88 d8 00 00
	00		 mov	 DWORD PTR [rax+216], ecx
  00497	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0049c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  004a1	8b 89 dc 00 00
	00		 mov	 ecx, DWORD PTR [rcx+220]
  004a7	89 88 dc 00 00
	00		 mov	 DWORD PTR [rax+220], ecx
  004ad	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  004b2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  004b7	8b 89 e0 00 00
	00		 mov	 ecx, DWORD PTR [rcx+224]
  004bd	89 88 e0 00 00
	00		 mov	 DWORD PTR [rax+224], ecx
  004c3	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  004c8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  004cd	8b 89 e4 00 00
	00		 mov	 ecx, DWORD PTR [rcx+228]
  004d3	89 88 e4 00 00
	00		 mov	 DWORD PTR [rax+228], ecx
  004d9	48 8b 44 24 48	 mov	 rax, QWORD PTR __that$[rsp]
  004de	48 8b 80 e8 00
	00 00		 mov	 rax, QWORD PTR [rax+232]
  004e5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  004ea	48 89 81 e8 00
	00 00		 mov	 QWORD PTR [rcx+232], rax
  004f1	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  004f6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  004fb	48 8d b8 f0 00
	00 00		 lea	 rdi, QWORD PTR [rax+240]
  00502	48 8d b1 f0 00
	00 00		 lea	 rsi, QWORD PTR [rcx+240]
  00509	b9 68 0a 00 00	 mov	 ecx, 2664		; 00000a68H
  0050e	f3 a4		 rep movsb
  00510	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00515	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  0051a	48 8d b8 58 0b
	00 00		 lea	 rdi, QWORD PTR [rax+2904]
  00521	48 8d b1 58 0b
	00 00		 lea	 rsi, QWORD PTR [rcx+2904]
  00528	b9 9a 02 00 00	 mov	 ecx, 666		; 0000029aH
  0052d	f3 a4		 rep movsb
  0052f	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00534	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00539	48 8d b8 f4 0d
	00 00		 lea	 rdi, QWORD PTR [rax+3572]
  00540	48 8d b1 f4 0d
	00 00		 lea	 rsi, QWORD PTR [rcx+3572]
  00547	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0054c	f3 a4		 rep movsb
  0054e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00553	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00558	48 8b 89 38 0e
	00 00		 mov	 rcx, QWORD PTR [rcx+3640]
  0055f	48 89 88 38 0e
	00 00		 mov	 QWORD PTR [rax+3640], rcx
  00566	48 8b 44 24 48	 mov	 rax, QWORD PTR __that$[rsp]
  0056b	48 8b 80 40 0e
	00 00		 mov	 rax, QWORD PTR [rax+3648]
  00572	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  00577	48 89 81 40 0e
	00 00		 mov	 QWORD PTR [rcx+3648], rax
  0057e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00583	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00588	48 8d b8 48 0e
	00 00		 lea	 rdi, QWORD PTR [rax+3656]
  0058f	48 8d b1 48 0e
	00 00		 lea	 rsi, QWORD PTR [rcx+3656]
  00596	b9 05 00 00 00	 mov	 ecx, 5
  0059b	f3 a4		 rep movsb
  0059d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  005a2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  005a7	f3 0f 10 81 50
	0e 00 00	 movss	 xmm0, DWORD PTR [rcx+3664]
  005af	f3 0f 11 80 50
	0e 00 00	 movss	 DWORD PTR [rax+3664], xmm0
  005b7	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  005bc	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  005c1	f3 0f 10 81 54
	0e 00 00	 movss	 xmm0, DWORD PTR [rcx+3668]
  005c9	f3 0f 11 80 54
	0e 00 00	 movss	 DWORD PTR [rax+3668], xmm0
  005d1	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  005d6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  005db	8b 89 58 0e 00
	00		 mov	 ecx, DWORD PTR [rcx+3672]
  005e1	89 88 58 0e 00
	00		 mov	 DWORD PTR [rax+3672], ecx
  005e7	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  005ec	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  005f1	8b 89 5c 0e 00
	00		 mov	 ecx, DWORD PTR [rcx+3676]
  005f7	89 88 5c 0e 00
	00		 mov	 DWORD PTR [rax+3676], ecx
  005fd	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00602	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00607	0f b6 89 60 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3680]
  0060e	88 88 60 0e 00
	00		 mov	 BYTE PTR [rax+3680], cl
  00614	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00619	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  0061e	0f b6 89 61 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3681]
  00625	88 88 61 0e 00
	00		 mov	 BYTE PTR [rax+3681], cl
  0062b	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00630	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00635	0f b6 89 62 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3682]
  0063c	88 88 62 0e 00
	00		 mov	 BYTE PTR [rax+3682], cl
  00642	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00647	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  0064c	0f b6 89 63 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3683]
  00653	88 88 63 0e 00
	00		 mov	 BYTE PTR [rax+3683], cl
  00659	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0065e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00663	8b 89 64 0e 00
	00		 mov	 ecx, DWORD PTR [rcx+3684]
  00669	89 88 64 0e 00
	00		 mov	 DWORD PTR [rax+3684], ecx
  0066f	48 8b 44 24 48	 mov	 rax, QWORD PTR __that$[rsp]
  00674	48 05 68 0e 00
	00		 add	 rax, 3688		; 00000e68H
  0067a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0067f	48 81 c1 68 0e
	00 00		 add	 rcx, 3688		; 00000e68H
  00686	48 8b f9	 mov	 rdi, rcx
  00689	48 8b f0	 mov	 rsi, rax
  0068c	b9 a0 29 00 00	 mov	 ecx, 10656		; 000029a0H
  00691	f3 a4		 rep movsb
  00693	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00698	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  0069d	0f b6 89 08 38
	00 00		 movzx	 ecx, BYTE PTR [rcx+14344]
  006a4	88 88 08 38 00
	00		 mov	 BYTE PTR [rax+14344], cl
  006aa	48 8b 44 24 48	 mov	 rax, QWORD PTR __that$[rsp]
  006af	48 8b 80 0c 38
	00 00		 mov	 rax, QWORD PTR [rax+14348]
  006b6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  006bb	48 89 81 0c 38
	00 00		 mov	 QWORD PTR [rcx+14348], rax
  006c2	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  006c7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  006cc	48 8d b8 14 38
	00 00		 lea	 rdi, QWORD PTR [rax+14356]
  006d3	48 8d b1 14 38
	00 00		 lea	 rsi, QWORD PTR [rcx+14356]
  006da	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  006df	f3 a4		 rep movsb
  006e1	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  006e6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  006eb	48 8d b8 40 38
	00 00		 lea	 rdi, QWORD PTR [rax+14400]
  006f2	48 8d b1 40 38
	00 00		 lea	 rsi, QWORD PTR [rcx+14400]
  006f9	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  006fe	f3 a4		 rep movsb
  00700	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00705	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  0070a	48 8d b8 68 38
	00 00		 lea	 rdi, QWORD PTR [rax+14440]
  00711	48 8d b1 68 38
	00 00		 lea	 rsi, QWORD PTR [rcx+14440]
  00718	b9 05 00 00 00	 mov	 ecx, 5
  0071d	f3 a4		 rep movsb
  0071f	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00724	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00729	48 8d b8 6d 38
	00 00		 lea	 rdi, QWORD PTR [rax+14445]
  00730	48 8d b1 6d 38
	00 00		 lea	 rsi, QWORD PTR [rcx+14445]
  00737	b9 05 00 00 00	 mov	 ecx, 5
  0073c	f3 a4		 rep movsb
  0073e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00743	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00748	48 8d b8 72 38
	00 00		 lea	 rdi, QWORD PTR [rax+14450]
  0074f	48 8d b1 72 38
	00 00		 lea	 rsi, QWORD PTR [rcx+14450]
  00756	b9 0a 00 00 00	 mov	 ecx, 10
  0075b	f3 a4		 rep movsb
  0075d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00762	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00767	48 8d b8 7c 38
	00 00		 lea	 rdi, QWORD PTR [rax+14460]
  0076e	48 8d b1 7c 38
	00 00		 lea	 rsi, QWORD PTR [rcx+14460]
  00775	b9 0a 00 00 00	 mov	 ecx, 10
  0077a	f3 a4		 rep movsb
  0077c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00781	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00786	48 8d b8 86 38
	00 00		 lea	 rdi, QWORD PTR [rax+14470]
  0078d	48 8d b1 86 38
	00 00		 lea	 rsi, QWORD PTR [rcx+14470]
  00794	b9 05 00 00 00	 mov	 ecx, 5
  00799	f3 a4		 rep movsb
  0079b	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  007a0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  007a5	48 8d b8 8b 38
	00 00		 lea	 rdi, QWORD PTR [rax+14475]
  007ac	48 8d b1 8b 38
	00 00		 lea	 rsi, QWORD PTR [rcx+14475]
  007b3	b9 05 00 00 00	 mov	 ecx, 5
  007b8	f3 a4		 rep movsb
  007ba	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  007bf	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  007c4	48 8d b8 90 38
	00 00		 lea	 rdi, QWORD PTR [rax+14480]
  007cb	48 8d b1 90 38
	00 00		 lea	 rsi, QWORD PTR [rcx+14480]
  007d2	b9 05 00 00 00	 mov	 ecx, 5
  007d7	f3 a4		 rep movsb
  007d9	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  007de	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  007e3	0f b6 89 95 38
	00 00		 movzx	 ecx, BYTE PTR [rcx+14485]
  007ea	88 88 95 38 00
	00		 mov	 BYTE PTR [rax+14485], cl
  007f0	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  007f5	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  007fa	48 8d b8 98 38
	00 00		 lea	 rdi, QWORD PTR [rax+14488]
  00801	48 8d b1 98 38
	00 00		 lea	 rsi, QWORD PTR [rcx+14488]
  00808	b9 14 00 00 00	 mov	 ecx, 20
  0080d	f3 a4		 rep movsb
  0080f	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00814	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00819	48 8d b8 ac 38
	00 00		 lea	 rdi, QWORD PTR [rax+14508]
  00820	48 8d b1 ac 38
	00 00		 lea	 rsi, QWORD PTR [rcx+14508]
  00827	b9 14 00 00 00	 mov	 ecx, 20
  0082c	f3 a4		 rep movsb
  0082e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00833	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00838	48 8d b8 c0 38
	00 00		 lea	 rdi, QWORD PTR [rax+14528]
  0083f	48 8d b1 c0 38
	00 00		 lea	 rsi, QWORD PTR [rcx+14528]
  00846	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  0084b	f3 a4		 rep movsb
  0084d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00852	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00857	48 8d b8 e8 38
	00 00		 lea	 rdi, QWORD PTR [rax+14568]
  0085e	48 8d b1 e8 38
	00 00		 lea	 rsi, QWORD PTR [rcx+14568]
  00865	b9 14 00 00 00	 mov	 ecx, 20
  0086a	f3 a4		 rep movsb
  0086c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00871	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00876	f3 0f 10 81 fc
	38 00 00	 movss	 xmm0, DWORD PTR [rcx+14588]
  0087e	f3 0f 11 80 fc
	38 00 00	 movss	 DWORD PTR [rax+14588], xmm0
  00886	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0088b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  00890	0f b6 89 00 39
	00 00		 movzx	 ecx, BYTE PTR [rcx+14592]
  00897	88 88 00 39 00
	00		 mov	 BYTE PTR [rax+14592], cl
  0089d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  008a2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  008a7	0f b6 89 01 39
	00 00		 movzx	 ecx, BYTE PTR [rcx+14593]
  008ae	88 88 01 39 00
	00		 mov	 BYTE PTR [rax+14593], cl
  008b4	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  008b9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  008be	0f b6 89 02 39
	00 00		 movzx	 ecx, BYTE PTR [rcx+14594]
  008c5	88 88 02 39 00
	00		 mov	 BYTE PTR [rax+14594], cl
  008cb	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  008d0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  008d5	0f b6 89 03 39
	00 00		 movzx	 ecx, BYTE PTR [rcx+14595]
  008dc	88 88 03 39 00
	00		 mov	 BYTE PTR [rax+14595], cl
  008e2	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  008e7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __that$[rsp]
  008ec	0f b7 89 04 39
	00 00		 movzx	 ecx, WORD PTR [rcx+14596]
  008f3	66 89 88 04 39
	00 00		 mov	 WORD PTR [rax+14596], cx
  008fa	48 8b 44 24 48	 mov	 rax, QWORD PTR __that$[rsp]
  008ff	48 05 08 39 00
	00		 add	 rax, 14600		; 00003908H
  00905	48 8b 4c 24 40	 mov	 rcx, QWORD PTR this$[rsp]
  0090a	48 81 c1 08 39
	00 00		 add	 rcx, 14600		; 00003908H
  00911	48 8b d0	 mov	 rdx, rax
  00914	e8 00 00 00 00	 call	 ??0?$ImVector@G@@QEAA@AEBU0@@Z ; ImVector<unsigned short>::ImVector<unsigned short>
  00919	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  0091e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00922	5f		 pop	 rdi
  00923	5e		 pop	 rsi
  00924	c3		 ret	 0
??0ImGuiIO@@QEAA@AEBU0@@Z ENDP				; ImGuiIO::ImGuiIO
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1ImGuiIO@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ImGuiIO@@QEAA@XZ PROC				; ImGuiIO::~ImGuiIO, COMDAT
$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 05 08 39 00
	00		 add	 rax, 14600		; 00003908H
  00014	48 8b c8	 mov	 rcx, rax
  00017	e8 00 00 00 00	 call	 ??1?$ImVector@G@@QEAA@XZ ; ImVector<unsigned short>::~ImVector<unsigned short>
  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
??1ImGuiIO@@QEAA@XZ ENDP				; ImGuiIO::~ImGuiIO
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\imgui\imgui.h
;	COMDAT ?reserve@?$ImVector@G@@QEAAXH@Z
_TEXT	SEGMENT
new_data$ = 32
this$ = 64
new_capacity$ = 72
?reserve@?$ImVector@G@@QEAAXH@Z PROC			; ImVector<unsigned short>::reserve, COMDAT

; 2028 :     inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00015	39 44 24 48	 cmp	 DWORD PTR new_capacity$[rsp], eax
  00019	7f 02		 jg	 SHORT $LN2@reserve
  0001b	eb 6a		 jmp	 SHORT $LN1@reserve
$LN2@reserve:
  0001d	48 63 44 24 48	 movsxd	 rax, DWORD PTR new_capacity$[rsp]
  00022	48 d1 e0	 shl	 rax, 1
  00025	48 8b c8	 mov	 rcx, rax
  00028	e8 00 00 00 00	 call	 ?MemAlloc@ImGui@@YAPEAX_K@Z ; ImGui::MemAlloc
  0002d	48 89 44 24 20	 mov	 QWORD PTR new_data$[rsp], rax
  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00037	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0003c	74 2f		 je	 SHORT $LN3@reserve
  0003e	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00043	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00046	48 d1 e0	 shl	 rax, 1
  00049	4c 8b c0	 mov	 r8, rax
  0004c	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00051	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00055	48 8b 4c 24 20	 mov	 rcx, QWORD PTR new_data$[rsp]
  0005a	e8 00 00 00 00	 call	 memcpy
  0005f	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00064	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00068	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPEAX@Z ; ImGui::MemFree
$LN3@reserve:
  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00072	48 8b 4c 24 20	 mov	 rcx, QWORD PTR new_data$[rsp]
  00077	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  0007b	48 8b 44 24 40	 mov	 rax, QWORD PTR this$[rsp]
  00080	8b 4c 24 48	 mov	 ecx, DWORD PTR new_capacity$[rsp]
  00084	89 48 04	 mov	 DWORD PTR [rax+4], ecx
$LN1@reserve:
  00087	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008b	c3		 ret	 0
?reserve@?$ImVector@G@@QEAAXH@Z ENDP			; ImVector<unsigned short>::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\imgui\imgui.h
;	COMDAT ?resize@?$ImVector@G@@QEAAXH@Z
_TEXT	SEGMENT
this$ = 48
new_size$ = 56
?resize@?$ImVector@G@@QEAAXH@Z PROC			; ImVector<unsigned short>::resize, COMDAT

; 2025 :     inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }

$LN4:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00015	39 44 24 38	 cmp	 DWORD PTR new_size$[rsp], eax
  00019	7e 1a		 jle	 SHORT $LN2@resize
  0001b	8b 54 24 38	 mov	 edx, DWORD PTR new_size$[rsp]
  0001f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00024	e8 00 00 00 00	 call	 ?_grow_capacity@?$ImVector@G@@QEBAHH@Z ; ImVector<unsigned short>::_grow_capacity
  00029	8b d0		 mov	 edx, eax
  0002b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00030	e8 00 00 00 00	 call	 ?reserve@?$ImVector@G@@QEAAXH@Z ; ImVector<unsigned short>::reserve
$LN2@resize:
  00035	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0003a	8b 4c 24 38	 mov	 ecx, DWORD PTR new_size$[rsp]
  0003e	89 08		 mov	 DWORD PTR [rax], ecx
  00040	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00044	c3		 ret	 0
?resize@?$ImVector@G@@QEAAXH@Z ENDP			; ImVector<unsigned short>::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\imgui\imgui.h
;	COMDAT ?_grow_capacity@?$ImVector@G@@QEBAHH@Z
_TEXT	SEGMENT
tv70 = 0
new_capacity$ = 4
tv72 = 8
this$ = 32
sz$ = 40
?_grow_capacity@?$ImVector@G@@QEBAHH@Z PROC		; ImVector<unsigned short>::_grow_capacity, COMDAT

; 2024 :     inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }

$LN7:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24
  0000d	48 8b 44 24 20	 mov	 rax, QWORD PTR this$[rsp]
  00012	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00016	74 1a		 je	 SHORT $LN3@grow_capac
  00018	48 8b 44 24 20	 mov	 rax, QWORD PTR this$[rsp]
  0001d	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00020	99		 cdq
  00021	2b c2		 sub	 eax, edx
  00023	d1 f8		 sar	 eax, 1
  00025	48 8b 4c 24 20	 mov	 rcx, QWORD PTR this$[rsp]
  0002a	03 41 04	 add	 eax, DWORD PTR [rcx+4]
  0002d	89 04 24	 mov	 DWORD PTR tv70[rsp], eax
  00030	eb 07		 jmp	 SHORT $LN4@grow_capac
$LN3@grow_capac:
  00032	c7 04 24 08 00
	00 00		 mov	 DWORD PTR tv70[rsp], 8
$LN4@grow_capac:
  00039	8b 04 24	 mov	 eax, DWORD PTR tv70[rsp]
  0003c	89 44 24 04	 mov	 DWORD PTR new_capacity$[rsp], eax
  00040	8b 44 24 28	 mov	 eax, DWORD PTR sz$[rsp]
  00044	39 44 24 04	 cmp	 DWORD PTR new_capacity$[rsp], eax
  00048	7e 0a		 jle	 SHORT $LN5@grow_capac
  0004a	8b 44 24 04	 mov	 eax, DWORD PTR new_capacity$[rsp]
  0004e	89 44 24 08	 mov	 DWORD PTR tv72[rsp], eax
  00052	eb 08		 jmp	 SHORT $LN6@grow_capac
$LN5@grow_capac:
  00054	8b 44 24 28	 mov	 eax, DWORD PTR sz$[rsp]
  00058	89 44 24 08	 mov	 DWORD PTR tv72[rsp], eax
$LN6@grow_capac:
  0005c	8b 44 24 08	 mov	 eax, DWORD PTR tv72[rsp]
  00060	48 83 c4 18	 add	 rsp, 24
  00064	c3		 ret	 0
?_grow_capacity@?$ImVector@G@@QEBAHH@Z ENDP		; ImVector<unsigned short>::_grow_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\imgui\imgui.h
;	COMDAT ?clear@?$ImVector@G@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$ImVector@G@@QEAAXXZ PROC			; ImVector<unsigned short>::clear, COMDAT

; 2002 :     inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }  // Important: does not destruct anything

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00013	74 32		 je	 SHORT $LN2@clear
  00015	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001a	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0
  00021	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00026	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  0002c	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00031	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00035	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPEAX@Z ; ImGui::MemFree
  0003a	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0003f	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
$LN2@clear:
  00047	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004b	c3		 ret	 0
?clear@?$ImVector@G@@QEAAXXZ ENDP			; ImVector<unsigned short>::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\imgui\imgui.h
;	COMDAT ??1?$ImVector@G@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$ImVector@G@@QEAA@XZ PROC				; ImVector<unsigned short>::~ImVector<unsigned short>, COMDAT

; 2000 :     inline ~ImVector()                                      { if (Data) IM_FREE(Data); } // Important: does not destruct anything

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0000e	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00013	74 0f		 je	 SHORT $LN2@ImVector
  00015	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001a	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0001e	e8 00 00 00 00	 call	 ?MemFree@ImGui@@YAXPEAX@Z ; ImGui::MemFree
  00023	90		 npad	 1
$LN2@ImVector:
  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	c3		 ret	 0
??1?$ImVector@G@@QEAA@XZ ENDP				; ImVector<unsigned short>::~ImVector<unsigned short>
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\imgui\imgui.h
;	COMDAT ??4?$ImVector@G@@QEAAAEAU0@AEBU0@@Z
_TEXT	SEGMENT
this$ = 48
src$ = 56
??4?$ImVector@G@@QEAAAEAU0@AEBU0@@Z PROC		; ImVector<unsigned short>::operator=, COMDAT

; 1999 :     inline ImVector<T>& operator=(const ImVector<T>& src)   { clear(); resize(src.Size); if (src.Data) memcpy(Data, src.Data, (size_t)Size * sizeof(T)); return *this; }

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00013	e8 00 00 00 00	 call	 ?clear@?$ImVector@G@@QEAAXXZ ; ImVector<unsigned short>::clear
  00018	48 8b 44 24 38	 mov	 rax, QWORD PTR src$[rsp]
  0001d	8b 10		 mov	 edx, DWORD PTR [rax]
  0001f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  00024	e8 00 00 00 00	 call	 ?resize@?$ImVector@G@@QEAAXH@Z ; ImVector<unsigned short>::resize
  00029	48 8b 44 24 38	 mov	 rax, QWORD PTR src$[rsp]
  0002e	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00033	74 25		 je	 SHORT $LN2@operator
  00035	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0003a	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  0003d	48 d1 e0	 shl	 rax, 1
  00040	4c 8b c0	 mov	 r8, rax
  00043	48 8b 44 24 38	 mov	 rax, QWORD PTR src$[rsp]
  00048	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0004c	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00051	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00055	e8 00 00 00 00	 call	 memcpy
$LN2@operator:
  0005a	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0005f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00063	c3		 ret	 0
??4?$ImVector@G@@QEAAAEAU0@AEBU0@@Z ENDP		; ImVector<unsigned short>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\imgui\imgui.h
;	COMDAT ??0?$ImVector@G@@QEAA@AEBU0@@Z
_TEXT	SEGMENT
this$ = 48
src$ = 56
??0?$ImVector@G@@QEAA@AEBU0@@Z PROC			; ImVector<unsigned short>::ImVector<unsigned short>, COMDAT

; 1998 :     inline ImVector(const ImVector<T>& src)                 { Size = Capacity = 0; Data = NULL; operator=(src); }

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00013	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0
  0001a	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0001f	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  00025	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  0002a	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  00032	48 8b 54 24 38	 mov	 rdx, QWORD PTR src$[rsp]
  00037	48 8b 4c 24 30	 mov	 rcx, QWORD PTR this$[rsp]
  0003c	e8 00 00 00 00	 call	 ??4?$ImVector@G@@QEAAAEAU0@AEBU0@@Z ; ImVector<unsigned short>::operator=
  00041	48 8b 44 24 30	 mov	 rax, QWORD PTR this$[rsp]
  00046	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004a	c3		 ret	 0
??0?$ImVector@G@@QEAA@AEBU0@@Z ENDP			; ImVector<unsigned short>::ImVector<unsigned short>
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\imgui\imgui.h
;	COMDAT ??0ImVec4@@QEAA@MMMM@Z
_TEXT	SEGMENT
this$ = 8
_x$ = 16
_y$ = 24
_z$ = 32
_w$ = 40
??0ImVec4@@QEAA@MMMM@Z PROC				; ImVec4::ImVec4, COMDAT

; 286  :     constexpr ImVec4(float _x, float _y, float _z, float _w)  : x(_x), y(_y), z(_z), w(_w) { }

  00000	f3 0f 11 5c 24
	20		 movss	 DWORD PTR [rsp+32], xmm3
  00006	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  0000c	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  00012	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00017	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0001c	f3 0f 10 44 24
	10		 movss	 xmm0, DWORD PTR _x$[rsp]
  00022	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0
  00026	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0002b	f3 0f 10 44 24
	18		 movss	 xmm0, DWORD PTR _y$[rsp]
  00031	f3 0f 11 40 04	 movss	 DWORD PTR [rax+4], xmm0
  00036	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0003b	f3 0f 10 44 24
	20		 movss	 xmm0, DWORD PTR _z$[rsp]
  00041	f3 0f 11 40 08	 movss	 DWORD PTR [rax+8], xmm0
  00046	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0004b	f3 0f 10 44 24
	28		 movss	 xmm0, DWORD PTR _w$[rsp]
  00051	f3 0f 11 40 0c	 movss	 DWORD PTR [rax+12], xmm0
  00056	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  0005b	c3		 ret	 0
??0ImVec4@@QEAA@MMMM@Z ENDP				; ImVec4::ImVec4
_TEXT	ENDS
; Function compile flags: /Odtp
; File W:\OpenGL_Viewer\lib\imgui\imgui.h
;	COMDAT ??0ImVec2@@QEAA@MM@Z
_TEXT	SEGMENT
this$ = 8
_x$ = 16
_y$ = 24
??0ImVec2@@QEAA@MM@Z PROC				; ImVec2::ImVec2, COMDAT

; 273  :     constexpr ImVec2(float _x, float _y)    : x(_x), y(_y) { }

  00000	f3 0f 11 54 24
	18		 movss	 DWORD PTR [rsp+24], xmm2
  00006	f3 0f 11 4c 24
	10		 movss	 DWORD PTR [rsp+16], xmm1
  0000c	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00011	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00016	f3 0f 10 44 24
	10		 movss	 xmm0, DWORD PTR _x$[rsp]
  0001c	f3 0f 11 00	 movss	 DWORD PTR [rax], xmm0
  00020	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00025	f3 0f 10 44 24
	18		 movss	 xmm0, DWORD PTR _y$[rsp]
  0002b	f3 0f 11 40 04	 movss	 DWORD PTR [rax+4], xmm0
  00030	48 8b 44 24 08	 mov	 rax, QWORD PTR this$[rsp]
  00035	c3		 ret	 0
??0ImVec2@@QEAA@MM@Z ENDP				; ImVec2::ImVec2
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.18362.0\ucrt\string.h
;	COMDAT ?strrchr@@YAPEADQEADH@Z
_TEXT	SEGMENT
_String$ = 48
_Ch$ = 56
?strrchr@@YAPEADQEADH@Z PROC				; strrchr, COMDAT

; 517  :     {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 518  :         return const_cast<char*>(strrchr(static_cast<char const*>(_String), _Ch));

  0000d	8b 54 24 38	 mov	 edx, DWORD PTR _Ch$[rsp]
  00011	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _String$[rsp]
  00016	e8 00 00 00 00	 call	 strrchr

; 519  :     }

  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
?strrchr@@YAPEADQEADH@Z ENDP				; strrchr
_TEXT	ENDS
END
